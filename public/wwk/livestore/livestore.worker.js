var __defProp = Object.defineProperty;
var __typeError = (msg) => {
  throw TypeError(msg);
};
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __publicField = (obj, key, value) => __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
var __accessCheck = (obj, member, msg) => member.has(obj) || __typeError("Cannot " + msg);
var __privateGet = (obj, member, getter) => (__accessCheck(obj, member, "read from private field"), getter ? getter.call(obj) : member.get(obj));
var __privateAdd = (obj, member, value) => member.has(obj) ? __typeError("Cannot add the same private member more than once") : member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
var __privateSet = (obj, member, value, setter) => (__accessCheck(obj, member, "write to private field"), setter ? setter.call(obj, value) : member.set(obj, value), value);
var __privateMethod = (obj, member, method) => (__accessCheck(obj, member, "access private method"), method);
(function() {
  "use strict";
  var _value, _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _A, _B, _C, _D, _E, _F, _G, _H, _I, _J, _K, _L, _M, _N, _O, _P, _Q, _R, _S, _T, _U, _V, _W, _X, _Y, _Z, __, _$, _aa, _ba, _ca, _da, _ea, _fa, _ga, _ha, _ia, _ja, _ka, _la, _ma, _na, _oa, _pa, _qa, _ra, _sa, _ta, _ua, _va, _wa, _xa, _ya, _za, _Aa, _Ba, _Ca, _Da, _Ea, _Fa, _Ga, _Ha, _Ia, _Ja, _Ka, _La, _Ma, _Na, _Oa, _Pa, _Qa, _Ra, _Sa, _Ta, _Ua, _Va, _FacadeVFS_instances, makeTypedDataView_fn, makeDataArray_fn, decodeFilename_fn, _Wa, _FacadeVFS_instances2, makeTypedDataView_fn2, makeDataArray_fn2, decodeFilename_fn2, _directoryPath, _directoryHandle, _mapAccessHandleToName, _mapPathToAccessHandle, _availableAccessHandles, _mapIdToFile, _AccessHandlePoolVFS_instances, acquireAccessHandles_fn, releaseAccessHandles_fn, getAssociatedPath_fn, setAssociatedPath_fn, computeDigest_fn, getPath_fn, deletePath_fn;
  const isFunction$1 = (input) => typeof input === "function";
  const dual = function(arity, body) {
    if (typeof arity === "function") {
      return function() {
        if (arity(arguments)) {
          return body.apply(this, arguments);
        }
        return (self2) => body(self2, ...arguments);
      };
    }
    switch (arity) {
      case 0:
      case 1:
        throw new RangeError(`Invalid arity ${arity}`);
      case 2:
        return function(a, b) {
          if (arguments.length >= 2) {
            return body(a, b);
          }
          return function(self2) {
            return body(self2, a);
          };
        };
      case 3:
        return function(a, b, c) {
          if (arguments.length >= 3) {
            return body(a, b, c);
          }
          return function(self2) {
            return body(self2, a, b);
          };
        };
      case 4:
        return function(a, b, c, d) {
          if (arguments.length >= 4) {
            return body(a, b, c, d);
          }
          return function(self2) {
            return body(self2, a, b, c);
          };
        };
      case 5:
        return function(a, b, c, d, e) {
          if (arguments.length >= 5) {
            return body(a, b, c, d, e);
          }
          return function(self2) {
            return body(self2, a, b, c, d);
          };
        };
      default:
        return function() {
          if (arguments.length >= arity) {
            return body.apply(this, arguments);
          }
          const args2 = arguments;
          return function(self2) {
            return body(self2, ...args2);
          };
        };
    }
  };
  const identity = (a) => a;
  const constant = (value2) => () => value2;
  const constTrue = /* @__PURE__ */ constant(true);
  const constFalse = /* @__PURE__ */ constant(false);
  const constUndefined = /* @__PURE__ */ constant(void 0);
  const constVoid = constUndefined;
  function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
    switch (arguments.length) {
      case 1:
        return a;
      case 2:
        return ab(a);
      case 3:
        return bc(ab(a));
      case 4:
        return cd(bc(ab(a)));
      case 5:
        return de(cd(bc(ab(a))));
      case 6:
        return ef(de(cd(bc(ab(a)))));
      case 7:
        return fg(ef(de(cd(bc(ab(a))))));
      case 8:
        return gh(fg(ef(de(cd(bc(ab(a)))))));
      case 9:
        return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
      default: {
        let ret = arguments[0];
        for (let i = 1; i < arguments.length; i++) {
          ret = arguments[i](ret);
        }
        return ret;
      }
    }
  }
  const make$11 = (isEquivalent) => (self2, that) => self2 === that || isEquivalent(self2, that);
  const isStrictEquivalent = (x, y) => x === y;
  const strict = () => isStrictEquivalent;
  const number$2 = /* @__PURE__ */ strict();
  const mapInput$1 = /* @__PURE__ */ dual(2, (self2, f) => make$11((x, y) => self2(f(x), f(y))));
  const Date$1 = /* @__PURE__ */ mapInput$1(number$2, (date) => date.getTime());
  const array$1 = (item) => make$11((self2, that) => {
    if (self2.length !== that.length) {
      return false;
    }
    for (let i = 0; i < self2.length; i++) {
      const isEq = item(self2[i], that[i]);
      if (!isEq) {
        return false;
      }
    }
    return true;
  });
  let moduleVersion = "3.15.2";
  const getCurrentVersion = () => moduleVersion;
  const globalStoreId = `effect/GlobalValue/globalStoreId/${/* @__PURE__ */ getCurrentVersion()}`;
  let globalStore;
  const globalValue = (id2, compute) => {
    if (!globalStore) {
      globalThis[globalStoreId] ?? (globalThis[globalStoreId] = /* @__PURE__ */ new Map());
      globalStore = globalThis[globalStoreId];
    }
    if (!globalStore.has(id2)) {
      globalStore.set(id2, compute());
    }
    return globalStore.get(id2);
  };
  const isSet = (input) => input instanceof Set;
  const isString = (input) => typeof input === "string";
  const isNumber = (input) => typeof input === "number";
  const isBoolean = (input) => typeof input === "boolean";
  const isBigInt = (input) => typeof input === "bigint";
  const isSymbol = (input) => typeof input === "symbol";
  const isFunction = isFunction$1;
  const isUndefined = (input) => input === void 0;
  const isNever = (_) => false;
  const isRecordOrArray = (input) => typeof input === "object" && input !== null;
  const isObject = (input) => isRecordOrArray(input) || isFunction(input);
  const hasProperty = /* @__PURE__ */ dual(2, (self2, property) => isObject(self2) && property in self2);
  const isTagged = /* @__PURE__ */ dual(2, (self2, tag2) => hasProperty(self2, "_tag") && self2["_tag"] === tag2);
  const isNullable = (input) => input === null || input === void 0;
  const isNotNullable = (input) => input !== null && input !== void 0;
  const isUint8Array = (input) => input instanceof Uint8Array;
  const isDate = (input) => input instanceof Date;
  const isIterable = (input) => hasProperty(input, Symbol.iterator);
  const isRecord = (input) => isRecordOrArray(input) && !Array.isArray(input);
  const isPromiseLike = (input) => hasProperty(input, "then") && isFunction(input.then);
  const getBugErrorMessage = (message) => `BUG: ${message} - please report an issue at https://github.com/Effect-TS/effect/issues`;
  let SingleShotGen$1 = class SingleShotGen2 {
    constructor(self2) {
      __publicField(this, "self");
      __publicField(this, "called", false);
      this.self = self2;
    }
    /**
     * @since 2.0.0
     */
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    /**
     * @since 2.0.0
     */
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    /**
     * @since 2.0.0
     */
    throw(e) {
      throw e;
    }
    /**
     * @since 2.0.0
     */
    [Symbol.iterator]() {
      return new SingleShotGen2(this.self);
    }
  };
  const defaultIncHi = 335903614;
  const defaultIncLo = 4150755663;
  const MUL_HI = 1481765933 >>> 0;
  const MUL_LO = 1284865837 >>> 0;
  const BIT_53 = 9007199254740992;
  const BIT_27 = 134217728;
  class PCGRandom {
    constructor(seedHi, seedLo, incHi, incLo) {
      __publicField(this, "_state");
      if (isNullable(seedLo) && isNullable(seedHi)) {
        seedLo = Math.random() * 4294967295 >>> 0;
        seedHi = 0;
      } else if (isNullable(seedLo)) {
        seedLo = seedHi;
        seedHi = 0;
      }
      if (isNullable(incLo) && isNullable(incHi)) {
        incLo = this._state ? this._state[3] : defaultIncLo;
        incHi = this._state ? this._state[2] : defaultIncHi;
      } else if (isNullable(incLo)) {
        incLo = incHi;
        incHi = 0;
      }
      this._state = new Int32Array([0, 0, incHi >>> 0, ((incLo || 0) | 1) >>> 0]);
      this._next();
      add64(this._state, this._state[0], this._state[1], seedHi >>> 0, seedLo >>> 0);
      this._next();
      return this;
    }
    /**
     * Returns a copy of the internal state of this random number generator as a
     * JavaScript Array.
     *
     * @category getters
     * @since 2.0.0
     */
    getState() {
      return [this._state[0], this._state[1], this._state[2], this._state[3]];
    }
    /**
     * Restore state previously retrieved using `getState()`.
     *
     * @since 2.0.0
     */
    setState(state2) {
      this._state[0] = state2[0];
      this._state[1] = state2[1];
      this._state[2] = state2[2];
      this._state[3] = state2[3] | 1;
    }
    /**
     * Get a uniformly distributed 32 bit integer between [0, max).
     *
     * @category getter
     * @since 2.0.0
     */
    integer(max2) {
      return Math.round(this.number() * Number.MAX_SAFE_INTEGER) % max2;
    }
    /**
     * Get a uniformly distributed IEEE-754 double between 0.0 and 1.0, with
     * 53 bits of precision (every bit of the mantissa is randomized).
     *
     * @category getters
     * @since 2.0.0
     */
    number() {
      const hi = (this._next() & 67108863) * 1;
      const lo = (this._next() & 134217727) * 1;
      return (hi * BIT_27 + lo) / BIT_53;
    }
    /** @internal */
    _next() {
      const oldHi = this._state[0] >>> 0;
      const oldLo = this._state[1] >>> 0;
      mul64(this._state, oldHi, oldLo, MUL_HI, MUL_LO);
      add64(this._state, this._state[0], this._state[1], this._state[2], this._state[3]);
      let xsHi = oldHi >>> 18;
      let xsLo = (oldLo >>> 18 | oldHi << 14) >>> 0;
      xsHi = (xsHi ^ oldHi) >>> 0;
      xsLo = (xsLo ^ oldLo) >>> 0;
      const xorshifted = (xsLo >>> 27 | xsHi << 5) >>> 0;
      const rot = oldHi >>> 27;
      const rot2 = (-rot >>> 0 & 31) >>> 0;
      return (xorshifted >>> rot | xorshifted << rot2) >>> 0;
    }
  }
  function mul64(out, aHi, aLo, bHi, bLo) {
    let c1 = (aLo >>> 16) * (bLo & 65535) >>> 0;
    let c0 = (aLo & 65535) * (bLo >>> 16) >>> 0;
    let lo = (aLo & 65535) * (bLo & 65535) >>> 0;
    let hi = (aLo >>> 16) * (bLo >>> 16) + ((c0 >>> 16) + (c1 >>> 16)) >>> 0;
    c0 = c0 << 16 >>> 0;
    lo = lo + c0 >>> 0;
    if (lo >>> 0 < c0 >>> 0) {
      hi = hi + 1 >>> 0;
    }
    c1 = c1 << 16 >>> 0;
    lo = lo + c1 >>> 0;
    if (lo >>> 0 < c1 >>> 0) {
      hi = hi + 1 >>> 0;
    }
    hi = hi + Math.imul(aLo, bHi) >>> 0;
    hi = hi + Math.imul(aHi, bLo) >>> 0;
    out[0] = hi;
    out[1] = lo;
  }
  function add64(out, aHi, aLo, bHi, bLo) {
    let hi = aHi + bHi >>> 0;
    const lo = aLo + bLo >>> 0;
    if (lo >>> 0 < aLo >>> 0) {
      hi = hi + 1 | 0;
    }
    out[0] = hi;
    out[1] = lo;
  }
  const YieldWrapTypeId = /* @__PURE__ */ Symbol.for("effect/Utils/YieldWrap");
  class YieldWrap {
    constructor(value2) {
      /**
       * @since 3.0.6
       */
      __privateAdd(this, _value);
      __privateSet(this, _value, value2);
    }
    /**
     * @since 3.0.6
     */
    [YieldWrapTypeId]() {
      return __privateGet(this, _value);
    }
  }
  _value = new WeakMap();
  function yieldWrapGet(self2) {
    if (typeof self2 === "object" && self2 !== null && YieldWrapTypeId in self2) {
      return self2[YieldWrapTypeId]();
    }
    throw new Error(getBugErrorMessage("yieldWrapGet"));
  }
  const structuralRegionState = /* @__PURE__ */ globalValue("effect/Utils/isStructuralRegion", () => ({
    enabled: false,
    tester: void 0
  }));
  const standard = {
    effect_internal_function: (body) => {
      return body();
    }
  };
  const forced = {
    effect_internal_function: (body) => {
      try {
        return body();
      } finally {
      }
    }
  };
  const isNotOptimizedAway = ((_a = standard.effect_internal_function(() => new Error().stack)) == null ? void 0 : /* @__PURE__ */ _a.includes("effect_internal_function")) === true;
  const internalCall = isNotOptimizedAway ? standard.effect_internal_function : forced.effect_internal_function;
  const genConstructor = (function* () {
  }).constructor;
  const isGeneratorFunction = (u) => isObject(u) && u.constructor === genConstructor;
  const randomHashCache = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Hash/randomHashCache"), () => /* @__PURE__ */ new WeakMap());
  const symbol$1 = /* @__PURE__ */ Symbol.for("effect/Hash");
  const hash$2 = (self2) => {
    if (structuralRegionState.enabled === true) {
      return 0;
    }
    switch (typeof self2) {
      case "number":
        return number$1(self2);
      case "bigint":
        return string(self2.toString(10));
      case "boolean":
        return string(String(self2));
      case "symbol":
        return string(String(self2));
      case "string":
        return string(self2);
      case "undefined":
        return string("undefined");
      case "function":
      case "object": {
        if (self2 === null) {
          return string("null");
        } else if (self2 instanceof Date) {
          return hash$2(self2.toISOString());
        } else if (self2 instanceof URL) {
          return hash$2(self2.href);
        } else if (isHash(self2)) {
          return self2[symbol$1]();
        } else {
          return random(self2);
        }
      }
      default:
        throw new Error(`BUG: unhandled typeof ${typeof self2} - please report an issue at https://github.com/Effect-TS/effect/issues`);
    }
  };
  const random = (self2) => {
    if (!randomHashCache.has(self2)) {
      randomHashCache.set(self2, number$1(Math.floor(Math.random() * Number.MAX_SAFE_INTEGER)));
    }
    return randomHashCache.get(self2);
  };
  const combine$7 = (b) => (self2) => self2 * 53 ^ b;
  const optimize = (n) => n & 3221225471 | n >>> 1 & 1073741824;
  const isHash = (u) => hasProperty(u, symbol$1);
  const number$1 = (n) => {
    if (n !== n || n === Infinity) {
      return 0;
    }
    let h = n | 0;
    if (h !== n) {
      h ^= n * 4294967295;
    }
    while (n > 4294967295) {
      h ^= n /= 4294967295;
    }
    return optimize(h);
  };
  const string = (str) => {
    let h = 5381, i = str.length;
    while (i) {
      h = h * 33 ^ str.charCodeAt(--i);
    }
    return optimize(h);
  };
  const structureKeys = (o, keys2) => {
    let h = 12289;
    for (let i = 0; i < keys2.length; i++) {
      h ^= pipe(string(keys2[i]), combine$7(hash$2(o[keys2[i]])));
    }
    return optimize(h);
  };
  const structure = (o) => structureKeys(o, Object.keys(o));
  const array = (arr) => {
    let h = 6151;
    for (let i = 0; i < arr.length; i++) {
      h = pipe(h, combine$7(hash$2(arr[i])));
    }
    return optimize(h);
  };
  const cached$1 = function() {
    if (arguments.length === 1) {
      const self3 = arguments[0];
      return function(hash3) {
        Object.defineProperty(self3, symbol$1, {
          value() {
            return hash3;
          },
          enumerable: false
        });
        return hash3;
      };
    }
    const self2 = arguments[0];
    const hash2 = arguments[1];
    Object.defineProperty(self2, symbol$1, {
      value() {
        return hash2;
      },
      enumerable: false
    });
    return hash2;
  };
  const symbol = /* @__PURE__ */ Symbol.for("effect/Equal");
  function equals$1() {
    if (arguments.length === 1) {
      return (self2) => compareBoth(self2, arguments[0]);
    }
    return compareBoth(arguments[0], arguments[1]);
  }
  function compareBoth(self2, that) {
    if (self2 === that) {
      return true;
    }
    const selfType = typeof self2;
    if (selfType !== typeof that) {
      return false;
    }
    if (selfType === "object" || selfType === "function") {
      if (self2 !== null && that !== null) {
        if (isEqual$1(self2) && isEqual$1(that)) {
          if (hash$2(self2) === hash$2(that) && self2[symbol](that)) {
            return true;
          } else {
            return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
          }
        } else if (self2 instanceof Date && that instanceof Date) {
          return self2.toISOString() === that.toISOString();
        } else if (self2 instanceof URL && that instanceof URL) {
          return self2.href === that.href;
        }
      }
      if (structuralRegionState.enabled) {
        if (Array.isArray(self2) && Array.isArray(that)) {
          return self2.length === that.length && self2.every((v, i) => compareBoth(v, that[i]));
        }
        if (Object.getPrototypeOf(self2) === Object.prototype && Object.getPrototypeOf(self2) === Object.prototype) {
          const keysSelf = Object.keys(self2);
          const keysThat = Object.keys(that);
          if (keysSelf.length === keysThat.length) {
            for (const key of keysSelf) {
              if (!(key in that && compareBoth(self2[key], that[key]))) {
                return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
              }
            }
            return true;
          }
        }
        return structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
      }
    }
    return structuralRegionState.enabled && structuralRegionState.tester ? structuralRegionState.tester(self2, that) : false;
  }
  const isEqual$1 = (u) => hasProperty(u, symbol);
  const equivalence = () => equals$1;
  const NodeInspectSymbol = /* @__PURE__ */ Symbol.for("nodejs.util.inspect.custom");
  const toJSON = (x) => {
    try {
      if (hasProperty(x, "toJSON") && isFunction(x["toJSON"]) && x["toJSON"].length === 0) {
        return x.toJSON();
      } else if (Array.isArray(x)) {
        return x.map(toJSON);
      }
    } catch {
      return {};
    }
    return redact$1(x);
  };
  const format$3 = (x) => JSON.stringify(x, null, 2);
  const BaseProto = {
    toJSON() {
      return toJSON(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format$3(this.toJSON());
    }
  };
  let Class$5 = class Class {
    /**
     * @since 2.0.0
     */
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    /**
     * @since 2.0.0
     */
    toString() {
      return format$3(this.toJSON());
    }
  };
  const toStringUnknown = (u, whitespace = 2) => {
    if (typeof u === "string") {
      return u;
    }
    try {
      return typeof u === "object" ? stringifyCircular(u, whitespace) : String(u);
    } catch {
      return String(u);
    }
  };
  const stringifyCircular = (obj, whitespace) => {
    let cache = [];
    const retVal = JSON.stringify(obj, (_key, value2) => typeof value2 === "object" && value2 !== null ? cache.includes(value2) ? void 0 : cache.push(value2) && (redactableState.fiberRefs !== void 0 && isRedactable(value2) ? value2[symbolRedactable](redactableState.fiberRefs) : value2) : value2, whitespace);
    cache = void 0;
    return retVal;
  };
  const symbolRedactable = /* @__PURE__ */ Symbol.for("effect/Inspectable/Redactable");
  const isRedactable = (u) => typeof u === "object" && u !== null && symbolRedactable in u;
  const redactableState = /* @__PURE__ */ globalValue("effect/Inspectable/redactableState", () => ({
    fiberRefs: void 0
  }));
  const withRedactableContext = (context2, f) => {
    const prev = redactableState.fiberRefs;
    redactableState.fiberRefs = context2;
    try {
      return f();
    } finally {
      redactableState.fiberRefs = prev;
    }
  };
  const redact$1 = (u) => {
    if (isRedactable(u) && redactableState.fiberRefs !== void 0) {
      return u[symbolRedactable](redactableState.fiberRefs);
    }
    return u;
  };
  const pipeArguments = (self2, args2) => {
    switch (args2.length) {
      case 0:
        return self2;
      case 1:
        return args2[0](self2);
      case 2:
        return args2[1](args2[0](self2));
      case 3:
        return args2[2](args2[1](args2[0](self2)));
      case 4:
        return args2[3](args2[2](args2[1](args2[0](self2))));
      case 5:
        return args2[4](args2[3](args2[2](args2[1](args2[0](self2)))));
      case 6:
        return args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))));
      case 7:
        return args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))));
      case 8:
        return args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2))))))));
      case 9:
        return args2[8](args2[7](args2[6](args2[5](args2[4](args2[3](args2[2](args2[1](args2[0](self2)))))))));
      default: {
        let ret = self2;
        for (let i = 0, len = args2.length; i < len; i++) {
          ret = args2[i](ret);
        }
        return ret;
      }
    }
  };
  const OP_ASYNC = "Async";
  const OP_COMMIT = "Commit";
  const OP_FAILURE = "Failure";
  const OP_ON_FAILURE$1 = "OnFailure";
  const OP_ON_SUCCESS$1 = "OnSuccess";
  const OP_ON_SUCCESS_AND_FAILURE = "OnSuccessAndFailure";
  const OP_SUCCESS = "Success";
  const OP_SYNC$1 = "Sync";
  const OP_TAG = "Tag";
  const OP_UPDATE_RUNTIME_FLAGS = "UpdateRuntimeFlags";
  const OP_WHILE = "While";
  const OP_ITERATOR = "Iterator";
  const OP_WITH_RUNTIME = "WithRuntime";
  const OP_YIELD$1 = "Yield";
  const OP_REVERT_FLAGS = "RevertFlags";
  const EffectTypeId$2 = /* @__PURE__ */ Symbol.for("effect/Effect");
  const StreamTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Stream");
  const SinkTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Sink");
  const ChannelTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Channel");
  const effectVariance = {
    /* c8 ignore next */
    _R: (_) => _,
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _A: (_) => _,
    _V: /* @__PURE__ */ getCurrentVersion()
  };
  const sinkVariance$1 = {
    /* c8 ignore next */
    _A: (_) => _,
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _L: (_) => _,
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _R: (_) => _
  };
  const channelVariance$1 = {
    /* c8 ignore next */
    _Env: (_) => _,
    /* c8 ignore next */
    _InErr: (_) => _,
    /* c8 ignore next */
    _InElem: (_) => _,
    /* c8 ignore next */
    _InDone: (_) => _,
    /* c8 ignore next */
    _OutErr: (_) => _,
    /* c8 ignore next */
    _OutElem: (_) => _,
    /* c8 ignore next */
    _OutDone: (_) => _
  };
  const EffectPrototype$1 = {
    [EffectTypeId$2]: effectVariance,
    [StreamTypeId$1]: effectVariance,
    [SinkTypeId$1]: sinkVariance$1,
    [ChannelTypeId$1]: channelVariance$1,
    [symbol](that) {
      return this === that;
    },
    [symbol$1]() {
      return cached$1(this, random(this));
    },
    [Symbol.iterator]() {
      return new SingleShotGen$1(new YieldWrap(this));
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const StructuralPrototype = {
    [symbol$1]() {
      return cached$1(this, structure(this));
    },
    [symbol](that) {
      const selfKeys = Object.keys(this);
      const thatKeys = Object.keys(that);
      if (selfKeys.length !== thatKeys.length) {
        return false;
      }
      for (const key of selfKeys) {
        if (!(key in that && equals$1(this[key], that[key]))) {
          return false;
        }
      }
      return true;
    }
  };
  const CommitPrototype = {
    ...EffectPrototype$1,
    _op: OP_COMMIT
  };
  const StructuralCommitPrototype = {
    ...CommitPrototype,
    ...StructuralPrototype
  };
  const Base$2 = /* @__PURE__ */ function() {
    function Base2() {
    }
    Base2.prototype = CommitPrototype;
    return Base2;
  }();
  const TypeId$t = /* @__PURE__ */ Symbol.for("effect/Option");
  const CommonProto$1 = {
    ...EffectPrototype$1,
    [TypeId$t]: {
      _A: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format$3(this.toJSON());
    }
  };
  const SomeProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
    _tag: "Some",
    _op: "Some",
    [symbol](that) {
      return isOption$1(that) && isSome$1(that) && equals$1(this.value, that.value);
    },
    [symbol$1]() {
      return cached$1(this, combine$7(hash$2(this._tag))(hash$2(this.value)));
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag,
        value: toJSON(this.value)
      };
    }
  });
  const NoneHash = /* @__PURE__ */ hash$2("None");
  const NoneProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto$1), {
    _tag: "None",
    _op: "None",
    [symbol](that) {
      return isOption$1(that) && isNone$1(that);
    },
    [symbol$1]() {
      return NoneHash;
    },
    toJSON() {
      return {
        _id: "Option",
        _tag: this._tag
      };
    }
  });
  const isOption$1 = (input) => hasProperty(input, TypeId$t);
  const isNone$1 = (fa) => fa._tag === "None";
  const isSome$1 = (fa) => fa._tag === "Some";
  const none$5 = /* @__PURE__ */ Object.create(NoneProto);
  const some$1 = (value2) => {
    const a = Object.create(SomeProto);
    a.value = value2;
    return a;
  };
  const TypeId$s = /* @__PURE__ */ Symbol.for("effect/Either");
  const CommonProto = {
    ...EffectPrototype$1,
    [TypeId$s]: {
      _R: (_) => _
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    toString() {
      return format$3(this.toJSON());
    }
  };
  const RightProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "Right",
    _op: "Right",
    [symbol](that) {
      return isEither$2(that) && isRight$1(that) && equals$1(this.right, that.right);
    },
    [symbol$1]() {
      return combine$7(hash$2(this._tag))(hash$2(this.right));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        right: toJSON(this.right)
      };
    }
  });
  const LeftProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(CommonProto), {
    _tag: "Left",
    _op: "Left",
    [symbol](that) {
      return isEither$2(that) && isLeft$1(that) && equals$1(this.left, that.left);
    },
    [symbol$1]() {
      return combine$7(hash$2(this._tag))(hash$2(this.left));
    },
    toJSON() {
      return {
        _id: "Either",
        _tag: this._tag,
        left: toJSON(this.left)
      };
    }
  });
  const isEither$2 = (input) => hasProperty(input, TypeId$s);
  const isLeft$1 = (ma) => ma._tag === "Left";
  const isRight$1 = (ma) => ma._tag === "Right";
  const left$1 = (left2) => {
    const a = Object.create(LeftProto);
    a.left = left2;
    return a;
  };
  const right$1 = (right2) => {
    const a = Object.create(RightProto);
    a.right = right2;
    return a;
  };
  const right = right$1;
  const left = left$1;
  const try_$2 = (evaluate2) => {
    if (isFunction(evaluate2)) {
      try {
        return right(evaluate2());
      } catch (e) {
        return left(e);
      }
    } else {
      try {
        return right(evaluate2.try());
      } catch (e) {
        return left(evaluate2.catch(e));
      }
    }
  };
  const isEither$1 = isEither$2;
  const isLeft = isLeft$1;
  const isRight = isRight$1;
  const mapBoth$4 = /* @__PURE__ */ dual(2, (self2, {
    onLeft,
    onRight
  }) => isLeft(self2) ? left(onLeft(self2.left)) : right(onRight(self2.right)));
  const mapLeft = /* @__PURE__ */ dual(2, (self2, f) => isLeft(self2) ? left(f(self2.left)) : right(self2.right));
  const map$i = /* @__PURE__ */ dual(2, (self2, f) => isRight(self2) ? right(f(self2.right)) : left(self2.left));
  const match$b = /* @__PURE__ */ dual(2, (self2, {
    onLeft,
    onRight
  }) => isLeft(self2) ? onLeft(self2.left) : onRight(self2.right));
  const merge$6 = /* @__PURE__ */ match$b({
    onLeft: identity,
    onRight: identity
  });
  const getOrThrowWith = /* @__PURE__ */ dual(2, (self2, onLeft) => {
    if (isRight(self2)) {
      return self2.right;
    }
    throw onLeft(self2.left);
  });
  const getOrThrow = /* @__PURE__ */ getOrThrowWith(() => new Error("getOrThrow called on a Left"));
  const isNonEmptyArray$1 = (self2) => self2.length > 0;
  const make$10 = (compare2) => (self2, that) => self2 === that ? 0 : compare2(self2, that);
  const number = /* @__PURE__ */ make$10((self2, that) => self2 < that ? -1 : 1);
  const mapInput = /* @__PURE__ */ dual(2, (self2, f) => make$10((b1, b2) => self2(f(b1), f(b2))));
  const greaterThan$1 = (O) => dual(2, (self2, that) => O(self2, that) === 1);
  const none$4 = () => none$5;
  const some = some$1;
  const isOption = isOption$1;
  const isNone = isNone$1;
  const isSome = isSome$1;
  const match$a = /* @__PURE__ */ dual(2, (self2, {
    onNone,
    onSome
  }) => isNone(self2) ? onNone() : onSome(self2.value));
  const getOrElse = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? onNone() : self2.value);
  const orElse$1 = /* @__PURE__ */ dual(2, (self2, that) => isNone(self2) ? that() : self2);
  const orElseSome = /* @__PURE__ */ dual(2, (self2, onNone) => isNone(self2) ? some(onNone()) : self2);
  const fromNullable = (nullableValue) => nullableValue == null ? none$4() : some(nullableValue);
  const getOrUndefined = /* @__PURE__ */ getOrElse(constUndefined);
  const liftThrowable = (f) => (...a) => {
    try {
      return some(f(...a));
    } catch {
      return none$4();
    }
  };
  const map$h = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? none$4() : some(f(self2.value)));
  const flatMap$a = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? none$4() : f(self2.value));
  const flatMapNullable = /* @__PURE__ */ dual(2, (self2, f) => isNone(self2) ? none$4() : fromNullable(f(self2.value)));
  const flatten$9 = /* @__PURE__ */ flatMap$a(identity);
  const getEquivalence$3 = (isEquivalent) => make$11((x, y) => isNone(x) ? isNone(y) : isNone(y) ? false : isEquivalent(x.value, y.value));
  const containsWith$1 = (isEquivalent) => dual(2, (self2, a) => isNone(self2) ? false : isEquivalent(self2.value, a));
  const _equivalence$3 = /* @__PURE__ */ equivalence();
  const contains = /* @__PURE__ */ containsWith$1(_equivalence$3);
  const exists = /* @__PURE__ */ dual(2, (self2, refinement) => isNone(self2) ? false : refinement(self2.value));
  const mergeWith$2 = (f) => (o1, o2) => {
    if (isNone(o1)) {
      return o2;
    } else if (isNone(o2)) {
      return o1;
    }
    return some(f(o1.value, o2.value));
  };
  const make$$ = (...elements) => elements;
  const unsafeHead$1 = (self2) => {
    const iterator = self2[Symbol.iterator]();
    const result = iterator.next();
    if (result.done) throw new Error("unsafeHead: empty iterable");
    return result.value;
  };
  const findFirst$1 = /* @__PURE__ */ dual(2, (self2, f) => {
    let i = 0;
    for (const a of self2) {
      const o = f(a, i);
      if (isBoolean(o)) {
        if (o) {
          return some(a);
        }
      } else {
        if (isSome(o)) {
          return o;
        }
      }
      i++;
    }
    return none$4();
  });
  const constEmpty = {
    [Symbol.iterator]() {
      return constEmptyIterator;
    }
  };
  const constEmptyIterator = {
    next() {
      return {
        done: true,
        value: void 0
      };
    }
  };
  const empty$v = () => constEmpty;
  const map$g = /* @__PURE__ */ dual(2, (self2, f) => ({
    [Symbol.iterator]() {
      const iterator = self2[Symbol.iterator]();
      let i = 0;
      return {
        next() {
          const result = iterator.next();
          if (result.done) {
            return {
              done: true,
              value: void 0
            };
          }
          return {
            done: false,
            value: f(result.value, i++)
          };
        }
      };
    }
  }));
  const map$f = /* @__PURE__ */ dual(2, (self2, f) => {
    const out = {
      ...self2
    };
    for (const key of keys$2(self2)) {
      out[key] = f(self2[key], key);
    }
    return out;
  });
  const keys$2 = (self2) => Object.keys(self2);
  const allocate = (n) => new Array(n);
  const makeBy = /* @__PURE__ */ dual(2, (n, f) => {
    const max2 = Math.max(1, Math.floor(n));
    const out = new Array(max2);
    for (let i = 0; i < max2; i++) {
      out[i] = f(i);
    }
    return out;
  });
  const fromIterable$8 = (collection) => Array.isArray(collection) ? collection : Array.from(collection);
  const ensure = (self2) => Array.isArray(self2) ? self2 : [self2];
  const match$9 = /* @__PURE__ */ dual(2, (self2, {
    onEmpty,
    onNonEmpty
  }) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(self2) : onEmpty());
  const matchLeft = /* @__PURE__ */ dual(2, (self2, {
    onEmpty,
    onNonEmpty
  }) => isNonEmptyReadonlyArray(self2) ? onNonEmpty(headNonEmpty$1(self2), tailNonEmpty$1(self2)) : onEmpty());
  const prepend$2 = /* @__PURE__ */ dual(2, (self2, head2) => [head2, ...self2]);
  const append$2 = /* @__PURE__ */ dual(2, (self2, last2) => [...self2, last2]);
  const appendAll$2 = /* @__PURE__ */ dual(2, (self2, that) => fromIterable$8(self2).concat(fromIterable$8(that)));
  const isArray = Array.isArray;
  const isEmptyArray = (self2) => self2.length === 0;
  const isEmptyReadonlyArray = isEmptyArray;
  const isNonEmptyArray = isNonEmptyArray$1;
  const isNonEmptyReadonlyArray = isNonEmptyArray$1;
  const isOutOfBounds = (i, as2) => i < 0 || i >= as2.length;
  const clamp = (i, as2) => Math.floor(Math.min(Math.max(0, i), as2.length));
  const get$g = /* @__PURE__ */ dual(2, (self2, index) => {
    const i = Math.floor(index);
    return isOutOfBounds(i, self2) ? none$4() : some(self2[i]);
  });
  const unsafeGet$5 = /* @__PURE__ */ dual(2, (self2, index) => {
    const i = Math.floor(index);
    if (isOutOfBounds(i, self2)) {
      throw new Error(`Index ${i} out of bounds`);
    }
    return self2[i];
  });
  const head$4 = /* @__PURE__ */ get$g(0);
  const headNonEmpty$1 = /* @__PURE__ */ unsafeGet$5(0);
  const last$1 = (self2) => isNonEmptyReadonlyArray(self2) ? some(lastNonEmpty(self2)) : none$4();
  const lastNonEmpty = (self2) => self2[self2.length - 1];
  const tailNonEmpty$1 = (self2) => self2.slice(1);
  const spanIndex = (self2, predicate) => {
    let i = 0;
    for (const a of self2) {
      if (!predicate(a, i)) {
        break;
      }
      i++;
    }
    return i;
  };
  const span = /* @__PURE__ */ dual(2, (self2, predicate) => splitAt$1(self2, spanIndex(self2, predicate)));
  const drop$1 = /* @__PURE__ */ dual(2, (self2, n) => {
    const input = fromIterable$8(self2);
    return input.slice(clamp(n, input), input.length);
  });
  const dropWhile = /* @__PURE__ */ dual(2, (self2, predicate) => fromIterable$8(self2).slice(spanIndex(self2, predicate)));
  const findFirst = findFirst$1;
  const reverse$2 = (self2) => Array.from(self2).reverse();
  const sort = /* @__PURE__ */ dual(2, (self2, O) => {
    const out = Array.from(self2);
    out.sort(O);
    return out;
  });
  const zip$4 = /* @__PURE__ */ dual(2, (self2, that) => zipWith$3(self2, that, make$$));
  const zipWith$3 = /* @__PURE__ */ dual(3, (self2, that, f) => {
    const as2 = fromIterable$8(self2);
    const bs = fromIterable$8(that);
    if (isNonEmptyReadonlyArray(as2) && isNonEmptyReadonlyArray(bs)) {
      const out = [f(headNonEmpty$1(as2), headNonEmpty$1(bs))];
      const len = Math.min(as2.length, bs.length);
      for (let i = 1; i < len; i++) {
        out[i] = f(as2[i], bs[i]);
      }
      return out;
    }
    return [];
  });
  const unzip = (self2) => {
    const input = fromIterable$8(self2);
    if (isNonEmptyReadonlyArray(input)) {
      const fa = [input[0][0]];
      const fb = [input[0][1]];
      for (let i = 1; i < input.length; i++) {
        fa[i] = input[i][0];
        fb[i] = input[i][1];
      }
      return [fa, fb];
    }
    return [[], []];
  };
  const containsWith = (isEquivalent) => dual(2, (self2, a) => {
    for (const i of self2) {
      if (isEquivalent(a, i)) {
        return true;
      }
    }
    return false;
  });
  const _equivalence$2 = /* @__PURE__ */ equivalence();
  const chop = /* @__PURE__ */ dual(2, (self2, f) => {
    const input = fromIterable$8(self2);
    if (isNonEmptyReadonlyArray(input)) {
      const [b, rest] = f(input);
      const out = [b];
      let next = rest;
      while (isNonEmptyArray$1(next)) {
        const [b2, rest2] = f(next);
        out.push(b2);
        next = rest2;
      }
      return out;
    }
    return [];
  });
  const splitAt$1 = /* @__PURE__ */ dual(2, (self2, n) => {
    const input = Array.from(self2);
    const _n2 = Math.floor(n);
    if (isNonEmptyReadonlyArray(input)) {
      if (_n2 >= 1) {
        return splitNonEmptyAt(input, _n2);
      }
      return [[], input];
    }
    return [input, []];
  });
  const splitNonEmptyAt = /* @__PURE__ */ dual(2, (self2, n) => {
    const _n2 = Math.max(1, Math.floor(n));
    return _n2 >= self2.length ? [copy$1(self2), []] : [prepend$2(self2.slice(1, _n2), headNonEmpty$1(self2)), self2.slice(_n2)];
  });
  const splitWhere$1 = /* @__PURE__ */ dual(2, (self2, predicate) => span(self2, (a, i) => !predicate(a, i)));
  const copy$1 = (self2) => self2.slice();
  const chunksOf = /* @__PURE__ */ dual(2, (self2, n) => {
    const input = fromIterable$8(self2);
    if (isNonEmptyReadonlyArray(input)) {
      return chop(input, splitNonEmptyAt(n));
    }
    return [];
  });
  const unionWith = /* @__PURE__ */ dual(3, (self2, that, isEquivalent) => {
    const a = fromIterable$8(self2);
    const b = fromIterable$8(that);
    if (isNonEmptyReadonlyArray(a)) {
      if (isNonEmptyReadonlyArray(b)) {
        const dedupe2 = dedupeWith(isEquivalent);
        return dedupe2(appendAll$2(a, b));
      }
      return a;
    }
    return b;
  });
  const union$2 = /* @__PURE__ */ dual(2, (self2, that) => unionWith(self2, that, _equivalence$2));
  const intersectionWith = (isEquivalent) => {
    const has2 = containsWith(isEquivalent);
    return dual(2, (self2, that) => fromIterable$8(self2).filter((a) => has2(that, a)));
  };
  const intersection = /* @__PURE__ */ intersectionWith(_equivalence$2);
  const empty$u = () => [];
  const of$3 = (a) => [a];
  const map$e = /* @__PURE__ */ dual(2, (self2, f) => self2.map(f));
  const flatMap$9 = /* @__PURE__ */ dual(2, (self2, f) => {
    if (isEmptyReadonlyArray(self2)) {
      return [];
    }
    const out = [];
    for (let i = 0; i < self2.length; i++) {
      const inner = f(self2[i], i);
      for (let j = 0; j < inner.length; j++) {
        out.push(inner[j]);
      }
    }
    return out;
  });
  const flatten$8 = /* @__PURE__ */ flatMap$9(identity);
  const filterMap$3 = /* @__PURE__ */ dual(2, (self2, f) => {
    const as2 = fromIterable$8(self2);
    const out = [];
    for (let i = 0; i < as2.length; i++) {
      const o = f(as2[i], i);
      if (isSome(o)) {
        out.push(o.value);
      }
    }
    return out;
  });
  const filter$4 = /* @__PURE__ */ dual(2, (self2, predicate) => {
    const as2 = fromIterable$8(self2);
    const out = [];
    for (let i = 0; i < as2.length; i++) {
      if (predicate(as2[i], i)) {
        out.push(as2[i]);
      }
    }
    return out;
  });
  const reduce$7 = /* @__PURE__ */ dual(3, (self2, b, f) => fromIterable$8(self2).reduce((b2, a, i) => f(b2, a, i), b));
  const unfold$1 = (b, f) => {
    const out = [];
    let next = b;
    let o;
    while (isSome(o = f(next))) {
      const [a, b2] = o.value;
      out.push(a);
      next = b2;
    }
    return out;
  };
  const getEquivalence$2 = array$1;
  const dedupeWith = /* @__PURE__ */ dual(2, (self2, isEquivalent) => {
    const input = fromIterable$8(self2);
    if (isNonEmptyReadonlyArray(input)) {
      const out = [headNonEmpty$1(input)];
      const rest = tailNonEmpty$1(input);
      for (const r of rest) {
        if (out.every((a) => !isEquivalent(r, a))) {
          out.push(r);
        }
      }
      return out;
    }
    return [];
  });
  const dedupe = (self2) => dedupeWith(self2, equivalence());
  const join$2 = /* @__PURE__ */ dual(2, (self2, sep) => fromIterable$8(self2).join(sep));
  const getKeysForIndexSignature = (input, parameter) => {
    switch (parameter._tag) {
      case "StringKeyword":
      case "TemplateLiteral":
        return Object.keys(input);
      case "SymbolKeyword":
        return Object.getOwnPropertySymbols(input);
      case "Refinement":
        return getKeysForIndexSignature(input, parameter.from);
    }
  };
  const ownKeys = (o) => Object.keys(o).concat(Object.getOwnPropertySymbols(o));
  const memoizeThunk = (f) => {
    let done2 = false;
    let a;
    return () => {
      if (done2) {
        return a;
      }
      a = f();
      done2 = true;
      return a;
    };
  };
  const formatDate = (date) => {
    try {
      return date.toISOString();
    } catch {
      return String(date);
    }
  };
  const formatUnknown = (u, checkCircular = true) => {
    if (Array.isArray(u)) {
      return `[${u.map((i) => formatUnknown(i, checkCircular)).join(",")}]`;
    }
    if (isDate(u)) {
      return formatDate(u);
    }
    if (hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString) {
      return u["toString"]();
    }
    if (isString(u)) {
      return JSON.stringify(u);
    }
    if (isNumber(u) || u == null || isBoolean(u) || isSymbol(u)) {
      return String(u);
    }
    if (isBigInt(u)) {
      return String(u) + "n";
    }
    if (isIterable(u)) {
      return `${u.constructor.name}(${formatUnknown(Array.from(u), checkCircular)})`;
    }
    try {
      if (checkCircular) {
        JSON.stringify(u);
      }
      const pojo = `{${ownKeys(u).map((k) => `${isString(k) ? JSON.stringify(k) : String(k)}:${formatUnknown(u[k], false)}`).join(",")}}`;
      const name = u.constructor.name;
      return u.constructor !== Object.prototype.constructor ? `${name}(${pojo})` : pojo;
    } catch {
      return "<circular structure>";
    }
  };
  const formatPropertyKey$1 = (name) => typeof name === "string" ? JSON.stringify(name) : String(name);
  const isNonEmpty$3 = (x) => Array.isArray(x);
  const isSingle = (x) => !Array.isArray(x);
  const formatPathKey = (key) => `[${formatPropertyKey$1(key)}]`;
  const formatPath = (path) => isNonEmpty$3(path) ? path.map(formatPathKey).join("") : formatPathKey(path);
  const getErrorMessage$1 = (reason, details, path, ast) => {
    let out = reason;
    if (path && isNonEmptyReadonlyArray(path)) {
      out += `
at path: ${formatPath(path)}`;
    }
    if (details !== void 0) {
      out += `
details: ${details}`;
    }
    if (ast) {
      out += `
schema (${ast._tag}): ${ast}`;
    }
    return out;
  };
  const getUnsupportedSchemaErrorMessage = (details, path, ast) => getErrorMessage$1("Unsupported schema", details, path, ast);
  const getSchemaExtendErrorMessage = (x, y, path) => getErrorMessage$1("Unsupported schema or overlapping types", `cannot extend ${x} with ${y}`, path);
  const getASTUnsupportedSchemaErrorMessage = (ast) => getUnsupportedSchemaErrorMessage(void 0, void 0, ast);
  const getASTUnsupportedKeySchemaErrorMessage = (ast) => getErrorMessage$1("Unsupported key schema", void 0, void 0, ast);
  const getASTUnsupportedLiteralErrorMessage = (literal) => getErrorMessage$1("Unsupported literal", `literal value: ${formatUnknown(literal)}`);
  const getASTDuplicateIndexSignatureErrorMessage = (type) => getErrorMessage$1("Duplicate index signature", `${type} index signature`);
  const getASTIndexSignatureParameterErrorMessage = /* @__PURE__ */ getErrorMessage$1("Unsupported index signature parameter", "An index signature parameter type must be `string`, `symbol`, a template literal type or a refinement of the previous types");
  const getASTRequiredElementFollowinAnOptionalElementErrorMessage = /* @__PURE__ */ getErrorMessage$1("Invalid element", "A required element cannot follow an optional element. ts(1257)");
  const getASTDuplicatePropertySignatureTransformationErrorMessage = (key) => getErrorMessage$1("Duplicate property signature transformation", `Duplicate key ${formatUnknown(key)}`);
  const getASTDuplicatePropertySignatureErrorMessage = (key) => getErrorMessage$1("Duplicate property signature", `Duplicate key ${formatUnknown(key)}`);
  const DateFromSelfSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/DateFromSelf");
  const GreaterThanOrEqualToSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/GreaterThanOrEqualTo");
  const IntSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/Int");
  const BetweenSchemaId$1 = /* @__PURE__ */ Symbol.for("effect/SchemaId/Between");
  const Order$1 = number;
  const escape = (string2) => string2.replace(/[/\\^$*+?.()|[\]{}]/g, "\\$&");
  const BrandAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Brand");
  const SchemaIdAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/SchemaId");
  const MessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Message");
  const MissingMessageAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/MissingMessage");
  const IdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Identifier");
  const TitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Title");
  const AutoTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/AutoTitle");
  const DescriptionAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Description");
  const ExamplesAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Examples");
  const DefaultAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Default");
  const JSONSchemaAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONSchema");
  const ArbitraryAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Arbitrary");
  const PrettyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Pretty");
  const EquivalenceAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Equivalence");
  const DocumentationAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Documentation");
  const ConcurrencyAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Concurrency");
  const BatchingAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Batching");
  const ParseIssueTitleAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseIssueTitle");
  const ParseOptionsAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/ParseOptions");
  const DecodingFallbackAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/DecodingFallback");
  const SurrogateAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/Surrogate");
  const StableFilterAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/StableFilter");
  const getAnnotation = /* @__PURE__ */ dual(2, (annotated, key) => Object.prototype.hasOwnProperty.call(annotated.annotations, key) ? some(annotated.annotations[key]) : none$4());
  const getBrandAnnotation = /* @__PURE__ */ getAnnotation(BrandAnnotationId);
  const getMessageAnnotation = /* @__PURE__ */ getAnnotation(MessageAnnotationId);
  const getMissingMessageAnnotation = /* @__PURE__ */ getAnnotation(MissingMessageAnnotationId);
  const getTitleAnnotation = /* @__PURE__ */ getAnnotation(TitleAnnotationId);
  const getAutoTitleAnnotation = /* @__PURE__ */ getAnnotation(AutoTitleAnnotationId);
  const getIdentifierAnnotation = /* @__PURE__ */ getAnnotation(IdentifierAnnotationId);
  const getDescriptionAnnotation = /* @__PURE__ */ getAnnotation(DescriptionAnnotationId);
  const getConcurrencyAnnotation = /* @__PURE__ */ getAnnotation(ConcurrencyAnnotationId);
  const getBatchingAnnotation = /* @__PURE__ */ getAnnotation(BatchingAnnotationId);
  const getParseIssueTitleAnnotation$1 = /* @__PURE__ */ getAnnotation(ParseIssueTitleAnnotationId);
  const getParseOptionsAnnotation = /* @__PURE__ */ getAnnotation(ParseOptionsAnnotationId);
  const getDecodingFallbackAnnotation = /* @__PURE__ */ getAnnotation(DecodingFallbackAnnotationId);
  const getSurrogateAnnotation = /* @__PURE__ */ getAnnotation(SurrogateAnnotationId);
  const getStableFilterAnnotation = /* @__PURE__ */ getAnnotation(StableFilterAnnotationId);
  const hasStableFilter = (annotated) => exists(getStableFilterAnnotation(annotated), (b) => b === true);
  const JSONIdentifierAnnotationId = /* @__PURE__ */ Symbol.for("effect/annotation/JSONIdentifier");
  const getJSONIdentifierAnnotation = /* @__PURE__ */ getAnnotation(JSONIdentifierAnnotationId);
  const getJSONIdentifier = (annotated) => orElse$1(getJSONIdentifierAnnotation(annotated), () => getIdentifierAnnotation(annotated));
  const ParseJsonSchemaId = /* @__PURE__ */ Symbol.for("effect/schema/ParseJson");
  class Declaration {
    constructor(typeParameters, decodeUnknown2, encodeUnknown2, annotations2 = {}) {
      __publicField(this, "typeParameters");
      __publicField(this, "decodeUnknown");
      __publicField(this, "encodeUnknown");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Declaration");
      this.typeParameters = typeParameters;
      this.decodeUnknown = decodeUnknown2;
      this.encodeUnknown = encodeUnknown2;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => "<declaration schema>");
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        typeParameters: this.typeParameters.map((ast) => ast.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const createASTGuard = (tag2) => (ast) => ast._tag === tag2;
  let Literal$1 = class Literal {
    constructor(literal, annotations2 = {}) {
      __publicField(this, "literal");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Literal");
      this.literal = literal;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => formatUnknown(this.literal));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        literal: isBigInt(this.literal) ? String(this.literal) : this.literal,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  };
  const isLiteral = /* @__PURE__ */ createASTGuard("Literal");
  const $null = /* @__PURE__ */ new Literal$1(null);
  class UniqueSymbol {
    constructor(symbol2, annotations2 = {}) {
      __publicField(this, "symbol");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "UniqueSymbol");
      this.symbol = symbol2;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => formatUnknown(this.symbol));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        symbol: String(this.symbol),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  class UndefinedKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "UndefinedKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const undefinedKeyword = /* @__PURE__ */ new UndefinedKeyword({
    [TitleAnnotationId]: "undefined"
  });
  class VoidKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "VoidKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const voidKeyword = /* @__PURE__ */ new VoidKeyword({
    [TitleAnnotationId]: "void"
  });
  class NeverKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "NeverKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const neverKeyword = /* @__PURE__ */ new NeverKeyword({
    [TitleAnnotationId]: "never"
  });
  const isNeverKeyword = /* @__PURE__ */ createASTGuard("NeverKeyword");
  class UnknownKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "UnknownKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const unknownKeyword = /* @__PURE__ */ new UnknownKeyword({
    [TitleAnnotationId]: "unknown"
  });
  class AnyKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "AnyKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const anyKeyword = /* @__PURE__ */ new AnyKeyword({
    [TitleAnnotationId]: "any"
  });
  class StringKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "StringKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const stringKeyword = /* @__PURE__ */ new StringKeyword({
    [TitleAnnotationId]: "string",
    [DescriptionAnnotationId]: "a string"
  });
  const isStringKeyword = /* @__PURE__ */ createASTGuard("StringKeyword");
  class NumberKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "NumberKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const numberKeyword = /* @__PURE__ */ new NumberKeyword({
    [TitleAnnotationId]: "number",
    [DescriptionAnnotationId]: "a number"
  });
  const isNumberKeyword = /* @__PURE__ */ createASTGuard("NumberKeyword");
  class BooleanKeyword {
    constructor(annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "BooleanKeyword");
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return formatKeyword(this);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const booleanKeyword = /* @__PURE__ */ new BooleanKeyword({
    [TitleAnnotationId]: "boolean",
    [DescriptionAnnotationId]: "a boolean"
  });
  const isBooleanKeyword = /* @__PURE__ */ createASTGuard("BooleanKeyword");
  const isSymbolKeyword = /* @__PURE__ */ createASTGuard("SymbolKeyword");
  let Type$1 = class Type {
    constructor(type, annotations2 = {}) {
      __publicField(this, "type");
      __publicField(this, "annotations");
      this.type = type;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        type: this.type.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return String(this.type);
    }
  };
  class OptionalType extends Type$1 {
    constructor(type, isOptional, annotations2 = {}) {
      super(type, annotations2);
      __publicField(this, "isOptional");
      this.isOptional = isOptional;
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return String(this.type) + (this.isOptional ? "?" : "");
    }
  }
  const getRestASTs = (rest) => rest.map((annotatedAST) => annotatedAST.type);
  class TupleType {
    constructor(elements, rest, isReadonly, annotations2 = {}) {
      __publicField(this, "elements");
      __publicField(this, "rest");
      __publicField(this, "isReadonly");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "TupleType");
      this.elements = elements;
      this.rest = rest;
      this.isReadonly = isReadonly;
      this.annotations = annotations2;
      let hasOptionalElement = false;
      let hasIllegalRequiredElement = false;
      for (const e of elements) {
        if (e.isOptional) {
          hasOptionalElement = true;
        } else if (hasOptionalElement) {
          hasIllegalRequiredElement = true;
          break;
        }
      }
      if (hasIllegalRequiredElement || hasOptionalElement && rest.length > 1) {
        throw new Error(getASTRequiredElementFollowinAnOptionalElementErrorMessage);
      }
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => formatTuple(this));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        elements: this.elements.map((e) => e.toJSON()),
        rest: this.rest.map((ast) => ast.toJSON()),
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const formatTuple = (ast) => {
    const formattedElements = ast.elements.map(String).join(", ");
    return matchLeft(ast.rest, {
      onEmpty: () => `readonly [${formattedElements}]`,
      onNonEmpty: (head2, tail) => {
        const formattedHead = String(head2);
        const wrappedHead = formattedHead.includes(" | ") ? `(${formattedHead})` : formattedHead;
        if (tail.length > 0) {
          const formattedTail = tail.map(String).join(", ");
          if (ast.elements.length > 0) {
            return `readonly [${formattedElements}, ...${wrappedHead}[], ${formattedTail}]`;
          } else {
            return `readonly [...${wrappedHead}[], ${formattedTail}]`;
          }
        } else {
          if (ast.elements.length > 0) {
            return `readonly [${formattedElements}, ...${wrappedHead}[]]`;
          } else {
            return `ReadonlyArray<${formattedHead}>`;
          }
        }
      }
    });
  };
  class PropertySignature extends OptionalType {
    constructor(name, type, isOptional, isReadonly, annotations2) {
      super(type, isOptional, annotations2);
      __publicField(this, "name");
      __publicField(this, "isReadonly");
      this.name = name;
      this.isReadonly = isReadonly;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return (this.isReadonly ? "readonly " : "") + String(this.name) + (this.isOptional ? "?" : "") + ": " + this.type;
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        name: String(this.name),
        type: this.type.toJSON(),
        isOptional: this.isOptional,
        isReadonly: this.isReadonly,
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const isParameter = (ast) => {
    switch (ast._tag) {
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
        return true;
      case "Refinement":
        return isParameter(ast.from);
    }
    return false;
  };
  class IndexSignature {
    constructor(parameter, type, isReadonly) {
      __publicField(this, "type");
      __publicField(this, "isReadonly");
      /**
       * @since 3.10.0
       */
      __publicField(this, "parameter");
      this.type = type;
      this.isReadonly = isReadonly;
      if (isParameter(parameter)) {
        this.parameter = parameter;
      } else {
        throw new Error(getASTIndexSignatureParameterErrorMessage);
      }
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return (this.isReadonly ? "readonly " : "") + `[x: ${this.parameter}]: ${this.type}`;
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        parameter: this.parameter.toJSON(),
        type: this.type.toJSON(),
        isReadonly: this.isReadonly
      };
    }
  }
  class TypeLiteral {
    constructor(propertySignatures, indexSignatures, annotations2 = {}) {
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "TypeLiteral");
      /**
       * @since 3.10.0
       */
      __publicField(this, "propertySignatures");
      /**
       * @since 3.10.0
       */
      __publicField(this, "indexSignatures");
      this.annotations = annotations2;
      const keys2 = {};
      for (let i = 0; i < propertySignatures.length; i++) {
        const name = propertySignatures[i].name;
        if (Object.prototype.hasOwnProperty.call(keys2, name)) {
          throw new Error(getASTDuplicatePropertySignatureErrorMessage(name));
        }
        keys2[name] = null;
      }
      const parameters = {
        string: false,
        symbol: false
      };
      for (let i = 0; i < indexSignatures.length; i++) {
        const encodedParameter = getEncodedParameter(indexSignatures[i].parameter);
        if (isStringKeyword(encodedParameter)) {
          if (parameters.string) {
            throw new Error(getASTDuplicateIndexSignatureErrorMessage("string"));
          }
          parameters.string = true;
        } else if (isSymbolKeyword(encodedParameter)) {
          if (parameters.symbol) {
            throw new Error(getASTDuplicateIndexSignatureErrorMessage("symbol"));
          }
          parameters.symbol = true;
        }
      }
      this.propertySignatures = propertySignatures;
      this.indexSignatures = indexSignatures;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => formatTypeLiteral(this));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        propertySignatures: this.propertySignatures.map((ps) => ps.toJSON()),
        indexSignatures: this.indexSignatures.map((ps) => ps.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }
  const formatIndexSignatures = (iss) => iss.map(String).join("; ");
  const formatTypeLiteral = (ast) => {
    if (ast.propertySignatures.length > 0) {
      const pss = ast.propertySignatures.map(String).join("; ");
      if (ast.indexSignatures.length > 0) {
        return `{ ${pss}; ${formatIndexSignatures(ast.indexSignatures)} }`;
      } else {
        return `{ ${pss} }`;
      }
    } else {
      if (ast.indexSignatures.length > 0) {
        return `{ ${formatIndexSignatures(ast.indexSignatures)} }`;
      } else {
        return "{}";
      }
    }
  };
  const isTypeLiteral = /* @__PURE__ */ createASTGuard("TypeLiteral");
  const sortCandidates = /* @__PURE__ */ sort(/* @__PURE__ */ mapInput(Order$1, (ast) => {
    switch (ast._tag) {
      case "AnyKeyword":
        return 0;
      case "UnknownKeyword":
        return 1;
      case "ObjectKeyword":
        return 2;
      case "StringKeyword":
      case "NumberKeyword":
      case "BooleanKeyword":
      case "BigIntKeyword":
      case "SymbolKeyword":
        return 3;
    }
    return 4;
  }));
  const literalMap = {
    string: "StringKeyword",
    number: "NumberKeyword",
    boolean: "BooleanKeyword",
    bigint: "BigIntKeyword"
  };
  const flatten$7 = (candidates) => flatMap$9(candidates, (ast) => isUnion(ast) ? flatten$7(ast.types) : [ast]);
  const unify = (candidates) => {
    const cs = sortCandidates(candidates);
    const out = [];
    const uniques = {};
    const literals = [];
    for (const ast of cs) {
      switch (ast._tag) {
        case "NeverKeyword":
          break;
        case "AnyKeyword":
          return [anyKeyword];
        case "UnknownKeyword":
          return [unknownKeyword];
        // uniques
        case "ObjectKeyword":
        case "UndefinedKeyword":
        case "VoidKeyword":
        case "StringKeyword":
        case "NumberKeyword":
        case "BooleanKeyword":
        case "BigIntKeyword":
        case "SymbolKeyword": {
          if (!uniques[ast._tag]) {
            uniques[ast._tag] = ast;
            out.push(ast);
          }
          break;
        }
        case "Literal": {
          const type = typeof ast.literal;
          switch (type) {
            case "string":
            case "number":
            case "bigint":
            case "boolean": {
              const _tag = literalMap[type];
              if (!uniques[_tag] && !literals.includes(ast.literal)) {
                literals.push(ast.literal);
                out.push(ast);
              }
              break;
            }
            // null
            case "object": {
              if (!literals.includes(ast.literal)) {
                literals.push(ast.literal);
                out.push(ast);
              }
              break;
            }
          }
          break;
        }
        case "UniqueSymbol": {
          if (!uniques["SymbolKeyword"] && !literals.includes(ast.symbol)) {
            literals.push(ast.symbol);
            out.push(ast);
          }
          break;
        }
        case "TupleType": {
          if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
        case "TypeLiteral": {
          if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
            if (!uniques["{}"]) {
              uniques["{}"] = ast;
              out.push(ast);
            }
          } else if (!uniques["ObjectKeyword"]) {
            out.push(ast);
          }
          break;
        }
        default:
          out.push(ast);
      }
    }
    return out;
  };
  let Union$1 = (_b = class {
    constructor(types, annotations2 = {}) {
      __publicField(this, "types");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Union");
      this.types = types;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => this.types.map(String).join(" | "));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        types: this.types.map((ast) => ast.toJSON()),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  }, __publicField(_b, "make", (types, annotations2) => {
    return isMembers(types) ? new _b(types, annotations2) : types.length === 1 ? types[0] : neverKeyword;
  }), /** @internal */
  __publicField(_b, "unify", (candidates, annotations2) => {
    return _b.make(unify(flatten$7(candidates)), annotations2);
  }), _b);
  const mapMembers = (members, f) => members.map(f);
  const isMembers = (as2) => as2.length > 1;
  const isUnion = /* @__PURE__ */ createASTGuard("Union");
  const toJSONMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Schema/AST/toJSONMemoMap"), () => /* @__PURE__ */ new WeakMap());
  class Suspend {
    constructor(f, annotations2 = {}) {
      __publicField(this, "f");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Suspend");
      this.f = f;
      this.annotations = annotations2;
      this.f = memoizeThunk(f);
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getExpected(this).pipe(orElse$1(() => flatMap$a(liftThrowable(this.f)(), (ast) => getExpected(ast))), getOrElse(() => "<suspended schema>"));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      const ast = this.f();
      let out = toJSONMemoMap.get(ast);
      if (out) {
        return out;
      }
      toJSONMemoMap.set(ast, {
        _tag: this._tag
      });
      out = {
        _tag: this._tag,
        ast: ast.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
      toJSONMemoMap.set(ast, out);
      return out;
    }
  }
  let Refinement$1 = class Refinement {
    constructor(from, filter2, annotations2 = {}) {
      __publicField(this, "from");
      __publicField(this, "filter");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Refinement");
      this.from = from;
      this.filter = filter2;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getIdentifierAnnotation(this).pipe(getOrElse(() => match$a(getOrElseExpected(this), {
        onNone: () => `{ ${this.from} | filter }`,
        onSome: (expected) => isRefinement$1(this.from) ? String(this.from) + " & " + expected : expected
      })));
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        from: this.from.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  };
  const isRefinement$1 = /* @__PURE__ */ createASTGuard("Refinement");
  const defaultParseOption = {};
  let Transformation$1 = class Transformation {
    constructor(from, to, transformation, annotations2 = {}) {
      __publicField(this, "from");
      __publicField(this, "to");
      __publicField(this, "transformation");
      __publicField(this, "annotations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Transformation");
      this.from = from;
      this.to = to;
      this.transformation = transformation;
      this.annotations = annotations2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return getOrElse(getExpected(this), () => `(${String(this.from)} <-> ${String(this.to)})`);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _tag: this._tag,
        from: this.from.toJSON(),
        to: this.to.toJSON(),
        annotations: toJSONAnnotations(this.annotations)
      };
    }
  };
  const isTransformation$1 = /* @__PURE__ */ createASTGuard("Transformation");
  class FinalTransformation {
    constructor(decode2, encode2) {
      __publicField(this, "decode");
      __publicField(this, "encode");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "FinalTransformation");
      this.decode = decode2;
      this.encode = encode2;
    }
  }
  const createTransformationGuard = (tag2) => (ast) => ast._tag === tag2;
  class ComposeTransformation {
    constructor() {
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "ComposeTransformation");
    }
  }
  const composeTransformation = /* @__PURE__ */ new ComposeTransformation();
  let PropertySignatureTransformation$1 = class PropertySignatureTransformation {
    constructor(from, to, decode2, encode2) {
      __publicField(this, "from");
      __publicField(this, "to");
      __publicField(this, "decode");
      __publicField(this, "encode");
      this.from = from;
      this.to = to;
      this.decode = decode2;
      this.encode = encode2;
    }
  };
  const isRenamingPropertySignatureTransformation = (t) => t.decode === identity && t.encode === identity;
  class TypeLiteralTransformation {
    constructor(propertySignatureTransformations) {
      __publicField(this, "propertySignatureTransformations");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "TypeLiteralTransformation");
      this.propertySignatureTransformations = propertySignatureTransformations;
      const fromKeys = {};
      const toKeys = {};
      for (const pst of propertySignatureTransformations) {
        const from = pst.from;
        if (fromKeys[from]) {
          throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(from));
        }
        fromKeys[from] = true;
        const to = pst.to;
        if (toKeys[to]) {
          throw new Error(getASTDuplicatePropertySignatureTransformationErrorMessage(to));
        }
        toKeys[to] = true;
      }
    }
  }
  const isTypeLiteralTransformation = /* @__PURE__ */ createTransformationGuard("TypeLiteralTransformation");
  const annotations$1 = (ast, overrides) => {
    const d = Object.getOwnPropertyDescriptors(ast);
    const value2 = {
      ...ast.annotations,
      ...overrides
    };
    const surrogate = getSurrogateAnnotation(ast);
    if (isSome(surrogate)) {
      value2[SurrogateAnnotationId] = annotations$1(surrogate.value, overrides);
    }
    d.annotations.value = value2;
    return Object.create(Object.getPrototypeOf(ast), d);
  };
  const STRING_KEYWORD_PATTERN = "[\\s\\S]*";
  const NUMBER_KEYWORD_PATTERN = "[+-]?\\d*\\.?\\d+(?:[Ee][+-]?\\d+)?";
  const getTemplateLiteralSpanTypePattern = (type, capture2) => {
    switch (type._tag) {
      case "Literal":
        return escape(String(type.literal));
      case "StringKeyword":
        return STRING_KEYWORD_PATTERN;
      case "NumberKeyword":
        return NUMBER_KEYWORD_PATTERN;
      case "TemplateLiteral":
        return getTemplateLiteralPattern(type);
      case "Union":
        return type.types.map((type2) => getTemplateLiteralSpanTypePattern(type2)).join("|");
    }
  };
  const handleTemplateLiteralSpanTypeParens = (type, s, capture2, top) => {
    if (isUnion(type)) ;
    else {
      return s;
    }
    return `(${s})`;
  };
  const getTemplateLiteralPattern = (ast, capture2, top) => {
    let pattern = ``;
    if (ast.head !== "") {
      const head2 = escape(ast.head);
      pattern += head2;
    }
    for (const span2 of ast.spans) {
      const spanPattern = getTemplateLiteralSpanTypePattern(span2.type);
      pattern += handleTemplateLiteralSpanTypeParens(span2.type, spanPattern);
      if (span2.literal !== "") {
        const literal = escape(span2.literal);
        pattern += literal;
      }
    }
    return pattern;
  };
  const getTemplateLiteralRegExp = (ast) => new RegExp(`^${getTemplateLiteralPattern(ast)}$`);
  const getPropertySignatures = (ast) => {
    const annotation = getSurrogateAnnotation(ast);
    if (isSome(annotation)) {
      return getPropertySignatures(annotation.value);
    }
    switch (ast._tag) {
      case "TypeLiteral":
        return ast.propertySignatures.slice();
      case "Suspend":
        return getPropertySignatures(ast.f());
      case "Refinement":
        return getPropertySignatures(ast.from);
    }
    return getPropertyKeys(ast).map((name) => getPropertyKeyIndexedAccess(ast, name));
  };
  const getNumberIndexedAccess$1 = (ast) => {
    switch (ast._tag) {
      case "TupleType": {
        let hasOptional = false;
        let out = [];
        for (const e of ast.elements) {
          if (e.isOptional) {
            hasOptional = true;
          }
          out.push(e.type);
        }
        if (hasOptional) {
          out.push(undefinedKeyword);
        }
        out = out.concat(getRestASTs(ast.rest));
        return Union$1.make(out);
      }
      case "Refinement":
        return getNumberIndexedAccess$1(ast.from);
      case "Union":
        return Union$1.make(ast.types.map(getNumberIndexedAccess$1));
      case "Suspend":
        return getNumberIndexedAccess$1(ast.f());
    }
    throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
  };
  const getTypeLiteralPropertySignature = (ast, name) => {
    const ops = findFirst(ast.propertySignatures, (ps) => ps.name === name);
    if (isSome(ops)) {
      return ops.value;
    }
    if (isString(name)) {
      let out = void 0;
      for (const is2 of ast.indexSignatures) {
        const encodedParameter = getEncodedParameter(is2.parameter);
        switch (encodedParameter._tag) {
          case "TemplateLiteral": {
            const regex = getTemplateLiteralRegExp(encodedParameter);
            if (regex.test(name)) {
              return new PropertySignature(name, is2.type, false, true);
            }
            break;
          }
          case "StringKeyword": {
            if (out === void 0) {
              out = new PropertySignature(name, is2.type, false, true);
            }
          }
        }
      }
      if (out) {
        return out;
      }
    } else if (isSymbol(name)) {
      for (const is2 of ast.indexSignatures) {
        const encodedParameter = getEncodedParameter(is2.parameter);
        if (isSymbolKeyword(encodedParameter)) {
          return new PropertySignature(name, is2.type, false, true);
        }
      }
    }
  };
  const getPropertyKeyIndexedAccess = (ast, name) => {
    const annotation = getSurrogateAnnotation(ast);
    if (isSome(annotation)) {
      return getPropertyKeyIndexedAccess(annotation.value, name);
    }
    switch (ast._tag) {
      case "TypeLiteral": {
        const ps = getTypeLiteralPropertySignature(ast, name);
        if (ps) {
          return ps;
        }
        break;
      }
      case "Union":
        return new PropertySignature(name, Union$1.make(ast.types.map((ast2) => getPropertyKeyIndexedAccess(ast2, name).type)), false, true);
      case "Suspend":
        return getPropertyKeyIndexedAccess(ast.f(), name);
      case "Refinement":
        return getPropertyKeyIndexedAccess(ast.from, name);
    }
    throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
  };
  const getPropertyKeys = (ast) => {
    const annotation = getSurrogateAnnotation(ast);
    if (isSome(annotation)) {
      return getPropertyKeys(annotation.value);
    }
    switch (ast._tag) {
      case "TypeLiteral":
        return ast.propertySignatures.map((ps) => ps.name);
      case "Union":
        return ast.types.slice(1).reduce((out, ast2) => intersection(out, getPropertyKeys(ast2)), getPropertyKeys(ast.types[0]));
      case "Suspend":
        return getPropertyKeys(ast.f());
      case "Refinement":
        return getPropertyKeys(ast.from);
      case "Transformation":
        return getPropertyKeys(ast.to);
    }
    return [];
  };
  const record = (key, value2) => {
    const propertySignatures = [];
    const indexSignatures = [];
    const go2 = (key2) => {
      switch (key2._tag) {
        case "NeverKeyword":
          break;
        case "StringKeyword":
        case "SymbolKeyword":
        case "TemplateLiteral":
        case "Refinement":
          indexSignatures.push(new IndexSignature(key2, value2, true));
          break;
        case "Literal":
          if (isString(key2.literal) || isNumber(key2.literal)) {
            propertySignatures.push(new PropertySignature(key2.literal, value2, false, true));
          } else {
            throw new Error(getASTUnsupportedLiteralErrorMessage(key2.literal));
          }
          break;
        case "Enums": {
          for (const [_, name] of key2.enums) {
            propertySignatures.push(new PropertySignature(name, value2, false, true));
          }
          break;
        }
        case "UniqueSymbol":
          propertySignatures.push(new PropertySignature(key2.symbol, value2, false, true));
          break;
        case "Union":
          key2.types.forEach(go2);
          break;
        default:
          throw new Error(getASTUnsupportedKeySchemaErrorMessage(key2));
      }
    };
    go2(key);
    return {
      propertySignatures,
      indexSignatures
    };
  };
  const pick$2 = (ast, keys2) => {
    const annotation = getSurrogateAnnotation(ast);
    if (isSome(annotation)) {
      return pick$2(annotation.value, keys2);
    }
    switch (ast._tag) {
      case "TypeLiteral": {
        const pss = [];
        const names = {};
        for (const ps of ast.propertySignatures) {
          names[ps.name] = null;
          if (keys2.includes(ps.name)) {
            pss.push(ps);
          }
        }
        for (const key of keys2) {
          if (!(key in names)) {
            const ps = getTypeLiteralPropertySignature(ast, key);
            if (ps) {
              pss.push(ps);
            }
          }
        }
        return new TypeLiteral(pss, []);
      }
      case "Union":
        return new TypeLiteral(keys2.map((name) => getPropertyKeyIndexedAccess(ast, name)), []);
      case "Suspend":
        return pick$2(ast.f(), keys2);
      case "Refinement":
        return pick$2(ast.from, keys2);
      case "Transformation": {
        switch (ast.transformation._tag) {
          case "ComposeTransformation":
            return new Transformation$1(pick$2(ast.from, keys2), pick$2(ast.to, keys2), composeTransformation);
          case "TypeLiteralTransformation": {
            const ts = [];
            const fromKeys = [];
            for (const k of keys2) {
              const t = ast.transformation.propertySignatureTransformations.find((t2) => t2.to === k);
              if (t) {
                ts.push(t);
                fromKeys.push(t.from);
              } else {
                fromKeys.push(k);
              }
            }
            return isNonEmptyReadonlyArray(ts) ? new Transformation$1(pick$2(ast.from, fromKeys), pick$2(ast.to, keys2), new TypeLiteralTransformation(ts)) : pick$2(ast.from, fromKeys);
          }
        }
      }
    }
    throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
  };
  const orUndefined = (ast) => Union$1.make([ast, undefinedKeyword]);
  const partial$1 = (ast, options2) => {
    switch (ast._tag) {
      case "TupleType":
        return new TupleType(ast.elements.map((e) => new OptionalType(orUndefined(e.type), true)), match$9(ast.rest, {
          onEmpty: () => ast.rest,
          onNonEmpty: (rest) => [new Type$1(Union$1.make([...getRestASTs(rest), undefinedKeyword]))]
        }), ast.isReadonly);
      case "TypeLiteral":
        return new TypeLiteral(ast.propertySignatures.map((ps) => new PropertySignature(ps.name, orUndefined(ps.type), true, ps.isReadonly, ps.annotations)), ast.indexSignatures.map((is2) => new IndexSignature(is2.parameter, orUndefined(is2.type), is2.isReadonly)));
      case "Union":
        return Union$1.make(ast.types.map((member) => partial$1(member)));
      case "Suspend":
        return new Suspend(() => partial$1(ast.f()));
      case "Declaration":
      case "Refinement":
        throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
      case "Transformation": {
        if (isTypeLiteralTransformation(ast.transformation) && ast.transformation.propertySignatureTransformations.every(isRenamingPropertySignatureTransformation)) {
          return new Transformation$1(partial$1(ast.from), partial$1(ast.to), ast.transformation);
        }
        throw new Error(getASTUnsupportedSchemaErrorMessage(ast));
      }
    }
    return ast;
  };
  const mutable$1 = (ast) => {
    switch (ast._tag) {
      case "TupleType":
        return ast.isReadonly === false ? ast : new TupleType(ast.elements, ast.rest, false, ast.annotations);
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (ps) => ps.isReadonly === false ? ps : new PropertySignature(ps.name, ps.type, ps.isOptional, false, ps.annotations));
        const indexSignatures = changeMap(ast.indexSignatures, (is2) => is2.isReadonly === false ? is2 : new IndexSignature(is2.parameter, is2.type, false));
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
      case "Union": {
        const types = changeMap(ast.types, mutable$1);
        return types === ast.types ? ast : Union$1.make(types, ast.annotations);
      }
      case "Suspend":
        return new Suspend(() => mutable$1(ast.f()), ast.annotations);
      case "Refinement": {
        const from = mutable$1(ast.from);
        return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
      }
      case "Transformation": {
        const from = mutable$1(ast.from);
        const to = mutable$1(ast.to);
        return from === ast.from && to === ast.to ? ast : new Transformation$1(from, to, ast.transformation, ast.annotations);
      }
    }
    return ast;
  };
  const pickAnnotations = (annotationIds) => (annotated) => {
    let out = void 0;
    for (const id2 of annotationIds) {
      if (Object.prototype.hasOwnProperty.call(annotated.annotations, id2)) {
        if (out === void 0) {
          out = {};
        }
        out[id2] = annotated.annotations[id2];
      }
    }
    return out;
  };
  const omitAnnotations = (annotationIds) => (annotated) => {
    const out = {
      ...annotated.annotations
    };
    for (const id2 of annotationIds) {
      delete out[id2];
    }
    return out;
  };
  const preserveTransformationAnnotations = /* @__PURE__ */ pickAnnotations([ExamplesAnnotationId, DefaultAnnotationId, JSONSchemaAnnotationId, ArbitraryAnnotationId, PrettyAnnotationId, EquivalenceAnnotationId]);
  const typeAST = (ast) => {
    switch (ast._tag) {
      case "Declaration": {
        const typeParameters = changeMap(ast.typeParameters, typeAST);
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
      case "TupleType": {
        const elements = changeMap(ast.elements, (e) => {
          const type = typeAST(e.type);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, typeAST);
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((type) => new Type$1(type)), ast.isReadonly, ast.annotations);
      }
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (p) => {
          const type = typeAST(p.type);
          return type === p.type ? p : new PropertySignature(p.name, type, p.isOptional, p.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, (is2) => {
          const type = typeAST(is2.type);
          return type === is2.type ? is2 : new IndexSignature(is2.parameter, type, is2.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, ast.annotations);
      }
      case "Union": {
        const types = changeMap(ast.types, typeAST);
        return types === ast.types ? ast : Union$1.make(types, ast.annotations);
      }
      case "Suspend":
        return new Suspend(() => typeAST(ast.f()), ast.annotations);
      case "Refinement": {
        const from = typeAST(ast.from);
        return from === ast.from ? ast : new Refinement$1(from, ast.filter, ast.annotations);
      }
      case "Transformation": {
        const preserve = preserveTransformationAnnotations(ast);
        return typeAST(preserve !== void 0 ? annotations$1(ast.to, preserve) : ast.to);
      }
    }
    return ast;
  };
  const createJSONIdentifierAnnotation = (annotated) => match$a(getJSONIdentifier(annotated), {
    onNone: () => void 0,
    onSome: (identifier2) => ({
      [JSONIdentifierAnnotationId]: identifier2
    })
  });
  function changeMap(as2, f) {
    let changed = false;
    const out = allocate(as2.length);
    for (let i = 0; i < as2.length; i++) {
      const a = as2[i];
      const fa = f(a);
      if (fa !== a) {
        changed = true;
      }
      out[i] = fa;
    }
    return changed ? out : as2;
  }
  const encodedAST_ = (ast, isBound) => {
    switch (ast._tag) {
      case "Declaration": {
        const typeParameters = changeMap(ast.typeParameters, (ast2) => encodedAST_(ast2));
        return typeParameters === ast.typeParameters ? ast : new Declaration(typeParameters, ast.decodeUnknown, ast.encodeUnknown, ast.annotations);
      }
      case "TupleType": {
        const elements = changeMap(ast.elements, (e) => {
          const type = encodedAST_(e.type);
          return type === e.type ? e : new OptionalType(type, e.isOptional);
        });
        const restASTs = getRestASTs(ast.rest);
        const rest = changeMap(restASTs, (ast2) => encodedAST_(ast2));
        return elements === ast.elements && rest === restASTs ? ast : new TupleType(elements, rest.map((ast2) => new Type$1(ast2)), ast.isReadonly, createJSONIdentifierAnnotation(ast));
      }
      case "TypeLiteral": {
        const propertySignatures = changeMap(ast.propertySignatures, (ps) => {
          const type = encodedAST_(ps.type);
          return type === ps.type ? ps : new PropertySignature(ps.name, type, ps.isOptional, ps.isReadonly);
        });
        const indexSignatures = changeMap(ast.indexSignatures, (is2) => {
          const type = encodedAST_(is2.type);
          return type === is2.type ? is2 : new IndexSignature(is2.parameter, type, is2.isReadonly);
        });
        return propertySignatures === ast.propertySignatures && indexSignatures === ast.indexSignatures ? ast : new TypeLiteral(propertySignatures, indexSignatures, createJSONIdentifierAnnotation(ast));
      }
      case "Union": {
        const types = changeMap(ast.types, (ast2) => encodedAST_(ast2));
        return types === ast.types ? ast : Union$1.make(types, createJSONIdentifierAnnotation(ast));
      }
      case "Suspend":
        return new Suspend(() => encodedAST_(ast.f()), createJSONIdentifierAnnotation(ast));
      case "Refinement": {
        const from = encodedAST_(ast.from);
        const identifier2 = createJSONIdentifierAnnotation(ast);
        return identifier2 ? annotations$1(from, identifier2) : from;
      }
      case "Transformation": {
        const identifier2 = createJSONIdentifierAnnotation(ast);
        return encodedAST_(identifier2 ? annotations$1(ast.from, identifier2) : ast.from);
      }
    }
    return ast;
  };
  const encodedAST = (ast) => encodedAST_(ast);
  const toJSONAnnotations = (annotations2) => {
    const out = {};
    for (const k of Object.getOwnPropertySymbols(annotations2)) {
      out[String(k)] = annotations2[k];
    }
    return out;
  };
  const getEncodedParameter = (ast) => {
    switch (ast._tag) {
      case "StringKeyword":
      case "SymbolKeyword":
      case "TemplateLiteral":
        return ast;
      case "Refinement":
        return getEncodedParameter(ast.from);
    }
  };
  const compose$1 = (ab, cd) => new Transformation$1(ab, cd, composeTransformation);
  const formatKeyword = (ast) => getOrElse(getExpected(ast), () => ast._tag);
  function getBrands(ast) {
    return match$a(getBrandAnnotation(ast), {
      onNone: () => "",
      onSome: (brands) => brands.map((brand2) => ` & Brand<${formatUnknown(brand2)}>`).join("")
    });
  }
  const getOrElseExpected = (ast) => getTitleAnnotation(ast).pipe(orElse$1(() => getDescriptionAnnotation(ast)), orElse$1(() => getAutoTitleAnnotation(ast)), map$h((s) => s + getBrands(ast)));
  const getExpected = (ast) => orElse$1(getIdentifierAnnotation(ast), () => getOrElseExpected(ast));
  const pruneUndefined$1 = (ast, self2, onTransformation) => {
    switch (ast._tag) {
      case "UndefinedKeyword":
        return neverKeyword;
      case "Union": {
        const types = [];
        let hasUndefined = false;
        for (const type of ast.types) {
          const pruned = self2(type);
          if (pruned) {
            hasUndefined = true;
            if (!isNeverKeyword(pruned)) {
              types.push(pruned);
            }
          } else {
            types.push(type);
          }
        }
        if (hasUndefined) {
          return Union$1.make(types);
        }
        break;
      }
      case "Suspend":
        return self2(ast.f());
      case "Transformation":
        return onTransformation(ast);
    }
  };
  const RefinedConstructorsTypeId = /* @__PURE__ */ Symbol.for("effect/Brand/Refined");
  const nominal = () => {
    return Object.assign((args2) => args2, {
      [RefinedConstructorsTypeId]: RefinedConstructorsTypeId,
      option: (args2) => some(args2),
      either: (args2) => right(args2),
      is: (_args) => true
    });
  };
  const TagTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Tag");
  const ReferenceTypeId = /* @__PURE__ */ Symbol.for("effect/Context/Reference");
  const STMSymbolKey$1 = "effect/STM";
  const STMTypeId$1 = /* @__PURE__ */ Symbol.for(STMSymbolKey$1);
  const TagProto = {
    ...EffectPrototype$1,
    _op: "Tag",
    [STMTypeId$1]: effectVariance,
    [TagTypeId]: {
      _Service: (_) => _,
      _Identifier: (_) => _
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Tag",
        key: this.key,
        stack: this.stack
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    of(self2) {
      return self2;
    },
    context(self2) {
      return make$_(this, self2);
    }
  };
  const ReferenceProto = {
    ...TagProto,
    [ReferenceTypeId]: ReferenceTypeId
  };
  const makeGenericTag = (key) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    const tag2 = Object.create(TagProto);
    Object.defineProperty(tag2, "stack", {
      get() {
        return creationError.stack;
      }
    });
    tag2.key = key;
    return tag2;
  };
  const Tag$1 = (id2) => () => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    function TagClass() {
    }
    Object.setPrototypeOf(TagClass, TagProto);
    TagClass.key = id2;
    Object.defineProperty(TagClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return TagClass;
  };
  const Reference$1 = () => (id2, options2) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const creationError = new Error();
    Error.stackTraceLimit = limit;
    function ReferenceClass() {
    }
    Object.setPrototypeOf(ReferenceClass, ReferenceProto);
    ReferenceClass.key = id2;
    ReferenceClass.defaultValue = options2.defaultValue;
    Object.defineProperty(ReferenceClass, "stack", {
      get() {
        return creationError.stack;
      }
    });
    return ReferenceClass;
  };
  const TypeId$r = /* @__PURE__ */ Symbol.for("effect/Context");
  const ContextProto = {
    [TypeId$r]: {
      _Services: (_) => _
    },
    [symbol](that) {
      if (isContext$1(that)) {
        if (this.unsafeMap.size === that.unsafeMap.size) {
          for (const k of this.unsafeMap.keys()) {
            if (!that.unsafeMap.has(k) || !equals$1(this.unsafeMap.get(k), that.unsafeMap.get(k))) {
              return false;
            }
          }
          return true;
        }
      }
      return false;
    },
    [symbol$1]() {
      return cached$1(this, number$1(this.unsafeMap.size));
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Context",
        services: Array.from(this.unsafeMap).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  const makeContext = (unsafeMap) => {
    const context2 = Object.create(ContextProto);
    context2.unsafeMap = unsafeMap;
    return context2;
  };
  const serviceNotFoundError = (tag2) => {
    const error = new Error(`Service not found${tag2.key ? `: ${String(tag2.key)}` : ""}`);
    if (tag2.stack) {
      const lines = tag2.stack.split("\n");
      if (lines.length > 2) {
        const afterAt = lines[2].match(/at (.*)/);
        if (afterAt) {
          error.message = error.message + ` (defined at ${afterAt[1]})`;
        }
      }
    }
    if (error.stack) {
      const lines = error.stack.split("\n");
      lines.splice(1, 3);
      error.stack = lines.join("\n");
    }
    return error;
  };
  const isContext$1 = (u) => hasProperty(u, TypeId$r);
  const isTag$1 = (u) => hasProperty(u, TagTypeId);
  const isReference = (u) => hasProperty(u, ReferenceTypeId);
  const _empty$6 = /* @__PURE__ */ makeContext(/* @__PURE__ */ new Map());
  const empty$t = () => _empty$6;
  const make$_ = (tag2, service) => makeContext(/* @__PURE__ */ new Map([[tag2.key, service]]));
  const add$3 = /* @__PURE__ */ dual(3, (self2, tag2, service) => {
    const map2 = new Map(self2.unsafeMap);
    map2.set(tag2.key, service);
    return makeContext(map2);
  });
  const defaultValueCache = /* @__PURE__ */ globalValue("effect/Context/defaultValueCache", () => /* @__PURE__ */ new Map());
  const getDefaultValue = (tag2) => {
    if (defaultValueCache.has(tag2.key)) {
      return defaultValueCache.get(tag2.key);
    }
    const value2 = tag2.defaultValue();
    defaultValueCache.set(tag2.key, value2);
    return value2;
  };
  const unsafeGetReference = (self2, tag2) => {
    return self2.unsafeMap.has(tag2.key) ? self2.unsafeMap.get(tag2.key) : getDefaultValue(tag2);
  };
  const unsafeGet$4 = /* @__PURE__ */ dual(2, (self2, tag2) => {
    if (!self2.unsafeMap.has(tag2.key)) {
      if (ReferenceTypeId in tag2) return getDefaultValue(tag2);
      throw serviceNotFoundError(tag2);
    }
    return self2.unsafeMap.get(tag2.key);
  });
  const get$f = unsafeGet$4;
  const getOption$1 = /* @__PURE__ */ dual(2, (self2, tag2) => {
    if (!self2.unsafeMap.has(tag2.key)) {
      return isReference(tag2) ? some$1(getDefaultValue(tag2)) : none$5;
    }
    return some$1(self2.unsafeMap.get(tag2.key));
  });
  const merge$5 = /* @__PURE__ */ dual(2, (self2, that) => {
    const map2 = new Map(self2.unsafeMap);
    for (const [tag2, s] of that.unsafeMap) {
      map2.set(tag2, s);
    }
    return makeContext(map2);
  });
  const omit$2 = (...tags) => (self2) => {
    const newEnv = new Map(self2.unsafeMap);
    for (const tag2 of tags) {
      newEnv.delete(tag2.key);
    }
    return makeContext(newEnv);
  };
  const GenericTag = makeGenericTag;
  const isContext = isContext$1;
  const isTag = isTag$1;
  const empty$s = empty$t;
  const make$Z = make$_;
  const add$2 = add$3;
  const get$e = get$f;
  const unsafeGet$3 = unsafeGet$4;
  const getOption = getOption$1;
  const merge$4 = merge$5;
  const omit$1 = omit$2;
  const Tag = Tag$1;
  const Reference = Reference$1;
  const TypeId$q = /* @__PURE__ */ Symbol.for("effect/Chunk");
  function copy(src, srcPos, dest, destPos, len) {
    for (let i = srcPos; i < Math.min(src.length, srcPos + len); i++) {
      dest[destPos + i - srcPos] = src[i];
    }
    return dest;
  }
  const emptyArray = [];
  const getEquivalence$1 = (isEquivalent) => make$11((self2, that) => self2.length === that.length && toReadonlyArray(self2).every((value2, i) => isEquivalent(value2, unsafeGet$2(that, i))));
  const _equivalence$1 = /* @__PURE__ */ getEquivalence$1(equals$1);
  const ChunkProto = {
    [TypeId$q]: {
      _A: (_) => _
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "Chunk",
        values: toReadonlyArray(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol](that) {
      return isChunk(that) && _equivalence$1(this, that);
    },
    [symbol$1]() {
      return cached$1(this, array(toReadonlyArray(this)));
    },
    [Symbol.iterator]() {
      switch (this.backing._tag) {
        case "IArray": {
          return this.backing.array[Symbol.iterator]();
        }
        case "IEmpty": {
          return emptyArray[Symbol.iterator]();
        }
        default: {
          return toReadonlyArray(this)[Symbol.iterator]();
        }
      }
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const makeChunk = (backing) => {
    const chunk2 = Object.create(ChunkProto);
    chunk2.backing = backing;
    switch (backing._tag) {
      case "IEmpty": {
        chunk2.length = 0;
        chunk2.depth = 0;
        chunk2.left = chunk2;
        chunk2.right = chunk2;
        break;
      }
      case "IConcat": {
        chunk2.length = backing.left.length + backing.right.length;
        chunk2.depth = 1 + Math.max(backing.left.depth, backing.right.depth);
        chunk2.left = backing.left;
        chunk2.right = backing.right;
        break;
      }
      case "IArray": {
        chunk2.length = backing.array.length;
        chunk2.depth = 0;
        chunk2.left = _empty$5;
        chunk2.right = _empty$5;
        break;
      }
      case "ISingleton": {
        chunk2.length = 1;
        chunk2.depth = 0;
        chunk2.left = _empty$5;
        chunk2.right = _empty$5;
        break;
      }
      case "ISlice": {
        chunk2.length = backing.length;
        chunk2.depth = backing.chunk.depth + 1;
        chunk2.left = _empty$5;
        chunk2.right = _empty$5;
        break;
      }
    }
    return chunk2;
  };
  const isChunk = (u) => hasProperty(u, TypeId$q);
  const _empty$5 = /* @__PURE__ */ makeChunk({
    _tag: "IEmpty"
  });
  const empty$r = () => _empty$5;
  const make$Y = (...as2) => unsafeFromNonEmptyArray(as2);
  const of$2 = (a) => makeChunk({
    _tag: "ISingleton",
    a
  });
  const fromIterable$7 = (self2) => isChunk(self2) ? self2 : unsafeFromArray(fromIterable$8(self2));
  const copyToArray = (self2, array2, initial) => {
    switch (self2.backing._tag) {
      case "IArray": {
        copy(self2.backing.array, 0, array2, initial, self2.length);
        break;
      }
      case "IConcat": {
        copyToArray(self2.left, array2, initial);
        copyToArray(self2.right, array2, initial + self2.left.length);
        break;
      }
      case "ISingleton": {
        array2[initial] = self2.backing.a;
        break;
      }
      case "ISlice": {
        let i = 0;
        let j = initial;
        while (i < self2.length) {
          array2[j] = unsafeGet$2(self2, i);
          i += 1;
          j += 1;
        }
        break;
      }
    }
  };
  const toReadonlyArray_ = (self2) => {
    switch (self2.backing._tag) {
      case "IEmpty": {
        return emptyArray;
      }
      case "IArray": {
        return self2.backing.array;
      }
      default: {
        const arr = new Array(self2.length);
        copyToArray(self2, arr, 0);
        self2.backing = {
          _tag: "IArray",
          array: arr
        };
        self2.left = _empty$5;
        self2.right = _empty$5;
        self2.depth = 0;
        return arr;
      }
    }
  };
  const toReadonlyArray = toReadonlyArray_;
  const reverseChunk = (self2) => {
    switch (self2.backing._tag) {
      case "IEmpty":
      case "ISingleton":
        return self2;
      case "IArray": {
        return makeChunk({
          _tag: "IArray",
          array: reverse$2(self2.backing.array)
        });
      }
      case "IConcat": {
        return makeChunk({
          _tag: "IConcat",
          left: reverse$1(self2.backing.right),
          right: reverse$1(self2.backing.left)
        });
      }
      case "ISlice":
        return unsafeFromArray(reverse$2(toReadonlyArray(self2)));
    }
  };
  const reverse$1 = reverseChunk;
  const get$d = /* @__PURE__ */ dual(2, (self2, index) => index < 0 || index >= self2.length ? none$4() : some(unsafeGet$2(self2, index)));
  const unsafeFromArray = (self2) => self2.length === 0 ? empty$r() : self2.length === 1 ? of$2(self2[0]) : makeChunk({
    _tag: "IArray",
    array: self2
  });
  const unsafeFromNonEmptyArray = (self2) => unsafeFromArray(self2);
  const unsafeGet$2 = /* @__PURE__ */ dual(2, (self2, index) => {
    switch (self2.backing._tag) {
      case "IEmpty": {
        throw new Error(`Index out of bounds`);
      }
      case "ISingleton": {
        if (index !== 0) {
          throw new Error(`Index out of bounds`);
        }
        return self2.backing.a;
      }
      case "IArray": {
        if (index >= self2.length || index < 0) {
          throw new Error(`Index out of bounds`);
        }
        return self2.backing.array[index];
      }
      case "IConcat": {
        return index < self2.left.length ? unsafeGet$2(self2.left, index) : unsafeGet$2(self2.right, index - self2.left.length);
      }
      case "ISlice": {
        return unsafeGet$2(self2.backing.chunk, index + self2.backing.offset);
      }
    }
  });
  const append$1 = /* @__PURE__ */ dual(2, (self2, a) => appendAll$1(self2, of$2(a)));
  const prepend$1 = /* @__PURE__ */ dual(2, (self2, elem) => appendAll$1(of$2(elem), self2));
  const take$6 = /* @__PURE__ */ dual(2, (self2, n) => {
    if (n <= 0) {
      return _empty$5;
    } else if (n >= self2.length) {
      return self2;
    } else {
      switch (self2.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2.backing.chunk,
            length: n,
            offset: self2.backing.offset
          });
        }
        case "IConcat": {
          if (n > self2.left.length) {
            return makeChunk({
              _tag: "IConcat",
              left: self2.left,
              right: take$6(self2.right, n - self2.left.length)
            });
          }
          return take$6(self2.left, n);
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2,
            offset: 0,
            length: n
          });
        }
      }
    }
  });
  const drop = /* @__PURE__ */ dual(2, (self2, n) => {
    if (n <= 0) {
      return self2;
    } else if (n >= self2.length) {
      return _empty$5;
    } else {
      switch (self2.backing._tag) {
        case "ISlice": {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2.backing.chunk,
            offset: self2.backing.offset + n,
            length: self2.backing.length - n
          });
        }
        case "IConcat": {
          if (n > self2.left.length) {
            return drop(self2.right, n - self2.left.length);
          }
          return makeChunk({
            _tag: "IConcat",
            left: drop(self2.left, n),
            right: self2.right
          });
        }
        default: {
          return makeChunk({
            _tag: "ISlice",
            chunk: self2,
            offset: n,
            length: self2.length - n
          });
        }
      }
    }
  });
  const appendAll$1 = /* @__PURE__ */ dual(2, (self2, that) => {
    if (self2.backing._tag === "IEmpty") {
      return that;
    }
    if (that.backing._tag === "IEmpty") {
      return self2;
    }
    const diff2 = that.depth - self2.depth;
    if (Math.abs(diff2) <= 1) {
      return makeChunk({
        _tag: "IConcat",
        left: self2,
        right: that
      });
    } else if (diff2 < -1) {
      if (self2.left.depth >= self2.right.depth) {
        const nr = appendAll$1(self2.right, that);
        return makeChunk({
          _tag: "IConcat",
          left: self2.left,
          right: nr
        });
      } else {
        const nrr = appendAll$1(self2.right.right, that);
        if (nrr.depth === self2.depth - 3) {
          const nr = makeChunk({
            _tag: "IConcat",
            left: self2.right.left,
            right: nrr
          });
          return makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: nr
          });
        } else {
          const nl = makeChunk({
            _tag: "IConcat",
            left: self2.left,
            right: self2.right.left
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: nrr
          });
        }
      }
    } else {
      if (that.right.depth >= that.left.depth) {
        const nl = appendAll$1(self2, that.left);
        return makeChunk({
          _tag: "IConcat",
          left: nl,
          right: that.right
        });
      } else {
        const nll = appendAll$1(self2, that.left.left);
        if (nll.depth === that.depth - 3) {
          const nl = makeChunk({
            _tag: "IConcat",
            left: nll,
            right: that.left.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nl,
            right: that.right
          });
        } else {
          const nr = makeChunk({
            _tag: "IConcat",
            left: that.left.right,
            right: that.right
          });
          return makeChunk({
            _tag: "IConcat",
            left: nll,
            right: nr
          });
        }
      }
    }
  });
  const filterMap$2 = /* @__PURE__ */ dual(2, (self2, f) => unsafeFromArray(filterMap$3(self2, f)));
  const filter$3 = /* @__PURE__ */ dual(2, (self2, predicate) => unsafeFromArray(filter$4(self2, predicate)));
  const isEmpty$7 = (self2) => self2.length === 0;
  const isNonEmpty$2 = (self2) => self2.length > 0;
  const head$3 = /* @__PURE__ */ get$d(0);
  const unsafeHead = (self2) => unsafeGet$2(self2, 0);
  const headNonEmpty = unsafeHead;
  const last = (self2) => get$d(self2, self2.length - 1);
  const unsafeLast = (self2) => unsafeGet$2(self2, self2.length - 1);
  const map$d = /* @__PURE__ */ dual(2, (self2, f) => self2.backing._tag === "ISingleton" ? of$2(f(self2.backing.a, 0)) : unsafeFromArray(pipe(toReadonlyArray(self2), map$e((a, i) => f(a, i)))));
  const splitAt = /* @__PURE__ */ dual(2, (self2, n) => [take$6(self2, n), drop(self2, n)]);
  const splitWhere = /* @__PURE__ */ dual(2, (self2, predicate) => {
    let i = 0;
    for (const a of toReadonlyArray(self2)) {
      if (predicate(a)) {
        break;
      } else {
        i++;
      }
    }
    return splitAt(self2, i);
  });
  const tailNonEmpty = (self2) => drop(self2, 1);
  const takeRight = /* @__PURE__ */ dual(2, (self2, n) => drop(self2, self2.length - n));
  const reduce$6 = reduce$7;
  const TypeId$p = /* @__PURE__ */ Symbol.for("effect/Duration");
  const bigint0$2 = /* @__PURE__ */ BigInt(0);
  const bigint24 = /* @__PURE__ */ BigInt(24);
  const bigint60 = /* @__PURE__ */ BigInt(60);
  const bigint1e3 = /* @__PURE__ */ BigInt(1e3);
  const bigint1e6 = /* @__PURE__ */ BigInt(1e6);
  const bigint1e9$1 = /* @__PURE__ */ BigInt(1e9);
  const DURATION_REGEX = /^(-?\d+(?:\.\d+)?)\s+(nanos?|micros?|millis?|seconds?|minutes?|hours?|days?|weeks?)$/;
  const decode$3 = (input) => {
    if (isDuration(input)) {
      return input;
    } else if (isNumber(input)) {
      return millis(input);
    } else if (isBigInt(input)) {
      return nanos(input);
    } else if (Array.isArray(input) && input.length === 2 && input.every(isNumber)) {
      if (input[0] === -Infinity || input[1] === -Infinity || Number.isNaN(input[0]) || Number.isNaN(input[1])) {
        return zero;
      }
      if (input[0] === Infinity || input[1] === Infinity) {
        return infinity;
      }
      return nanos(BigInt(Math.round(input[0] * 1e9)) + BigInt(Math.round(input[1])));
    } else if (isString(input)) {
      const match2 = DURATION_REGEX.exec(input);
      if (match2) {
        const [_, valueStr, unit] = match2;
        const value2 = Number(valueStr);
        switch (unit) {
          case "nano":
          case "nanos":
            return nanos(BigInt(valueStr));
          case "micro":
          case "micros":
            return micros(BigInt(valueStr));
          case "milli":
          case "millis":
            return millis(value2);
          case "second":
          case "seconds":
            return seconds(value2);
          case "minute":
          case "minutes":
            return minutes(value2);
          case "hour":
          case "hours":
            return hours(value2);
          case "day":
          case "days":
            return days(value2);
          case "week":
          case "weeks":
            return weeks(value2);
        }
      }
    }
    throw new Error("Invalid DurationInput");
  };
  const zeroValue = {
    _tag: "Millis",
    millis: 0
  };
  const infinityValue = {
    _tag: "Infinity"
  };
  const DurationProto = {
    [TypeId$p]: TypeId$p,
    [symbol$1]() {
      return cached$1(this, structure(this.value));
    },
    [symbol](that) {
      return isDuration(that) && equals(this, that);
    },
    toString() {
      return `Duration(${format$2(this)})`;
    },
    toJSON() {
      switch (this.value._tag) {
        case "Millis":
          return {
            _id: "Duration",
            _tag: "Millis",
            millis: this.value.millis
          };
        case "Nanos":
          return {
            _id: "Duration",
            _tag: "Nanos",
            hrtime: toHrTime(this)
          };
        case "Infinity":
          return {
            _id: "Duration",
            _tag: "Infinity"
          };
      }
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const make$X = (input) => {
    const duration = Object.create(DurationProto);
    if (isNumber(input)) {
      if (isNaN(input) || input <= 0) {
        duration.value = zeroValue;
      } else if (!Number.isFinite(input)) {
        duration.value = infinityValue;
      } else if (!Number.isInteger(input)) {
        duration.value = {
          _tag: "Nanos",
          nanos: BigInt(Math.round(input * 1e6))
        };
      } else {
        duration.value = {
          _tag: "Millis",
          millis: input
        };
      }
    } else if (input <= bigint0$2) {
      duration.value = zeroValue;
    } else {
      duration.value = {
        _tag: "Nanos",
        nanos: input
      };
    }
    return duration;
  };
  const isDuration = (u) => hasProperty(u, TypeId$p);
  const isZero = (self2) => {
    switch (self2.value._tag) {
      case "Millis": {
        return self2.value.millis === 0;
      }
      case "Nanos": {
        return self2.value.nanos === bigint0$2;
      }
      case "Infinity": {
        return false;
      }
    }
  };
  const zero = /* @__PURE__ */ make$X(0);
  const infinity = /* @__PURE__ */ make$X(Infinity);
  const nanos = (nanos2) => make$X(nanos2);
  const micros = (micros2) => make$X(micros2 * bigint1e3);
  const millis = (millis2) => make$X(millis2);
  const seconds = (seconds2) => make$X(seconds2 * 1e3);
  const minutes = (minutes2) => make$X(minutes2 * 6e4);
  const hours = (hours2) => make$X(hours2 * 36e5);
  const days = (days2) => make$X(days2 * 864e5);
  const weeks = (weeks2) => make$X(weeks2 * 6048e5);
  const toMillis = (self2) => match$8(self2, {
    onMillis: (millis2) => millis2,
    onNanos: (nanos2) => Number(nanos2) / 1e6
  });
  const unsafeToNanos = (self2) => {
    const _self = decode$3(self2);
    switch (_self.value._tag) {
      case "Infinity":
        throw new Error("Cannot convert infinite duration to nanos");
      case "Nanos":
        return _self.value.nanos;
      case "Millis":
        return BigInt(Math.round(_self.value.millis * 1e6));
    }
  };
  const toHrTime = (self2) => {
    const _self = decode$3(self2);
    switch (_self.value._tag) {
      case "Infinity":
        return [Infinity, 0];
      case "Nanos":
        return [Number(_self.value.nanos / bigint1e9$1), Number(_self.value.nanos % bigint1e9$1)];
      case "Millis":
        return [Math.floor(_self.value.millis / 1e3), Math.round(_self.value.millis % 1e3 * 1e6)];
    }
  };
  const match$8 = /* @__PURE__ */ dual(2, (self2, options2) => {
    const _self = decode$3(self2);
    switch (_self.value._tag) {
      case "Nanos":
        return options2.onNanos(_self.value.nanos);
      case "Infinity":
        return options2.onMillis(Infinity);
      case "Millis":
        return options2.onMillis(_self.value.millis);
    }
  });
  const matchWith = /* @__PURE__ */ dual(3, (self2, that, options2) => {
    const _self = decode$3(self2);
    const _that = decode$3(that);
    if (_self.value._tag === "Infinity" || _that.value._tag === "Infinity") {
      return options2.onMillis(toMillis(_self), toMillis(_that));
    } else if (_self.value._tag === "Nanos" || _that.value._tag === "Nanos") {
      const selfNanos = _self.value._tag === "Nanos" ? _self.value.nanos : BigInt(Math.round(_self.value.millis * 1e6));
      const thatNanos = _that.value._tag === "Nanos" ? _that.value.nanos : BigInt(Math.round(_that.value.millis * 1e6));
      return options2.onNanos(selfNanos, thatNanos);
    }
    return options2.onMillis(_self.value.millis, _that.value.millis);
  });
  const Equivalence = (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 === that2,
    onNanos: (self3, that2) => self3 === that2
  });
  const times = /* @__PURE__ */ dual(2, (self2, times2) => match$8(self2, {
    onMillis: (millis2) => make$X(millis2 * times2),
    onNanos: (nanos2) => make$X(nanos2 * BigInt(times2))
  }));
  const sum = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => make$X(self3 + that2),
    onNanos: (self3, that2) => make$X(self3 + that2)
  }));
  const lessThanOrEqualTo = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 <= that2,
    onNanos: (self3, that2) => self3 <= that2
  }));
  const greaterThanOrEqualTo$1 = /* @__PURE__ */ dual(2, (self2, that) => matchWith(self2, that, {
    onMillis: (self3, that2) => self3 >= that2,
    onNanos: (self3, that2) => self3 >= that2
  }));
  const equals = /* @__PURE__ */ dual(2, (self2, that) => Equivalence(decode$3(self2), decode$3(that)));
  const parts = (self2) => {
    const duration = decode$3(self2);
    if (duration.value._tag === "Infinity") {
      return {
        days: Infinity,
        hours: Infinity,
        minutes: Infinity,
        seconds: Infinity,
        millis: Infinity,
        nanos: Infinity
      };
    }
    const nanos2 = unsafeToNanos(duration);
    const ms = nanos2 / bigint1e6;
    const sec = ms / bigint1e3;
    const min2 = sec / bigint60;
    const hr = min2 / bigint60;
    const days2 = hr / bigint24;
    return {
      days: Number(days2),
      hours: Number(hr % bigint24),
      minutes: Number(min2 % bigint60),
      seconds: Number(sec % bigint60),
      millis: Number(ms % bigint1e3),
      nanos: Number(nanos2 % bigint1e6)
    };
  };
  const format$2 = (self2) => {
    const duration = decode$3(self2);
    if (duration.value._tag === "Infinity") {
      return "Infinity";
    }
    if (isZero(duration)) {
      return "0";
    }
    const fragments = parts(duration);
    const pieces = [];
    if (fragments.days !== 0) {
      pieces.push(`${fragments.days}d`);
    }
    if (fragments.hours !== 0) {
      pieces.push(`${fragments.hours}h`);
    }
    if (fragments.minutes !== 0) {
      pieces.push(`${fragments.minutes}m`);
    }
    if (fragments.seconds !== 0) {
      pieces.push(`${fragments.seconds}s`);
    }
    if (fragments.millis !== 0) {
      pieces.push(`${fragments.millis}ms`);
    }
    if (fragments.nanos !== 0) {
      pieces.push(`${fragments.nanos}ns`);
    }
    return pieces.join(" ");
  };
  const SIZE = 5;
  const BUCKET_SIZE = /* @__PURE__ */ Math.pow(2, SIZE);
  const MASK = BUCKET_SIZE - 1;
  const MAX_INDEX_NODE = BUCKET_SIZE / 2;
  const MIN_ARRAY_NODE = BUCKET_SIZE / 4;
  function popcount(x) {
    x -= x >> 1 & 1431655765;
    x = (x & 858993459) + (x >> 2 & 858993459);
    x = x + (x >> 4) & 252645135;
    x += x >> 8;
    x += x >> 16;
    return x & 127;
  }
  function hashFragment(shift2, h) {
    return h >>> shift2 & MASK;
  }
  function toBitmap(x) {
    return 1 << x;
  }
  function fromBitmap(bitmap, bit) {
    return popcount(bitmap & bit - 1);
  }
  const make$W = (value2, previous) => ({
    value: value2,
    previous
  });
  function arrayUpdate(mutate2, at, v, arr) {
    let out = arr;
    if (!mutate2) {
      const len = arr.length;
      out = new Array(len);
      for (let i = 0; i < len; ++i) out[i] = arr[i];
    }
    out[at] = v;
    return out;
  }
  function arraySpliceOut(mutate2, at, arr) {
    const newLen = arr.length - 1;
    let i = 0;
    let g = 0;
    let out = arr;
    if (mutate2) {
      i = g = at;
    } else {
      out = new Array(newLen);
      while (i < at) out[g++] = arr[i++];
    }
    ++i;
    while (i <= newLen) out[g++] = arr[i++];
    if (mutate2) {
      out.length = newLen;
    }
    return out;
  }
  function arraySpliceIn(mutate2, at, v, arr) {
    const len = arr.length;
    if (mutate2) {
      let i2 = len;
      while (i2 >= at) arr[i2--] = arr[i2];
      arr[at] = v;
      return arr;
    }
    let i = 0, g = 0;
    const out = new Array(len + 1);
    while (i < at) out[g++] = arr[i++];
    out[at] = v;
    while (i < len) out[++g] = arr[i++];
    return out;
  }
  class EmptyNode {
    constructor() {
      __publicField(this, "_tag", "EmptyNode");
    }
    modify(edit, _shift, f, hash2, key, size2) {
      const v = f(none$4());
      if (isNone(v)) return new EmptyNode();
      ++size2.value;
      return new LeafNode(edit, hash2, key, v);
    }
  }
  function isEmptyNode(a) {
    return isTagged(a, "EmptyNode");
  }
  function isLeafNode(node) {
    return isEmptyNode(node) || node._tag === "LeafNode" || node._tag === "CollisionNode";
  }
  function canEditNode(node, edit) {
    return isEmptyNode(node) ? false : edit === node.edit;
  }
  class LeafNode {
    constructor(edit, hash2, key, value2) {
      __publicField(this, "edit");
      __publicField(this, "hash");
      __publicField(this, "key");
      __publicField(this, "value");
      __publicField(this, "_tag", "LeafNode");
      this.edit = edit;
      this.hash = hash2;
      this.key = key;
      this.value = value2;
    }
    modify(edit, shift2, f, hash2, key, size2) {
      if (equals$1(key, this.key)) {
        const v2 = f(this.value);
        if (v2 === this.value) return this;
        else if (isNone(v2)) {
          --size2.value;
          return new EmptyNode();
        }
        if (canEditNode(this, edit)) {
          this.value = v2;
          return this;
        }
        return new LeafNode(edit, hash2, key, v2);
      }
      const v = f(none$4());
      if (isNone(v)) return this;
      ++size2.value;
      return mergeLeaves(edit, shift2, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
    }
  }
  class CollisionNode {
    constructor(edit, hash2, children) {
      __publicField(this, "edit");
      __publicField(this, "hash");
      __publicField(this, "children");
      __publicField(this, "_tag", "CollisionNode");
      this.edit = edit;
      this.hash = hash2;
      this.children = children;
    }
    modify(edit, shift2, f, hash2, key, size2) {
      if (hash2 === this.hash) {
        const canEdit = canEditNode(this, edit);
        const list = this.updateCollisionList(canEdit, edit, this.hash, this.children, f, key, size2);
        if (list === this.children) return this;
        return list.length > 1 ? new CollisionNode(edit, this.hash, list) : list[0];
      }
      const v = f(none$4());
      if (isNone(v)) return this;
      ++size2.value;
      return mergeLeaves(edit, shift2, this.hash, this, hash2, new LeafNode(edit, hash2, key, v));
    }
    updateCollisionList(mutate2, edit, hash2, list, f, key, size2) {
      const len = list.length;
      for (let i = 0; i < len; ++i) {
        const child = list[i];
        if ("key" in child && equals$1(key, child.key)) {
          const value2 = child.value;
          const newValue2 = f(value2);
          if (newValue2 === value2) return list;
          if (isNone(newValue2)) {
            --size2.value;
            return arraySpliceOut(mutate2, i, list);
          }
          return arrayUpdate(mutate2, i, new LeafNode(edit, hash2, key, newValue2), list);
        }
      }
      const newValue = f(none$4());
      if (isNone(newValue)) return list;
      ++size2.value;
      return arrayUpdate(mutate2, len, new LeafNode(edit, hash2, key, newValue), list);
    }
  }
  class IndexedNode {
    constructor(edit, mask, children) {
      __publicField(this, "edit");
      __publicField(this, "mask");
      __publicField(this, "children");
      __publicField(this, "_tag", "IndexedNode");
      this.edit = edit;
      this.mask = mask;
      this.children = children;
    }
    modify(edit, shift2, f, hash2, key, size2) {
      const mask = this.mask;
      const children = this.children;
      const frag = hashFragment(shift2, hash2);
      const bit = toBitmap(frag);
      const indx = fromBitmap(mask, bit);
      const exists2 = mask & bit;
      const canEdit = canEditNode(this, edit);
      if (!exists2) {
        const _newChild = new EmptyNode().modify(edit, shift2 + SIZE, f, hash2, key, size2);
        if (!_newChild) return this;
        return children.length >= MAX_INDEX_NODE ? expand(edit, frag, _newChild, mask, children) : new IndexedNode(edit, mask | bit, arraySpliceIn(canEdit, indx, _newChild, children));
      }
      const current = children[indx];
      const child = current.modify(edit, shift2 + SIZE, f, hash2, key, size2);
      if (current === child) return this;
      let bitmap = mask;
      let newChildren;
      if (isEmptyNode(child)) {
        bitmap &= ~bit;
        if (!bitmap) return new EmptyNode();
        if (children.length <= 2 && isLeafNode(children[indx ^ 1])) {
          return children[indx ^ 1];
        }
        newChildren = arraySpliceOut(canEdit, indx, children);
      } else {
        newChildren = arrayUpdate(canEdit, indx, child, children);
      }
      if (canEdit) {
        this.mask = bitmap;
        this.children = newChildren;
        return this;
      }
      return new IndexedNode(edit, bitmap, newChildren);
    }
  }
  class ArrayNode {
    constructor(edit, size2, children) {
      __publicField(this, "edit");
      __publicField(this, "size");
      __publicField(this, "children");
      __publicField(this, "_tag", "ArrayNode");
      this.edit = edit;
      this.size = size2;
      this.children = children;
    }
    modify(edit, shift2, f, hash2, key, size2) {
      let count = this.size;
      const children = this.children;
      const frag = hashFragment(shift2, hash2);
      const child = children[frag];
      const newChild = (child || new EmptyNode()).modify(edit, shift2 + SIZE, f, hash2, key, size2);
      if (child === newChild) return this;
      const canEdit = canEditNode(this, edit);
      let newChildren;
      if (isEmptyNode(child) && !isEmptyNode(newChild)) {
        ++count;
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      } else if (!isEmptyNode(child) && isEmptyNode(newChild)) {
        --count;
        if (count <= MIN_ARRAY_NODE) {
          return pack(edit, count, frag, children);
        }
        newChildren = arrayUpdate(canEdit, frag, new EmptyNode(), children);
      } else {
        newChildren = arrayUpdate(canEdit, frag, newChild, children);
      }
      if (canEdit) {
        this.size = count;
        this.children = newChildren;
        return this;
      }
      return new ArrayNode(edit, count, newChildren);
    }
  }
  function pack(edit, count, removed, elements) {
    const children = new Array(count - 1);
    let g = 0;
    let bitmap = 0;
    for (let i = 0, len = elements.length; i < len; ++i) {
      if (i !== removed) {
        const elem = elements[i];
        if (elem && !isEmptyNode(elem)) {
          children[g++] = elem;
          bitmap |= 1 << i;
        }
      }
    }
    return new IndexedNode(edit, bitmap, children);
  }
  function expand(edit, frag, child, bitmap, subNodes) {
    const arr = [];
    let bit = bitmap;
    let count = 0;
    for (let i = 0; bit; ++i) {
      if (bit & 1) arr[i] = subNodes[count++];
      bit >>>= 1;
    }
    arr[frag] = child;
    return new ArrayNode(edit, count + 1, arr);
  }
  function mergeLeavesInner(edit, shift2, h1, n1, h2, n2) {
    if (h1 === h2) return new CollisionNode(edit, h1, [n2, n1]);
    const subH1 = hashFragment(shift2, h1);
    const subH2 = hashFragment(shift2, h2);
    if (subH1 === subH2) {
      return (child) => new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), [child]);
    } else {
      const children = subH1 < subH2 ? [n1, n2] : [n2, n1];
      return new IndexedNode(edit, toBitmap(subH1) | toBitmap(subH2), children);
    }
  }
  function mergeLeaves(edit, shift2, h1, n1, h2, n2) {
    let stack = void 0;
    let currentShift = shift2;
    while (true) {
      const res = mergeLeavesInner(edit, currentShift, h1, n1, h2, n2);
      if (typeof res === "function") {
        stack = make$W(res, stack);
        currentShift = currentShift + SIZE;
      } else {
        let final = res;
        while (stack != null) {
          final = stack.value(final);
          stack = stack.previous;
        }
        return final;
      }
    }
  }
  const HashMapSymbolKey = "effect/HashMap";
  const HashMapTypeId = /* @__PURE__ */ Symbol.for(HashMapSymbolKey);
  const HashMapProto = {
    [HashMapTypeId]: HashMapTypeId,
    [Symbol.iterator]() {
      return new HashMapIterator(this, (k, v) => [k, v]);
    },
    [symbol$1]() {
      let hash2 = hash$2(HashMapSymbolKey);
      for (const item of this) {
        hash2 ^= pipe(hash$2(item[0]), combine$7(hash$2(item[1])));
      }
      return cached$1(this, hash2);
    },
    [symbol](that) {
      if (isHashMap(that)) {
        if (that._size !== this._size) {
          return false;
        }
        for (const item of this) {
          const elem = pipe(that, getHash(item[0], hash$2(item[0])));
          if (isNone(elem)) {
            return false;
          } else {
            if (!equals$1(item[1], elem.value)) {
              return false;
            }
          }
        }
        return true;
      }
      return false;
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const makeImpl$1 = (editable, edit, root, size2) => {
    const map2 = Object.create(HashMapProto);
    map2._editable = editable;
    map2._edit = edit;
    map2._root = root;
    map2._size = size2;
    return map2;
  };
  class HashMapIterator {
    constructor(map2, f) {
      __publicField(this, "map");
      __publicField(this, "f");
      __publicField(this, "v");
      this.map = map2;
      this.f = f;
      this.v = visitLazy(this.map._root, this.f, void 0);
    }
    next() {
      if (isNone(this.v)) {
        return {
          done: true,
          value: void 0
        };
      }
      const v0 = this.v.value;
      this.v = applyCont(v0.cont);
      return {
        done: false,
        value: v0.value
      };
    }
    [Symbol.iterator]() {
      return new HashMapIterator(this.map, this.f);
    }
  }
  const applyCont = (cont) => cont ? visitLazyChildren(cont[0], cont[1], cont[2], cont[3], cont[4]) : none$4();
  const visitLazy = (node, f, cont = void 0) => {
    switch (node._tag) {
      case "LeafNode": {
        if (isSome(node.value)) {
          return some({
            value: f(node.key, node.value.value),
            cont
          });
        }
        return applyCont(cont);
      }
      case "CollisionNode":
      case "ArrayNode":
      case "IndexedNode": {
        const children = node.children;
        return visitLazyChildren(children.length, children, 0, f, cont);
      }
      default: {
        return applyCont(cont);
      }
    }
  };
  const visitLazyChildren = (len, children, i, f, cont) => {
    while (i < len) {
      const child = children[i++];
      if (child && !isEmptyNode(child)) {
        return visitLazy(child, f, [len, children, i, f, cont]);
      }
    }
    return applyCont(cont);
  };
  const _empty$4 = /* @__PURE__ */ makeImpl$1(false, 0, /* @__PURE__ */ new EmptyNode(), 0);
  const empty$q = () => _empty$4;
  const fromIterable$6 = (entries) => {
    const map2 = beginMutation$1(empty$q());
    for (const entry of entries) {
      set$a(map2, entry[0], entry[1]);
    }
    return endMutation$1(map2);
  };
  const isHashMap = (u) => hasProperty(u, HashMapTypeId);
  const isEmpty$6 = (self2) => self2 && isEmptyNode(self2._root);
  const get$c = /* @__PURE__ */ dual(2, (self2, key) => getHash(self2, key, hash$2(key)));
  const getHash = /* @__PURE__ */ dual(3, (self2, key, hash2) => {
    let node = self2._root;
    let shift2 = 0;
    while (true) {
      switch (node._tag) {
        case "LeafNode": {
          return equals$1(key, node.key) ? node.value : none$4();
        }
        case "CollisionNode": {
          if (hash2 === node.hash) {
            const children = node.children;
            for (let i = 0, len = children.length; i < len; ++i) {
              const child = children[i];
              if ("key" in child && equals$1(key, child.key)) {
                return child.value;
              }
            }
          }
          return none$4();
        }
        case "IndexedNode": {
          const frag = hashFragment(shift2, hash2);
          const bit = toBitmap(frag);
          if (node.mask & bit) {
            node = node.children[fromBitmap(node.mask, bit)];
            shift2 += SIZE;
            break;
          }
          return none$4();
        }
        case "ArrayNode": {
          node = node.children[hashFragment(shift2, hash2)];
          if (node) {
            shift2 += SIZE;
            break;
          }
          return none$4();
        }
        default:
          return none$4();
      }
    }
  });
  const has$3 = /* @__PURE__ */ dual(2, (self2, key) => isSome(getHash(self2, key, hash$2(key))));
  const set$a = /* @__PURE__ */ dual(3, (self2, key, value2) => modifyAt$1(self2, key, () => some(value2)));
  const setTree = /* @__PURE__ */ dual(3, (self2, newRoot, newSize) => {
    if (self2._editable) {
      self2._root = newRoot;
      self2._size = newSize;
      return self2;
    }
    return newRoot === self2._root ? self2 : makeImpl$1(self2._editable, self2._edit, newRoot, newSize);
  });
  const keys$1 = (self2) => new HashMapIterator(self2, (key) => key);
  const size$8 = (self2) => self2._size;
  const beginMutation$1 = (self2) => makeImpl$1(true, self2._edit + 1, self2._root, self2._size);
  const endMutation$1 = (self2) => {
    self2._editable = false;
    return self2;
  };
  const modifyAt$1 = /* @__PURE__ */ dual(3, (self2, key, f) => modifyHash(self2, key, hash$2(key), f));
  const modifyHash = /* @__PURE__ */ dual(4, (self2, key, hash2, f) => {
    const size2 = {
      value: self2._size
    };
    const newRoot = self2._root.modify(self2._editable ? self2._edit : NaN, 0, f, hash2, key, size2);
    return pipe(self2, setTree(newRoot, size2.value));
  });
  const remove$6 = /* @__PURE__ */ dual(2, (self2, key) => modifyAt$1(self2, key, none$4));
  const map$c = /* @__PURE__ */ dual(2, (self2, f) => reduce$5(self2, empty$q(), (map2, value2, key) => set$a(map2, key, f(value2, key))));
  const forEach$4 = /* @__PURE__ */ dual(2, (self2, f) => reduce$5(self2, void 0, (_, value2, key) => f(value2, key)));
  const reduce$5 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
    const root = self2._root;
    if (root._tag === "LeafNode") {
      return isSome(root.value) ? f(zero2, root.value.value, root.key) : zero2;
    }
    if (root._tag === "EmptyNode") {
      return zero2;
    }
    const toVisit = [root.children];
    let children;
    while (children = toVisit.pop()) {
      for (let i = 0, len = children.length; i < len; ) {
        const child = children[i++];
        if (child && !isEmptyNode(child)) {
          if (child._tag === "LeafNode") {
            if (isSome(child.value)) {
              zero2 = f(zero2, child.value.value, child.key);
            }
          } else {
            toVisit.push(child.children);
          }
        }
      }
    }
    return zero2;
  });
  const HashSetSymbolKey = "effect/HashSet";
  const HashSetTypeId = /* @__PURE__ */ Symbol.for(HashSetSymbolKey);
  const HashSetProto = {
    [HashSetTypeId]: HashSetTypeId,
    [Symbol.iterator]() {
      return keys$1(this._keyMap);
    },
    [symbol$1]() {
      return cached$1(this, combine$7(hash$2(this._keyMap))(hash$2(HashSetSymbolKey)));
    },
    [symbol](that) {
      if (isHashSet(that)) {
        return size$8(this._keyMap) === size$8(that._keyMap) && equals$1(this._keyMap, that._keyMap);
      }
      return false;
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "HashSet",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const makeImpl = (keyMap) => {
    const set2 = Object.create(HashSetProto);
    set2._keyMap = keyMap;
    return set2;
  };
  const isHashSet = (u) => hasProperty(u, HashSetTypeId);
  const _empty$3 = /* @__PURE__ */ makeImpl(/* @__PURE__ */ empty$q());
  const empty$p = () => _empty$3;
  const fromIterable$5 = (elements) => {
    const set2 = beginMutation(empty$p());
    for (const value2 of elements) {
      add$1(set2, value2);
    }
    return endMutation(set2);
  };
  const make$V = (...elements) => {
    const set2 = beginMutation(empty$p());
    for (const value2 of elements) {
      add$1(set2, value2);
    }
    return endMutation(set2);
  };
  const has$2 = /* @__PURE__ */ dual(2, (self2, value2) => has$3(self2._keyMap, value2));
  const size$7 = (self2) => size$8(self2._keyMap);
  const beginMutation = (self2) => makeImpl(beginMutation$1(self2._keyMap));
  const endMutation = (self2) => {
    self2._keyMap._editable = false;
    return self2;
  };
  const mutate = /* @__PURE__ */ dual(2, (self2, f) => {
    const transient = beginMutation(self2);
    f(transient);
    return endMutation(transient);
  });
  const add$1 = /* @__PURE__ */ dual(2, (self2, value2) => self2._keyMap._editable ? (set$a(value2, true)(self2._keyMap), self2) : makeImpl(set$a(value2, true)(self2._keyMap)));
  const remove$5 = /* @__PURE__ */ dual(2, (self2, value2) => self2._keyMap._editable ? (remove$6(value2)(self2._keyMap), self2) : makeImpl(remove$6(value2)(self2._keyMap)));
  const difference$1 = /* @__PURE__ */ dual(2, (self2, that) => mutate(self2, (set2) => {
    for (const value2 of that) {
      remove$5(set2, value2);
    }
  }));
  const union$1 = /* @__PURE__ */ dual(2, (self2, that) => mutate(empty$p(), (set2) => {
    forEach$3(self2, (value2) => add$1(set2, value2));
    for (const value2 of that) {
      add$1(set2, value2);
    }
  }));
  const forEach$3 = /* @__PURE__ */ dual(2, (self2, f) => forEach$4(self2._keyMap, (_, k) => f(k)));
  const reduce$4 = /* @__PURE__ */ dual(3, (self2, zero2, f) => reduce$5(self2._keyMap, zero2, (z, _, a) => f(z, a)));
  const empty$o = empty$p;
  const fromIterable$4 = fromIterable$5;
  const make$U = make$V;
  const has$1 = has$2;
  const size$6 = size$7;
  const add = add$1;
  const remove$4 = remove$5;
  const difference = difference$1;
  const union = union$1;
  const reduce$3 = reduce$4;
  const TypeId$o = /* @__PURE__ */ Symbol.for("effect/MutableRef");
  const MutableRefProto = {
    [TypeId$o]: TypeId$o,
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableRef",
        current: toJSON(this.current)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const make$T = (value2) => {
    const ref = Object.create(MutableRefProto);
    ref.current = value2;
    return ref;
  };
  const compareAndSet = /* @__PURE__ */ dual(3, (self2, oldValue, newValue) => {
    if (equals$1(oldValue, self2.current)) {
      self2.current = newValue;
      return true;
    }
    return false;
  });
  const get$b = (self2) => self2.current;
  const set$9 = /* @__PURE__ */ dual(2, (self2, value2) => {
    self2.current = value2;
    return self2;
  });
  const FiberIdSymbolKey = "effect/FiberId";
  const FiberIdTypeId = /* @__PURE__ */ Symbol.for(FiberIdSymbolKey);
  const OP_NONE = "None";
  const OP_RUNTIME = "Runtime";
  const OP_COMPOSITE = "Composite";
  const emptyHash = /* @__PURE__ */ string(`${FiberIdSymbolKey}-${OP_NONE}`);
  let None$2 = class None {
    constructor() {
      __publicField(this, _c, FiberIdTypeId);
      __publicField(this, "_tag", OP_NONE);
      __publicField(this, "id", -1);
      __publicField(this, "startTimeMillis", -1);
    }
    [(_c = FiberIdTypeId, symbol$1)]() {
      return emptyHash;
    }
    [symbol](that) {
      return isFiberId(that) && that._tag === OP_NONE;
    }
    toString() {
      return format$3(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  class Runtime {
    constructor(id2, startTimeMillis) {
      __publicField(this, "id");
      __publicField(this, "startTimeMillis");
      __publicField(this, _d, FiberIdTypeId);
      __publicField(this, "_tag", OP_RUNTIME);
      this.id = id2;
      this.startTimeMillis = startTimeMillis;
    }
    [(_d = FiberIdTypeId, symbol$1)]() {
      return cached$1(this, string(`${FiberIdSymbolKey}-${this._tag}-${this.id}-${this.startTimeMillis}`));
    }
    [symbol](that) {
      return isFiberId(that) && that._tag === OP_RUNTIME && this.id === that.id && this.startTimeMillis === that.startTimeMillis;
    }
    toString() {
      return format$3(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        id: this.id,
        startTimeMillis: this.startTimeMillis
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  }
  let Composite$1 = class Composite {
    constructor(left2, right2) {
      __publicField(this, "left");
      __publicField(this, "right");
      __publicField(this, _e, FiberIdTypeId);
      __publicField(this, "_tag", OP_COMPOSITE);
      __publicField(this, "_hash");
      this.left = left2;
      this.right = right2;
    }
    [(_e = FiberIdTypeId, symbol$1)]() {
      return pipe(string(`${FiberIdSymbolKey}-${this._tag}`), combine$7(hash$2(this.left)), combine$7(hash$2(this.right)), cached$1(this));
    }
    [symbol](that) {
      return isFiberId(that) && that._tag === OP_COMPOSITE && equals$1(this.left, that.left) && equals$1(this.right, that.right);
    }
    toString() {
      return format$3(this.toJSON());
    }
    toJSON() {
      return {
        _id: "FiberId",
        _tag: this._tag,
        left: toJSON(this.left),
        right: toJSON(this.right)
      };
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  const none$3 = /* @__PURE__ */ new None$2();
  const runtime$3 = (id2, startTimeMillis) => {
    return new Runtime(id2, startTimeMillis);
  };
  const composite$1 = (left2, right2) => {
    return new Composite$1(left2, right2);
  };
  const isFiberId = (self2) => hasProperty(self2, FiberIdTypeId);
  const combine$6 = /* @__PURE__ */ dual(2, (self2, that) => {
    if (self2._tag === OP_NONE) {
      return that;
    }
    if (that._tag === OP_NONE) {
      return self2;
    }
    return new Composite$1(self2, that);
  });
  const combineAll$1 = (fiberIds) => {
    return pipe(fiberIds, reduce$3(none$3, (a, b) => combine$6(b)(a)));
  };
  const ids$1 = (self2) => {
    switch (self2._tag) {
      case OP_NONE: {
        return empty$o();
      }
      case OP_RUNTIME: {
        return make$U(self2.id);
      }
      case OP_COMPOSITE: {
        return pipe(ids$1(self2.left), union(ids$1(self2.right)));
      }
    }
  };
  const _fiberCounter = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Fiber/Id/_fiberCounter"), () => make$T(0));
  const make$S = (id2, startTimeSeconds) => {
    return new Runtime(id2, startTimeSeconds);
  };
  const threadName$1 = (self2) => {
    const identifiers = Array.from(ids$1(self2)).map((n) => `#${n}`).join(",");
    return identifiers;
  };
  const unsafeMake$b = () => {
    const id2 = get$b(_fiberCounter);
    pipe(_fiberCounter, set$9(id2 + 1));
    return new Runtime(id2, Date.now());
  };
  const none$2 = none$3;
  const runtime$2 = runtime$3;
  const composite = composite$1;
  const combine$5 = combine$6;
  const combineAll = combineAll$1;
  const ids = ids$1;
  const make$R = make$S;
  const threadName = threadName$1;
  const unsafeMake$a = unsafeMake$b;
  const empty$n = empty$q;
  const fromIterable$3 = fromIterable$6;
  const isEmpty$5 = isEmpty$6;
  const get$a = get$c;
  const set$8 = set$a;
  const keys = keys$1;
  const size$5 = size$8;
  const modifyAt = modifyAt$1;
  const map$b = map$c;
  const forEach$2 = forEach$4;
  const reduce$2 = reduce$5;
  const TypeId$n = /* @__PURE__ */ Symbol.for("effect/List");
  const toArray = (self2) => fromIterable$8(self2);
  const getEquivalence = (isEquivalent) => mapInput$1(getEquivalence$2(isEquivalent), toArray);
  const _equivalence = /* @__PURE__ */ getEquivalence(equals$1);
  const ConsProto = {
    [TypeId$n]: TypeId$n,
    _tag: "Cons",
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Cons",
        values: toArray(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol](that) {
      return isList(that) && this._tag === that._tag && _equivalence(this, that);
    },
    [symbol$1]() {
      return cached$1(this, array(toArray(this)));
    },
    [Symbol.iterator]() {
      let done2 = false;
      let self2 = this;
      return {
        next() {
          if (done2) {
            return this.return();
          }
          if (self2._tag === "Nil") {
            done2 = true;
            return this.return();
          }
          const value2 = self2.head;
          self2 = self2.tail;
          return {
            done: done2,
            value: value2
          };
        },
        return(value2) {
          if (!done2) {
            done2 = true;
          }
          return {
            done: true,
            value: value2
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const makeCons = (head2, tail) => {
    const cons2 = Object.create(ConsProto);
    cons2.head = head2;
    cons2.tail = tail;
    return cons2;
  };
  const NilHash = /* @__PURE__ */ string("Nil");
  const NilProto = {
    [TypeId$n]: TypeId$n,
    _tag: "Nil",
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "List",
        _tag: "Nil"
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    [symbol$1]() {
      return NilHash;
    },
    [symbol](that) {
      return isList(that) && this._tag === that._tag;
    },
    [Symbol.iterator]() {
      return {
        next() {
          return {
            done: true,
            value: void 0
          };
        }
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const _Nil = /* @__PURE__ */ Object.create(NilProto);
  const isList = (u) => hasProperty(u, TypeId$n);
  const isNil$1 = (self2) => self2._tag === "Nil";
  const isCons = (self2) => self2._tag === "Cons";
  const nil = () => _Nil;
  const cons = (head2, tail) => makeCons(head2, tail);
  const empty$m = nil;
  const of$1 = (value2) => makeCons(value2, _Nil);
  const appendAll = /* @__PURE__ */ dual(2, (self2, that) => prependAll(that, self2));
  const prepend = /* @__PURE__ */ dual(2, (self2, element) => cons(element, self2));
  const prependAll = /* @__PURE__ */ dual(2, (self2, prefix) => {
    if (isNil$1(self2)) {
      return prefix;
    } else if (isNil$1(prefix)) {
      return self2;
    } else {
      const result = makeCons(prefix.head, self2);
      let curr = result;
      let that = prefix.tail;
      while (!isNil$1(that)) {
        const temp = makeCons(that.head, self2);
        curr.tail = temp;
        curr = temp;
        that = that.tail;
      }
      return result;
    }
  });
  const reduce$1 = /* @__PURE__ */ dual(3, (self2, zero2, f) => {
    let acc = zero2;
    let these = self2;
    while (!isNil$1(these)) {
      acc = f(acc, these.head);
      these = these.tail;
    }
    return acc;
  });
  const reverse = (self2) => {
    let result = empty$m();
    let these = self2;
    while (!isNil$1(these)) {
      result = prepend(result, these.head);
      these = these.tail;
    }
    return result;
  };
  const Structural = /* @__PURE__ */ function() {
    function Structural2(args2) {
      if (args2) {
        Object.assign(this, args2);
      }
    }
    Structural2.prototype = StructuralPrototype;
    return Structural2;
  }();
  const ContextPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferContextPatch");
  function variance$5(a) {
    return a;
  }
  const PatchProto$2 = {
    ...Structural.prototype,
    [ContextPatchTypeId]: {
      _Value: variance$5,
      _Patch: variance$5
    }
  };
  const EmptyProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), {
    _tag: "Empty"
  });
  const _empty$2 = /* @__PURE__ */ Object.create(EmptyProto$2);
  const empty$l = () => _empty$2;
  const AndThenProto$2 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), {
    _tag: "AndThen"
  });
  const makeAndThen$2 = (first, second) => {
    const o = Object.create(AndThenProto$2);
    o.first = first;
    o.second = second;
    return o;
  };
  const AddServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), {
    _tag: "AddService"
  });
  const makeAddService = (key, service) => {
    const o = Object.create(AddServiceProto);
    o.key = key;
    o.service = service;
    return o;
  };
  const RemoveServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), {
    _tag: "RemoveService"
  });
  const makeRemoveService = (key) => {
    const o = Object.create(RemoveServiceProto);
    o.key = key;
    return o;
  };
  const UpdateServiceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$2), {
    _tag: "UpdateService"
  });
  const makeUpdateService = (key, update2) => {
    const o = Object.create(UpdateServiceProto);
    o.key = key;
    o.update = update2;
    return o;
  };
  const diff$6 = (oldValue, newValue) => {
    const missingServices = new Map(oldValue.unsafeMap);
    let patch2 = empty$l();
    for (const [tag2, newService] of newValue.unsafeMap.entries()) {
      if (missingServices.has(tag2)) {
        const old = missingServices.get(tag2);
        missingServices.delete(tag2);
        if (!equals$1(old, newService)) {
          patch2 = combine$4(makeUpdateService(tag2, () => newService))(patch2);
        }
      } else {
        missingServices.delete(tag2);
        patch2 = combine$4(makeAddService(tag2, newService))(patch2);
      }
    }
    for (const [tag2] of missingServices.entries()) {
      patch2 = combine$4(makeRemoveService(tag2))(patch2);
    }
    return patch2;
  };
  const combine$4 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen$2(self2, that));
  const patch$9 = /* @__PURE__ */ dual(2, (self2, context2) => {
    if (self2._tag === "Empty") {
      return context2;
    }
    let wasServiceUpdated = false;
    let patches = of$2(self2);
    const updatedContext = new Map(context2.unsafeMap);
    while (isNonEmpty$2(patches)) {
      const head2 = headNonEmpty(patches);
      const tail = tailNonEmpty(patches);
      switch (head2._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AddService": {
          updatedContext.set(head2.key, head2.service);
          patches = tail;
          break;
        }
        case "AndThen": {
          patches = prepend$1(prepend$1(tail, head2.second), head2.first);
          break;
        }
        case "RemoveService": {
          updatedContext.delete(head2.key);
          patches = tail;
          break;
        }
        case "UpdateService": {
          updatedContext.set(head2.key, head2.update(updatedContext.get(head2.key)));
          wasServiceUpdated = true;
          patches = tail;
          break;
        }
      }
    }
    if (!wasServiceUpdated) {
      return makeContext(updatedContext);
    }
    const map2 = /* @__PURE__ */ new Map();
    for (const [tag2] of context2.unsafeMap) {
      if (updatedContext.has(tag2)) {
        map2.set(tag2, updatedContext.get(tag2));
        updatedContext.delete(tag2);
      }
    }
    for (const [tag2, s] of updatedContext) {
      map2.set(tag2, s);
    }
    return makeContext(map2);
  });
  const HashSetPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferHashSetPatch");
  function variance$4(a) {
    return a;
  }
  const PatchProto$1 = {
    ...Structural.prototype,
    [HashSetPatchTypeId]: {
      _Value: variance$4,
      _Key: variance$4,
      _Patch: variance$4
    }
  };
  const EmptyProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), {
    _tag: "Empty"
  });
  const _empty$1 = /* @__PURE__ */ Object.create(EmptyProto$1);
  const empty$k = () => _empty$1;
  const AndThenProto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), {
    _tag: "AndThen"
  });
  const makeAndThen$1 = (first, second) => {
    const o = Object.create(AndThenProto$1);
    o.first = first;
    o.second = second;
    return o;
  };
  const AddProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), {
    _tag: "Add"
  });
  const makeAdd = (value2) => {
    const o = Object.create(AddProto);
    o.value = value2;
    return o;
  };
  const RemoveProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto$1), {
    _tag: "Remove"
  });
  const makeRemove = (value2) => {
    const o = Object.create(RemoveProto);
    o.value = value2;
    return o;
  };
  const diff$5 = (oldValue, newValue) => {
    const [removed, patch2] = reduce$3([oldValue, empty$k()], ([set2, patch3], value2) => {
      if (has$1(value2)(set2)) {
        return [remove$4(value2)(set2), patch3];
      }
      return [set2, combine$3(makeAdd(value2))(patch3)];
    })(newValue);
    return reduce$3(patch2, (patch3, value2) => combine$3(makeRemove(value2))(patch3))(removed);
  };
  const combine$3 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen$1(self2, that));
  const patch$8 = /* @__PURE__ */ dual(2, (self2, oldValue) => {
    if (self2._tag === "Empty") {
      return oldValue;
    }
    let set2 = oldValue;
    let patches = of$2(self2);
    while (isNonEmpty$2(patches)) {
      const head2 = headNonEmpty(patches);
      const tail = tailNonEmpty(patches);
      switch (head2._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AndThen": {
          patches = prepend$1(head2.first)(prepend$1(head2.second)(tail));
          break;
        }
        case "Add": {
          set2 = add(head2.value)(set2);
          patches = tail;
          break;
        }
        case "Remove": {
          set2 = remove$4(head2.value)(set2);
          patches = tail;
        }
      }
    }
    return set2;
  });
  const ReadonlyArrayPatchTypeId = /* @__PURE__ */ Symbol.for("effect/DifferReadonlyArrayPatch");
  function variance$3(a) {
    return a;
  }
  const PatchProto = {
    ...Structural.prototype,
    [ReadonlyArrayPatchTypeId]: {
      _Value: variance$3,
      _Patch: variance$3
    }
  };
  const EmptyProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "Empty"
  });
  const _empty = /* @__PURE__ */ Object.create(EmptyProto);
  const empty$j = () => _empty;
  const AndThenProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "AndThen"
  });
  const makeAndThen = (first, second) => {
    const o = Object.create(AndThenProto);
    o.first = first;
    o.second = second;
    return o;
  };
  const AppendProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "Append"
  });
  const makeAppend = (values) => {
    const o = Object.create(AppendProto);
    o.values = values;
    return o;
  };
  const SliceProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "Slice"
  });
  const makeSlice = (from, until) => {
    const o = Object.create(SliceProto);
    o.from = from;
    o.until = until;
    return o;
  };
  const UpdateProto = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(PatchProto), {
    _tag: "Update"
  });
  const makeUpdate = (index, patch2) => {
    const o = Object.create(UpdateProto);
    o.index = index;
    o.patch = patch2;
    return o;
  };
  const diff$4 = (options2) => {
    let i = 0;
    let patch2 = empty$j();
    while (i < options2.oldValue.length && i < options2.newValue.length) {
      const oldElement = options2.oldValue[i];
      const newElement = options2.newValue[i];
      const valuePatch = options2.differ.diff(oldElement, newElement);
      if (!equals$1(valuePatch, options2.differ.empty)) {
        patch2 = combine$2(patch2, makeUpdate(i, valuePatch));
      }
      i = i + 1;
    }
    if (i < options2.oldValue.length) {
      patch2 = combine$2(patch2, makeSlice(0, i));
    }
    if (i < options2.newValue.length) {
      patch2 = combine$2(patch2, makeAppend(drop$1(i)(options2.newValue)));
    }
    return patch2;
  };
  const combine$2 = /* @__PURE__ */ dual(2, (self2, that) => makeAndThen(self2, that));
  const patch$7 = /* @__PURE__ */ dual(3, (self2, oldValue, differ2) => {
    if (self2._tag === "Empty") {
      return oldValue;
    }
    let readonlyArray2 = oldValue.slice();
    let patches = of$3(self2);
    while (isNonEmptyArray(patches)) {
      const head2 = headNonEmpty$1(patches);
      const tail = tailNonEmpty$1(patches);
      switch (head2._tag) {
        case "Empty": {
          patches = tail;
          break;
        }
        case "AndThen": {
          tail.unshift(head2.first, head2.second);
          patches = tail;
          break;
        }
        case "Append": {
          for (const value2 of head2.values) {
            readonlyArray2.push(value2);
          }
          patches = tail;
          break;
        }
        case "Slice": {
          readonlyArray2 = readonlyArray2.slice(head2.from, head2.until);
          patches = tail;
          break;
        }
        case "Update": {
          readonlyArray2[head2.index] = differ2.patch(head2.patch, readonlyArray2[head2.index]);
          patches = tail;
          break;
        }
      }
    }
    return readonlyArray2;
  });
  const DifferTypeId = /* @__PURE__ */ Symbol.for("effect/Differ");
  const DifferProto = {
    [DifferTypeId]: {
      _P: identity,
      _V: identity
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const make$Q = (params) => {
    const differ2 = Object.create(DifferProto);
    differ2.empty = params.empty;
    differ2.diff = params.diff;
    differ2.combine = params.combine;
    differ2.patch = params.patch;
    return differ2;
  };
  const environment = () => make$Q({
    empty: empty$l(),
    combine: (first, second) => combine$4(second)(first),
    diff: (oldValue, newValue) => diff$6(oldValue, newValue),
    patch: (patch2, oldValue) => patch$9(oldValue)(patch2)
  });
  const hashSet = () => make$Q({
    empty: empty$k(),
    combine: (first, second) => combine$3(second)(first),
    diff: (oldValue, newValue) => diff$5(oldValue, newValue),
    patch: (patch2, oldValue) => patch$8(oldValue)(patch2)
  });
  const readonlyArray = (differ2) => make$Q({
    empty: empty$j(),
    combine: (first, second) => combine$2(first, second),
    diff: (oldValue, newValue) => diff$4({
      oldValue,
      newValue,
      differ: differ2
    }),
    patch: (patch2, oldValue) => patch$7(patch2, oldValue, differ2)
  });
  const update$5 = () => updateWith((_, a) => a);
  const updateWith = (f) => make$Q({
    empty: identity,
    combine: (first, second) => {
      if (first === identity) {
        return second;
      }
      if (second === identity) {
        return first;
      }
      return (a) => second(first(a));
    },
    diff: (oldValue, newValue) => {
      if (equals$1(oldValue, newValue)) {
        return identity;
      }
      return constant(newValue);
    },
    patch: (patch2, oldValue) => f(oldValue, patch2(oldValue))
  });
  const BIT_MASK = 255;
  const BIT_SHIFT = 8;
  const active = (patch2) => patch2 & BIT_MASK;
  const enabled = (patch2) => patch2 >> BIT_SHIFT & BIT_MASK;
  const make$P = (active2, enabled2) => (active2 & BIT_MASK) + ((enabled2 & active2 & BIT_MASK) << BIT_SHIFT);
  const empty$i = /* @__PURE__ */ make$P(0, 0);
  const enable$2 = (flag) => make$P(flag, flag);
  const disable$1 = (flag) => make$P(flag, 0);
  const exclude$1 = /* @__PURE__ */ dual(2, (self2, flag) => make$P(active(self2) & ~flag, enabled(self2)));
  const andThen$2 = /* @__PURE__ */ dual(2, (self2, that) => self2 | that);
  const invert = (n) => ~n >>> 0 & BIT_MASK;
  const None$1 = 0;
  const Interruption = 1 << 0;
  const OpSupervision = 1 << 1;
  const RuntimeMetrics = 1 << 2;
  const WindDown = 1 << 4;
  const CooperativeYielding = 1 << 5;
  const cooperativeYielding = (self2) => isEnabled(self2, CooperativeYielding);
  const enable$1 = /* @__PURE__ */ dual(2, (self2, flag) => self2 | flag);
  const interruptible$3 = (self2) => interruption(self2) && !windDown(self2);
  const interruption = (self2) => isEnabled(self2, Interruption);
  const isEnabled = /* @__PURE__ */ dual(2, (self2, flag) => (self2 & flag) !== 0);
  const make$O = (...flags) => flags.reduce((a, b) => a | b, 0);
  const none$1 = /* @__PURE__ */ make$O(None$1);
  const runtimeMetrics = (self2) => isEnabled(self2, RuntimeMetrics);
  const windDown = (self2) => isEnabled(self2, WindDown);
  const diff$3 = /* @__PURE__ */ dual(2, (self2, that) => make$P(self2 ^ that, that));
  const patch$6 = /* @__PURE__ */ dual(2, (self2, patch2) => self2 & (invert(active(patch2)) | enabled(patch2)) | active(patch2) & enabled(patch2));
  const differ$1 = /* @__PURE__ */ make$Q({
    empty: empty$i,
    diff: (oldValue, newValue) => diff$3(oldValue, newValue),
    combine: (first, second) => andThen$2(second)(first),
    patch: (_patch, oldValue) => patch$6(oldValue, _patch)
  });
  const enable = enable$2;
  const disable = disable$1;
  const exclude = exclude$1;
  const par = (self2, that) => ({
    _tag: "Par",
    left: self2,
    right: that
  });
  const seq = (self2, that) => ({
    _tag: "Seq",
    left: self2,
    right: that
  });
  const flatten$6 = (self2) => {
    let current = of$1(self2);
    let updated = empty$m();
    while (1) {
      const [parallel2, sequential2] = reduce$1(current, [parallelCollectionEmpty(), empty$m()], ([parallel3, sequential3], blockedRequest) => {
        const [par2, seq2] = step$1(blockedRequest);
        return [parallelCollectionCombine(parallel3, par2), appendAll(sequential3, seq2)];
      });
      updated = merge$3(updated, parallel2);
      if (isNil$1(sequential2)) {
        return reverse(updated);
      }
      current = sequential2;
    }
    throw new Error("BUG: BlockedRequests.flatten - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  const step$1 = (requests) => {
    let current = requests;
    let parallel2 = parallelCollectionEmpty();
    let stack = empty$m();
    let sequential2 = empty$m();
    while (1) {
      switch (current._tag) {
        case "Empty": {
          if (isNil$1(stack)) {
            return [parallel2, sequential2];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
        case "Par": {
          stack = cons(current.right, stack);
          current = current.left;
          break;
        }
        case "Seq": {
          const left2 = current.left;
          const right2 = current.right;
          switch (left2._tag) {
            case "Empty": {
              current = right2;
              break;
            }
            case "Par": {
              const l = left2.left;
              const r = left2.right;
              current = par(seq(l, right2), seq(r, right2));
              break;
            }
            case "Seq": {
              const l = left2.left;
              const r = left2.right;
              current = seq(l, seq(r, right2));
              break;
            }
            case "Single": {
              current = left2;
              sequential2 = cons(right2, sequential2);
              break;
            }
          }
          break;
        }
        case "Single": {
          parallel2 = parallelCollectionAdd(parallel2, current);
          if (isNil$1(stack)) {
            return [parallel2, sequential2];
          }
          current = stack.head;
          stack = stack.tail;
          break;
        }
      }
    }
    throw new Error("BUG: BlockedRequests.step - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  const merge$3 = (sequential2, parallel2) => {
    if (isNil$1(sequential2)) {
      return of$1(parallelCollectionToSequentialCollection(parallel2));
    }
    if (parallelCollectionIsEmpty(parallel2)) {
      return sequential2;
    }
    const seqHeadKeys = sequentialCollectionKeys(sequential2.head);
    const parKeys = parallelCollectionKeys(parallel2);
    if (seqHeadKeys.length === 1 && parKeys.length === 1 && equals$1(seqHeadKeys[0], parKeys[0])) {
      return cons(sequentialCollectionCombine(sequential2.head, parallelCollectionToSequentialCollection(parallel2)), sequential2.tail);
    }
    return cons(parallelCollectionToSequentialCollection(parallel2), sequential2);
  };
  const RequestBlockParallelTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockParallel");
  const parallelVariance = {
    /* c8 ignore next */
    _R: (_) => _
  };
  _f = RequestBlockParallelTypeId;
  class ParallelImpl {
    constructor(map2) {
      __publicField(this, "map");
      __publicField(this, _f, parallelVariance);
      this.map = map2;
    }
  }
  const parallelCollectionEmpty = () => new ParallelImpl(empty$n());
  const parallelCollectionAdd = (self2, blockedRequest) => new ParallelImpl(modifyAt(self2.map, blockedRequest.dataSource, (_) => orElseSome(map$h(_, append$1(blockedRequest.blockedRequest)), () => of$2(blockedRequest.blockedRequest))));
  const parallelCollectionCombine = (self2, that) => new ParallelImpl(reduce$2(self2.map, that.map, (map2, value2, key) => set$8(map2, key, match$a(get$a(map2, key), {
    onNone: () => value2,
    onSome: (other) => appendAll$1(value2, other)
  }))));
  const parallelCollectionIsEmpty = (self2) => isEmpty$5(self2.map);
  const parallelCollectionKeys = (self2) => Array.from(keys(self2.map));
  const parallelCollectionToSequentialCollection = (self2) => sequentialCollectionMake(map$b(self2.map, (x) => of$2(x)));
  const SequentialCollectionTypeId = /* @__PURE__ */ Symbol.for("effect/RequestBlock/RequestBlockSequential");
  const sequentialVariance = {
    /* c8 ignore next */
    _R: (_) => _
  };
  _g = SequentialCollectionTypeId;
  class SequentialImpl {
    constructor(map2) {
      __publicField(this, "map");
      __publicField(this, _g, sequentialVariance);
      this.map = map2;
    }
  }
  const sequentialCollectionMake = (map2) => new SequentialImpl(map2);
  const sequentialCollectionCombine = (self2, that) => new SequentialImpl(reduce$2(that.map, self2.map, (map2, value2, key) => set$8(map2, key, match$a(get$a(map2, key), {
    onNone: () => empty$r(),
    onSome: (a) => appendAll$1(a, value2)
  }))));
  const sequentialCollectionKeys = (self2) => Array.from(keys(self2.map));
  const sequentialCollectionToChunk = (self2) => Array.from(self2.map);
  const OP_DIE$2 = "Die";
  const OP_EMPTY$2 = "Empty";
  const OP_FAIL$4 = "Fail";
  const OP_INTERRUPT$2 = "Interrupt";
  const OP_PARALLEL$1 = "Parallel";
  const OP_SEQUENTIAL$1 = "Sequential";
  const CauseSymbolKey = "effect/Cause";
  const CauseTypeId = /* @__PURE__ */ Symbol.for(CauseSymbolKey);
  const variance$2 = {
    /* c8 ignore next */
    _E: (_) => _
  };
  const proto$b = {
    [CauseTypeId]: variance$2,
    [symbol$1]() {
      return pipe(hash$2(CauseSymbolKey), combine$7(hash$2(flattenCause(this))), cached$1(this));
    },
    [symbol](that) {
      return isCause$1(that) && causeEquals(this, that);
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toJSON() {
      switch (this._tag) {
        case "Empty":
          return {
            _id: "Cause",
            _tag: this._tag
          };
        case "Die":
          return {
            _id: "Cause",
            _tag: this._tag,
            defect: toJSON(this.defect)
          };
        case "Interrupt":
          return {
            _id: "Cause",
            _tag: this._tag,
            fiberId: this.fiberId.toJSON()
          };
        case "Fail":
          return {
            _id: "Cause",
            _tag: this._tag,
            failure: toJSON(this.error)
          };
        case "Sequential":
        case "Parallel":
          return {
            _id: "Cause",
            _tag: this._tag,
            left: toJSON(this.left),
            right: toJSON(this.right)
          };
      }
    },
    toString() {
      return pretty$1(this);
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
  };
  const empty$h = /* @__PURE__ */ (() => {
    const o = /* @__PURE__ */ Object.create(proto$b);
    o._tag = OP_EMPTY$2;
    return o;
  })();
  const fail$c = (error) => {
    const o = Object.create(proto$b);
    o._tag = OP_FAIL$4;
    o.error = error;
    return o;
  };
  const die$7 = (defect) => {
    const o = Object.create(proto$b);
    o._tag = OP_DIE$2;
    o.defect = defect;
    return o;
  };
  const interrupt$6 = (fiberId2) => {
    const o = Object.create(proto$b);
    o._tag = OP_INTERRUPT$2;
    o.fiberId = fiberId2;
    return o;
  };
  const parallel$3 = (left2, right2) => {
    const o = Object.create(proto$b);
    o._tag = OP_PARALLEL$1;
    o.left = left2;
    o.right = right2;
    return o;
  };
  const sequential$3 = (left2, right2) => {
    const o = Object.create(proto$b);
    o._tag = OP_SEQUENTIAL$1;
    o.left = left2;
    o.right = right2;
    return o;
  };
  const isCause$1 = (u) => hasProperty(u, CauseTypeId);
  const isEmptyType = (self2) => self2._tag === OP_EMPTY$2;
  const isFailType$1 = (self2) => self2._tag === OP_FAIL$4;
  const isDieType$1 = (self2) => self2._tag === OP_DIE$2;
  const isEmpty$4 = (self2) => {
    if (self2._tag === OP_EMPTY$2) {
      return true;
    }
    return reduce(self2, true, (acc, cause) => {
      switch (cause._tag) {
        case OP_EMPTY$2: {
          return some(acc);
        }
        case OP_DIE$2:
        case OP_FAIL$4:
        case OP_INTERRUPT$2: {
          return some(false);
        }
        default: {
          return none$4();
        }
      }
    });
  };
  const isInterrupted$2 = (self2) => isSome(interruptOption(self2));
  const isInterruptedOnly$1 = (self2) => reduceWithContext$1(void 0, IsInterruptedOnlyCauseReducer)(self2);
  const failures = (self2) => reverse$1(reduce(self2, empty$r(), (list, cause) => cause._tag === OP_FAIL$4 ? some(pipe(list, prepend$1(cause.error))) : none$4()));
  const defects = (self2) => reverse$1(reduce(self2, empty$r(), (list, cause) => cause._tag === OP_DIE$2 ? some(pipe(list, prepend$1(cause.defect))) : none$4()));
  const interruptors$1 = (self2) => reduce(self2, empty$o(), (set2, cause) => cause._tag === OP_INTERRUPT$2 ? some(pipe(set2, add(cause.fiberId))) : none$4());
  const failureOption = (self2) => find(self2, (cause) => cause._tag === OP_FAIL$4 ? some(cause.error) : none$4());
  const failureOrCause$1 = (self2) => {
    const option = failureOption(self2);
    switch (option._tag) {
      case "None": {
        return right(self2);
      }
      case "Some": {
        return left(option.value);
      }
    }
  };
  const flipCauseOption$1 = (self2) => match$7(self2, {
    onEmpty: some(empty$h),
    onFail: map$h(fail$c),
    onDie: (defect) => some(die$7(defect)),
    onInterrupt: (fiberId2) => some(interrupt$6(fiberId2)),
    onSequential: mergeWith$2(sequential$3),
    onParallel: mergeWith$2(parallel$3)
  });
  const interruptOption = (self2) => find(self2, (cause) => cause._tag === OP_INTERRUPT$2 ? some(cause.fiberId) : none$4());
  const stripFailures = (self2) => match$7(self2, {
    onEmpty: empty$h,
    onFail: () => empty$h,
    onDie: die$7,
    onInterrupt: interrupt$6,
    onSequential: sequential$3,
    onParallel: parallel$3
  });
  const electFailures = (self2) => match$7(self2, {
    onEmpty: empty$h,
    onFail: die$7,
    onDie: die$7,
    onInterrupt: interrupt$6,
    onSequential: sequential$3,
    onParallel: parallel$3
  });
  const map$a = /* @__PURE__ */ dual(2, (self2, f) => flatMap$8(self2, (e) => fail$c(f(e))));
  const flatMap$8 = /* @__PURE__ */ dual(2, (self2, f) => match$7(self2, {
    onEmpty: empty$h,
    onFail: (error) => f(error),
    onDie: (defect) => die$7(defect),
    onInterrupt: (fiberId2) => interrupt$6(fiberId2),
    onSequential: (left2, right2) => sequential$3(left2, right2),
    onParallel: (left2, right2) => parallel$3(left2, right2)
  }));
  const causeEquals = (left2, right2) => {
    let leftStack = of$2(left2);
    let rightStack = of$2(right2);
    while (isNonEmpty$2(leftStack) && isNonEmpty$2(rightStack)) {
      const [leftParallel, leftSequential] = pipe(headNonEmpty(leftStack), reduce([empty$o(), empty$r()], ([parallel2, sequential2], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return some([pipe(parallel2, union(par2)), pipe(sequential2, appendAll$1(seq2))]);
      }));
      const [rightParallel, rightSequential] = pipe(headNonEmpty(rightStack), reduce([empty$o(), empty$r()], ([parallel2, sequential2], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return some([pipe(parallel2, union(par2)), pipe(sequential2, appendAll$1(seq2))]);
      }));
      if (!equals$1(leftParallel, rightParallel)) {
        return false;
      }
      leftStack = leftSequential;
      rightStack = rightSequential;
    }
    return true;
  };
  const flattenCause = (cause) => {
    return flattenCauseLoop(of$2(cause), empty$r());
  };
  const flattenCauseLoop = (causes, flattened) => {
    while (1) {
      const [parallel2, sequential2] = pipe(causes, reduce$7([empty$o(), empty$r()], ([parallel3, sequential3], cause) => {
        const [par2, seq2] = evaluateCause(cause);
        return [pipe(parallel3, union(par2)), pipe(sequential3, appendAll$1(seq2))];
      }));
      const updated = size$6(parallel2) > 0 ? pipe(flattened, prepend$1(parallel2)) : flattened;
      if (isEmpty$7(sequential2)) {
        return reverse$1(updated);
      }
      causes = sequential2;
      flattened = updated;
    }
    throw new Error(getBugErrorMessage("Cause.flattenCauseLoop"));
  };
  const find = /* @__PURE__ */ dual(2, (self2, pf) => {
    const stack = [self2];
    while (stack.length > 0) {
      const item = stack.pop();
      const option = pf(item);
      switch (option._tag) {
        case "None": {
          switch (item._tag) {
            case OP_SEQUENTIAL$1:
            case OP_PARALLEL$1: {
              stack.push(item.right);
              stack.push(item.left);
              break;
            }
          }
          break;
        }
        case "Some": {
          return option;
        }
      }
    }
    return none$4();
  });
  const evaluateCause = (self2) => {
    let cause = self2;
    const stack = [];
    let _parallel = empty$o();
    let _sequential = empty$r();
    while (cause !== void 0) {
      switch (cause._tag) {
        case OP_EMPTY$2: {
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_FAIL$4: {
          _parallel = add(_parallel, make$Y(cause._tag, cause.error));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_DIE$2: {
          _parallel = add(_parallel, make$Y(cause._tag, cause.defect));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_INTERRUPT$2: {
          _parallel = add(_parallel, make$Y(cause._tag, cause.fiberId));
          if (stack.length === 0) {
            return [_parallel, _sequential];
          }
          cause = stack.pop();
          break;
        }
        case OP_SEQUENTIAL$1: {
          switch (cause.left._tag) {
            case OP_EMPTY$2: {
              cause = cause.right;
              break;
            }
            case OP_SEQUENTIAL$1: {
              cause = sequential$3(cause.left.left, sequential$3(cause.left.right, cause.right));
              break;
            }
            case OP_PARALLEL$1: {
              cause = parallel$3(sequential$3(cause.left.left, cause.right), sequential$3(cause.left.right, cause.right));
              break;
            }
            default: {
              _sequential = prepend$1(_sequential, cause.right);
              cause = cause.left;
              break;
            }
          }
          break;
        }
        case OP_PARALLEL$1: {
          stack.push(cause.right);
          cause = cause.left;
          break;
        }
      }
    }
    throw new Error(getBugErrorMessage("Cause.evaluateCauseLoop"));
  };
  const IsInterruptedOnlyCauseReducer = {
    emptyCase: constTrue,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: constTrue,
    sequentialCase: (_, left2, right2) => left2 && right2,
    parallelCase: (_, left2, right2) => left2 && right2
  };
  const OP_SEQUENTIAL_CASE = "SequentialCase";
  const OP_PARALLEL_CASE = "ParallelCase";
  const match$7 = /* @__PURE__ */ dual(2, (self2, {
    onDie,
    onEmpty,
    onFail,
    onInterrupt: onInterrupt2,
    onParallel,
    onSequential
  }) => {
    return reduceWithContext$1(self2, void 0, {
      emptyCase: () => onEmpty,
      failCase: (_, error) => onFail(error),
      dieCase: (_, defect) => onDie(defect),
      interruptCase: (_, fiberId2) => onInterrupt2(fiberId2),
      sequentialCase: (_, left2, right2) => onSequential(left2, right2),
      parallelCase: (_, left2, right2) => onParallel(left2, right2)
    });
  });
  const reduce = /* @__PURE__ */ dual(3, (self2, zero2, pf) => {
    let accumulator = zero2;
    let cause = self2;
    const causes = [];
    while (cause !== void 0) {
      const option = pf(accumulator, cause);
      accumulator = isSome(option) ? option.value : accumulator;
      switch (cause._tag) {
        case OP_SEQUENTIAL$1: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        case OP_PARALLEL$1: {
          causes.push(cause.right);
          cause = cause.left;
          break;
        }
        default: {
          cause = void 0;
          break;
        }
      }
      if (cause === void 0 && causes.length > 0) {
        cause = causes.pop();
      }
    }
    return accumulator;
  });
  const reduceWithContext$1 = /* @__PURE__ */ dual(3, (self2, context2, reducer) => {
    const input = [self2];
    const output = [];
    while (input.length > 0) {
      const cause = input.pop();
      switch (cause._tag) {
        case OP_EMPTY$2: {
          output.push(right(reducer.emptyCase(context2)));
          break;
        }
        case OP_FAIL$4: {
          output.push(right(reducer.failCase(context2, cause.error)));
          break;
        }
        case OP_DIE$2: {
          output.push(right(reducer.dieCase(context2, cause.defect)));
          break;
        }
        case OP_INTERRUPT$2: {
          output.push(right(reducer.interruptCase(context2, cause.fiberId)));
          break;
        }
        case OP_SEQUENTIAL$1: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left({
            _tag: OP_SEQUENTIAL_CASE
          }));
          break;
        }
        case OP_PARALLEL$1: {
          input.push(cause.right);
          input.push(cause.left);
          output.push(left({
            _tag: OP_PARALLEL_CASE
          }));
          break;
        }
      }
    }
    const accumulator = [];
    while (output.length > 0) {
      const either2 = output.pop();
      switch (either2._tag) {
        case "Left": {
          switch (either2.left._tag) {
            case OP_SEQUENTIAL_CASE: {
              const left2 = accumulator.pop();
              const right2 = accumulator.pop();
              const value2 = reducer.sequentialCase(context2, left2, right2);
              accumulator.push(value2);
              break;
            }
            case OP_PARALLEL_CASE: {
              const left2 = accumulator.pop();
              const right2 = accumulator.pop();
              const value2 = reducer.parallelCase(context2, left2, right2);
              accumulator.push(value2);
              break;
            }
          }
          break;
        }
        case "Right": {
          accumulator.push(either2.right);
          break;
        }
      }
    }
    if (accumulator.length === 0) {
      throw new Error("BUG: Cause.reduceWithContext - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    return accumulator.pop();
  });
  const pretty$1 = (cause, options2) => {
    if (isInterruptedOnly$1(cause)) {
      return "All fibers interrupted without errors.";
    }
    return prettyErrors$1(cause).map(function(e) {
      if ((options2 == null ? void 0 : options2.renderErrorCause) !== true || e.cause === void 0) {
        return e.stack;
      }
      return `${e.stack} {
${renderErrorCause(e.cause, "  ")}
}`;
    }).join("\n");
  };
  const renderErrorCause = (cause, prefix) => {
    const lines = cause.stack.split("\n");
    let stack = `${prefix}[cause]: ${lines[0]}`;
    for (let i = 1, len = lines.length; i < len; i++) {
      stack += `
${prefix}${lines[i]}`;
    }
    if (cause.cause) {
      stack += ` {
${renderErrorCause(cause.cause, `${prefix}  `)}
${prefix}}`;
    }
    return stack;
  };
  class PrettyError extends globalThis.Error {
    constructor(originalError) {
      const originalErrorIsObject = typeof originalError === "object" && originalError !== null;
      const prevLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = 1;
      super(prettyErrorMessage(originalError), originalErrorIsObject && "cause" in originalError && typeof originalError.cause !== "undefined" ? {
        cause: new PrettyError(originalError.cause)
      } : void 0);
      __publicField(this, "span");
      if (this.message === "") {
        this.message = "An error has occurred";
      }
      Error.stackTraceLimit = prevLimit;
      this.name = originalError instanceof Error ? originalError.name : "Error";
      if (originalErrorIsObject) {
        if (spanSymbol in originalError) {
          this.span = originalError[spanSymbol];
        }
        Object.keys(originalError).forEach((key) => {
          if (!(key in this)) {
            this[key] = originalError[key];
          }
        });
      }
      this.stack = prettyErrorStack(`${this.name}: ${this.message}`, originalError instanceof Error && originalError.stack ? originalError.stack : "", this.span);
    }
  }
  const prettyErrorMessage = (u) => {
    if (typeof u === "string") {
      return u;
    }
    if (typeof u === "object" && u !== null && u instanceof Error) {
      return u.message;
    }
    try {
      if (hasProperty(u, "toString") && isFunction(u["toString"]) && u["toString"] !== Object.prototype.toString && u["toString"] !== globalThis.Array.prototype.toString) {
        return u["toString"]();
      }
    } catch {
    }
    return stringifyCircular(u);
  };
  const locationRegex = /\((.*)\)/g;
  const spanToTrace = /* @__PURE__ */ globalValue("effect/Tracer/spanToTrace", () => /* @__PURE__ */ new WeakMap());
  const prettyErrorStack = (message, stack, span2) => {
    const out = [message];
    const lines = stack.startsWith(message) ? stack.slice(message.length).split("\n") : stack.split("\n");
    for (let i = 1; i < lines.length; i++) {
      if (lines[i].includes(" at new BaseEffectError") || lines[i].includes(" at new YieldableError")) {
        i++;
        continue;
      }
      if (lines[i].includes("Generator.next")) {
        break;
      }
      if (lines[i].includes("effect_internal_function")) {
        break;
      }
      out.push(lines[i].replace(/at .*effect_instruction_i.*\((.*)\)/, "at $1").replace(/EffectPrimitive\.\w+/, "<anonymous>"));
    }
    if (span2) {
      let current = span2;
      let i = 0;
      while (current && current._tag === "Span" && i < 10) {
        const stackFn = spanToTrace.get(current);
        if (typeof stackFn === "function") {
          const stack2 = stackFn();
          if (typeof stack2 === "string") {
            const locationMatchAll = stack2.matchAll(locationRegex);
            let match2 = false;
            for (const [, location2] of locationMatchAll) {
              match2 = true;
              out.push(`    at ${current.name} (${location2})`);
            }
            if (!match2) {
              out.push(`    at ${current.name} (${stack2.replace(/^at /, "")})`);
            }
          } else {
            out.push(`    at ${current.name}`);
          }
        } else {
          out.push(`    at ${current.name}`);
        }
        current = getOrUndefined(current.parent);
        i++;
      }
    }
    return out.join("\n");
  };
  const spanSymbol = /* @__PURE__ */ Symbol.for("effect/SpanAnnotation");
  const prettyErrors$1 = (cause) => reduceWithContext$1(cause, void 0, {
    emptyCase: () => [],
    dieCase: (_, unknownError) => {
      return [new PrettyError(unknownError)];
    },
    failCase: (_, error) => {
      return [new PrettyError(error)];
    },
    interruptCase: () => [],
    parallelCase: (_, l, r) => [...l, ...r],
    sequentialCase: (_, l, r) => [...l, ...r]
  });
  const OP_STATE_PENDING = "Pending";
  const OP_STATE_DONE$1 = "Done";
  const DeferredSymbolKey = "effect/Deferred";
  const DeferredTypeId = /* @__PURE__ */ Symbol.for(DeferredSymbolKey);
  const deferredVariance = {
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _A: (_) => _
  };
  const pending = (joiners) => {
    return {
      _tag: OP_STATE_PENDING,
      joiners
    };
  };
  const done$8 = (effect2) => {
    return {
      _tag: OP_STATE_DONE$1,
      effect: effect2
    };
  };
  class SingleShotGen {
    constructor(self2) {
      __publicField(this, "self");
      __publicField(this, "called", false);
      this.self = self2;
    }
    next(a) {
      return this.called ? {
        value: a,
        done: true
      } : (this.called = true, {
        value: this.self,
        done: false
      });
    }
    return(a) {
      return {
        value: a,
        done: true
      };
    }
    throw(e) {
      throw e;
    }
    [Symbol.iterator]() {
      return new SingleShotGen(this.self);
    }
  }
  const blocked = (blockedRequests, _continue2) => {
    const effect2 = new EffectPrimitive("Blocked");
    effect2.effect_instruction_i0 = blockedRequests;
    effect2.effect_instruction_i1 = _continue2;
    return effect2;
  };
  const runRequestBlock = (blockedRequests) => {
    const effect2 = new EffectPrimitive("RunBlocked");
    effect2.effect_instruction_i0 = blockedRequests;
    return effect2;
  };
  const EffectTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Effect");
  class RevertFlags {
    constructor(patch2, op) {
      __publicField(this, "patch");
      __publicField(this, "op");
      __publicField(this, "_op", OP_REVERT_FLAGS);
      this.patch = patch2;
      this.op = op;
    }
  }
  class EffectPrimitive {
    constructor(_op) {
      __publicField(this, "_op");
      __publicField(this, "effect_instruction_i0");
      __publicField(this, "effect_instruction_i1");
      __publicField(this, "effect_instruction_i2");
      __publicField(this, "trace");
      __publicField(this, _h, effectVariance);
      this._op = _op;
    }
    [(_h = EffectTypeId$1, symbol)](that) {
      return this === that;
    }
    [symbol$1]() {
      return cached$1(this, random(this));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Effect",
        _op: this._op,
        effect_instruction_i0: toJSON(this.effect_instruction_i0),
        effect_instruction_i1: toJSON(this.effect_instruction_i1),
        effect_instruction_i2: toJSON(this.effect_instruction_i2)
      };
    }
    toString() {
      return format$3(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    }
  }
  class EffectPrimitiveFailure {
    constructor(_op) {
      __publicField(this, "_op");
      __publicField(this, "effect_instruction_i0");
      __publicField(this, "effect_instruction_i1");
      __publicField(this, "effect_instruction_i2");
      __publicField(this, "trace");
      __publicField(this, _i, effectVariance);
      this._op = _op;
      this._tag = _op;
    }
    [(_i = EffectTypeId$1, symbol)](that) {
      return exitIsExit(that) && that._op === "Failure" && // @ts-expect-error
      equals$1(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol$1]() {
      return pipe(
        // @ts-expect-error
        string(this._tag),
        // @ts-expect-error
        combine$7(hash$2(this.effect_instruction_i0)),
        cached$1(this)
      );
    }
    get cause() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        cause: this.cause.toJSON()
      };
    }
    toString() {
      return format$3(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    }
  }
  class EffectPrimitiveSuccess {
    constructor(_op) {
      __publicField(this, "_op");
      __publicField(this, "effect_instruction_i0");
      __publicField(this, "effect_instruction_i1");
      __publicField(this, "effect_instruction_i2");
      __publicField(this, "trace");
      __publicField(this, _j, effectVariance);
      this._op = _op;
      this._tag = _op;
    }
    [(_j = EffectTypeId$1, symbol)](that) {
      return exitIsExit(that) && that._op === "Success" && // @ts-expect-error
      equals$1(this.effect_instruction_i0, that.effect_instruction_i0);
    }
    [symbol$1]() {
      return pipe(
        // @ts-expect-error
        string(this._tag),
        // @ts-expect-error
        combine$7(hash$2(this.effect_instruction_i0)),
        cached$1(this)
      );
    }
    get value() {
      return this.effect_instruction_i0;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "Exit",
        _tag: this._op,
        value: toJSON(this.value)
      };
    }
    toString() {
      return format$3(this.toJSON());
    }
    [NodeInspectSymbol]() {
      return this.toJSON();
    }
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    }
  }
  const isEffect$1 = (u) => hasProperty(u, EffectTypeId$1);
  const withFiberRuntime$1 = (withRuntime) => {
    const effect2 = new EffectPrimitive(OP_WITH_RUNTIME);
    effect2.effect_instruction_i0 = withRuntime;
    return effect2;
  };
  const acquireUseRelease$2 = /* @__PURE__ */ dual(3, (acquire, use, release) => uninterruptibleMask$2((restore) => flatMap$7(acquire, (a) => flatMap$7(exit$1(suspend$8(() => restore(use(a)))), (exit2) => {
    return suspend$8(() => release(a, exit2)).pipe(matchCauseEffect$2({
      onFailure: (cause) => {
        switch (exit2._tag) {
          case OP_FAILURE:
            return failCause$8(sequential$3(exit2.effect_instruction_i0, cause));
          case OP_SUCCESS:
            return failCause$8(cause);
        }
      },
      onSuccess: () => exit2
    }));
  }))));
  const as$1 = /* @__PURE__ */ dual(2, (self2, value2) => flatMap$7(self2, () => succeed$a(value2)));
  const asVoid$1 = (self2) => as$1(self2, void 0);
  const custom = function() {
    const wrapper = new EffectPrimitive(OP_COMMIT);
    switch (arguments.length) {
      case 2: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.commit = arguments[1];
        break;
      }
      case 3: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.commit = arguments[2];
        break;
      }
      case 4: {
        wrapper.effect_instruction_i0 = arguments[0];
        wrapper.effect_instruction_i1 = arguments[1];
        wrapper.effect_instruction_i2 = arguments[2];
        wrapper.commit = arguments[3];
        break;
      }
      default: {
        throw new Error(getBugErrorMessage("you're not supposed to end up here"));
      }
    }
    return wrapper;
  };
  const unsafeAsync = (register, blockingOn = none$2) => {
    const effect2 = new EffectPrimitive(OP_ASYNC);
    let cancelerRef = void 0;
    effect2.effect_instruction_i0 = (resume2) => {
      cancelerRef = register(resume2);
    };
    effect2.effect_instruction_i1 = blockingOn;
    return onInterrupt$1(effect2, (_) => isEffect$1(cancelerRef) ? cancelerRef : void_$4);
  };
  const asyncInterrupt = (register, blockingOn = none$2) => suspend$8(() => unsafeAsync(register, blockingOn));
  const async_ = (resume2, blockingOn = none$2) => {
    return custom(resume2, function() {
      let backingResume = void 0;
      let pendingEffect = void 0;
      function proxyResume(effect3) {
        if (backingResume) {
          backingResume(effect3);
        } else if (pendingEffect === void 0) {
          pendingEffect = effect3;
        }
      }
      const effect2 = new EffectPrimitive(OP_ASYNC);
      effect2.effect_instruction_i0 = (resume3) => {
        backingResume = resume3;
        if (pendingEffect) {
          resume3(pendingEffect);
        }
      };
      effect2.effect_instruction_i1 = blockingOn;
      let cancelerRef = void 0;
      let controllerRef = void 0;
      if (this.effect_instruction_i0.length !== 1) {
        controllerRef = new AbortController();
        cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume, controllerRef.signal));
      } else {
        cancelerRef = internalCall(() => this.effect_instruction_i0(proxyResume));
      }
      return cancelerRef || controllerRef ? onInterrupt$1(effect2, (_) => {
        if (controllerRef) {
          controllerRef.abort();
        }
        return cancelerRef ?? void_$4;
      }) : effect2;
    });
  };
  const catchAllCause$2 = /* @__PURE__ */ dual(2, (self2, f) => {
    const effect2 = new EffectPrimitive(OP_ON_FAILURE$1);
    effect2.effect_instruction_i0 = self2;
    effect2.effect_instruction_i1 = f;
    return effect2;
  });
  const catchAll$3 = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
    onFailure: f,
    onSuccess: succeed$a
  }));
  const catchIf$1 = /* @__PURE__ */ dual(3, (self2, predicate, f) => catchAllCause$2(self2, (cause) => {
    const either2 = failureOrCause$1(cause);
    switch (either2._tag) {
      case "Left":
        return predicate(either2.left) ? f(either2.left) : failCause$8(cause);
      case "Right":
        return failCause$8(either2.right);
    }
  }));
  const originalSymbol = /* @__PURE__ */ Symbol.for("effect/OriginalAnnotation");
  const capture = (obj, span2) => {
    if (isSome(span2)) {
      return new Proxy(obj, {
        has(target, p) {
          return p === spanSymbol || p === originalSymbol || p in target;
        },
        get(target, p) {
          if (p === spanSymbol) {
            return span2.value;
          }
          if (p === originalSymbol) {
            return obj;
          }
          return target[p];
        }
      });
    }
    return obj;
  };
  const die$6 = (defect) => isObject(defect) && !(spanSymbol in defect) ? withFiberRuntime$1((fiber) => failCause$8(die$7(capture(defect, currentSpanFromFiber(fiber))))) : failCause$8(die$7(defect));
  const dieMessage$1 = (message) => failCauseSync$1(() => die$7(new RuntimeException(message)));
  const either$2 = (self2) => matchEffect(self2, {
    onFailure: (e) => succeed$a(left(e)),
    onSuccess: (a) => succeed$a(right(a))
  });
  const exit$1 = (self2) => matchCause$2(self2, {
    onFailure: exitFailCause$1,
    onSuccess: exitSucceed$1
  });
  const fail$b = (error) => isObject(error) && !(spanSymbol in error) ? withFiberRuntime$1((fiber) => failCause$8(fail$c(capture(error, currentSpanFromFiber(fiber))))) : failCause$8(fail$c(error));
  const failSync$1 = (evaluate2) => flatMap$7(sync$5(evaluate2), fail$b);
  const failCause$8 = (cause) => {
    const effect2 = new EffectPrimitiveFailure(OP_FAILURE);
    effect2.effect_instruction_i0 = cause;
    return effect2;
  };
  const failCauseSync$1 = (evaluate2) => flatMap$7(sync$5(evaluate2), failCause$8);
  const fiberId = /* @__PURE__ */ withFiberRuntime$1((state2) => succeed$a(state2.id()));
  const fiberIdWith$1 = (f) => withFiberRuntime$1((state2) => f(state2.id()));
  const flatMap$7 = /* @__PURE__ */ dual(2, (self2, f) => {
    const effect2 = new EffectPrimitive(OP_ON_SUCCESS$1);
    effect2.effect_instruction_i0 = self2;
    effect2.effect_instruction_i1 = f;
    return effect2;
  });
  const andThen$1 = /* @__PURE__ */ dual(2, (self2, f) => flatMap$7(self2, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect$1(b)) {
      return b;
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume2) => {
        b.then((a2) => resume2(succeed$a(a2)), (e) => resume2(fail$b(new UnknownException(e, "An unknown error occurred in Effect.andThen"))));
      });
    }
    return succeed$a(b);
  }));
  const step = (self2) => {
    const effect2 = new EffectPrimitive("OnStep");
    effect2.effect_instruction_i0 = self2;
    return effect2;
  };
  const flatten$5 = (self2) => flatMap$7(self2, identity);
  const matchCause$2 = /* @__PURE__ */ dual(2, (self2, options2) => matchCauseEffect$2(self2, {
    onFailure: (cause) => succeed$a(options2.onFailure(cause)),
    onSuccess: (a) => succeed$a(options2.onSuccess(a))
  }));
  const matchCauseEffect$2 = /* @__PURE__ */ dual(2, (self2, options2) => {
    const effect2 = new EffectPrimitive(OP_ON_SUCCESS_AND_FAILURE);
    effect2.effect_instruction_i0 = self2;
    effect2.effect_instruction_i1 = options2.onFailure;
    effect2.effect_instruction_i2 = options2.onSuccess;
    return effect2;
  });
  const matchEffect = /* @__PURE__ */ dual(2, (self2, options2) => matchCauseEffect$2(self2, {
    onFailure: (cause) => {
      const defects$1 = defects(cause);
      if (defects$1.length > 0) {
        return failCause$8(electFailures(cause));
      }
      const failures$1 = failures(cause);
      if (failures$1.length > 0) {
        return options2.onFailure(unsafeHead(failures$1));
      }
      return failCause$8(cause);
    },
    onSuccess: options2.onSuccess
  }));
  const forEachSequential = /* @__PURE__ */ dual(2, (self2, f) => suspend$8(() => {
    const arr = fromIterable$8(self2);
    const ret = allocate(arr.length);
    let i = 0;
    return as$1(whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: (b) => {
        ret[i++] = b;
      }
    }), ret);
  }));
  const forEachSequentialDiscard = /* @__PURE__ */ dual(2, (self2, f) => suspend$8(() => {
    const arr = fromIterable$8(self2);
    let i = 0;
    return whileLoop({
      while: () => i < arr.length,
      body: () => f(arr[i], i),
      step: () => {
        i++;
      }
    });
  }));
  const interrupt$5 = /* @__PURE__ */ flatMap$7(fiberId, (fiberId2) => interruptWith(fiberId2));
  const interruptWith = (fiberId2) => failCause$8(interrupt$6(fiberId2));
  const interruptible$2 = (self2) => {
    const effect2 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect2.effect_instruction_i0 = enable(Interruption);
    effect2.effect_instruction_i1 = () => self2;
    return effect2;
  };
  const intoDeferred$1 = /* @__PURE__ */ dual(2, (self2, deferred) => uninterruptibleMask$2((restore) => flatMap$7(exit$1(restore(self2)), (exit2) => deferredDone(deferred, exit2))));
  const map$9 = /* @__PURE__ */ dual(2, (self2, f) => flatMap$7(self2, (a) => sync$5(() => f(a))));
  const mapBoth$3 = /* @__PURE__ */ dual(2, (self2, options2) => matchEffect(self2, {
    onFailure: (e) => failSync$1(() => options2.onFailure(e)),
    onSuccess: (a) => sync$5(() => options2.onSuccess(a))
  }));
  const mapError$5 = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect$2(self2, {
    onFailure: (cause) => {
      const either2 = failureOrCause$1(cause);
      switch (either2._tag) {
        case "Left": {
          return failSync$1(() => f(either2.left));
        }
        case "Right": {
          return failCause$8(either2.right);
        }
      }
    },
    onSuccess: succeed$a
  }));
  const onError$1 = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit$2(self2, (exit2) => exitIsSuccess(exit2) ? void_$4 : cleanup(exit2.effect_instruction_i0)));
  const onExit$2 = /* @__PURE__ */ dual(2, (self2, cleanup) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self2), {
    onFailure: (cause1) => {
      const result = exitFailCause$1(cause1);
      return matchCauseEffect$2(cleanup(result), {
        onFailure: (cause2) => exitFailCause$1(sequential$3(cause1, cause2)),
        onSuccess: () => result
      });
    },
    onSuccess: (success) => {
      const result = exitSucceed$1(success);
      return zipRight$4(cleanup(result), result);
    }
  })));
  const onInterrupt$1 = /* @__PURE__ */ dual(2, (self2, cleanup) => onExit$2(self2, exitMatch({
    onFailure: (cause) => isInterruptedOnly$1(cause) ? asVoid$1(cleanup(interruptors$1(cause))) : void_$4,
    onSuccess: () => void_$4
  })));
  const orDie$3 = (self2) => orDieWith$2(self2, identity);
  const orDieWith$2 = /* @__PURE__ */ dual(2, (self2, f) => matchEffect(self2, {
    onFailure: (e) => die$6(f(e)),
    onSuccess: succeed$a
  }));
  const runtimeFlags = /* @__PURE__ */ withFiberRuntime$1((_, status) => succeed$a(status.runtimeFlags));
  const succeed$a = (value2) => {
    const effect2 = new EffectPrimitiveSuccess(OP_SUCCESS);
    effect2.effect_instruction_i0 = value2;
    return effect2;
  };
  const suspend$8 = (evaluate2) => {
    const effect2 = new EffectPrimitive(OP_COMMIT);
    effect2.commit = evaluate2;
    return effect2;
  };
  const sync$5 = (thunk) => {
    const effect2 = new EffectPrimitive(OP_SYNC$1);
    effect2.effect_instruction_i0 = thunk;
    return effect2;
  };
  const tap$3 = /* @__PURE__ */ dual((args2) => args2.length === 3 || args2.length === 2 && !(isObject(args2[1]) && "onlyEffect" in args2[1]), (self2, f) => flatMap$7(self2, (a) => {
    const b = typeof f === "function" ? f(a) : f;
    if (isEffect$1(b)) {
      return as$1(b, a);
    } else if (isPromiseLike(b)) {
      return unsafeAsync((resume2) => {
        b.then((_) => resume2(succeed$a(a)), (e) => resume2(fail$b(new UnknownException(e, "An unknown error occurred in Effect.tap"))));
      });
    }
    return succeed$a(a);
  }));
  const transplant = (f) => withFiberRuntime$1((state2) => {
    const scopeOverride = state2.getFiberRef(currentForkScopeOverride);
    const scope2 = pipe(scopeOverride, getOrElse(() => state2.scope()));
    return f(fiberRefLocally(currentForkScopeOverride, some(scope2)));
  });
  const uninterruptible$1 = (self2) => {
    const effect2 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect2.effect_instruction_i0 = disable(Interruption);
    effect2.effect_instruction_i1 = () => self2;
    return effect2;
  };
  const uninterruptibleMask$2 = (f) => custom(f, function() {
    const effect2 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect2.effect_instruction_i0 = disable(Interruption);
    effect2.effect_instruction_i1 = (oldFlags) => interruption(oldFlags) ? internalCall(() => this.effect_instruction_i0(interruptible$2)) : internalCall(() => this.effect_instruction_i0(uninterruptible$1));
    return effect2;
  });
  const void_$4 = /* @__PURE__ */ succeed$a(void 0);
  const updateRuntimeFlags = (patch2) => {
    const effect2 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect2.effect_instruction_i0 = patch2;
    effect2.effect_instruction_i1 = void 0;
    return effect2;
  };
  const whenEffect = /* @__PURE__ */ dual(2, (self2, condition) => flatMap$7(condition, (b) => {
    if (b) {
      return pipe(self2, map$9(some));
    }
    return succeed$a(none$4());
  }));
  const whileLoop = (options2) => {
    const effect2 = new EffectPrimitive(OP_WHILE);
    effect2.effect_instruction_i0 = options2.while;
    effect2.effect_instruction_i1 = options2.body;
    effect2.effect_instruction_i2 = options2.step;
    return effect2;
  };
  const fromIterator = (iterator) => suspend$8(() => {
    const effect2 = new EffectPrimitive(OP_ITERATOR);
    effect2.effect_instruction_i0 = iterator();
    return effect2;
  });
  const gen$3 = function() {
    const f = arguments.length === 1 ? arguments[0] : arguments[1].bind(arguments[0]);
    return fromIterator(() => f(pipe));
  };
  const fnUntraced$1 = (body, ...pipeables) => Object.defineProperty(pipeables.length === 0 ? function(...args2) {
    return fromIterator(() => body.apply(this, args2));
  } : function(...args2) {
    let effect2 = fromIterator(() => body.apply(this, args2));
    for (const x of pipeables) {
      effect2 = x(effect2, ...args2);
    }
    return effect2;
  }, "length", {
    value: body.length,
    configurable: true
  });
  const withRuntimeFlags = /* @__PURE__ */ dual(2, (self2, update2) => {
    const effect2 = new EffectPrimitive(OP_UPDATE_RUNTIME_FLAGS);
    effect2.effect_instruction_i0 = update2;
    effect2.effect_instruction_i1 = () => self2;
    return effect2;
  });
  const yieldNow$2 = (options2) => {
    const effect2 = new EffectPrimitive(OP_YIELD$1);
    return typeof (options2 == null ? void 0 : options2.priority) !== "undefined" ? withSchedulingPriority(effect2, options2.priority) : effect2;
  };
  const zip$3 = /* @__PURE__ */ dual(2, (self2, that) => flatMap$7(self2, (a) => map$9(that, (b) => [a, b])));
  const zipLeft$1 = /* @__PURE__ */ dual(2, (self2, that) => flatMap$7(self2, (a) => as$1(that, a)));
  const zipRight$4 = /* @__PURE__ */ dual(2, (self2, that) => flatMap$7(self2, () => that));
  const zipWith$2 = /* @__PURE__ */ dual(3, (self2, that, f) => flatMap$7(self2, (a) => map$9(that, (b) => f(a, b))));
  const never$3 = /* @__PURE__ */ asyncInterrupt(() => {
    const interval = setInterval(() => {
    }, 2 ** 31 - 1);
    return sync$5(() => clearInterval(interval));
  });
  const interruptFiber = (self2) => flatMap$7(fiberId, (fiberId2) => pipe(self2, interruptAsFiber(fiberId2)));
  const interruptAsFiber = /* @__PURE__ */ dual(2, (self2, fiberId2) => flatMap$7(self2.interruptAsFork(fiberId2), () => self2.await));
  const logLevelAll = {
    _tag: "All",
    syslog: 0,
    label: "ALL",
    ordinal: Number.MIN_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelFatal = {
    _tag: "Fatal",
    syslog: 2,
    label: "FATAL",
    ordinal: 5e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelError = {
    _tag: "Error",
    syslog: 3,
    label: "ERROR",
    ordinal: 4e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelWarning = {
    _tag: "Warning",
    syslog: 4,
    label: "WARN",
    ordinal: 3e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelInfo = {
    _tag: "Info",
    syslog: 6,
    label: "INFO",
    ordinal: 2e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelDebug = {
    _tag: "Debug",
    syslog: 7,
    label: "DEBUG",
    ordinal: 1e4,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelTrace = {
    _tag: "Trace",
    syslog: 7,
    label: "TRACE",
    ordinal: 0,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const logLevelNone = {
    _tag: "None",
    syslog: 7,
    label: "OFF",
    ordinal: Number.MAX_SAFE_INTEGER,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const FiberRefSymbolKey = "effect/FiberRef";
  const FiberRefTypeId = /* @__PURE__ */ Symbol.for(FiberRefSymbolKey);
  const fiberRefVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  const fiberRefGet = (self2) => withFiberRuntime$1((fiber) => exitSucceed$1(fiber.getFiberRef(self2)));
  const fiberRefGetWith = /* @__PURE__ */ dual(2, (self2, f) => flatMap$7(fiberRefGet(self2), f));
  const fiberRefSet = /* @__PURE__ */ dual(2, (self2, value2) => fiberRefModify(self2, () => [void 0, value2]));
  const fiberRefModify = /* @__PURE__ */ dual(2, (self2, f) => withFiberRuntime$1((state2) => {
    const [b, a] = f(state2.getFiberRef(self2));
    state2.setFiberRef(self2, a);
    return succeed$a(b);
  }));
  const fiberRefLocally = /* @__PURE__ */ dual(3, (use, self2, value2) => acquireUseRelease$2(zipLeft$1(fiberRefGet(self2), fiberRefSet(self2, value2)), () => use, (oldValue) => fiberRefSet(self2, oldValue)));
  const fiberRefLocallyWith = /* @__PURE__ */ dual(3, (use, self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocally(use, self2, f(a))));
  const fiberRefUnsafeMake = (initial, options2) => fiberRefUnsafeMakePatch(initial, {
    differ: update$5(),
    fork: (options2 == null ? void 0 : options2.fork) ?? identity,
    join: options2 == null ? void 0 : options2.join
  });
  const fiberRefUnsafeMakeHashSet = (initial) => {
    const differ2 = hashSet();
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  const fiberRefUnsafeMakeReadonlyArray = (initial) => {
    const differ2 = readonlyArray(update$5());
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  const fiberRefUnsafeMakeContext = (initial) => {
    const differ2 = environment();
    return fiberRefUnsafeMakePatch(initial, {
      differ: differ2,
      fork: differ2.empty
    });
  };
  const fiberRefUnsafeMakePatch = (initial, options2) => {
    const _fiberRef = {
      ...CommitPrototype,
      [FiberRefTypeId]: fiberRefVariance,
      initial,
      commit() {
        return fiberRefGet(this);
      },
      diff: (oldValue, newValue) => options2.differ.diff(oldValue, newValue),
      combine: (first, second) => options2.differ.combine(first, second),
      patch: (patch2) => (oldValue) => options2.differ.patch(patch2, oldValue),
      fork: options2.fork,
      join: options2.join ?? ((_, n) => n)
    };
    return _fiberRef;
  };
  const fiberRefUnsafeMakeRuntimeFlags = (initial) => fiberRefUnsafeMakePatch(initial, {
    differ: differ$1,
    fork: differ$1.empty
  });
  const currentContext$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentContext"), () => fiberRefUnsafeMakeContext(empty$s()));
  const currentSchedulingPriority$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentSchedulingPriority"), () => fiberRefUnsafeMake(0));
  const currentMaxOpsBeforeYield = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMaxOpsBeforeYield"), () => fiberRefUnsafeMake(2048));
  const currentLogAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogAnnotation"), () => fiberRefUnsafeMake(empty$n()));
  const currentLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogLevel"), () => fiberRefUnsafeMake(logLevelInfo));
  const currentLogSpan = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLogSpan"), () => fiberRefUnsafeMake(empty$m()));
  const withSchedulingPriority = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentSchedulingPriority$1, scheduler));
  const withMaxOpsBeforeYield$1 = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentMaxOpsBeforeYield, scheduler));
  const currentConcurrency = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentConcurrency"), () => fiberRefUnsafeMake("unbounded"));
  const currentRequestBatching = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestBatching"), () => fiberRefUnsafeMake(true));
  const currentUnhandledErrorLogLevel = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentUnhandledErrorLogLevel"), () => fiberRefUnsafeMake(some(logLevelDebug)));
  const withUnhandledErrorLogLevel$1 = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(self2, currentUnhandledErrorLogLevel, level));
  const currentMetricLabels = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentMetricLabels"), () => fiberRefUnsafeMakeReadonlyArray(empty$u()));
  const currentForkScopeOverride = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentForkScopeOverride"), () => fiberRefUnsafeMake(none$4(), {
    fork: () => none$4(),
    join: (parent, _) => parent
  }));
  const currentInterruptedCause = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentInterruptedCause"), () => fiberRefUnsafeMake(empty$h, {
    fork: () => empty$h,
    join: (parent, _) => parent
  }));
  const currentTracerEnabled$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerEnabled"), () => fiberRefUnsafeMake(true));
  const currentTracerTimingEnabled$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerTiming"), () => fiberRefUnsafeMake(true));
  const currentTracerSpanAnnotations = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanAnnotations"), () => fiberRefUnsafeMake(empty$n()));
  const currentTracerSpanLinks = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentTracerSpanLinks"), () => fiberRefUnsafeMake(empty$r()));
  const ScopeTypeId = /* @__PURE__ */ Symbol.for("effect/Scope");
  const CloseableScopeTypeId = /* @__PURE__ */ Symbol.for("effect/CloseableScope");
  const scopeAddFinalizer = (self2, finalizer) => self2.addFinalizer(() => asVoid$1(finalizer));
  const scopeAddFinalizerExit = (self2, finalizer) => self2.addFinalizer(finalizer);
  const scopeClose = (self2, exit2) => self2.close(exit2);
  const scopeFork = (self2, strategy) => self2.fork(strategy);
  const causeSquash = (self2) => {
    return causeSquashWith(identity)(self2);
  };
  const causeSquashWith = /* @__PURE__ */ dual(2, (self2, f) => {
    const option = pipe(self2, failureOption, map$h(f));
    switch (option._tag) {
      case "None": {
        return pipe(defects(self2), head$3, match$a({
          onNone: () => {
            const interrupts = fromIterable$8(interruptors$1(self2)).flatMap((fiberId2) => fromIterable$8(ids(fiberId2)).map((id2) => `#${id2}`));
            return new InterruptedException(interrupts ? `Interrupted by fibers: ${interrupts.join(", ")}` : void 0);
          },
          onSome: identity
        }));
      }
      case "Some": {
        return option.value;
      }
    }
  });
  const YieldableError = /* @__PURE__ */ function() {
    class YieldableError2 extends globalThis.Error {
      commit() {
        return fail$b(this);
      }
      toJSON() {
        const obj = {
          ...this
        };
        if (this.message) obj.message = this.message;
        if (this.cause) obj.cause = this.cause;
        return obj;
      }
      [NodeInspectSymbol]() {
        if (this.toString !== globalThis.Error.prototype.toString) {
          return this.stack ? `${this.toString()}
${this.stack.split("\n").slice(1).join("\n")}` : this.toString();
        } else if ("Bun" in globalThis) {
          return pretty$1(fail$c(this), {
            renderErrorCause: true
          });
        }
        return this;
      }
    }
    Object.assign(YieldableError2.prototype, StructuralCommitPrototype);
    return YieldableError2;
  }();
  const makeException = (proto2, tag2) => {
    class Base2 extends YieldableError {
      constructor() {
        super(...arguments);
        __publicField(this, "_tag", tag2);
      }
    }
    Object.assign(Base2.prototype, proto2);
    Base2.prototype.name = tag2;
    return Base2;
  };
  const RuntimeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/RuntimeException");
  const RuntimeException = /* @__PURE__ */ makeException({
    [RuntimeExceptionTypeId]: RuntimeExceptionTypeId
  }, "RuntimeException");
  const InterruptedExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/InterruptedException");
  const InterruptedException = /* @__PURE__ */ makeException({
    [InterruptedExceptionTypeId]: InterruptedExceptionTypeId
  }, "InterruptedException");
  const isInterruptedException = (u) => hasProperty(u, InterruptedExceptionTypeId);
  const IllegalArgumentExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/IllegalArgument");
  const IllegalArgumentException$1 = /* @__PURE__ */ makeException({
    [IllegalArgumentExceptionTypeId]: IllegalArgumentExceptionTypeId
  }, "IllegalArgumentException");
  const NoSuchElementExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/NoSuchElement");
  const NoSuchElementException$1 = /* @__PURE__ */ makeException({
    [NoSuchElementExceptionTypeId]: NoSuchElementExceptionTypeId
  }, "NoSuchElementException");
  const TimeoutExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/Timeout");
  const TimeoutException = /* @__PURE__ */ makeException({
    [TimeoutExceptionTypeId]: TimeoutExceptionTypeId
  }, "TimeoutException");
  const timeoutExceptionFromDuration = (duration) => new TimeoutException(`Operation timed out after '${format$2(duration)}'`);
  const UnknownExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Cause/errors/UnknownException");
  const UnknownException = /* @__PURE__ */ function() {
    class UnknownException2 extends YieldableError {
      constructor(cause, message) {
        super(message ?? "An unknown error occurred", {
          cause
        });
        __publicField(this, "_tag", "UnknownException");
        __publicField(this, "error");
        this.error = cause;
      }
    }
    Object.assign(UnknownException2.prototype, {
      [UnknownExceptionTypeId]: UnknownExceptionTypeId,
      name: "UnknownException"
    });
    return UnknownException2;
  }();
  const exitIsExit = (u) => isEffect$1(u) && "_tag" in u && (u._tag === "Success" || u._tag === "Failure");
  const exitIsFailure = (self2) => self2._tag === "Failure";
  const exitIsSuccess = (self2) => self2._tag === "Success";
  const exitIsInterrupted = (self2) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return isInterrupted$2(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return false;
    }
  };
  const exitAs = /* @__PURE__ */ dual(2, (self2, value2) => {
    switch (self2._tag) {
      case OP_FAILURE: {
        return exitFailCause$1(self2.effect_instruction_i0);
      }
      case OP_SUCCESS: {
        return exitSucceed$1(value2);
      }
    }
  });
  const exitAsVoid = (self2) => exitAs(self2, void 0);
  const exitCollectAll = (exits, options2) => exitCollectAllInternal(exits, (options2 == null ? void 0 : options2.parallel) ? parallel$3 : sequential$3);
  const exitDie$1 = (defect) => exitFailCause$1(die$7(defect));
  const exitFail = (error) => exitFailCause$1(fail$c(error));
  const exitFailCause$1 = (cause) => {
    const effect2 = new EffectPrimitiveFailure(OP_FAILURE);
    effect2.effect_instruction_i0 = cause;
    return effect2;
  };
  const exitInterrupt$1 = (fiberId2) => exitFailCause$1(interrupt$6(fiberId2));
  const exitMap = /* @__PURE__ */ dual(2, (self2, f) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return exitFailCause$1(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return exitSucceed$1(f(self2.effect_instruction_i0));
    }
  });
  const exitMapBoth = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return exitFailCause$1(pipe(self2.effect_instruction_i0, map$a(onFailure)));
      case OP_SUCCESS:
        return exitSucceed$1(onSuccess(self2.effect_instruction_i0));
    }
  });
  const exitMatch = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return onFailure(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self2.effect_instruction_i0);
    }
  });
  const exitMatchEffect = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE:
        return onFailure(self2.effect_instruction_i0);
      case OP_SUCCESS:
        return onSuccess(self2.effect_instruction_i0);
    }
  });
  const exitSucceed$1 = (value2) => {
    const effect2 = new EffectPrimitiveSuccess(OP_SUCCESS);
    effect2.effect_instruction_i0 = value2;
    return effect2;
  };
  const exitVoid$1 = /* @__PURE__ */ exitSucceed$1(void 0);
  const exitZip = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
    onSuccess: (a, a2) => [a, a2],
    onFailure: sequential$3
  }));
  const exitZipRight = /* @__PURE__ */ dual(2, (self2, that) => exitZipWith(self2, that, {
    onSuccess: (_, a2) => a2,
    onFailure: sequential$3
  }));
  const exitZipWith = /* @__PURE__ */ dual(3, (self2, that, {
    onFailure,
    onSuccess
  }) => {
    switch (self2._tag) {
      case OP_FAILURE: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitFailCause$1(self2.effect_instruction_i0);
          case OP_FAILURE: {
            return exitFailCause$1(onFailure(self2.effect_instruction_i0, that.effect_instruction_i0));
          }
        }
      }
      case OP_SUCCESS: {
        switch (that._tag) {
          case OP_SUCCESS:
            return exitSucceed$1(onSuccess(self2.effect_instruction_i0, that.effect_instruction_i0));
          case OP_FAILURE:
            return exitFailCause$1(that.effect_instruction_i0);
        }
      }
    }
  });
  const exitCollectAllInternal = (exits, combineCauses) => {
    const list = fromIterable$7(exits);
    if (!isNonEmpty$2(list)) {
      return none$4();
    }
    return pipe(tailNonEmpty(list), reduce$7(pipe(headNonEmpty(list), exitMap(of$2)), (accumulator, current) => pipe(accumulator, exitZipWith(current, {
      onSuccess: (list2, value2) => pipe(list2, prepend$1(value2)),
      onFailure: combineCauses
    }))), exitMap(reverse$1), exitMap((chunk2) => toReadonlyArray(chunk2)), some);
  };
  const deferredUnsafeMake = (fiberId2) => {
    const _deferred = {
      ...CommitPrototype,
      [DeferredTypeId]: deferredVariance,
      state: make$T(pending([])),
      commit() {
        return deferredAwait(this);
      },
      blockingOn: fiberId2
    };
    return _deferred;
  };
  const deferredMake = () => flatMap$7(fiberId, (id2) => deferredMakeAs(id2));
  const deferredMakeAs = (fiberId2) => sync$5(() => deferredUnsafeMake(fiberId2));
  const deferredAwait = (self2) => asyncInterrupt((resume2) => {
    const state2 = get$b(self2.state);
    switch (state2._tag) {
      case OP_STATE_DONE$1: {
        return resume2(state2.effect);
      }
      case OP_STATE_PENDING: {
        state2.joiners.push(resume2);
        return deferredInterruptJoiner(self2, resume2);
      }
    }
  }, self2.blockingOn);
  const deferredCompleteWith = /* @__PURE__ */ dual(2, (self2, effect2) => sync$5(() => {
    const state2 = get$b(self2.state);
    switch (state2._tag) {
      case OP_STATE_DONE$1: {
        return false;
      }
      case OP_STATE_PENDING: {
        set$9(self2.state, done$8(effect2));
        for (let i = 0, len = state2.joiners.length; i < len; i++) {
          state2.joiners[i](effect2);
        }
        return true;
      }
    }
  }));
  const deferredDone = /* @__PURE__ */ dual(2, (self2, exit2) => deferredCompleteWith(self2, exit2));
  const deferredFail = /* @__PURE__ */ dual(2, (self2, error) => deferredCompleteWith(self2, fail$b(error)));
  const deferredFailCause = /* @__PURE__ */ dual(2, (self2, cause) => deferredCompleteWith(self2, failCause$8(cause)));
  const deferredInterruptWith = /* @__PURE__ */ dual(2, (self2, fiberId2) => deferredCompleteWith(self2, interruptWith(fiberId2)));
  const deferredIsDone = (self2) => sync$5(() => get$b(self2.state)._tag === OP_STATE_DONE$1);
  const deferredSucceed = /* @__PURE__ */ dual(2, (self2, value2) => deferredCompleteWith(self2, succeed$a(value2)));
  const deferredUnsafeDone = (self2, effect2) => {
    const state2 = get$b(self2.state);
    if (state2._tag === OP_STATE_PENDING) {
      set$9(self2.state, done$8(effect2));
      for (let i = 0, len = state2.joiners.length; i < len; i++) {
        state2.joiners[i](effect2);
      }
    }
  };
  const deferredInterruptJoiner = (self2, joiner) => sync$5(() => {
    const state2 = get$b(self2.state);
    if (state2._tag === OP_STATE_PENDING) {
      const index = state2.joiners.indexOf(joiner);
      if (index >= 0) {
        state2.joiners.splice(index, 1);
      }
    }
  });
  const constContext = /* @__PURE__ */ withFiberRuntime$1((fiber) => exitSucceed$1(fiber.currentContext));
  const context$3 = () => constContext;
  const contextWithEffect = (f) => flatMap$7(context$3(), f);
  const provideContext$4 = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocally(currentContext$1, context2)(self2));
  const provideSomeContext = /* @__PURE__ */ dual(2, (self2, context2) => fiberRefLocallyWith(currentContext$1, (parent) => merge$4(parent, context2))(self2));
  const mapInputContext$1 = /* @__PURE__ */ dual(2, (self2, f) => contextWithEffect((context2) => provideContext$4(self2, f(context2))));
  const currentSpanFromFiber = (fiber) => {
    const span2 = fiber.currentSpan;
    return span2 !== void 0 && span2._tag === "Span" ? some(span2) : none$4();
  };
  const NoopSpanProto = {
    _tag: "Span",
    spanId: "noop",
    traceId: "noop",
    sampled: false,
    status: {
      _tag: "Ended",
      startTime: /* @__PURE__ */ BigInt(0),
      endTime: /* @__PURE__ */ BigInt(0),
      exit: exitVoid$1
    },
    attributes: /* @__PURE__ */ new Map(),
    links: [],
    kind: "internal",
    attribute() {
    },
    event() {
    },
    end() {
    },
    addLinks() {
    }
  };
  const noopSpan = (options2) => Object.assign(Object.create(NoopSpanProto), options2);
  const make$N = deferredMake;
  const _await$2 = deferredAwait;
  const done$7 = deferredDone;
  const fail$a = deferredFail;
  const failCause$7 = deferredFailCause;
  const isDone$5 = deferredIsDone;
  const succeed$9 = deferredSucceed;
  const unsafeMake$9 = deferredUnsafeMake;
  const unsafeDone = deferredUnsafeDone;
  const isExit$1 = exitIsExit;
  const isFailure = exitIsFailure;
  const isSuccess$1 = exitIsSuccess;
  const isInterrupted$1 = exitIsInterrupted;
  const all$2 = exitCollectAll;
  const die$5 = exitDie$1;
  const fail$9 = exitFail;
  const failCause$6 = exitFailCause$1;
  const interrupt$4 = exitInterrupt$1;
  const map$8 = exitMap;
  const mapBoth$2 = exitMapBoth;
  const match$6 = exitMatch;
  const succeed$8 = exitSucceed$1;
  const void_$3 = exitVoid$1;
  const zip$2 = exitZip;
  const zipRight$3 = exitZipRight;
  const TypeId$m = /* @__PURE__ */ Symbol.for("effect/MutableHashMap");
  const MutableHashMapProto = {
    [TypeId$m]: TypeId$m,
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this);
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableHashMap",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  class MutableHashMapIterator {
    constructor(self2) {
      __publicField(this, "self");
      __publicField(this, "referentialIterator");
      __publicField(this, "bucketIterator");
      this.self = self2;
      this.referentialIterator = self2.referential[Symbol.iterator]();
    }
    next() {
      if (this.bucketIterator !== void 0) {
        return this.bucketIterator.next();
      }
      const result = this.referentialIterator.next();
      if (result.done) {
        this.bucketIterator = new BucketIterator(this.self.buckets.values());
        return this.next();
      }
      return result;
    }
    [Symbol.iterator]() {
      return new MutableHashMapIterator(this.self);
    }
  }
  class BucketIterator {
    constructor(backing) {
      __publicField(this, "backing");
      __publicField(this, "currentBucket");
      this.backing = backing;
    }
    next() {
      if (this.currentBucket === void 0) {
        const result2 = this.backing.next();
        if (result2.done) {
          return result2;
        }
        this.currentBucket = result2.value[Symbol.iterator]();
      }
      const result = this.currentBucket.next();
      if (result.done) {
        this.currentBucket = void 0;
        return this.next();
      }
      return result;
    }
  }
  const empty$g = () => {
    const self2 = Object.create(MutableHashMapProto);
    self2.referential = /* @__PURE__ */ new Map();
    self2.buckets = /* @__PURE__ */ new Map();
    self2.bucketsSize = 0;
    return self2;
  };
  const get$9 = /* @__PURE__ */ dual(2, (self2, key) => {
    if (isEqual$1(key) === false) {
      return self2.referential.has(key) ? some(self2.referential.get(key)) : none$4();
    }
    const hash2 = key[symbol$1]();
    const bucket = self2.buckets.get(hash2);
    if (bucket === void 0) {
      return none$4();
    }
    return getFromBucket(self2, bucket, key);
  });
  const getFromBucket = (self2, bucket, key, remove2 = false) => {
    for (let i = 0, len = bucket.length; i < len; i++) {
      if (key[symbol](bucket[i][0])) {
        const value2 = bucket[i][1];
        if (remove2) {
          bucket.splice(i, 1);
          self2.bucketsSize--;
        }
        return some(value2);
      }
    }
    return none$4();
  };
  const has = /* @__PURE__ */ dual(2, (self2, key) => isSome(get$9(self2, key)));
  const set$7 = /* @__PURE__ */ dual(3, (self2, key, value2) => {
    if (isEqual$1(key) === false) {
      self2.referential.set(key, value2);
      return self2;
    }
    const hash2 = key[symbol$1]();
    const bucket = self2.buckets.get(hash2);
    if (bucket === void 0) {
      self2.buckets.set(hash2, [[key, value2]]);
      self2.bucketsSize++;
      return self2;
    }
    removeFromBucket(self2, bucket, key);
    bucket.push([key, value2]);
    self2.bucketsSize++;
    return self2;
  });
  const removeFromBucket = (self2, bucket, key) => {
    for (let i = 0, len = bucket.length; i < len; i++) {
      if (key[symbol](bucket[i][0])) {
        bucket.splice(i, 1);
        self2.bucketsSize--;
        return;
      }
    }
  };
  const remove$3 = /* @__PURE__ */ dual(2, (self2, key) => {
    if (isEqual$1(key) === false) {
      self2.referential.delete(key);
      return self2;
    }
    const hash2 = key[symbol$1]();
    const bucket = self2.buckets.get(hash2);
    if (bucket === void 0) {
      return self2;
    }
    removeFromBucket(self2, bucket, key);
    if (bucket.length === 0) {
      self2.buckets.delete(hash2);
    }
    return self2;
  });
  const TypeId$l = /* @__PURE__ */ Symbol.for("effect/MutableList");
  const MutableListProto = {
    [TypeId$l]: TypeId$l,
    [Symbol.iterator]() {
      let done2 = false;
      let head2 = this.head;
      return {
        next() {
          if (done2) {
            return this.return();
          }
          if (head2 == null) {
            done2 = true;
            return this.return();
          }
          const value2 = head2.value;
          head2 = head2.next;
          return {
            done: done2,
            value: value2
          };
        },
        return(value2) {
          if (!done2) {
            done2 = true;
          }
          return {
            done: true,
            value: value2
          };
        }
      };
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableList",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const makeNode = (value2) => ({
    value: value2,
    removed: false,
    prev: void 0,
    next: void 0
  });
  const empty$f = () => {
    const list = Object.create(MutableListProto);
    list.head = void 0;
    list.tail = void 0;
    list._length = 0;
    return list;
  };
  const isEmpty$3 = (self2) => length$1(self2) === 0;
  const length$1 = (self2) => self2._length;
  const append = /* @__PURE__ */ dual(2, (self2, value2) => {
    const node = makeNode(value2);
    if (self2.head === void 0) {
      self2.head = node;
    }
    if (self2.tail === void 0) {
      self2.tail = node;
    } else {
      self2.tail.next = node;
      node.prev = self2.tail;
      self2.tail = node;
    }
    self2._length += 1;
    return self2;
  });
  const shift = (self2) => {
    const head2 = self2.head;
    if (head2 !== void 0) {
      remove$2(self2, head2);
      return head2.value;
    }
    return void 0;
  };
  const remove$2 = (self2, node) => {
    if (node.removed) {
      return;
    }
    node.removed = true;
    if (node.prev !== void 0 && node.next !== void 0) {
      node.prev.next = node.next;
      node.next.prev = node.prev;
    } else if (node.prev !== void 0) {
      self2.tail = node.prev;
      node.prev.next = void 0;
    } else if (node.next !== void 0) {
      self2.head = node.next;
      node.next.prev = void 0;
    } else {
      self2.tail = void 0;
      self2.head = void 0;
    }
    if (self2._length > 0) {
      self2._length -= 1;
    }
  };
  const TypeId$k = /* @__PURE__ */ Symbol.for("effect/MutableQueue");
  const EmptyMutableQueue = /* @__PURE__ */ Symbol.for("effect/mutable/MutableQueue/Empty");
  const MutableQueueProto = {
    [TypeId$k]: TypeId$k,
    [Symbol.iterator]() {
      return Array.from(this.queue)[Symbol.iterator]();
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "MutableQueue",
        values: Array.from(this).map(toJSON)
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const make$M = (capacity2) => {
    const queue = Object.create(MutableQueueProto);
    queue.queue = empty$f();
    queue.capacity = capacity2;
    return queue;
  };
  const bounded$2 = (capacity2) => make$M(capacity2);
  const unbounded$6 = () => make$M(void 0);
  const length = (self2) => length$1(self2.queue);
  const isEmpty$2 = (self2) => isEmpty$3(self2.queue);
  const capacity = (self2) => self2.capacity === void 0 ? Infinity : self2.capacity;
  const offer$4 = /* @__PURE__ */ dual(2, (self2, value2) => {
    const queueLength = length$1(self2.queue);
    if (self2.capacity !== void 0 && queueLength === self2.capacity) {
      return false;
    }
    append(value2)(self2.queue);
    return true;
  });
  const offerAll$3 = /* @__PURE__ */ dual(2, (self2, values) => {
    const iterator = values[Symbol.iterator]();
    let next;
    let remainder = empty$r();
    let offering = true;
    while (offering && (next = iterator.next()) && !next.done) {
      offering = offer$4(next.value)(self2);
    }
    while (next != null && !next.done) {
      remainder = prepend$1(next.value)(remainder);
      next = iterator.next();
    }
    return reverse$1(remainder);
  });
  const poll = /* @__PURE__ */ dual(2, (self2, def) => {
    if (isEmpty$3(self2.queue)) {
      return def;
    }
    return shift(self2.queue);
  });
  const pollUpTo = /* @__PURE__ */ dual(2, (self2, n) => {
    let result = empty$r();
    let count = 0;
    while (count < n) {
      const element = poll(EmptyMutableQueue)(self2);
      if (element === EmptyMutableQueue) {
        break;
      }
      result = prepend$1(element)(result);
      count += 1;
    }
    return reverse$1(result);
  });
  const ClockSymbolKey = "effect/Clock";
  const ClockTypeId = /* @__PURE__ */ Symbol.for(ClockSymbolKey);
  const clockTag = /* @__PURE__ */ GenericTag("effect/Clock");
  const MAX_TIMER_MILLIS = 2 ** 31 - 1;
  const globalClockScheduler = {
    unsafeSchedule(task, duration) {
      const millis2 = toMillis(duration);
      if (millis2 > MAX_TIMER_MILLIS) {
        return constFalse;
      }
      let completed = false;
      const handle = setTimeout(() => {
        completed = true;
        task();
      }, millis2);
      return () => {
        clearTimeout(handle);
        return !completed;
      };
    }
  };
  const performanceNowNanos = /* @__PURE__ */ function() {
    const bigint1e62 = /* @__PURE__ */ BigInt(1e6);
    if (typeof performance === "undefined") {
      return () => BigInt(Date.now()) * bigint1e62;
    }
    let origin;
    return () => {
      if (origin === void 0) {
        origin = BigInt(Date.now()) * bigint1e62 - BigInt(Math.round(performance.now() * 1e6));
      }
      return origin + BigInt(Math.round(performance.now() * 1e6));
    };
  }();
  const processOrPerformanceNow = /* @__PURE__ */ function() {
    const processHrtime = typeof process === "object" && "hrtime" in process && typeof process.hrtime.bigint === "function" ? process.hrtime : void 0;
    if (!processHrtime) {
      return performanceNowNanos;
    }
    const origin = /* @__PURE__ */ performanceNowNanos() - /* @__PURE__ */ processHrtime.bigint();
    return () => origin + processHrtime.bigint();
  }();
  _k = ClockTypeId;
  class ClockImpl {
    constructor() {
      __publicField(this, _k, ClockTypeId);
      __publicField(this, "currentTimeMillis", /* @__PURE__ */ sync$5(() => this.unsafeCurrentTimeMillis()));
      __publicField(this, "currentTimeNanos", /* @__PURE__ */ sync$5(() => this.unsafeCurrentTimeNanos()));
    }
    unsafeCurrentTimeMillis() {
      return Date.now();
    }
    unsafeCurrentTimeNanos() {
      return processOrPerformanceNow();
    }
    scheduler() {
      return succeed$a(globalClockScheduler);
    }
    sleep(duration) {
      return async_((resume2) => {
        const canceler = globalClockScheduler.unsafeSchedule(() => resume2(void_$4), duration);
        return asVoid$1(sync$5(canceler));
      });
    }
  }
  const make$L = () => new ClockImpl();
  const OP_AND = "And";
  const OP_OR = "Or";
  const OP_INVALID_DATA = "InvalidData";
  const OP_MISSING_DATA = "MissingData";
  const OP_SOURCE_UNAVAILABLE = "SourceUnavailable";
  const OP_UNSUPPORTED = "Unsupported";
  const ConfigErrorSymbolKey = "effect/ConfigError";
  const ConfigErrorTypeId = /* @__PURE__ */ Symbol.for(ConfigErrorSymbolKey);
  const proto$a = {
    _tag: "ConfigError",
    [ConfigErrorTypeId]: ConfigErrorTypeId
  };
  const And = (self2, that) => {
    const error = Object.create(proto$a);
    error._op = OP_AND;
    error.left = self2;
    error.right = that;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        return `${this.left} and ${this.right}`;
      }
    });
    Object.defineProperty(error, "message", {
      enumerable: false,
      get() {
        return this.toString();
      }
    });
    return error;
  };
  const Or = (self2, that) => {
    const error = Object.create(proto$a);
    error._op = OP_OR;
    error.left = self2;
    error.right = that;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        return `${this.left} or ${this.right}`;
      }
    });
    Object.defineProperty(error, "message", {
      enumerable: false,
      get() {
        return this.toString();
      }
    });
    return error;
  };
  const InvalidData = (path, message, options2 = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto$a);
    error._op = OP_INVALID_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join$2(options2.pathDelim));
        return `(Invalid data at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  const MissingData = (path, message, options2 = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto$a);
    error._op = OP_MISSING_DATA;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join$2(options2.pathDelim));
        return `(Missing data at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  const SourceUnavailable = (path, message, cause, options2 = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto$a);
    error._op = OP_SOURCE_UNAVAILABLE;
    error.path = path;
    error.message = message;
    error.cause = cause;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join$2(options2.pathDelim));
        return `(Source unavailable at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  const Unsupported = (path, message, options2 = {
    pathDelim: "."
  }) => {
    const error = Object.create(proto$a);
    error._op = OP_UNSUPPORTED;
    error.path = path;
    error.message = message;
    Object.defineProperty(error, "toString", {
      enumerable: false,
      value() {
        const path2 = pipe(this.path, join$2(options2.pathDelim));
        return `(Unsupported operation at ${path2}: "${this.message}")`;
      }
    });
    return error;
  };
  const prefixed = /* @__PURE__ */ dual(2, (self2, prefix) => {
    switch (self2._op) {
      case OP_AND: {
        return And(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
      }
      case OP_OR: {
        return Or(prefixed(self2.left, prefix), prefixed(self2.right, prefix));
      }
      case OP_INVALID_DATA: {
        return InvalidData([...prefix, ...self2.path], self2.message);
      }
      case OP_MISSING_DATA: {
        return MissingData([...prefix, ...self2.path], self2.message);
      }
      case OP_SOURCE_UNAVAILABLE: {
        return SourceUnavailable([...prefix, ...self2.path], self2.message, self2.cause);
      }
      case OP_UNSUPPORTED: {
        return Unsupported([...prefix, ...self2.path], self2.message);
      }
    }
  });
  const empty$e = {
    _tag: "Empty"
  };
  const patch$5 = /* @__PURE__ */ dual(2, (path, patch2) => {
    let input = of$1(patch2);
    let output = path;
    while (isCons(input)) {
      const patch3 = input.head;
      switch (patch3._tag) {
        case "Empty": {
          input = input.tail;
          break;
        }
        case "AndThen": {
          input = cons(patch3.first, cons(patch3.second, input.tail));
          break;
        }
        case "MapName": {
          output = map$e(output, patch3.f);
          input = input.tail;
          break;
        }
        case "Nested": {
          output = prepend$2(output, patch3.name);
          input = input.tail;
          break;
        }
        case "Unnested": {
          const containsName = pipe(head$4(output), contains(patch3.name));
          if (containsName) {
            output = tailNonEmpty$1(output);
            input = input.tail;
          } else {
            return left(MissingData(output, `Expected ${patch3.name} to be in path in ConfigProvider#unnested`));
          }
          break;
        }
      }
    }
    return right(output);
  });
  const OP_CONSTANT = "Constant";
  const OP_FAIL$3 = "Fail";
  const OP_FALLBACK = "Fallback";
  const OP_DESCRIBED = "Described";
  const OP_LAZY = "Lazy";
  const OP_MAP_OR_FAIL = "MapOrFail";
  const OP_NESTED = "Nested";
  const OP_PRIMITIVE = "Primitive";
  const OP_SEQUENCE = "Sequence";
  const OP_HASHMAP = "HashMap";
  const OP_ZIP_WITH$1 = "ZipWith";
  var define_process_env_default$2 = {};
  const concat$1 = (l, r) => [...l, ...r];
  const ConfigProviderSymbolKey = "effect/ConfigProvider";
  const ConfigProviderTypeId = /* @__PURE__ */ Symbol.for(ConfigProviderSymbolKey);
  const configProviderTag = /* @__PURE__ */ GenericTag("effect/ConfigProvider");
  const FlatConfigProviderSymbolKey = "effect/ConfigProviderFlat";
  const FlatConfigProviderTypeId = /* @__PURE__ */ Symbol.for(FlatConfigProviderSymbolKey);
  const make$K = (options2) => ({
    [ConfigProviderTypeId]: ConfigProviderTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...options2
  });
  const makeFlat = (options2) => ({
    [FlatConfigProviderTypeId]: FlatConfigProviderTypeId,
    patch: options2.patch,
    load: (path, config, split = true) => options2.load(path, config, split),
    enumerateChildren: options2.enumerateChildren
  });
  const fromFlat = (flat) => make$K({
    load: (config) => flatMap$7(fromFlatLoop(flat, empty$u(), config, false), (chunk2) => match$a(head$4(chunk2), {
      onNone: () => fail$b(MissingData(empty$u(), `Expected a single value having structure: ${config}`)),
      onSome: succeed$a
    })),
    flattened: flat
  });
  const fromEnv = (options2) => {
    const {
      pathDelim,
      seqDelim
    } = Object.assign({}, {
      pathDelim: "_",
      seqDelim: ","
    }, options2);
    const makePathString = (path) => pipe(path, join$2(pathDelim));
    const unmakePathString = (pathString) => pathString.split(pathDelim);
    const getEnv = () => typeof process !== "undefined" && "env" in process && typeof define_process_env_default$2 === "object" ? define_process_env_default$2 : {};
    const load = (path, primitive, split = true) => {
      const pathString = makePathString(path);
      const current = getEnv();
      const valueOpt = pathString in current ? some(current[pathString]) : none$4();
      return pipe(valueOpt, mapError$5(() => MissingData(path, `Expected ${pathString} to exist in the process context`)), flatMap$7((value2) => parsePrimitive(value2, path, primitive, seqDelim, split)));
    };
    const enumerateChildren = (path) => sync$5(() => {
      const current = getEnv();
      const keys2 = Object.keys(current);
      const keyPaths = keys2.map((value2) => unmakePathString(value2.toUpperCase()));
      const filteredKeyPaths = keyPaths.filter((keyPath) => {
        for (let i = 0; i < path.length; i++) {
          const pathComponent = pipe(path, unsafeGet$5(i));
          const currentElement = keyPath[i];
          if (currentElement === void 0 || pathComponent !== currentElement) {
            return false;
          }
        }
        return true;
      }).flatMap((keyPath) => keyPath.slice(path.length, path.length + 1));
      return fromIterable$4(filteredKeyPaths);
    });
    return fromFlat(makeFlat({
      load,
      enumerateChildren,
      patch: empty$e
    }));
  };
  const extend$2 = (leftDef, rightDef, left2, right2) => {
    const leftPad = unfold$1(left2.length, (index) => index >= right2.length ? none$4() : some([leftDef(index), index + 1]));
    const rightPad = unfold$1(right2.length, (index) => index >= left2.length ? none$4() : some([rightDef(index), index + 1]));
    const leftExtension = concat$1(left2, leftPad);
    const rightExtension = concat$1(right2, rightPad);
    return [leftExtension, rightExtension];
  };
  const appendConfigPath = (path, config) => {
    let op = config;
    if (op._tag === "Nested") {
      const out = path.slice();
      while (op._tag === "Nested") {
        out.push(op.name);
        op = op.config;
      }
      return out;
    }
    return path;
  };
  const fromFlatLoop = (flat, prefix, config, split) => {
    const op = config;
    switch (op._tag) {
      case OP_CONSTANT: {
        return succeed$a(of$3(op.value));
      }
      case OP_DESCRIBED: {
        return suspend$8(() => fromFlatLoop(flat, prefix, op.config, split));
      }
      case OP_FAIL$3: {
        return fail$b(MissingData(prefix, op.message));
      }
      case OP_FALLBACK: {
        return pipe(suspend$8(() => fromFlatLoop(flat, prefix, op.first, split)), catchAll$3((error1) => {
          if (op.condition(error1)) {
            return pipe(fromFlatLoop(flat, prefix, op.second, split), catchAll$3((error2) => fail$b(Or(error1, error2))));
          }
          return fail$b(error1);
        }));
      }
      case OP_LAZY: {
        return suspend$8(() => fromFlatLoop(flat, prefix, op.config(), split));
      }
      case OP_MAP_OR_FAIL: {
        return suspend$8(() => pipe(fromFlatLoop(flat, prefix, op.original, split), flatMap$7(forEachSequential((a) => pipe(op.mapOrFail(a), mapError$5(prefixed(appendConfigPath(prefix, op.original))))))));
      }
      case OP_NESTED: {
        return suspend$8(() => fromFlatLoop(flat, concat$1(prefix, of$3(op.name)), op.config, split));
      }
      case OP_PRIMITIVE: {
        return pipe(patch$5(prefix, flat.patch), flatMap$7((prefix2) => pipe(flat.load(prefix2, op, split), flatMap$7((values) => {
          if (values.length === 0) {
            const name = pipe(last$1(prefix2), getOrElse(() => "<n/a>"));
            return fail$b(MissingData([], `Expected ${op.description} with name ${name}`));
          }
          return succeed$a(values);
        }))));
      }
      case OP_SEQUENCE: {
        return pipe(patch$5(prefix, flat.patch), flatMap$7((patchedPrefix) => pipe(flat.enumerateChildren(patchedPrefix), flatMap$7(indicesFrom), flatMap$7((indices) => {
          if (indices.length === 0) {
            return suspend$8(() => map$9(fromFlatLoop(flat, prefix, op.config, true), of$3));
          }
          return pipe(forEachSequential(indices, (index) => fromFlatLoop(flat, append$2(prefix, `[${index}]`), op.config, true)), map$9((chunkChunk) => {
            const flattened = flatten$8(chunkChunk);
            if (flattened.length === 0) {
              return of$3(empty$u());
            }
            return of$3(flattened);
          }));
        }))));
      }
      case OP_HASHMAP: {
        return suspend$8(() => pipe(patch$5(prefix, flat.patch), flatMap$7((prefix2) => pipe(flat.enumerateChildren(prefix2), flatMap$7((keys2) => {
          return pipe(keys2, forEachSequential((key) => fromFlatLoop(flat, concat$1(prefix2, of$3(key)), op.valueConfig, split)), map$9((matrix) => {
            if (matrix.length === 0) {
              return of$3(empty$n());
            }
            return pipe(transpose(matrix), map$e((values) => fromIterable$3(zip$4(fromIterable$8(keys2), values))));
          }));
        })))));
      }
      case OP_ZIP_WITH$1: {
        return suspend$8(() => pipe(fromFlatLoop(flat, prefix, op.left, split), either$2, flatMap$7((left2) => pipe(fromFlatLoop(flat, prefix, op.right, split), either$2, flatMap$7((right$12) => {
          if (isLeft(left2) && isLeft(right$12)) {
            return fail$b(And(left2.left, right$12.left));
          }
          if (isLeft(left2) && isRight(right$12)) {
            return fail$b(left2.left);
          }
          if (isRight(left2) && isLeft(right$12)) {
            return fail$b(right$12.left);
          }
          if (isRight(left2) && isRight(right$12)) {
            const path = pipe(prefix, join$2("."));
            const fail2 = fromFlatLoopFail(prefix, path);
            const [lefts, rights] = extend$2(fail2, fail2, pipe(left2.right, map$e(right)), pipe(right$12.right, map$e(right)));
            return pipe(lefts, zip$4(rights), forEachSequential(([left22, right2]) => pipe(zip$3(left22, right2), map$9(([left3, right3]) => op.zip(left3, right3)))));
          }
          throw new Error("BUG: ConfigProvider.fromFlatLoop - please report an issue at https://github.com/Effect-TS/effect/issues");
        })))));
      }
    }
  };
  const fromFlatLoopFail = (prefix, path) => (index) => left(MissingData(prefix, `The element at index ${index} in a sequence at path "${path}" was missing`));
  const splitPathString = (text2, delim) => {
    const split = text2.split(new RegExp(`\\s*${escape(delim)}\\s*`));
    return split;
  };
  const parsePrimitive = (text2, path, primitive, delimiter, split) => {
    if (!split) {
      return pipe(primitive.parse(text2), mapBoth$3({
        onFailure: prefixed(path),
        onSuccess: of$3
      }));
    }
    return pipe(splitPathString(text2, delimiter), forEachSequential((char) => primitive.parse(char.trim())), mapError$5(prefixed(path)));
  };
  const transpose = (array2) => {
    return Object.keys(array2[0]).map((column2) => array2.map((row) => row[column2]));
  };
  const indicesFrom = (quotedIndices) => pipe(forEachSequential(quotedIndices, parseQuotedIndex), mapBoth$3({
    onFailure: () => empty$u(),
    onSuccess: sort(Order$1)
  }), either$2, map$9(merge$6));
  const QUOTED_INDEX_REGEX = /^(\[(\d+)\])$/;
  const parseQuotedIndex = (str) => {
    const match2 = str.match(QUOTED_INDEX_REGEX);
    if (match2 !== null) {
      const matchedIndex = match2[2];
      return pipe(matchedIndex !== void 0 && matchedIndex.length > 0 ? some(matchedIndex) : none$4(), flatMap$a(parseInteger));
    }
    return none$4();
  };
  const parseInteger = (str) => {
    const parsedIndex = Number.parseInt(str);
    return Number.isNaN(parsedIndex) ? none$4() : some(parsedIndex);
  };
  const TypeId$j = /* @__PURE__ */ Symbol.for("effect/Console");
  const consoleTag = /* @__PURE__ */ GenericTag("effect/Console");
  const defaultConsole = {
    [TypeId$j]: TypeId$j,
    assert(condition, ...args2) {
      return sync$5(() => {
        console.assert(condition, ...args2);
      });
    },
    clear: /* @__PURE__ */ sync$5(() => {
      console.clear();
    }),
    count(label) {
      return sync$5(() => {
        console.count(label);
      });
    },
    countReset(label) {
      return sync$5(() => {
        console.countReset(label);
      });
    },
    debug(...args2) {
      return sync$5(() => {
        console.debug(...args2);
      });
    },
    dir(item, options2) {
      return sync$5(() => {
        console.dir(item, options2);
      });
    },
    dirxml(...args2) {
      return sync$5(() => {
        console.dirxml(...args2);
      });
    },
    error(...args2) {
      return sync$5(() => {
        console.error(...args2);
      });
    },
    group(options2) {
      return (options2 == null ? void 0 : options2.collapsed) ? sync$5(() => console.groupCollapsed(options2 == null ? void 0 : options2.label)) : sync$5(() => console.group(options2 == null ? void 0 : options2.label));
    },
    groupEnd: /* @__PURE__ */ sync$5(() => {
      console.groupEnd();
    }),
    info(...args2) {
      return sync$5(() => {
        console.info(...args2);
      });
    },
    log(...args2) {
      return sync$5(() => {
        console.log(...args2);
      });
    },
    table(tabularData, properties) {
      return sync$5(() => {
        console.table(tabularData, properties);
      });
    },
    time(label) {
      return sync$5(() => console.time(label));
    },
    timeEnd(label) {
      return sync$5(() => console.timeEnd(label));
    },
    timeLog(label, ...args2) {
      return sync$5(() => {
        console.timeLog(label, ...args2);
      });
    },
    trace(...args2) {
      return sync$5(() => {
        console.trace(...args2);
      });
    },
    warn(...args2) {
      return sync$5(() => {
        console.warn(...args2);
      });
    },
    unsafe: console
  };
  const RandomSymbolKey = "effect/Random";
  const RandomTypeId = /* @__PURE__ */ Symbol.for(RandomSymbolKey);
  const randomTag = /* @__PURE__ */ GenericTag("effect/Random");
  _l = RandomTypeId;
  class RandomImpl {
    constructor(seed) {
      __publicField(this, "seed");
      __publicField(this, _l, RandomTypeId);
      __publicField(this, "PRNG");
      this.seed = seed;
      this.PRNG = new PCGRandom(seed);
    }
    get next() {
      return sync$5(() => this.PRNG.number());
    }
    get nextBoolean() {
      return map$9(this.next, (n) => n > 0.5);
    }
    get nextInt() {
      return sync$5(() => this.PRNG.integer(Number.MAX_SAFE_INTEGER));
    }
    nextRange(min2, max2) {
      return map$9(this.next, (n) => (max2 - min2) * n + min2);
    }
    nextIntBetween(min2, max2) {
      return sync$5(() => this.PRNG.integer(max2 - min2) + min2);
    }
    shuffle(elements) {
      return shuffleWith(elements, (n) => this.nextIntBetween(0, n));
    }
  }
  const shuffleWith = (elements, nextIntBounded) => {
    return suspend$8(() => pipe(sync$5(() => Array.from(elements)), flatMap$7((buffer) => {
      const numbers = [];
      for (let i = buffer.length; i >= 2; i = i - 1) {
        numbers.push(i);
      }
      return pipe(numbers, forEachSequentialDiscard((n) => pipe(nextIntBounded(n), map$9((k) => swap$1(buffer, n - 1, k)))), as$1(fromIterable$7(buffer)));
    })));
  };
  const swap$1 = (buffer, index1, index2) => {
    const tmp = buffer[index1];
    buffer[index1] = buffer[index2];
    buffer[index2] = tmp;
    return buffer;
  };
  const make$J = (seed) => new RandomImpl(hash$2(seed));
  const TracerTypeId = /* @__PURE__ */ Symbol.for("effect/Tracer");
  const make$I = (options2) => ({
    [TracerTypeId]: TracerTypeId,
    ...options2
  });
  const tracerTag = /* @__PURE__ */ GenericTag("effect/Tracer");
  const spanTag = /* @__PURE__ */ GenericTag("effect/ParentSpan");
  const randomHexString = /* @__PURE__ */ function() {
    const characters = "abcdef0123456789";
    const charactersLength = characters.length;
    return function(length2) {
      let result = "";
      for (let i = 0; i < length2; i++) {
        result += characters.charAt(Math.floor(Math.random() * charactersLength));
      }
      return result;
    };
  }();
  class NativeSpan {
    constructor(name, parent, context2, links, startTime, kind) {
      __publicField(this, "name");
      __publicField(this, "parent");
      __publicField(this, "context");
      __publicField(this, "startTime");
      __publicField(this, "kind");
      __publicField(this, "_tag", "Span");
      __publicField(this, "spanId");
      __publicField(this, "traceId", "native");
      __publicField(this, "sampled", true);
      __publicField(this, "status");
      __publicField(this, "attributes");
      __publicField(this, "events", []);
      __publicField(this, "links");
      this.name = name;
      this.parent = parent;
      this.context = context2;
      this.startTime = startTime;
      this.kind = kind;
      this.status = {
        _tag: "Started",
        startTime
      };
      this.attributes = /* @__PURE__ */ new Map();
      this.traceId = parent._tag === "Some" ? parent.value.traceId : randomHexString(32);
      this.spanId = randomHexString(16);
      this.links = Array.from(links);
    }
    end(endTime, exit2) {
      this.status = {
        _tag: "Ended",
        endTime,
        exit: exit2,
        startTime: this.status.startTime
      };
    }
    attribute(key, value2) {
      this.attributes.set(key, value2);
    }
    event(name, startTime, attributes) {
      this.events.push([name, startTime, attributes ?? {}]);
    }
    addLinks(links) {
      this.links.push(...links);
    }
  }
  const nativeTracer = /* @__PURE__ */ make$I({
    span: (name, parent, context2, links, startTime, kind) => new NativeSpan(name, parent, context2, links, startTime, kind),
    context: (f) => f()
  });
  const addSpanStackTrace = (options2) => {
    if ((options2 == null ? void 0 : options2.captureStackTrace) === false) {
      return options2;
    } else if ((options2 == null ? void 0 : options2.captureStackTrace) !== void 0 && typeof options2.captureStackTrace !== "boolean") {
      return options2;
    }
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 3;
    const traceError = new Error();
    Error.stackTraceLimit = limit;
    let cache = false;
    return {
      ...options2,
      captureStackTrace: () => {
        if (cache !== false) {
          return cache;
        }
        if (traceError.stack !== void 0) {
          const stack = traceError.stack.split("\n");
          if (stack[3] !== void 0) {
            cache = stack[3].trim();
            return cache;
          }
        }
      }
    };
  };
  const DisablePropagation = /* @__PURE__ */ Reference()("effect/Tracer/DisablePropagation", {
    defaultValue: constFalse
  });
  const liveServices = /* @__PURE__ */ pipe(/* @__PURE__ */ empty$s(), /* @__PURE__ */ add$2(clockTag, /* @__PURE__ */ make$L()), /* @__PURE__ */ add$2(consoleTag, defaultConsole), /* @__PURE__ */ add$2(randomTag, /* @__PURE__ */ make$J(/* @__PURE__ */ Math.random())), /* @__PURE__ */ add$2(configProviderTag, /* @__PURE__ */ fromEnv()), /* @__PURE__ */ add$2(tracerTag, nativeTracer));
  const currentServices = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/DefaultServices/currentServices"), () => fiberRefUnsafeMakeContext(liveServices));
  const sleep$3 = (duration) => {
    const decodedDuration = decode$3(duration);
    return clockWith$2((clock2) => clock2.sleep(decodedDuration));
  };
  const defaultServicesWith = (f) => withFiberRuntime$1((fiber) => f(fiber.currentDefaultServices));
  const clockWith$2 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(clockTag.key)));
  const currentTimeMillis$1 = /* @__PURE__ */ clockWith$2((clock2) => clock2.currentTimeMillis);
  const tracerWith$2 = (f) => defaultServicesWith((services) => f(services.unsafeMap.get(tracerTag.key)));
  const sleep$2 = sleep$3;
  const currentTimeMillis = currentTimeMillis$1;
  const clockWith$1 = clockWith$2;
  const Clock = clockTag;
  function unsafeMake$8(fiberRefLocals) {
    return new FiberRefsImpl(fiberRefLocals);
  }
  function empty$d() {
    return unsafeMake$8(/* @__PURE__ */ new Map());
  }
  const FiberRefsSym = /* @__PURE__ */ Symbol.for("effect/FiberRefs");
  _m = FiberRefsSym;
  class FiberRefsImpl {
    constructor(locals) {
      __publicField(this, "locals");
      __publicField(this, _m, FiberRefsSym);
      this.locals = locals;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const findAncestor = (_ref, _parentStack, _childStack, _childModified = false) => {
    const ref = _ref;
    let parentStack = _parentStack;
    let childStack = _childStack;
    let childModified = _childModified;
    let ret = void 0;
    while (ret === void 0) {
      if (isNonEmptyReadonlyArray(parentStack) && isNonEmptyReadonlyArray(childStack)) {
        const parentFiberId = headNonEmpty$1(parentStack)[0];
        const parentAncestors = tailNonEmpty$1(parentStack);
        const childFiberId = headNonEmpty$1(childStack)[0];
        const childRefValue = headNonEmpty$1(childStack)[1];
        const childAncestors = tailNonEmpty$1(childStack);
        if (parentFiberId.startTimeMillis < childFiberId.startTimeMillis) {
          childStack = childAncestors;
          childModified = true;
        } else if (parentFiberId.startTimeMillis > childFiberId.startTimeMillis) {
          parentStack = parentAncestors;
        } else {
          if (parentFiberId.id < childFiberId.id) {
            childStack = childAncestors;
            childModified = true;
          } else if (parentFiberId.id > childFiberId.id) {
            parentStack = parentAncestors;
          } else {
            ret = [childRefValue, childModified];
          }
        }
      } else {
        ret = [ref.initial, true];
      }
    }
    return ret;
  };
  const joinAs = /* @__PURE__ */ dual(3, (self2, fiberId2, that) => {
    const parentFiberRefs = new Map(self2.locals);
    that.locals.forEach((childStack, fiberRef) => {
      const childValue = childStack[0][1];
      if (!childStack[0][0][symbol](fiberId2)) {
        if (!parentFiberRefs.has(fiberRef)) {
          if (equals$1(childValue, fiberRef.initial)) {
            return;
          }
          parentFiberRefs.set(fiberRef, [[fiberId2, fiberRef.join(fiberRef.initial, childValue)]]);
          return;
        }
        const parentStack = parentFiberRefs.get(fiberRef);
        const [ancestor, wasModified] = findAncestor(fiberRef, parentStack, childStack);
        if (wasModified) {
          const patch2 = fiberRef.diff(ancestor, childValue);
          const oldValue = parentStack[0][1];
          const newValue = fiberRef.join(oldValue, fiberRef.patch(patch2)(oldValue));
          if (!equals$1(oldValue, newValue)) {
            let newStack;
            const parentFiberId = parentStack[0][0];
            if (parentFiberId[symbol](fiberId2)) {
              newStack = [[parentFiberId, newValue], ...parentStack.slice(1)];
            } else {
              newStack = [[fiberId2, newValue], ...parentStack];
            }
            parentFiberRefs.set(fiberRef, newStack);
          }
        }
      }
    });
    return new FiberRefsImpl(parentFiberRefs);
  });
  const forkAs = /* @__PURE__ */ dual(2, (self2, childId) => {
    const map2 = /* @__PURE__ */ new Map();
    unsafeForkAs(self2, map2, childId);
    return new FiberRefsImpl(map2);
  });
  const unsafeForkAs = (self2, map2, fiberId2) => {
    self2.locals.forEach((stack, fiberRef) => {
      const oldValue = stack[0][1];
      const newValue = fiberRef.patch(fiberRef.fork)(oldValue);
      if (equals$1(oldValue, newValue)) {
        map2.set(fiberRef, stack);
      } else {
        map2.set(fiberRef, [[fiberId2, newValue], ...stack]);
      }
    });
  };
  const delete_ = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
    const locals = new Map(self2.locals);
    locals.delete(fiberRef);
    return new FiberRefsImpl(locals);
  });
  const get$8 = /* @__PURE__ */ dual(2, (self2, fiberRef) => {
    if (!self2.locals.has(fiberRef)) {
      return none$4();
    }
    return some(headNonEmpty$1(self2.locals.get(fiberRef))[1]);
  });
  const getOrDefault$1 = /* @__PURE__ */ dual(2, (self2, fiberRef) => pipe(get$8(self2, fiberRef), getOrElse(() => fiberRef.initial)));
  const updateAs = /* @__PURE__ */ dual(2, (self2, {
    fiberId: fiberId2,
    fiberRef,
    value: value2
  }) => {
    if (self2.locals.size === 0) {
      return new FiberRefsImpl(/* @__PURE__ */ new Map([[fiberRef, [[fiberId2, value2]]]]));
    }
    const locals = new Map(self2.locals);
    unsafeUpdateAs(locals, fiberId2, fiberRef, value2);
    return new FiberRefsImpl(locals);
  });
  const unsafeUpdateAs = (locals, fiberId2, fiberRef, value2) => {
    const oldStack = locals.get(fiberRef) ?? [];
    let newStack;
    if (isNonEmptyReadonlyArray(oldStack)) {
      const [currentId, currentValue] = headNonEmpty$1(oldStack);
      if (currentId[symbol](fiberId2)) {
        if (equals$1(currentValue, value2)) {
          return;
        } else {
          newStack = [[fiberId2, value2], ...oldStack.slice(1)];
        }
      } else {
        newStack = [[fiberId2, value2], ...oldStack];
      }
    } else {
      newStack = [[fiberId2, value2]];
    }
    locals.set(fiberRef, newStack);
  };
  const updateManyAs$1 = /* @__PURE__ */ dual(2, (self2, {
    entries,
    forkAs: forkAs2
  }) => {
    if (self2.locals.size === 0) {
      return new FiberRefsImpl(new Map(entries));
    }
    const locals = new Map(self2.locals);
    if (forkAs2 !== void 0) {
      unsafeForkAs(self2, locals, forkAs2);
    }
    entries.forEach(([fiberRef, values]) => {
      if (values.length === 1) {
        unsafeUpdateAs(locals, values[0][0], fiberRef, values[0][1]);
      } else {
        values.forEach(([fiberId2, value2]) => {
          unsafeUpdateAs(locals, fiberId2, fiberRef, value2);
        });
      }
    });
    return new FiberRefsImpl(locals);
  });
  const get$7 = get$8;
  const getOrDefault = getOrDefault$1;
  const updateManyAs = updateManyAs$1;
  const empty$c = empty$d;
  const All$1 = logLevelAll;
  const Fatal = logLevelFatal;
  const Error$2 = logLevelError;
  const Warning = logLevelWarning;
  const Info = logLevelInfo;
  const Debug = logLevelDebug;
  const Trace = logLevelTrace;
  const None = logLevelNone;
  const Order = /* @__PURE__ */ pipe(Order$1, /* @__PURE__ */ mapInput((level) => level.ordinal));
  const greaterThan = /* @__PURE__ */ greaterThan$1(Order);
  const fromLiteral = (literal) => {
    switch (literal) {
      case "All":
        return All$1;
      case "Debug":
        return Debug;
      case "Error":
        return Error$2;
      case "Fatal":
        return Fatal;
      case "Info":
        return Info;
      case "Trace":
        return Trace;
      case "None":
        return None;
      case "Warning":
        return Warning;
    }
  };
  const formatLabel = (key) => key.replace(/[\s="]/g, "_");
  const render = (now) => (self2) => {
    const label = formatLabel(self2.label);
    return `${label}=${now - self2.startTime}ms`;
  };
  const EffectPrototype = EffectPrototype$1;
  const Base$1 = Base$2;
  let Class$4 = class Class extends Base$1 {
  };
  const TypeId$i = /* @__PURE__ */ Symbol.for("effect/Readable");
  const RefTypeId$1 = /* @__PURE__ */ Symbol.for("effect/Ref");
  const refVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  class RefImpl extends (_p = Class$4, _o = RefTypeId$1, _n = TypeId$i, _p) {
    constructor(ref) {
      super();
      __publicField(this, "ref");
      __publicField(this, _o, refVariance);
      __publicField(this, _n, TypeId$i);
      __publicField(this, "get");
      this.ref = ref;
      this.get = sync$5(() => get$b(this.ref));
    }
    commit() {
      return this.get;
    }
    modify(f) {
      return sync$5(() => {
        const current = get$b(this.ref);
        const [b, a] = f(current);
        if (current !== a) {
          set$9(a)(this.ref);
        }
        return b;
      });
    }
  }
  const unsafeMake$7 = (value2) => new RefImpl(make$T(value2));
  const make$H = (value2) => sync$5(() => unsafeMake$7(value2));
  const get$6 = (self2) => self2.get;
  const set$6 = /* @__PURE__ */ dual(2, (self2, value2) => self2.modify(() => [void 0, value2]));
  const getAndSet$1 = /* @__PURE__ */ dual(2, (self2, value2) => self2.modify((a) => [a, value2]));
  const modify$2 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify(f));
  const update$4 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, f(a)]));
  const RefTypeId = RefTypeId$1;
  const make$G = make$H;
  const get$5 = get$6;
  const getAndSet = getAndSet$1;
  const modify$1 = modify$2;
  const set$5 = set$6;
  const update$3 = update$4;
  const ParentSpan = spanTag;
  const make$F = make$I;
  const tracerWith$1 = tracerWith$2;
  const OP_EMPTY$1 = "Empty";
  const OP_ADD = "Add";
  const OP_REMOVE = "Remove";
  const OP_UPDATE = "Update";
  const OP_AND_THEN$1 = "AndThen";
  const empty$b = {
    _tag: OP_EMPTY$1
  };
  const diff$2 = (oldValue, newValue) => {
    const missingLocals = new Map(oldValue.locals);
    let patch2 = empty$b;
    for (const [fiberRef, pairs] of newValue.locals.entries()) {
      const newValue2 = headNonEmpty$1(pairs)[1];
      const old = missingLocals.get(fiberRef);
      if (old !== void 0) {
        const oldValue2 = headNonEmpty$1(old)[1];
        if (!equals$1(oldValue2, newValue2)) {
          patch2 = combine$1({
            _tag: OP_UPDATE,
            fiberRef,
            patch: fiberRef.diff(oldValue2, newValue2)
          })(patch2);
        }
      } else {
        patch2 = combine$1({
          _tag: OP_ADD,
          fiberRef,
          value: newValue2
        })(patch2);
      }
      missingLocals.delete(fiberRef);
    }
    for (const [fiberRef] of missingLocals.entries()) {
      patch2 = combine$1({
        _tag: OP_REMOVE,
        fiberRef
      })(patch2);
    }
    return patch2;
  };
  const combine$1 = /* @__PURE__ */ dual(2, (self2, that) => ({
    _tag: OP_AND_THEN$1,
    first: self2,
    second: that
  }));
  const patch$4 = /* @__PURE__ */ dual(3, (self2, fiberId2, oldValue) => {
    let fiberRefs2 = oldValue;
    let patches = of$3(self2);
    while (isNonEmptyReadonlyArray(patches)) {
      const head2 = headNonEmpty$1(patches);
      const tail = tailNonEmpty$1(patches);
      switch (head2._tag) {
        case OP_EMPTY$1: {
          patches = tail;
          break;
        }
        case OP_ADD: {
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head2.fiberRef,
            value: head2.value
          });
          patches = tail;
          break;
        }
        case OP_REMOVE: {
          fiberRefs2 = delete_(fiberRefs2, head2.fiberRef);
          patches = tail;
          break;
        }
        case OP_UPDATE: {
          const value2 = getOrDefault$1(fiberRefs2, head2.fiberRef);
          fiberRefs2 = updateAs(fiberRefs2, {
            fiberId: fiberId2,
            fiberRef: head2.fiberRef,
            value: head2.fiberRef.patch(head2.patch)(value2)
          });
          patches = tail;
          break;
        }
        case OP_AND_THEN$1: {
          patches = prepend$2(head2.first)(prepend$2(head2.second)(tail));
          break;
        }
      }
    }
    return fiberRefs2;
  });
  const MetricLabelSymbolKey = "effect/MetricLabel";
  const MetricLabelTypeId = /* @__PURE__ */ Symbol.for(MetricLabelSymbolKey);
  class MetricLabelImpl {
    constructor(key, value2) {
      __publicField(this, "key");
      __publicField(this, "value");
      __publicField(this, _q, MetricLabelTypeId);
      __publicField(this, "_hash");
      this.key = key;
      this.value = value2;
      this._hash = string(MetricLabelSymbolKey + this.key + this.value);
    }
    [(_q = MetricLabelTypeId, symbol$1)]() {
      return this._hash;
    }
    [symbol](that) {
      return isMetricLabel(that) && this.key === that.key && this.value === that.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const make$E = (key, value2) => {
    return new MetricLabelImpl(key, value2);
  };
  const isMetricLabel = (u) => hasProperty(u, MetricLabelTypeId);
  const annotateLogs$1 = /* @__PURE__ */ dual((args2) => isEffect$1(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith(args2[0], currentLogAnnotations, typeof args2[1] === "string" ? set$8(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value2]) => set$8(acc, key, value2), annotations2));
  });
  const asSome = (self2) => map$9(self2, some);
  const try_$1 = (arg) => {
    let evaluate2;
    let onFailure = void 0;
    if (typeof arg === "function") {
      evaluate2 = arg;
    } else {
      evaluate2 = arg.try;
      onFailure = arg.catch;
    }
    return suspend$8(() => {
      try {
        return succeed$a(internalCall(evaluate2));
      } catch (error) {
        return fail$b(onFailure ? internalCall(() => onFailure(error)) : new UnknownException(error, "An unknown error occurred in Effect.try"));
      }
    });
  };
  const catchAllDefect$1 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause$2(self2, (cause) => {
    const option = find(cause, (_) => isDieType$1(_) ? some(_) : none$4());
    switch (option._tag) {
      case "None": {
        return failCause$8(cause);
      }
      case "Some": {
        return f(option.value.defect);
      }
    }
  }));
  const catchSomeCause$1 = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect$2(self2, {
    onFailure: (cause) => {
      const option = f(cause);
      switch (option._tag) {
        case "None": {
          return failCause$8(cause);
        }
        case "Some": {
          return option.value;
        }
      }
    },
    onSuccess: succeed$a
  }));
  const catchTag$1 = /* @__PURE__ */ dual((args2) => isEffect$1(args2[0]), (self2, ...args2) => {
    const f = args2[args2.length - 1];
    let predicate;
    if (args2.length === 2) {
      predicate = isTagged(args2[0]);
    } else {
      predicate = (e) => {
        const tag2 = hasProperty(e, "_tag") ? e["_tag"] : void 0;
        if (!tag2) return false;
        for (let i = 0; i < args2.length - 1; i++) {
          if (args2[i] === tag2) return true;
        }
        return false;
      };
    }
    return catchIf$1(self2, predicate, f);
  });
  const clockWith = clockWith$1;
  const clock$1 = /* @__PURE__ */ clockWith(succeed$a);
  const delay$1 = /* @__PURE__ */ dual(2, (self2, duration) => zipRight$4(sleep$2(duration), self2));
  const diffFiberRefs = (self2) => summarized(self2, fiberRefs, diff$2);
  const diffFiberRefsAndRuntimeFlags = (self2) => summarized(self2, zip$3(fiberRefs, runtimeFlags), ([refs, flags], [refsNew, flagsNew]) => [diff$2(refs, refsNew), diff$3(flags, flagsNew)]);
  const match$5 = /* @__PURE__ */ dual(2, (self2, options2) => matchEffect(self2, {
    onFailure: (e) => succeed$a(options2.onFailure(e)),
    onSuccess: (a) => succeed$a(options2.onSuccess(a))
  }));
  const forever$2 = (self2) => {
    const loop = flatMap$7(flatMap$7(self2, () => yieldNow$2()), () => loop);
    return loop;
  };
  const fiberRefs = /* @__PURE__ */ withFiberRuntime$1((state2) => succeed$a(state2.getFiberRefs()));
  const ignore$1 = (self2) => match$5(self2, {
    onFailure: constVoid,
    onSuccess: constVoid
  });
  const ignoreLogged$1 = (self2) => matchCauseEffect$2(self2, {
    onFailure: (cause) => logDebug$1(cause, "An error was silently ignored because it is not anticipated to be useful"),
    onSuccess: () => void_$4
  });
  const logWithLevel = (level) => (...message) => {
    const levelOption = fromNullable(level);
    let cause = void 0;
    for (let i = 0, len = message.length; i < len; i++) {
      const msg = message[i];
      if (isCause$1(msg)) {
        if (cause !== void 0) {
          cause = sequential$3(cause, msg);
        } else {
          cause = msg;
        }
        message = [...message.slice(0, i), ...message.slice(i + 1)];
        i--;
      }
    }
    if (cause === void 0) {
      cause = empty$h;
    }
    return withFiberRuntime$1((fiberState) => {
      fiberState.log(message, cause, levelOption);
      return void_$4;
    });
  };
  const log$1 = /* @__PURE__ */ logWithLevel();
  const logDebug$1 = /* @__PURE__ */ logWithLevel(Debug);
  const logWarning$1 = /* @__PURE__ */ logWithLevel(Warning);
  const logError$1 = /* @__PURE__ */ logWithLevel(Error$2);
  const mapErrorCause$1 = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect$2(self2, {
    onFailure: (c) => failCauseSync$1(() => f(c)),
    onSuccess: succeed$a
  }));
  const memoize = (self2) => pipe(deferredMake(), flatMap$7((deferred) => pipe(diffFiberRefsAndRuntimeFlags(self2), intoDeferred$1(deferred), once, map$9((complete2) => zipRight$4(complete2, pipe(deferredAwait(deferred), flatMap$7(([patch2, a]) => as$1(zip$3(patchFiberRefs(patch2[0]), updateRuntimeFlags(patch2[1])), a))))))));
  const negate = (self2) => map$9(self2, (b) => !b);
  const once = (self2) => map$9(make$G(true), (ref) => asVoid$1(whenEffect(self2, getAndSet(ref, false))));
  const patchFiberRefs = (patch2) => updateFiberRefs((fiberId2, fiberRefs2) => pipe(patch2, patch$4(fiberId2, fiberRefs2)));
  const promise$1 = (evaluate2) => evaluate2.length >= 1 ? async_((resolve, signal) => {
    try {
      evaluate2(signal).then((a) => resolve(exitSucceed$1(a)), (e) => resolve(exitDie$1(e)));
    } catch (e) {
      resolve(exitDie$1(e));
    }
  }) : async_((resolve) => {
    try {
      ;
      evaluate2().then((a) => resolve(exitSucceed$1(a)), (e) => resolve(exitDie$1(e)));
    } catch (e) {
      resolve(exitDie$1(e));
    }
  });
  const provideService$1 = /* @__PURE__ */ dual(3, (self2, tag2, service) => contextWithEffect((env2) => provideContext$4(self2, add$2(env2, tag2, service))));
  const sleep$1 = sleep$2;
  const succeedNone = /* @__PURE__ */ succeed$a(/* @__PURE__ */ none$4());
  const summarized = /* @__PURE__ */ dual(3, (self2, summary2, f) => flatMap$7(summary2, (start2) => flatMap$7(self2, (value2) => map$9(summary2, (end2) => [f(start2, end2), value2]))));
  const tapErrorCause$1 = /* @__PURE__ */ dual(2, (self2, f) => matchCauseEffect$2(self2, {
    onFailure: (cause) => zipRight$4(f(cause), failCause$8(cause)),
    onSuccess: succeed$a
  }));
  const tracerWith = tracerWith$1;
  const tracer$1 = /* @__PURE__ */ tracerWith(succeed$a);
  const tryPromise$1 = (arg) => {
    let evaluate2;
    let catcher = void 0;
    if (typeof arg === "function") {
      evaluate2 = arg;
    } else {
      evaluate2 = arg.try;
      catcher = arg.catch;
    }
    const fail2 = (e) => catcher ? failSync$1(() => catcher(e)) : fail$b(new UnknownException(e, "An unknown error occurred in Effect.tryPromise"));
    if (evaluate2.length >= 1) {
      return async_((resolve, signal) => {
        try {
          evaluate2(signal).then((a) => resolve(exitSucceed$1(a)), (e) => resolve(fail2(e)));
        } catch (e) {
          resolve(fail2(e));
        }
      });
    }
    return async_((resolve) => {
      try {
        evaluate2().then((a) => resolve(exitSucceed$1(a)), (e) => resolve(fail2(e)));
      } catch (e) {
        resolve(fail2(e));
      }
    });
  };
  const tryMap$1 = /* @__PURE__ */ dual(2, (self2, options2) => flatMap$7(self2, (a) => try_$1({
    try: () => options2.try(a),
    catch: options2.catch
  })));
  const updateFiberRefs = (f) => withFiberRuntime$1((state2) => {
    state2.setFiberRefs(f(state2.id(), state2.getFiberRefs()));
    return void_$4;
  });
  const when$3 = /* @__PURE__ */ dual(2, (self2, condition) => suspend$8(() => condition() ? map$9(self2, some) : succeed$a(none$4())));
  const serviceFunctions$1 = (getService) => new Proxy({}, {
    get(_target, prop, _receiver) {
      return (...args2) => flatMap$7(getService, (s) => s[prop](...args2));
    }
  });
  const serviceOption$1 = (tag2) => map$9(context$3(), getOption(tag2));
  const annotateCurrentSpan$1 = function() {
    const args2 = arguments;
    return ignore$1(flatMap$7(currentSpan$1, (span2) => sync$5(() => {
      if (typeof args2[0] === "string") {
        span2.attribute(args2[0], args2[1]);
      } else {
        for (const key in args2[0]) {
          span2.attribute(key, args2[0][key]);
        }
      }
    })));
  };
  const annotateSpans$1 = /* @__PURE__ */ dual((args2) => isEffect$1(args2[0]), function() {
    const args2 = arguments;
    return fiberRefLocallyWith(args2[0], currentTracerSpanAnnotations, typeof args2[1] === "string" ? set$8(args2[1], args2[2]) : (annotations2) => Object.entries(args2[1]).reduce((acc, [key, value2]) => set$8(acc, key, value2), annotations2));
  });
  const currentSpan$1 = /* @__PURE__ */ flatMap$7(/* @__PURE__ */ context$3(), (context2) => {
    const span2 = context2.unsafeMap.get(spanTag.key);
    return span2 !== void 0 && span2._tag === "Span" ? succeed$a(span2) : fail$b(new NoSuchElementException$1());
  });
  const bigint0$1 = /* @__PURE__ */ BigInt(0);
  const filterDisablePropagation = /* @__PURE__ */ flatMap$a((span2) => get$e(span2.context, DisablePropagation) ? span2._tag === "Span" ? filterDisablePropagation(span2.parent) : none$4() : some(span2));
  const unsafeMakeSpan = (fiber, name, options2) => {
    const disablePropagation = !fiber.getFiberRef(currentTracerEnabled$1) || options2.context && get$e(options2.context, DisablePropagation);
    const context2 = fiber.getFiberRef(currentContext$1);
    const parent = options2.parent ? some(options2.parent) : options2.root ? none$4() : filterDisablePropagation(getOption(context2, spanTag));
    let span2;
    if (disablePropagation) {
      span2 = noopSpan({
        name,
        parent,
        context: add$2(options2.context ?? empty$s(), DisablePropagation, true)
      });
    } else {
      const services = fiber.getFiberRef(currentServices);
      const tracer2 = get$e(services, tracerTag);
      const clock2 = get$e(services, Clock);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled$1);
      const fiberRefs2 = fiber.getFiberRefs();
      const annotationsFromEnv = get$7(fiberRefs2, currentTracerSpanAnnotations);
      const linksFromEnv = get$7(fiberRefs2, currentTracerSpanLinks);
      const links = linksFromEnv._tag === "Some" ? options2.links !== void 0 ? [...toReadonlyArray(linksFromEnv.value), ...options2.links ?? []] : toReadonlyArray(linksFromEnv.value) : options2.links ?? empty$u();
      span2 = tracer2.span(name, parent, options2.context ?? empty$s(), links, timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint0$1, options2.kind ?? "internal");
      if (annotationsFromEnv._tag === "Some") {
        forEach$2(annotationsFromEnv.value, (value2, key) => span2.attribute(key, value2));
      }
      if (options2.attributes !== void 0) {
        Object.entries(options2.attributes).forEach(([k, v]) => span2.attribute(k, v));
      }
    }
    if (typeof options2.captureStackTrace === "function") {
      spanToTrace.set(span2, options2.captureStackTrace);
    }
    return span2;
  };
  const makeSpan$1 = (name, options2) => {
    options2 = addSpanStackTrace(options2);
    return withFiberRuntime$1((fiber) => succeed$a(unsafeMakeSpan(fiber, name, options2)));
  };
  const endSpan = (span2, exit2, clock2, timingEnabled) => sync$5(() => {
    if (span2.status._tag === "Ended") {
      return;
    }
    if (exitIsFailure(exit2) && spanToTrace.has(span2)) {
      span2.attribute("code.stacktrace", spanToTrace.get(span2)());
    }
    span2.end(timingEnabled ? clock2.unsafeCurrentTimeNanos() : bigint0$1, exit2);
  });
  const useSpan$1 = (name, ...args2) => {
    const options2 = addSpanStackTrace(args2.length === 1 ? void 0 : args2[0]);
    const evaluate2 = args2[args2.length - 1];
    return withFiberRuntime$1((fiber) => {
      const span2 = unsafeMakeSpan(fiber, name, options2);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled$1);
      const clock2 = get$e(fiber.getFiberRef(currentServices), clockTag);
      return onExit$2(evaluate2(span2), (exit2) => endSpan(span2, exit2, clock2, timingEnabled));
    });
  };
  const withParentSpan$1 = /* @__PURE__ */ dual(2, (self2, span2) => provideService$1(self2, spanTag, span2));
  const withSpan$4 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options2 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return useSpan$1(name, options2, (span2) => withParentSpan$1(self2, span2));
    }
    return (self2) => useSpan$1(name, options2, (span2) => withParentSpan$1(self2, span2));
  };
  const OP_SEQUENTIAL = "Sequential";
  const OP_PARALLEL = "Parallel";
  const OP_PARALLEL_N = "ParallelN";
  const sequential$2 = {
    _tag: OP_SEQUENTIAL
  };
  const parallel$2 = {
    _tag: OP_PARALLEL
  };
  const parallelN$1 = (parallelism) => ({
    _tag: OP_PARALLEL_N,
    parallelism
  });
  const isSequential = (self2) => self2._tag === OP_SEQUENTIAL;
  const isParallel = (self2) => self2._tag === OP_PARALLEL;
  const sequential$1 = sequential$2;
  const parallel$1 = parallel$2;
  const parallelN = parallelN$1;
  const diff$1 = diff$2;
  const patch$3 = patch$4;
  const FiberStatusSymbolKey = "effect/FiberStatus";
  const FiberStatusTypeId = /* @__PURE__ */ Symbol.for(FiberStatusSymbolKey);
  const OP_DONE$5 = "Done";
  const OP_RUNNING$1 = "Running";
  const OP_SUSPENDED = "Suspended";
  const DoneHash = /* @__PURE__ */ string(`${FiberStatusSymbolKey}-${OP_DONE$5}`);
  let Done$3 = class Done {
    constructor() {
      __publicField(this, _r, FiberStatusTypeId);
      __publicField(this, "_tag", OP_DONE$5);
    }
    [(_r = FiberStatusTypeId, symbol$1)]() {
      return DoneHash;
    }
    [symbol](that) {
      return isFiberStatus(that) && that._tag === OP_DONE$5;
    }
  };
  class Running {
    constructor(runtimeFlags2) {
      __publicField(this, "runtimeFlags");
      __publicField(this, _s, FiberStatusTypeId);
      __publicField(this, "_tag", OP_RUNNING$1);
      this.runtimeFlags = runtimeFlags2;
    }
    [(_s = FiberStatusTypeId, symbol$1)]() {
      return pipe(hash$2(FiberStatusSymbolKey), combine$7(hash$2(this._tag)), combine$7(hash$2(this.runtimeFlags)), cached$1(this));
    }
    [symbol](that) {
      return isFiberStatus(that) && that._tag === OP_RUNNING$1 && this.runtimeFlags === that.runtimeFlags;
    }
  }
  class Suspended {
    constructor(runtimeFlags2, blockingOn) {
      __publicField(this, "runtimeFlags");
      __publicField(this, "blockingOn");
      __publicField(this, _t, FiberStatusTypeId);
      __publicField(this, "_tag", OP_SUSPENDED);
      this.runtimeFlags = runtimeFlags2;
      this.blockingOn = blockingOn;
    }
    [(_t = FiberStatusTypeId, symbol$1)]() {
      return pipe(hash$2(FiberStatusSymbolKey), combine$7(hash$2(this._tag)), combine$7(hash$2(this.runtimeFlags)), combine$7(hash$2(this.blockingOn)), cached$1(this));
    }
    [symbol](that) {
      return isFiberStatus(that) && that._tag === OP_SUSPENDED && this.runtimeFlags === that.runtimeFlags && equals$1(this.blockingOn, that.blockingOn);
    }
  }
  const done$6 = /* @__PURE__ */ new Done$3();
  const running$2 = (runtimeFlags2) => new Running(runtimeFlags2);
  const suspended$1 = (runtimeFlags2, blockingOn) => new Suspended(runtimeFlags2, blockingOn);
  const isFiberStatus = (u) => hasProperty(u, FiberStatusTypeId);
  const isDone$4 = (self2) => self2._tag === OP_DONE$5;
  const done$5 = done$6;
  const running$1 = running$2;
  const suspended = suspended$1;
  const isDone$3 = isDone$4;
  const TypeId$h = /* @__PURE__ */ Symbol.for("effect/Micro");
  const MicroExitTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroExit");
  const MicroCauseTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroCause");
  const microCauseVariance = {
    _E: identity
  };
  class MicroCauseImpl extends globalThis.Error {
    constructor(_tag, originalError, traces) {
      const causeName = `MicroCause.${_tag}`;
      let name;
      let message;
      let stack;
      if (originalError instanceof globalThis.Error) {
        name = `(${causeName}) ${originalError.name}`;
        message = originalError.message;
        const messageLines = message.split("\n").length;
        stack = originalError.stack ? `(${causeName}) ${originalError.stack.split("\n").slice(0, messageLines + 3).join("\n")}` : `${name}: ${message}`;
      } else {
        name = causeName;
        message = toStringUnknown(originalError, 0);
        stack = `${name}: ${message}`;
      }
      if (traces.length > 0) {
        stack += `
    ${traces.join("\n    ")}`;
      }
      super(message);
      __publicField(this, "_tag");
      __publicField(this, "traces");
      __publicField(this, _u);
      this._tag = _tag;
      this.traces = traces;
      this[MicroCauseTypeId] = microCauseVariance;
      this.name = name;
      this.stack = stack;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toString() {
      return this.stack;
    }
    [(_u = MicroCauseTypeId, NodeInspectSymbol)]() {
      return this.stack;
    }
  }
  class Die extends MicroCauseImpl {
    constructor(defect, traces = []) {
      super("Die", defect, traces);
      __publicField(this, "defect");
      this.defect = defect;
    }
  }
  const causeDie = (defect, traces = []) => new Die(defect, traces);
  class Interrupt extends MicroCauseImpl {
    constructor(traces = []) {
      super("Interrupt", "interrupted", traces);
    }
  }
  const causeInterrupt = (traces = []) => new Interrupt(traces);
  const causeIsInterrupt = (self2) => self2._tag === "Interrupt";
  const MicroFiberTypeId = /* @__PURE__ */ Symbol.for("effect/Micro/MicroFiber");
  const fiberVariance$1 = {
    _A: identity,
    _E: identity
  };
  _v = MicroFiberTypeId;
  class MicroFiberImpl {
    constructor(context2, interruptible2 = true) {
      __publicField(this, "context");
      __publicField(this, "interruptible");
      __publicField(this, _v);
      __publicField(this, "_stack", []);
      __publicField(this, "_observers", []);
      __publicField(this, "_exit");
      __publicField(this, "_children");
      __publicField(this, "currentOpCount", 0);
      __publicField(this, "_interrupted", false);
      // cancel the yielded operation, or for the yielded exit value
      __publicField(this, "_yielded");
      this.context = context2;
      this.interruptible = interruptible2;
      this[MicroFiberTypeId] = fiberVariance$1;
    }
    getRef(ref) {
      return unsafeGetReference(this.context, ref);
    }
    addObserver(cb) {
      if (this._exit) {
        cb(this._exit);
        return constVoid;
      }
      this._observers.push(cb);
      return () => {
        const index = this._observers.indexOf(cb);
        if (index >= 0) {
          this._observers.splice(index, 1);
        }
      };
    }
    unsafeInterrupt() {
      if (this._exit) {
        return;
      }
      this._interrupted = true;
      if (this.interruptible) {
        this.evaluate(exitInterrupt);
      }
    }
    unsafePoll() {
      return this._exit;
    }
    evaluate(effect2) {
      if (this._exit) {
        return;
      } else if (this._yielded !== void 0) {
        const yielded = this._yielded;
        this._yielded = void 0;
        yielded();
      }
      const exit2 = this.runLoop(effect2);
      if (exit2 === Yield) {
        return;
      }
      const interruptChildren = fiberMiddleware.interruptChildren && fiberMiddleware.interruptChildren(this);
      if (interruptChildren !== void 0) {
        return this.evaluate(flatMap$6(interruptChildren, () => exit2));
      }
      this._exit = exit2;
      for (let i = 0; i < this._observers.length; i++) {
        this._observers[i](exit2);
      }
      this._observers.length = 0;
    }
    runLoop(effect2) {
      let yielding = false;
      let current = effect2;
      this.currentOpCount = 0;
      try {
        while (true) {
          this.currentOpCount++;
          if (!yielding && this.getRef(CurrentScheduler).shouldYield(this)) {
            yielding = true;
            const prev = current;
            current = flatMap$6(yieldNow$1, () => prev);
          }
          current = current[evaluate$1](this);
          if (current === Yield) {
            const yielded = this._yielded;
            if (MicroExitTypeId in yielded) {
              this._yielded = void 0;
              return yielded;
            }
            return Yield;
          }
        }
      } catch (error) {
        if (!hasProperty(current, evaluate$1)) {
          return exitDie(`MicroFiber.runLoop: Not a valid effect: ${String(current)}`);
        }
        return exitDie(error);
      }
    }
    getCont(symbol2) {
      while (true) {
        const op = this._stack.pop();
        if (!op) return void 0;
        const cont = op[ensureCont] && op[ensureCont](this);
        if (cont) return {
          [symbol2]: cont
        };
        if (op[symbol2]) return op;
      }
    }
    yieldWith(value2) {
      this._yielded = value2;
      return Yield;
    }
    children() {
      return this._children ?? (this._children = /* @__PURE__ */ new Set());
    }
  }
  const fiberMiddleware = /* @__PURE__ */ globalValue("effect/Micro/fiberMiddleware", () => ({
    interruptChildren: void 0
  }));
  const identifier = /* @__PURE__ */ Symbol.for("effect/Micro/identifier");
  const args = /* @__PURE__ */ Symbol.for("effect/Micro/args");
  const evaluate$1 = /* @__PURE__ */ Symbol.for("effect/Micro/evaluate");
  const successCont = /* @__PURE__ */ Symbol.for("effect/Micro/successCont");
  const failureCont = /* @__PURE__ */ Symbol.for("effect/Micro/failureCont");
  const ensureCont = /* @__PURE__ */ Symbol.for("effect/Micro/ensureCont");
  const Yield = /* @__PURE__ */ Symbol.for("effect/Micro/Yield");
  const microVariance = {
    _A: identity,
    _E: identity,
    _R: identity
  };
  const MicroProto = {
    ...EffectPrototype,
    _op: "Micro",
    [TypeId$h]: microVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    [Symbol.iterator]() {
      return new SingleShotGen$1(new YieldWrap(this));
    },
    toJSON() {
      return {
        _id: "Micro",
        op: this[identifier],
        ...args in this ? {
          args: this[args]
        } : void 0
      };
    },
    toString() {
      return format$3(this);
    },
    [NodeInspectSymbol]() {
      return format$3(this);
    }
  };
  function defaultEvaluate(_fiber) {
    return exitDie(`Micro.evaluate: Not implemented`);
  }
  const makePrimitiveProto = (options2) => ({
    ...MicroProto,
    [identifier]: options2.op,
    [evaluate$1]: options2.eval ?? defaultEvaluate,
    [successCont]: options2.contA,
    [failureCont]: options2.contE,
    [ensureCont]: options2.ensure
  });
  const makePrimitive = (options2) => {
    const Proto2 = makePrimitiveProto(options2);
    return function() {
      const self2 = Object.create(Proto2);
      self2[args] = options2.single === false ? arguments : arguments[0];
      return self2;
    };
  };
  const makeExit = (options2) => {
    const Proto2 = {
      ...makePrimitiveProto(options2),
      [MicroExitTypeId]: MicroExitTypeId,
      _tag: options2.op,
      get [options2.prop]() {
        return this[args];
      },
      toJSON() {
        return {
          _id: "MicroExit",
          _tag: options2.op,
          [options2.prop]: this[args]
        };
      },
      [symbol](that) {
        return isMicroExit(that) && that._tag === options2.op && equals$1(this[args], that[args]);
      },
      [symbol$1]() {
        return cached$1(this, combine$7(string(options2.op))(hash$2(this[args])));
      }
    };
    return function(value2) {
      const self2 = Object.create(Proto2);
      self2[args] = value2;
      self2[successCont] = void 0;
      self2[failureCont] = void 0;
      self2[ensureCont] = void 0;
      return self2;
    };
  };
  const succeed$7 = /* @__PURE__ */ makeExit({
    op: "Success",
    prop: "value",
    eval(fiber) {
      const cont = fiber.getCont(successCont);
      return cont ? cont[successCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  const failCause$5 = /* @__PURE__ */ makeExit({
    op: "Failure",
    prop: "cause",
    eval(fiber) {
      let cont = fiber.getCont(failureCont);
      while (causeIsInterrupt(this[args]) && cont && fiber.interruptible) {
        cont = fiber.getCont(failureCont);
      }
      return cont ? cont[failureCont](this[args], fiber) : fiber.yieldWith(this);
    }
  });
  const yieldNowWith = /* @__PURE__ */ makePrimitive({
    op: "Yield",
    eval(fiber) {
      let resumed = false;
      fiber.getRef(CurrentScheduler).scheduleTask(() => {
        if (resumed) return;
        fiber.evaluate(exitVoid);
      }, this[args] ?? 0);
      return fiber.yieldWith(() => {
        resumed = true;
      });
    }
  });
  const yieldNow$1 = /* @__PURE__ */ yieldNowWith(0);
  const void_$2 = /* @__PURE__ */ succeed$7(void 0);
  const withMicroFiber = /* @__PURE__ */ makePrimitive({
    op: "WithMicroFiber",
    eval(fiber) {
      return this[args](fiber);
    }
  });
  const flatMap$6 = /* @__PURE__ */ dual(2, (self2, f) => {
    const onSuccess = Object.create(OnSuccessProto);
    onSuccess[args] = self2;
    onSuccess[successCont] = f;
    return onSuccess;
  });
  const OnSuccessProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccess",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  const isMicroExit = (u) => hasProperty(u, MicroExitTypeId);
  const exitSucceed = succeed$7;
  const exitFailCause = failCause$5;
  const exitInterrupt = /* @__PURE__ */ exitFailCause(/* @__PURE__ */ causeInterrupt());
  const exitDie = (defect) => exitFailCause(causeDie(defect));
  const exitVoid = /* @__PURE__ */ exitSucceed(void 0);
  const setImmediate = "setImmediate" in globalThis ? globalThis.setImmediate : (f) => setTimeout(f, 0);
  class MicroSchedulerDefault {
    constructor() {
      __publicField(this, "tasks", []);
      __publicField(this, "running", false);
      /**
       * @since 3.5.9
       */
      __publicField(this, "afterScheduled", () => {
        this.running = false;
        this.runTasks();
      });
    }
    /**
     * @since 3.5.9
     */
    scheduleTask(task, _priority) {
      this.tasks.push(task);
      if (!this.running) {
        this.running = true;
        setImmediate(this.afterScheduled);
      }
    }
    /**
     * @since 3.5.9
     */
    runTasks() {
      const tasks = this.tasks;
      this.tasks = [];
      for (let i = 0, len = tasks.length; i < len; i++) {
        tasks[i]();
      }
    }
    /**
     * @since 3.5.9
     */
    shouldYield(fiber) {
      return fiber.currentOpCount >= fiber.getRef(MaxOpsBeforeYield);
    }
    /**
     * @since 3.5.9
     */
    flush() {
      while (this.tasks.length > 0) {
        this.runTasks();
      }
    }
  }
  const updateContext$2 = /* @__PURE__ */ dual(2, (self2, f) => withMicroFiber((fiber) => {
    const prev = fiber.context;
    fiber.context = f(prev);
    return onExit$1(self2, () => {
      fiber.context = prev;
      return void_$2;
    });
  }));
  const provideContext$3 = /* @__PURE__ */ dual(2, (self2, provided) => updateContext$2(self2, merge$4(provided)));
  class MaxOpsBeforeYield extends (/* @__PURE__ */ Reference()("effect/Micro/currentMaxOpsBeforeYield", {
    defaultValue: () => 2048
  })) {
  }
  class CurrentScheduler extends (/* @__PURE__ */ Reference()("effect/Micro/currentScheduler", {
    defaultValue: () => new MicroSchedulerDefault()
  })) {
  }
  const matchCauseEffect$1 = /* @__PURE__ */ dual(2, (self2, options2) => {
    const primitive = Object.create(OnSuccessAndFailureProto);
    primitive[args] = self2;
    primitive[successCont] = options2.onSuccess;
    primitive[failureCont] = options2.onFailure;
    return primitive;
  });
  const OnSuccessAndFailureProto = /* @__PURE__ */ makePrimitiveProto({
    op: "OnSuccessAndFailure",
    eval(fiber) {
      fiber._stack.push(this);
      return this[args];
    }
  });
  const onExit$1 = /* @__PURE__ */ dual(2, (self2, f) => uninterruptibleMask$1((restore) => matchCauseEffect$1(restore(self2), {
    onFailure: (cause) => flatMap$6(f(exitFailCause(cause)), () => failCause$5(cause)),
    onSuccess: (a) => flatMap$6(f(exitSucceed(a)), () => succeed$7(a))
  })));
  const setInterruptible = /* @__PURE__ */ makePrimitive({
    op: "SetInterruptible",
    ensure(fiber) {
      fiber.interruptible = this[args];
      if (fiber._interrupted && fiber.interruptible) {
        return () => exitInterrupt;
      }
    }
  });
  const interruptible$1 = (self2) => withMicroFiber((fiber) => {
    if (fiber.interruptible) return self2;
    fiber.interruptible = true;
    fiber._stack.push(setInterruptible(false));
    if (fiber._interrupted) return exitInterrupt;
    return self2;
  });
  const uninterruptibleMask$1 = (f) => withMicroFiber((fiber) => {
    if (!fiber.interruptible) return f(identity);
    fiber.interruptible = false;
    fiber._stack.push(setInterruptible(true));
    return f(interruptible$1);
  });
  const runFork$2 = (effect2, options2) => {
    const fiber = new MicroFiberImpl(CurrentScheduler.context(new MicroSchedulerDefault()));
    fiber.evaluate(effect2);
    return fiber;
  };
  class PriorityBuckets {
    constructor() {
      /**
       * @since 2.0.0
       */
      __publicField(this, "buckets", []);
    }
    /**
     * @since 2.0.0
     */
    scheduleTask(task, priority) {
      const length2 = this.buckets.length;
      let bucket = void 0;
      let index = 0;
      for (; index < length2; index++) {
        if (this.buckets[index][0] <= priority) {
          bucket = this.buckets[index];
        } else {
          break;
        }
      }
      if (bucket && bucket[0] === priority) {
        bucket[1].push(task);
      } else if (index === length2) {
        this.buckets.push([priority, [task]]);
      } else {
        this.buckets.splice(index, 0, [priority, [task]]);
      }
    }
  }
  class MixedScheduler {
    constructor(maxNextTickBeforeTimer) {
      __publicField(this, "maxNextTickBeforeTimer");
      /**
       * @since 2.0.0
       */
      __publicField(this, "running", false);
      /**
       * @since 2.0.0
       */
      __publicField(this, "tasks", /* @__PURE__ */ new PriorityBuckets());
      this.maxNextTickBeforeTimer = maxNextTickBeforeTimer;
    }
    /**
     * @since 2.0.0
     */
    starveInternal(depth) {
      const tasks = this.tasks.buckets;
      this.tasks.buckets = [];
      for (const [_, toRun] of tasks) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
      if (this.tasks.buckets.length === 0) {
        this.running = false;
      } else {
        this.starve(depth);
      }
    }
    /**
     * @since 2.0.0
     */
    starve(depth = 0) {
      if (depth >= this.maxNextTickBeforeTimer) {
        setTimeout(() => this.starveInternal(0), 0);
      } else {
        Promise.resolve(void 0).then(() => this.starveInternal(depth + 1));
      }
    }
    /**
     * @since 2.0.0
     */
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority$1) : false;
    }
    /**
     * @since 2.0.0
     */
    scheduleTask(task, priority) {
      this.tasks.scheduleTask(task, priority);
      if (!this.running) {
        this.running = true;
        this.starve();
      }
    }
  }
  const defaultScheduler = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Scheduler/defaultScheduler"), () => new MixedScheduler(2048));
  class SyncScheduler {
    constructor() {
      /**
       * @since 2.0.0
       */
      __publicField(this, "tasks", /* @__PURE__ */ new PriorityBuckets());
      /**
       * @since 2.0.0
       */
      __publicField(this, "deferred", false);
    }
    /**
     * @since 2.0.0
     */
    scheduleTask(task, priority) {
      if (this.deferred) {
        defaultScheduler.scheduleTask(task, priority);
      } else {
        this.tasks.scheduleTask(task, priority);
      }
    }
    /**
     * @since 2.0.0
     */
    shouldYield(fiber) {
      return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority$1) : false;
    }
    /**
     * @since 2.0.0
     */
    flush() {
      while (this.tasks.buckets.length > 0) {
        const tasks = this.tasks.buckets;
        this.tasks.buckets = [];
        for (const [_, toRun] of tasks) {
          for (let i = 0; i < toRun.length; i++) {
            toRun[i]();
          }
        }
      }
      this.deferred = true;
    }
  }
  const defaultShouldYield = (fiber) => {
    return fiber.currentOpCount > fiber.getFiberRef(currentMaxOpsBeforeYield) ? fiber.getFiberRef(currentSchedulingPriority$1) : false;
  };
  const make$D = (scheduleTask, shouldYield = defaultShouldYield) => ({
    scheduleTask,
    shouldYield
  });
  const makeBatched = (callback, shouldYield = defaultShouldYield) => {
    let running2 = false;
    const tasks = new PriorityBuckets();
    const starveInternal = () => {
      const tasksToRun = tasks.buckets;
      tasks.buckets = [];
      for (const [_, toRun] of tasksToRun) {
        for (let i = 0; i < toRun.length; i++) {
          toRun[i]();
        }
      }
      if (tasks.buckets.length === 0) {
        running2 = false;
      } else {
        starve();
      }
    };
    const starve = () => callback(starveInternal);
    return make$D((task, priority) => {
      tasks.scheduleTask(task, priority);
      if (!running2) {
        running2 = true;
        starve();
      }
    }, shouldYield);
  };
  const currentScheduler$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentScheduler"), () => fiberRefUnsafeMake(defaultScheduler));
  const withScheduler$1 = /* @__PURE__ */ dual(2, (self2, scheduler) => fiberRefLocally(self2, currentScheduler$1, scheduler));
  const currentRequestMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentRequestMap"), () => fiberRefUnsafeMake(/* @__PURE__ */ new Map()));
  const match$4 = (concurrency, sequential2, unbounded2, bounded2) => {
    switch (concurrency) {
      case void 0:
        return sequential2();
      case "unbounded":
        return unbounded2();
      case "inherit":
        return fiberRefGetWith(currentConcurrency, (concurrency2) => concurrency2 === "unbounded" ? unbounded2() : concurrency2 > 1 ? bounded2(concurrency2) : sequential2());
      default:
        return concurrency > 1 ? bounded2(concurrency) : sequential2();
    }
  };
  const OP_INTERRUPT_SIGNAL = "InterruptSignal";
  const OP_STATEFUL = "Stateful";
  const OP_RESUME = "Resume";
  const OP_YIELD_NOW = "YieldNow";
  const interruptSignal = (cause) => ({
    _tag: OP_INTERRUPT_SIGNAL,
    cause
  });
  const stateful = (onFiber) => ({
    _tag: OP_STATEFUL,
    onFiber
  });
  const resume = (effect2) => ({
    _tag: OP_RESUME,
    effect: effect2
  });
  const yieldNow = () => ({
    _tag: OP_YIELD_NOW
  });
  const FiberScopeSymbolKey = "effect/FiberScope";
  const FiberScopeTypeId = /* @__PURE__ */ Symbol.for(FiberScopeSymbolKey);
  _w = FiberScopeTypeId;
  class Global {
    constructor() {
      __publicField(this, _w, FiberScopeTypeId);
      __publicField(this, "fiberId", none$2);
      __publicField(this, "roots", /* @__PURE__ */ new Set());
    }
    add(_runtimeFlags, child) {
      this.roots.add(child);
      child.addObserver(() => {
        this.roots.delete(child);
      });
    }
  }
  _x = FiberScopeTypeId;
  class Local {
    constructor(fiberId2, parent) {
      __publicField(this, "fiberId");
      __publicField(this, "parent");
      __publicField(this, _x, FiberScopeTypeId);
      this.fiberId = fiberId2;
      this.parent = parent;
    }
    add(_runtimeFlags, child) {
      this.parent.tell(stateful((parentFiber) => {
        parentFiber.addChild(child);
        child.addObserver(() => {
          parentFiber.removeChild(child);
        });
      }));
    }
  }
  const unsafeMake$6 = (fiber) => {
    return new Local(fiber.id(), fiber);
  };
  const globalScope = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberScope/Global"), () => new Global());
  const FiberSymbolKey = "effect/Fiber";
  const FiberTypeId = /* @__PURE__ */ Symbol.for(FiberSymbolKey);
  const fiberVariance = {
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _A: (_) => _
  };
  const RuntimeFiberSymbolKey = "effect/Fiber";
  const RuntimeFiberTypeId = /* @__PURE__ */ Symbol.for(RuntimeFiberSymbolKey);
  const _await$1 = (self2) => self2.await;
  const inheritAll$1 = (self2) => self2.inheritAll;
  const interruptAllAs$1 = /* @__PURE__ */ dual(2, (fibers, fiberId2) => pipe(forEachSequentialDiscard(fibers, interruptAsFork(fiberId2)), zipRight$4(pipe(fibers, forEachSequentialDiscard(_await$1)))));
  const interruptAsFork = /* @__PURE__ */ dual(2, (self2, fiberId2) => self2.interruptAsFork(fiberId2));
  const join$1 = (self2) => zipLeft$1(flatten$5(self2.await), self2.inheritAll);
  ({
    ...CommitPrototype
  });
  const currentFiberURI = "effect/FiberCurrent";
  const getCurrentFiber$1 = () => fromNullable(globalThis[currentFiberURI]);
  const LoggerSymbolKey = "effect/Logger";
  const LoggerTypeId = /* @__PURE__ */ Symbol.for(LoggerSymbolKey);
  const loggerVariance = {
    /* c8 ignore next */
    _Message: (_) => _,
    /* c8 ignore next */
    _Output: (_) => _
  };
  const makeLogger = (log2) => ({
    [LoggerTypeId]: loggerVariance,
    log: log2,
    pipe() {
      return pipeArguments(this, arguments);
    }
  });
  const textOnly = /^[^\s"=]*$/;
  const format$1 = (quoteValue, whitespace) => ({
    annotations: annotations2,
    cause,
    date,
    fiberId: fiberId2,
    logLevel,
    message,
    spans
  }) => {
    const formatValue = (value2) => value2.match(textOnly) ? value2 : quoteValue(value2);
    const format2 = (label, value2) => `${formatLabel(label)}=${formatValue(value2)}`;
    const append2 = (label, value2) => " " + format2(label, value2);
    let out = format2("timestamp", date.toISOString());
    out += append2("level", logLevel.label);
    out += append2("fiber", threadName$1(fiberId2));
    const messages = ensure(message);
    for (let i = 0; i < messages.length; i++) {
      out += append2("message", toStringUnknown(messages[i], whitespace));
    }
    if (!isEmptyType(cause)) {
      out += append2("cause", pretty$1(cause, {
        renderErrorCause: true
      }));
    }
    for (const span2 of spans) {
      out += " " + render(date.getTime())(span2);
    }
    for (const [label, value2] of annotations2) {
      out += append2(label, toStringUnknown(value2, whitespace));
    }
    return out;
  };
  const escapeDoubleQuotes = (s) => `"${s.replace(/\\([\s\S])|(")/g, "\\$1$2")}"`;
  const stringLogger = /* @__PURE__ */ makeLogger(/* @__PURE__ */ format$1(escapeDoubleQuotes));
  const structuredMessage = (u) => {
    switch (typeof u) {
      case "bigint":
      case "function":
      case "symbol": {
        return String(u);
      }
      default: {
        return toJSON(u);
      }
    }
  };
  const withColor = (text2, ...colors2) => {
    let out = "";
    for (let i = 0; i < colors2.length; i++) {
      out += `\x1B[${colors2[i]}m`;
    }
    return out + text2 + "\x1B[0m";
  };
  const withColorNoop = (text2, ..._colors) => text2;
  const colors = {
    bold: "1",
    red: "31",
    green: "32",
    yellow: "33",
    blue: "34",
    cyan: "36",
    white: "37",
    gray: "90",
    black: "30",
    bgBrightRed: "101"
  };
  const logLevelColors = {
    None: [],
    All: [],
    Trace: [colors.gray],
    Debug: [colors.blue],
    Info: [colors.green],
    Warning: [colors.yellow],
    Error: [colors.red],
    Fatal: [colors.bgBrightRed, colors.black]
  };
  const logLevelStyle = {
    None: "",
    All: "",
    Trace: "color:gray",
    Debug: "color:blue",
    Info: "color:green",
    Warning: "color:orange",
    Error: "color:red",
    Fatal: "background-color:red;color:white"
  };
  const defaultDateFormat$1 = (date) => `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}.${date.getMilliseconds().toString().padStart(3, "0")}`;
  const hasProcessStdout = typeof process === "object" && process !== null && typeof process.stdout === "object" && process.stdout !== null;
  const processStdoutIsTTY = hasProcessStdout && process.stdout.isTTY === true;
  const hasProcessStdoutOrDeno = hasProcessStdout || "Deno" in globalThis;
  const prettyLogger$1 = (options2) => {
    const mode_ = (options2 == null ? void 0 : options2.mode) ?? "auto";
    const mode = mode_ === "auto" ? hasProcessStdoutOrDeno ? "tty" : "browser" : mode_;
    const isBrowser = mode === "browser";
    const showColors = typeof (options2 == null ? void 0 : options2.colors) === "boolean" ? options2.colors : processStdoutIsTTY || isBrowser;
    const formatDate2 = (options2 == null ? void 0 : options2.formatDate) ?? defaultDateFormat$1;
    return isBrowser ? prettyLoggerBrowser({
      colors: showColors,
      formatDate: formatDate2
    }) : prettyLoggerTty({
      colors: showColors,
      formatDate: formatDate2,
      stderr: (options2 == null ? void 0 : options2.stderr) === true
    });
  };
  const prettyLoggerTty = (options2) => {
    const processIsBun = typeof process === "object" && "isBun" in process && process.isBun === true;
    const color = options2.colors ? withColor : withColorNoop;
    return makeLogger(({
      annotations: annotations2,
      cause,
      context: context2,
      date,
      fiberId: fiberId2,
      logLevel,
      message: message_,
      spans
    }) => {
      const services = getOrDefault(context2, currentServices);
      const console2 = get$e(services, consoleTag).unsafe;
      const log2 = options2.stderr === true ? console2.error : console2.log;
      const message = ensure(message_);
      let firstLine = color(`[${options2.formatDate(date)}]`, colors.white) + ` ${color(logLevel.label, ...logLevelColors[logLevel._tag])} (${threadName$1(fiberId2)})`;
      if (isCons(spans)) {
        const now = date.getTime();
        const render$1 = render(now);
        for (const span2 of spans) {
          firstLine += " " + render$1(span2);
        }
      }
      firstLine += ":";
      let messageIndex = 0;
      if (message.length > 0) {
        const firstMaybeString = structuredMessage(message[0]);
        if (typeof firstMaybeString === "string") {
          firstLine += " " + color(firstMaybeString, colors.bold, colors.cyan);
          messageIndex++;
        }
      }
      log2(firstLine);
      if (!processIsBun) console2.group();
      if (!isEmpty$4(cause)) {
        log2(pretty$1(cause, {
          renderErrorCause: true
        }));
      }
      if (messageIndex < message.length) {
        for (; messageIndex < message.length; messageIndex++) {
          log2(redact$1(message[messageIndex]));
        }
      }
      if (size$5(annotations2) > 0) {
        for (const [key, value2] of annotations2) {
          log2(color(`${key}:`, colors.bold, colors.white), redact$1(value2));
        }
      }
      if (!processIsBun) console2.groupEnd();
    });
  };
  const prettyLoggerBrowser = (options2) => {
    const color = options2.colors ? "%c" : "";
    return makeLogger(({
      annotations: annotations2,
      cause,
      context: context2,
      date,
      fiberId: fiberId2,
      logLevel,
      message: message_,
      spans
    }) => {
      const services = getOrDefault(context2, currentServices);
      const console2 = get$e(services, consoleTag).unsafe;
      const message = ensure(message_);
      let firstLine = `${color}[${options2.formatDate(date)}]`;
      const firstParams = [];
      if (options2.colors) {
        firstParams.push("color:gray");
      }
      firstLine += ` ${color}${logLevel.label}${color} (${threadName$1(fiberId2)})`;
      if (options2.colors) {
        firstParams.push(logLevelStyle[logLevel._tag], "");
      }
      if (isCons(spans)) {
        const now = date.getTime();
        const render$1 = render(now);
        for (const span2 of spans) {
          firstLine += " " + render$1(span2);
        }
      }
      firstLine += ":";
      let messageIndex = 0;
      if (message.length > 0) {
        const firstMaybeString = structuredMessage(message[0]);
        if (typeof firstMaybeString === "string") {
          firstLine += ` ${color}${firstMaybeString}`;
          if (options2.colors) {
            firstParams.push("color:deepskyblue");
          }
          messageIndex++;
        }
      }
      console2.groupCollapsed(firstLine, ...firstParams);
      if (!isEmpty$4(cause)) {
        console2.error(pretty$1(cause, {
          renderErrorCause: true
        }));
      }
      if (messageIndex < message.length) {
        for (; messageIndex < message.length; messageIndex++) {
          console2.log(redact$1(message[messageIndex]));
        }
      }
      if (size$5(annotations2) > 0) {
        for (const [key, value2] of annotations2) {
          const redacted = redact$1(value2);
          if (options2.colors) {
            console2.log(`%c${key}:`, "color:gray", redacted);
          } else {
            console2.log(`${key}:`, redacted);
          }
        }
      }
      console2.groupEnd();
    });
  };
  const MetricBoundariesSymbolKey = "effect/MetricBoundaries";
  const MetricBoundariesTypeId = /* @__PURE__ */ Symbol.for(MetricBoundariesSymbolKey);
  class MetricBoundariesImpl {
    constructor(values) {
      __publicField(this, "values");
      __publicField(this, _y, MetricBoundariesTypeId);
      __publicField(this, "_hash");
      this.values = values;
      this._hash = pipe(string(MetricBoundariesSymbolKey), combine$7(array(this.values)));
    }
    [(_y = MetricBoundariesTypeId, symbol$1)]() {
      return this._hash;
    }
    [symbol](u) {
      return isMetricBoundaries(u) && equals$1(this.values, u.values);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const isMetricBoundaries = (u) => hasProperty(u, MetricBoundariesTypeId);
  const fromIterable$2 = (iterable) => {
    const values = pipe(iterable, appendAll$2(of$2(Number.POSITIVE_INFINITY)), dedupe);
    return new MetricBoundariesImpl(values);
  };
  const exponential$2 = (options2) => pipe(makeBy(options2.count - 1, (i) => options2.start * Math.pow(options2.factor, i)), unsafeFromArray, fromIterable$2);
  const MetricKeyTypeSymbolKey = "effect/MetricKeyType";
  const MetricKeyTypeTypeId = /* @__PURE__ */ Symbol.for(MetricKeyTypeSymbolKey);
  const CounterKeyTypeSymbolKey = "effect/MetricKeyType/Counter";
  const CounterKeyTypeTypeId = /* @__PURE__ */ Symbol.for(CounterKeyTypeSymbolKey);
  const FrequencyKeyTypeSymbolKey = "effect/MetricKeyType/Frequency";
  const FrequencyKeyTypeTypeId = /* @__PURE__ */ Symbol.for(FrequencyKeyTypeSymbolKey);
  const GaugeKeyTypeSymbolKey = "effect/MetricKeyType/Gauge";
  const GaugeKeyTypeTypeId = /* @__PURE__ */ Symbol.for(GaugeKeyTypeSymbolKey);
  const HistogramKeyTypeSymbolKey = "effect/MetricKeyType/Histogram";
  const HistogramKeyTypeTypeId = /* @__PURE__ */ Symbol.for(HistogramKeyTypeSymbolKey);
  const SummaryKeyTypeSymbolKey = "effect/MetricKeyType/Summary";
  const SummaryKeyTypeTypeId = /* @__PURE__ */ Symbol.for(SummaryKeyTypeSymbolKey);
  const metricKeyTypeVariance = {
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _Out: (_) => _
  };
  class CounterKeyType {
    constructor(incremental, bigint) {
      __publicField(this, "incremental");
      __publicField(this, "bigint");
      __publicField(this, _A, metricKeyTypeVariance);
      __publicField(this, _z, CounterKeyTypeTypeId);
      __publicField(this, "_hash");
      this.incremental = incremental;
      this.bigint = bigint;
      this._hash = string(CounterKeyTypeSymbolKey);
    }
    [(_A = MetricKeyTypeTypeId, _z = CounterKeyTypeTypeId, symbol$1)]() {
      return this._hash;
    }
    [symbol](that) {
      return isCounterKey(that);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  class HistogramKeyType {
    constructor(boundaries) {
      __publicField(this, "boundaries");
      __publicField(this, _C, metricKeyTypeVariance);
      __publicField(this, _B, HistogramKeyTypeTypeId);
      __publicField(this, "_hash");
      this.boundaries = boundaries;
      this._hash = pipe(string(HistogramKeyTypeSymbolKey), combine$7(hash$2(this.boundaries)));
    }
    [(_C = MetricKeyTypeTypeId, _B = HistogramKeyTypeTypeId, symbol$1)]() {
      return this._hash;
    }
    [symbol](that) {
      return isHistogramKey(that) && equals$1(this.boundaries, that.boundaries);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const counter$4 = (options2) => new CounterKeyType((options2 == null ? void 0 : options2.incremental) ?? false, (options2 == null ? void 0 : options2.bigint) ?? false);
  const histogram$4 = (boundaries) => {
    return new HistogramKeyType(boundaries);
  };
  const isCounterKey = (u) => hasProperty(u, CounterKeyTypeTypeId);
  const isFrequencyKey = (u) => hasProperty(u, FrequencyKeyTypeTypeId);
  const isGaugeKey = (u) => hasProperty(u, GaugeKeyTypeTypeId);
  const isHistogramKey = (u) => hasProperty(u, HistogramKeyTypeTypeId);
  const isSummaryKey = (u) => hasProperty(u, SummaryKeyTypeTypeId);
  const MetricKeySymbolKey = "effect/MetricKey";
  const MetricKeyTypeId = /* @__PURE__ */ Symbol.for(MetricKeySymbolKey);
  const metricKeyVariance = {
    /* c8 ignore next */
    _Type: (_) => _
  };
  const arrayEquivilence = /* @__PURE__ */ getEquivalence$2(equals$1);
  class MetricKeyImpl {
    constructor(name, keyType, description, tags = []) {
      __publicField(this, "name");
      __publicField(this, "keyType");
      __publicField(this, "description");
      __publicField(this, "tags");
      __publicField(this, _D, metricKeyVariance);
      __publicField(this, "_hash");
      this.name = name;
      this.keyType = keyType;
      this.description = description;
      this.tags = tags;
      this._hash = pipe(string(this.name + this.description), combine$7(hash$2(this.keyType)), combine$7(array(this.tags)));
    }
    [(_D = MetricKeyTypeId, symbol$1)]() {
      return this._hash;
    }
    [symbol](u) {
      return isMetricKey(u) && this.name === u.name && equals$1(this.keyType, u.keyType) && equals$1(this.description, u.description) && arrayEquivilence(this.tags, u.tags);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const isMetricKey = (u) => hasProperty(u, MetricKeyTypeId);
  const counter$3 = (name, options2) => new MetricKeyImpl(name, counter$4(options2), fromNullable(options2 == null ? void 0 : options2.description));
  const histogram$3 = (name, boundaries, description) => new MetricKeyImpl(name, histogram$4(boundaries), fromNullable(description));
  const taggedWithLabels$1 = /* @__PURE__ */ dual(2, (self2, extraTags) => extraTags.length === 0 ? self2 : new MetricKeyImpl(self2.name, self2.keyType, self2.description, union$2(self2.tags, extraTags)));
  const MetricStateSymbolKey = "effect/MetricState";
  const MetricStateTypeId = /* @__PURE__ */ Symbol.for(MetricStateSymbolKey);
  const CounterStateSymbolKey = "effect/MetricState/Counter";
  const CounterStateTypeId = /* @__PURE__ */ Symbol.for(CounterStateSymbolKey);
  const FrequencyStateSymbolKey = "effect/MetricState/Frequency";
  const FrequencyStateTypeId = /* @__PURE__ */ Symbol.for(FrequencyStateSymbolKey);
  const GaugeStateSymbolKey = "effect/MetricState/Gauge";
  const GaugeStateTypeId = /* @__PURE__ */ Symbol.for(GaugeStateSymbolKey);
  const HistogramStateSymbolKey = "effect/MetricState/Histogram";
  const HistogramStateTypeId = /* @__PURE__ */ Symbol.for(HistogramStateSymbolKey);
  const SummaryStateSymbolKey = "effect/MetricState/Summary";
  const SummaryStateTypeId = /* @__PURE__ */ Symbol.for(SummaryStateSymbolKey);
  const metricStateVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  class CounterState {
    constructor(count) {
      __publicField(this, "count");
      __publicField(this, _F, metricStateVariance);
      __publicField(this, _E, CounterStateTypeId);
      this.count = count;
    }
    [(_F = MetricStateTypeId, _E = CounterStateTypeId, symbol$1)]() {
      return pipe(hash$2(CounterStateSymbolKey), combine$7(hash$2(this.count)), cached$1(this));
    }
    [symbol](that) {
      return isCounterState(that) && this.count === that.count;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const arrayEquals = /* @__PURE__ */ getEquivalence$2(equals$1);
  class FrequencyState {
    constructor(occurrences) {
      __publicField(this, "occurrences");
      __publicField(this, _H, metricStateVariance);
      __publicField(this, _G, FrequencyStateTypeId);
      __publicField(this, "_hash");
      this.occurrences = occurrences;
    }
    [(_H = MetricStateTypeId, _G = FrequencyStateTypeId, symbol$1)]() {
      return pipe(string(FrequencyStateSymbolKey), combine$7(array(fromIterable$8(this.occurrences.entries()))), cached$1(this));
    }
    [symbol](that) {
      return isFrequencyState(that) && arrayEquals(fromIterable$8(this.occurrences.entries()), fromIterable$8(that.occurrences.entries()));
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  class GaugeState {
    constructor(value2) {
      __publicField(this, "value");
      __publicField(this, _J, metricStateVariance);
      __publicField(this, _I, GaugeStateTypeId);
      this.value = value2;
    }
    [(_J = MetricStateTypeId, _I = GaugeStateTypeId, symbol$1)]() {
      return pipe(hash$2(GaugeStateSymbolKey), combine$7(hash$2(this.value)), cached$1(this));
    }
    [symbol](u) {
      return isGaugeState(u) && this.value === u.value;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  class HistogramState {
    constructor(buckets, count, min2, max2, sum2) {
      __publicField(this, "buckets");
      __publicField(this, "count");
      __publicField(this, "min");
      __publicField(this, "max");
      __publicField(this, "sum");
      __publicField(this, _L, metricStateVariance);
      __publicField(this, _K, HistogramStateTypeId);
      this.buckets = buckets;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [(_L = MetricStateTypeId, _K = HistogramStateTypeId, symbol$1)]() {
      return pipe(hash$2(HistogramStateSymbolKey), combine$7(hash$2(this.buckets)), combine$7(hash$2(this.count)), combine$7(hash$2(this.min)), combine$7(hash$2(this.max)), combine$7(hash$2(this.sum)), cached$1(this));
    }
    [symbol](that) {
      return isHistogramState(that) && equals$1(this.buckets, that.buckets) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  class SummaryState {
    constructor(error, quantiles, count, min2, max2, sum2) {
      __publicField(this, "error");
      __publicField(this, "quantiles");
      __publicField(this, "count");
      __publicField(this, "min");
      __publicField(this, "max");
      __publicField(this, "sum");
      __publicField(this, _N, metricStateVariance);
      __publicField(this, _M, SummaryStateTypeId);
      this.error = error;
      this.quantiles = quantiles;
      this.count = count;
      this.min = min2;
      this.max = max2;
      this.sum = sum2;
    }
    [(_N = MetricStateTypeId, _M = SummaryStateTypeId, symbol$1)]() {
      return pipe(hash$2(SummaryStateSymbolKey), combine$7(hash$2(this.error)), combine$7(hash$2(this.quantiles)), combine$7(hash$2(this.count)), combine$7(hash$2(this.min)), combine$7(hash$2(this.max)), combine$7(hash$2(this.sum)), cached$1(this));
    }
    [symbol](that) {
      return isSummaryState(that) && this.error === that.error && equals$1(this.quantiles, that.quantiles) && this.count === that.count && this.min === that.min && this.max === that.max && this.sum === that.sum;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const counter$2 = (count) => new CounterState(count);
  const frequency$1 = (occurrences) => {
    return new FrequencyState(occurrences);
  };
  const gauge$1 = (count) => new GaugeState(count);
  const histogram$2 = (options2) => new HistogramState(options2.buckets, options2.count, options2.min, options2.max, options2.sum);
  const summary$1 = (options2) => new SummaryState(options2.error, options2.quantiles, options2.count, options2.min, options2.max, options2.sum);
  const isCounterState = (u) => hasProperty(u, CounterStateTypeId);
  const isFrequencyState = (u) => hasProperty(u, FrequencyStateTypeId);
  const isGaugeState = (u) => hasProperty(u, GaugeStateTypeId);
  const isHistogramState = (u) => hasProperty(u, HistogramStateTypeId);
  const isSummaryState = (u) => hasProperty(u, SummaryStateTypeId);
  const MetricHookSymbolKey = "effect/MetricHook";
  const MetricHookTypeId = /* @__PURE__ */ Symbol.for(MetricHookSymbolKey);
  const metricHookVariance = {
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _Out: (_) => _
  };
  const make$C = (options2) => ({
    [MetricHookTypeId]: metricHookVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...options2
  });
  const bigint0 = /* @__PURE__ */ BigInt(0);
  const counter$1 = (key) => {
    let sum2 = key.keyType.bigint ? bigint0 : 0;
    const canUpdate = key.keyType.incremental ? key.keyType.bigint ? (value2) => value2 >= bigint0 : (value2) => value2 >= 0 : (_value2) => true;
    const update2 = (value2) => {
      if (canUpdate(value2)) {
        sum2 = sum2 + value2;
      }
    };
    return make$C({
      get: () => counter$2(sum2),
      update: update2,
      modify: update2
    });
  };
  const frequency = (key) => {
    const values = /* @__PURE__ */ new Map();
    for (const word of key.keyType.preregisteredWords) {
      values.set(word, 0);
    }
    const update2 = (word) => {
      const slotCount = values.get(word) ?? 0;
      values.set(word, slotCount + 1);
    };
    return make$C({
      get: () => frequency$1(values),
      update: update2,
      modify: update2
    });
  };
  const gauge = (_key, startAt) => {
    let value2 = startAt;
    return make$C({
      get: () => gauge$1(value2),
      update: (v) => {
        value2 = v;
      },
      modify: (v) => {
        value2 = value2 + v;
      }
    });
  };
  const histogram$1 = (key) => {
    const bounds = key.keyType.boundaries.values;
    const size2 = bounds.length;
    const values = new Uint32Array(size2 + 1);
    const boundaries = new Float32Array(size2);
    let count = 0;
    let sum2 = 0;
    let min2 = Number.MAX_VALUE;
    let max2 = Number.MIN_VALUE;
    pipe(bounds, sort(Order$1), map$e((n, i) => {
      boundaries[i] = n;
    }));
    const update2 = (value2) => {
      let from = 0;
      let to = size2;
      while (from !== to) {
        const mid = Math.floor(from + (to - from) / 2);
        const boundary = boundaries[mid];
        if (value2 <= boundary) {
          to = mid;
        } else {
          from = mid;
        }
        if (to === from + 1) {
          if (value2 <= boundaries[from]) {
            to = from;
          } else {
            from = to;
          }
        }
      }
      values[from] = values[from] + 1;
      count = count + 1;
      sum2 = sum2 + value2;
      if (value2 < min2) {
        min2 = value2;
      }
      if (value2 > max2) {
        max2 = value2;
      }
    };
    const getBuckets = () => {
      const builder = allocate(size2);
      let cumulated = 0;
      for (let i = 0; i < size2; i++) {
        const boundary = boundaries[i];
        const value2 = values[i];
        cumulated = cumulated + value2;
        builder[i] = [boundary, cumulated];
      }
      return builder;
    };
    return make$C({
      get: () => histogram$2({
        buckets: getBuckets(),
        count,
        min: min2,
        max: max2,
        sum: sum2
      }),
      update: update2,
      modify: update2
    });
  };
  const summary = (key) => {
    const {
      error,
      maxAge,
      maxSize,
      quantiles
    } = key.keyType;
    const sortedQuantiles = pipe(quantiles, sort(Order$1));
    const values = allocate(maxSize);
    let head2 = 0;
    let count = 0;
    let sum2 = 0;
    let min2 = Number.MAX_VALUE;
    let max2 = Number.MIN_VALUE;
    const snapshot = (now) => {
      const builder = [];
      let i = 0;
      while (i !== maxSize - 1) {
        const item = values[i];
        if (item != null) {
          const [t, v] = item;
          const age = millis(now - t);
          if (greaterThanOrEqualTo$1(age, zero) && lessThanOrEqualTo(age, maxAge)) {
            builder.push(v);
          }
        }
        i = i + 1;
      }
      return calculateQuantiles(error, sortedQuantiles, sort(builder, Order$1));
    };
    const observe = (value2, timestamp) => {
      if (maxSize > 0) {
        head2 = head2 + 1;
        const target = head2 % maxSize;
        values[target] = [timestamp, value2];
      }
      count = count + 1;
      sum2 = sum2 + value2;
      if (value2 < min2) {
        min2 = value2;
      }
      if (value2 > max2) {
        max2 = value2;
      }
    };
    return make$C({
      get: () => summary$1({
        error,
        quantiles: snapshot(Date.now()),
        count,
        min: min2,
        max: max2,
        sum: sum2
      }),
      update: ([value2, timestamp]) => observe(value2, timestamp),
      modify: ([value2, timestamp]) => observe(value2, timestamp)
    });
  };
  const calculateQuantiles = (error, sortedQuantiles, sortedSamples) => {
    const sampleCount = sortedSamples.length;
    if (!isNonEmptyReadonlyArray(sortedQuantiles)) {
      return empty$u();
    }
    const head2 = sortedQuantiles[0];
    const tail = sortedQuantiles.slice(1);
    const resolvedHead = resolveQuantile(error, sampleCount, none$4(), 0, head2, sortedSamples);
    const resolved = of$3(resolvedHead);
    tail.forEach((quantile) => {
      resolved.push(resolveQuantile(error, sampleCount, resolvedHead.value, resolvedHead.consumed, quantile, resolvedHead.rest));
    });
    return map$e(resolved, (rq) => [rq.quantile, rq.value]);
  };
  const resolveQuantile = (error, sampleCount, current, consumed, quantile, rest) => {
    let error_1 = error;
    let sampleCount_1 = sampleCount;
    let current_1 = current;
    let consumed_1 = consumed;
    let quantile_1 = quantile;
    let rest_1 = rest;
    let error_2 = error;
    let sampleCount_2 = sampleCount;
    let current_2 = current;
    let consumed_2 = consumed;
    let quantile_2 = quantile;
    let rest_2 = rest;
    while (1) {
      if (!isNonEmptyReadonlyArray(rest_1)) {
        return {
          quantile: quantile_1,
          value: none$4(),
          consumed: consumed_1,
          rest: []
        };
      }
      if (quantile_1 === 1) {
        return {
          quantile: quantile_1,
          value: some(lastNonEmpty(rest_1)),
          consumed: consumed_1 + rest_1.length,
          rest: []
        };
      }
      const headValue = headNonEmpty$1(rest_1);
      const sameHead = span(rest_1, (n) => n === headValue);
      const desired = quantile_1 * sampleCount_1;
      const allowedError = error_1 / 2 * desired;
      const candConsumed = consumed_1 + sameHead[0].length;
      const candError = Math.abs(candConsumed - desired);
      if (candConsumed < desired - allowedError) {
        error_2 = error_1;
        sampleCount_2 = sampleCount_1;
        current_2 = head$4(rest_1);
        consumed_2 = candConsumed;
        quantile_2 = quantile_1;
        rest_2 = sameHead[1];
        error_1 = error_2;
        sampleCount_1 = sampleCount_2;
        current_1 = current_2;
        consumed_1 = consumed_2;
        quantile_1 = quantile_2;
        rest_1 = rest_2;
        continue;
      }
      if (candConsumed > desired + allowedError) {
        const valueToReturn = isNone(current_1) ? some(headValue) : current_1;
        return {
          quantile: quantile_1,
          value: valueToReturn,
          consumed: consumed_1,
          rest: rest_1
        };
      }
      switch (current_1._tag) {
        case "None": {
          error_2 = error_1;
          sampleCount_2 = sampleCount_1;
          current_2 = head$4(rest_1);
          consumed_2 = candConsumed;
          quantile_2 = quantile_1;
          rest_2 = sameHead[1];
          error_1 = error_2;
          sampleCount_1 = sampleCount_2;
          current_1 = current_2;
          consumed_1 = consumed_2;
          quantile_1 = quantile_2;
          rest_1 = rest_2;
          continue;
        }
        case "Some": {
          const prevError = Math.abs(desired - current_1.value);
          if (candError < prevError) {
            error_2 = error_1;
            sampleCount_2 = sampleCount_1;
            current_2 = head$4(rest_1);
            consumed_2 = candConsumed;
            quantile_2 = quantile_1;
            rest_2 = sameHead[1];
            error_1 = error_2;
            sampleCount_1 = sampleCount_2;
            current_1 = current_2;
            consumed_1 = consumed_2;
            quantile_1 = quantile_2;
            rest_1 = rest_2;
            continue;
          }
          return {
            quantile: quantile_1,
            value: some(current_1.value),
            consumed: consumed_1,
            rest: rest_1
          };
        }
      }
    }
    throw new Error("BUG: MetricHook.resolveQuantiles - please report an issue at https://github.com/Effect-TS/effect/issues");
  };
  const MetricPairSymbolKey = "effect/MetricPair";
  const MetricPairTypeId = /* @__PURE__ */ Symbol.for(MetricPairSymbolKey);
  const metricPairVariance = {
    /* c8 ignore next */
    _Type: (_) => _
  };
  const unsafeMake$5 = (metricKey, metricState) => {
    return {
      [MetricPairTypeId]: metricPairVariance,
      metricKey,
      metricState,
      pipe() {
        return pipeArguments(this, arguments);
      }
    };
  };
  const MetricRegistrySymbolKey = "effect/MetricRegistry";
  const MetricRegistryTypeId = /* @__PURE__ */ Symbol.for(MetricRegistrySymbolKey);
  _O = MetricRegistryTypeId;
  class MetricRegistryImpl {
    constructor() {
      __publicField(this, _O, MetricRegistryTypeId);
      __publicField(this, "map", /* @__PURE__ */ empty$g());
    }
    snapshot() {
      const result = [];
      for (const [key, hook] of this.map) {
        result.push(unsafeMake$5(key, hook.get()));
      }
      return result;
    }
    get(key) {
      const hook = pipe(this.map, get$9(key), getOrUndefined);
      if (hook == null) {
        if (isCounterKey(key.keyType)) {
          return this.getCounter(key);
        }
        if (isGaugeKey(key.keyType)) {
          return this.getGauge(key);
        }
        if (isFrequencyKey(key.keyType)) {
          return this.getFrequency(key);
        }
        if (isHistogramKey(key.keyType)) {
          return this.getHistogram(key);
        }
        if (isSummaryKey(key.keyType)) {
          return this.getSummary(key);
        }
        throw new Error("BUG: MetricRegistry.get - unknown MetricKeyType - please report an issue at https://github.com/Effect-TS/effect/issues");
      } else {
        return hook;
      }
    }
    getCounter(key) {
      let value2 = pipe(this.map, get$9(key), getOrUndefined);
      if (value2 == null) {
        const counter2 = counter$1(key);
        if (!pipe(this.map, has(key))) {
          pipe(this.map, set$7(key, counter2));
        }
        value2 = counter2;
      }
      return value2;
    }
    getFrequency(key) {
      let value2 = pipe(this.map, get$9(key), getOrUndefined);
      if (value2 == null) {
        const frequency$12 = frequency(key);
        if (!pipe(this.map, has(key))) {
          pipe(this.map, set$7(key, frequency$12));
        }
        value2 = frequency$12;
      }
      return value2;
    }
    getGauge(key) {
      let value2 = pipe(this.map, get$9(key), getOrUndefined);
      if (value2 == null) {
        const gauge$12 = gauge(key, key.keyType.bigint ? BigInt(0) : 0);
        if (!pipe(this.map, has(key))) {
          pipe(this.map, set$7(key, gauge$12));
        }
        value2 = gauge$12;
      }
      return value2;
    }
    getHistogram(key) {
      let value2 = pipe(this.map, get$9(key), getOrUndefined);
      if (value2 == null) {
        const histogram2 = histogram$1(key);
        if (!pipe(this.map, has(key))) {
          pipe(this.map, set$7(key, histogram2));
        }
        value2 = histogram2;
      }
      return value2;
    }
    getSummary(key) {
      let value2 = pipe(this.map, get$9(key), getOrUndefined);
      if (value2 == null) {
        const summary$12 = summary(key);
        if (!pipe(this.map, has(key))) {
          pipe(this.map, set$7(key, summary$12));
        }
        value2 = summary$12;
      }
      return value2;
    }
  }
  const make$B = () => {
    return new MetricRegistryImpl();
  };
  const MetricSymbolKey = "effect/Metric";
  const MetricTypeId = /* @__PURE__ */ Symbol.for(MetricSymbolKey);
  const metricVariance = {
    /* c8 ignore next */
    _Type: (_) => _,
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _Out: (_) => _
  };
  const globalMetricRegistry = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Metric/globalMetricRegistry"), () => make$B());
  const make$A = function(keyType, unsafeUpdate, unsafeValue, unsafeModify) {
    const metric = Object.assign((effect2) => tap$3(effect2, (a) => update$2(metric, a)), {
      [MetricTypeId]: metricVariance,
      keyType,
      unsafeUpdate,
      unsafeValue,
      unsafeModify,
      register() {
        this.unsafeValue([]);
        return this;
      },
      pipe() {
        return pipeArguments(this, arguments);
      }
    });
    return metric;
  };
  const counter = (name, options2) => fromMetricKey(counter$3(name, options2));
  const fromMetricKey = (key) => {
    let untaggedHook;
    const hookCache = /* @__PURE__ */ new WeakMap();
    const hook = (extraTags) => {
      if (extraTags.length === 0) {
        if (untaggedHook !== void 0) {
          return untaggedHook;
        }
        untaggedHook = globalMetricRegistry.get(key);
        return untaggedHook;
      }
      let hook2 = hookCache.get(extraTags);
      if (hook2 !== void 0) {
        return hook2;
      }
      hook2 = globalMetricRegistry.get(taggedWithLabels$1(key, extraTags));
      hookCache.set(extraTags, hook2);
      return hook2;
    };
    return make$A(key.keyType, (input, extraTags) => hook(extraTags).update(input), (extraTags) => hook(extraTags).get(), (input, extraTags) => hook(extraTags).modify(input));
  };
  const histogram = (name, boundaries, description) => fromMetricKey(histogram$3(name, boundaries, description));
  const tagged = /* @__PURE__ */ dual(3, (self2, key, value2) => taggedWithLabels(self2, [make$E(key, value2)]));
  const taggedWithLabels = /* @__PURE__ */ dual(2, (self2, extraTags) => {
    return make$A(self2.keyType, (input, extraTags1) => self2.unsafeUpdate(input, union$2(extraTags, extraTags1)), (extraTags1) => self2.unsafeValue(union$2(extraTags, extraTags1)), (input, extraTags1) => self2.unsafeModify(input, union$2(extraTags, extraTags1)));
  });
  const update$2 = /* @__PURE__ */ dual(2, (self2, input) => fiberRefGetWith(currentMetricLabels, (tags) => sync$5(() => self2.unsafeUpdate(input, tags))));
  const RequestSymbolKey = "effect/Request";
  const RequestTypeId = /* @__PURE__ */ Symbol.for(RequestSymbolKey);
  const requestVariance = {
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _A: (_) => _
  };
  const RequestPrototype = {
    ...StructuralPrototype,
    [RequestTypeId]: requestVariance
  };
  const Class$3 = /* @__PURE__ */ function() {
    function Class2(args2) {
      if (args2) {
        Object.assign(this, args2);
      }
    }
    Class2.prototype = RequestPrototype;
    return Class2;
  }();
  const complete = /* @__PURE__ */ dual(2, (self2, result) => fiberRefGetWith(currentRequestMap, (map2) => sync$5(() => {
    if (map2.has(self2)) {
      const entry = map2.get(self2);
      if (!entry.state.completed) {
        entry.state.completed = true;
        deferredUnsafeDone(entry.result, result);
      }
    }
  })));
  const SupervisorSymbolKey = "effect/Supervisor";
  const SupervisorTypeId = /* @__PURE__ */ Symbol.for(SupervisorSymbolKey);
  const supervisorVariance = {
    /* c8 ignore next */
    _T: (_) => _
  };
  _P = SupervisorTypeId;
  const _ProxySupervisor = class _ProxySupervisor {
    constructor(underlying, value0) {
      __publicField(this, "underlying");
      __publicField(this, "value0");
      __publicField(this, _P, supervisorVariance);
      this.underlying = underlying;
      this.value0 = value0;
    }
    get value() {
      return this.value0;
    }
    onStart(context2, effect2, parent, fiber) {
      this.underlying.onStart(context2, effect2, parent, fiber);
    }
    onEnd(value2, fiber) {
      this.underlying.onEnd(value2, fiber);
    }
    onEffect(fiber, effect2) {
      this.underlying.onEffect(fiber, effect2);
    }
    onSuspend(fiber) {
      this.underlying.onSuspend(fiber);
    }
    onResume(fiber) {
      this.underlying.onResume(fiber);
    }
    map(f) {
      return new _ProxySupervisor(this, pipe(this.value, map$9(f)));
    }
    zip(right2) {
      return new Zip(this, right2);
    }
  };
  let ProxySupervisor = _ProxySupervisor;
  _Q = SupervisorTypeId;
  const _Zip = class _Zip {
    constructor(left2, right2) {
      __publicField(this, "left");
      __publicField(this, "right");
      __publicField(this, "_tag", "Zip");
      __publicField(this, _Q, supervisorVariance);
      this.left = left2;
      this.right = right2;
    }
    get value() {
      return zip$3(this.left.value, this.right.value);
    }
    onStart(context2, effect2, parent, fiber) {
      this.left.onStart(context2, effect2, parent, fiber);
      this.right.onStart(context2, effect2, parent, fiber);
    }
    onEnd(value2, fiber) {
      this.left.onEnd(value2, fiber);
      this.right.onEnd(value2, fiber);
    }
    onEffect(fiber, effect2) {
      this.left.onEffect(fiber, effect2);
      this.right.onEffect(fiber, effect2);
    }
    onSuspend(fiber) {
      this.left.onSuspend(fiber);
      this.right.onSuspend(fiber);
    }
    onResume(fiber) {
      this.left.onResume(fiber);
      this.right.onResume(fiber);
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map$9(f)));
    }
    zip(right2) {
      return new _Zip(this, right2);
    }
  };
  let Zip = _Zip;
  const isZip = (self2) => hasProperty(self2, SupervisorTypeId) && isTagged(self2, "Zip");
  _R = SupervisorTypeId;
  class Const {
    constructor(effect2) {
      __publicField(this, "effect");
      __publicField(this, _R, supervisorVariance);
      this.effect = effect2;
    }
    get value() {
      return this.effect;
    }
    onStart(_context, _effect, _parent, _fiber) {
    }
    onEnd(_value2, _fiber) {
    }
    onEffect(_fiber, _effect) {
    }
    onSuspend(_fiber) {
    }
    onResume(_fiber) {
    }
    map(f) {
      return new ProxySupervisor(this, pipe(this.value, map$9(f)));
    }
    zip(right2) {
      return new Zip(this, right2);
    }
    onRun(execution, _fiber) {
      return execution();
    }
  }
  const fromEffect$5 = (effect2) => {
    return new Const(effect2);
  };
  const none = /* @__PURE__ */ globalValue("effect/Supervisor/none", () => fromEffect$5(void_$4));
  const make$z = make$Q;
  const OP_EMPTY = "Empty";
  const OP_ADD_SUPERVISOR = "AddSupervisor";
  const OP_REMOVE_SUPERVISOR = "RemoveSupervisor";
  const OP_AND_THEN = "AndThen";
  const empty$a = {
    _tag: OP_EMPTY
  };
  const combine = (self2, that) => {
    return {
      _tag: OP_AND_THEN,
      first: self2,
      second: that
    };
  };
  const patch$2 = (self2, supervisor) => {
    return patchLoop(supervisor, of$2(self2));
  };
  const patchLoop = (_supervisor, _patches) => {
    let supervisor = _supervisor;
    let patches = _patches;
    while (isNonEmpty$2(patches)) {
      const head2 = headNonEmpty(patches);
      switch (head2._tag) {
        case OP_EMPTY: {
          patches = tailNonEmpty(patches);
          break;
        }
        case OP_ADD_SUPERVISOR: {
          supervisor = supervisor.zip(head2.supervisor);
          patches = tailNonEmpty(patches);
          break;
        }
        case OP_REMOVE_SUPERVISOR: {
          supervisor = removeSupervisor(supervisor, head2.supervisor);
          patches = tailNonEmpty(patches);
          break;
        }
        case OP_AND_THEN: {
          patches = prepend$1(head2.first)(prepend$1(head2.second)(tailNonEmpty(patches)));
          break;
        }
      }
    }
    return supervisor;
  };
  const removeSupervisor = (self2, that) => {
    if (equals$1(self2, that)) {
      return none;
    } else {
      if (isZip(self2)) {
        return removeSupervisor(self2.left, that).zip(removeSupervisor(self2.right, that));
      } else {
        return self2;
      }
    }
  };
  const toSet = (self2) => {
    if (equals$1(self2, none)) {
      return empty$o();
    } else {
      if (isZip(self2)) {
        return pipe(toSet(self2.left), union(toSet(self2.right)));
      } else {
        return make$U(self2);
      }
    }
  };
  const diff = (oldValue, newValue) => {
    if (equals$1(oldValue, newValue)) {
      return empty$a;
    }
    const oldSupervisors = toSet(oldValue);
    const newSupervisors = toSet(newValue);
    const added = pipe(newSupervisors, difference(oldSupervisors), reduce$3(empty$a, (patch2, supervisor) => combine(patch2, {
      _tag: OP_ADD_SUPERVISOR,
      supervisor
    })));
    const removed = pipe(oldSupervisors, difference(newSupervisors), reduce$3(empty$a, (patch2, supervisor) => combine(patch2, {
      _tag: OP_REMOVE_SUPERVISOR,
      supervisor
    })));
    return combine(added, removed);
  };
  const differ = /* @__PURE__ */ make$z({
    empty: empty$a,
    patch: patch$2,
    combine,
    diff
  });
  const fiberStarted = /* @__PURE__ */ counter("effect_fiber_started", {
    incremental: true
  });
  const fiberActive = /* @__PURE__ */ counter("effect_fiber_active");
  const fiberSuccesses = /* @__PURE__ */ counter("effect_fiber_successes", {
    incremental: true
  });
  const fiberFailures = /* @__PURE__ */ counter("effect_fiber_failures", {
    incremental: true
  });
  const fiberLifetimes = /* @__PURE__ */ tagged(/* @__PURE__ */ histogram("effect_fiber_lifetimes", /* @__PURE__ */ exponential$2({
    start: 0.5,
    factor: 2,
    count: 35
  })), "time_unit", "milliseconds");
  const EvaluationSignalContinue = "Continue";
  const EvaluationSignalDone = "Done";
  const EvaluationSignalYieldNow = "Yield";
  const runtimeFiberVariance = {
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _A: (_) => _
  };
  const absurd = (_) => {
    throw new Error(`BUG: FiberRuntime - ${toStringUnknown(_)} - please report an issue at https://github.com/Effect-TS/effect/issues`);
  };
  const YieldedOp = /* @__PURE__ */ Symbol.for("effect/internal/fiberRuntime/YieldedOp");
  const yieldedOpChannel = /* @__PURE__ */ globalValue("effect/internal/fiberRuntime/yieldedOpChannel", () => ({
    currentOp: null
  }));
  const contOpSuccess = {
    [OP_ON_SUCCESS$1]: (_, cont, value2) => {
      return internalCall(() => cont.effect_instruction_i1(value2));
    },
    ["OnStep"]: (_, _cont, value2) => {
      return exitSucceed$1(exitSucceed$1(value2));
    },
    [OP_ON_SUCCESS_AND_FAILURE]: (_, cont, value2) => {
      return internalCall(() => cont.effect_instruction_i2(value2));
    },
    [OP_REVERT_FLAGS]: (self2, cont, value2) => {
      self2.patchRuntimeFlags(self2.currentRuntimeFlags, cont.patch);
      if (interruptible$3(self2.currentRuntimeFlags) && self2.isInterrupted()) {
        return exitFailCause$1(self2.getInterruptedCause());
      } else {
        return exitSucceed$1(value2);
      }
    },
    [OP_WHILE]: (self2, cont, value2) => {
      internalCall(() => cont.effect_instruction_i2(value2));
      if (internalCall(() => cont.effect_instruction_i0())) {
        self2.pushStack(cont);
        return internalCall(() => cont.effect_instruction_i1());
      } else {
        return void_$4;
      }
    },
    [OP_ITERATOR]: (self2, cont, value2) => {
      const state2 = internalCall(() => cont.effect_instruction_i0.next(value2));
      if (state2.done) return exitSucceed$1(state2.value);
      self2.pushStack(cont);
      return yieldWrapGet(state2.value);
    }
  };
  const drainQueueWhileRunningTable = {
    [OP_INTERRUPT_SIGNAL]: (self2, runtimeFlags2, cur, message) => {
      self2.processNewInterruptSignal(message.cause);
      return interruptible$3(runtimeFlags2) ? exitFailCause$1(message.cause) : cur;
    },
    [OP_RESUME]: (_self, _runtimeFlags, _cur, _message) => {
      throw new Error("It is illegal to have multiple concurrent run loops in a single fiber");
    },
    [OP_STATEFUL]: (self2, runtimeFlags2, cur, message) => {
      message.onFiber(self2, running$1(runtimeFlags2));
      return cur;
    },
    [OP_YIELD_NOW]: (_self, _runtimeFlags, cur, _message) => {
      return flatMap$7(yieldNow$2(), () => cur);
    }
  };
  const runBlockedRequests = (self2) => forEachSequentialDiscard(flatten$6(self2), (requestsByRequestResolver) => forEachConcurrentDiscard(sequentialCollectionToChunk(requestsByRequestResolver), ([dataSource, sequential2]) => {
    const map2 = /* @__PURE__ */ new Map();
    const arr = [];
    for (const block of sequential2) {
      arr.push(toReadonlyArray(block));
      for (const entry of block) {
        map2.set(entry.request, entry);
      }
    }
    const flat = arr.flat();
    return fiberRefLocally(invokeWithInterrupt(dataSource.runAll(arr), flat, () => flat.forEach((entry) => {
      entry.listeners.interrupted = true;
    })), currentRequestMap, map2);
  }, false, false));
  const _version = /* @__PURE__ */ getCurrentVersion();
  class FiberRuntime extends Class$4 {
    constructor(fiberId2, fiberRefs0, runtimeFlags0) {
      super();
      __publicField(this, _T, fiberVariance);
      __publicField(this, _S, runtimeFiberVariance);
      __publicField(this, "_fiberRefs");
      __publicField(this, "_fiberId");
      __publicField(this, "_queue", /* @__PURE__ */ new Array());
      __publicField(this, "_children", null);
      __publicField(this, "_observers", /* @__PURE__ */ new Array());
      __publicField(this, "_running", false);
      __publicField(this, "_stack", []);
      __publicField(this, "_asyncInterruptor", null);
      __publicField(this, "_asyncBlockingOn", null);
      __publicField(this, "_exitValue", null);
      __publicField(this, "_steps", []);
      __publicField(this, "_isYielding", false);
      __publicField(this, "currentRuntimeFlags");
      __publicField(this, "currentOpCount", 0);
      __publicField(this, "currentSupervisor");
      __publicField(this, "currentScheduler");
      __publicField(this, "currentTracer");
      __publicField(this, "currentSpan");
      __publicField(this, "currentContext");
      __publicField(this, "currentDefaultServices");
      __publicField(this, "run", () => {
        this.drainQueueOnCurrentThread();
      });
      this.currentRuntimeFlags = runtimeFlags0;
      this._fiberId = fiberId2;
      this._fiberRefs = fiberRefs0;
      if (runtimeMetrics(runtimeFlags0)) {
        const tags = this.getFiberRef(currentMetricLabels);
        fiberStarted.unsafeUpdate(1, tags);
        fiberActive.unsafeUpdate(1, tags);
      }
      this.refreshRefCache();
    }
    commit() {
      return join$1(this);
    }
    /**
     * The identity of the fiber.
     */
    id() {
      return this._fiberId;
    }
    /**
     * Begins execution of the effect associated with this fiber on in the
     * background. This can be called to "kick off" execution of a fiber after
     * it has been created.
     */
    resume(effect2) {
      this.tell(resume(effect2));
    }
    /**
     * The status of the fiber.
     */
    get status() {
      return this.ask((_, status) => status);
    }
    /**
     * Gets the fiber runtime flags.
     */
    get runtimeFlags() {
      return this.ask((state2, status) => {
        if (isDone$3(status)) {
          return state2.currentRuntimeFlags;
        }
        return status.runtimeFlags;
      });
    }
    /**
     * Returns the current `FiberScope` for the fiber.
     */
    scope() {
      return unsafeMake$6(this);
    }
    /**
     * Retrieves the immediate children of the fiber.
     */
    get children() {
      return this.ask((fiber) => Array.from(fiber.getChildren()));
    }
    /**
     * Gets the fiber's set of children.
     */
    getChildren() {
      if (this._children === null) {
        this._children = /* @__PURE__ */ new Set();
      }
      return this._children;
    }
    /**
     * Retrieves the interrupted cause of the fiber, which will be `Cause.empty`
     * if the fiber has not been interrupted.
     *
     * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
     * on this fiber, then values derived from the fiber's state (including the
     * log annotations and log level) may not be up-to-date.
     */
    getInterruptedCause() {
      return this.getFiberRef(currentInterruptedCause);
    }
    /**
     * Retrieves the whole set of fiber refs.
     */
    fiberRefs() {
      return this.ask((fiber) => fiber.getFiberRefs());
    }
    /**
     * Returns an effect that will contain information computed from the fiber
     * state and status while running on the fiber.
     *
     * This allows the outside world to interact safely with mutable fiber state
     * without locks or immutable data.
     */
    ask(f) {
      return suspend$8(() => {
        const deferred = deferredUnsafeMake(this._fiberId);
        this.tell(stateful((fiber, status) => {
          deferredUnsafeDone(deferred, sync$5(() => f(fiber, status)));
        }));
        return deferredAwait(deferred);
      });
    }
    /**
     * Adds a message to be processed by the fiber on the fiber.
     */
    tell(message) {
      this._queue.push(message);
      if (!this._running) {
        this._running = true;
        this.drainQueueLaterOnExecutor();
      }
    }
    get await() {
      return async_((resume2) => {
        const cb = (exit2) => resume2(succeed$a(exit2));
        this.tell(stateful((fiber, _) => {
          if (fiber._exitValue !== null) {
            cb(this._exitValue);
          } else {
            fiber.addObserver(cb);
          }
        }));
        return sync$5(() => this.tell(stateful((fiber, _) => {
          fiber.removeObserver(cb);
        })));
      }, this.id());
    }
    get inheritAll() {
      return withFiberRuntime$1((parentFiber, parentStatus) => {
        const parentFiberId = parentFiber.id();
        const parentFiberRefs = parentFiber.getFiberRefs();
        const parentRuntimeFlags = parentStatus.runtimeFlags;
        const childFiberRefs = this.getFiberRefs();
        const updatedFiberRefs = joinAs(parentFiberRefs, parentFiberId, childFiberRefs);
        parentFiber.setFiberRefs(updatedFiberRefs);
        const updatedRuntimeFlags = parentFiber.getFiberRef(currentRuntimeFlags);
        const patch2 = pipe(
          diff$3(parentRuntimeFlags, updatedRuntimeFlags),
          // Do not inherit WindDown or Interruption!
          exclude(Interruption),
          exclude(WindDown)
        );
        return updateRuntimeFlags(patch2);
      });
    }
    /**
     * Tentatively observes the fiber, but returns immediately if it is not
     * already done.
     */
    get poll() {
      return sync$5(() => fromNullable(this._exitValue));
    }
    /**
     * Unsafely observes the fiber, but returns immediately if it is not
     * already done.
     */
    unsafePoll() {
      return this._exitValue;
    }
    /**
     * In the background, interrupts the fiber as if interrupted from the specified fiber.
     */
    interruptAsFork(fiberId2) {
      return sync$5(() => this.tell(interruptSignal(interrupt$6(fiberId2))));
    }
    /**
     * In the background, interrupts the fiber as if interrupted from the specified fiber.
     */
    unsafeInterruptAsFork(fiberId2) {
      this.tell(interruptSignal(interrupt$6(fiberId2)));
    }
    /**
     * Adds an observer to the list of observers.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    addObserver(observer) {
      if (this._exitValue !== null) {
        observer(this._exitValue);
      } else {
        this._observers.push(observer);
      }
    }
    /**
     * Removes the specified observer from the list of observers that will be
     * notified when the fiber exits.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    removeObserver(observer) {
      this._observers = this._observers.filter((o) => o !== observer);
    }
    /**
     * Retrieves all fiber refs of the fiber.
     *
     * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
     * on this fiber, then values derived from the fiber's state (including the
     * log annotations and log level) may not be up-to-date.
     */
    getFiberRefs() {
      this.setFiberRef(currentRuntimeFlags, this.currentRuntimeFlags);
      return this._fiberRefs;
    }
    /**
     * Deletes the specified fiber ref.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    unsafeDeleteFiberRef(fiberRef) {
      this._fiberRefs = delete_(this._fiberRefs, fiberRef);
    }
    /**
     * Retrieves the state of the fiber ref, or else its initial value.
     *
     * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
     * on this fiber, then values derived from the fiber's state (including the
     * log annotations and log level) may not be up-to-date.
     */
    getFiberRef(fiberRef) {
      if (this._fiberRefs.locals.has(fiberRef)) {
        return this._fiberRefs.locals.get(fiberRef)[0][1];
      }
      return fiberRef.initial;
    }
    /**
     * Sets the fiber ref to the specified value.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    setFiberRef(fiberRef, value2) {
      this._fiberRefs = updateAs(this._fiberRefs, {
        fiberId: this._fiberId,
        fiberRef,
        value: value2
      });
      this.refreshRefCache();
    }
    refreshRefCache() {
      this.currentDefaultServices = this.getFiberRef(currentServices);
      this.currentTracer = this.currentDefaultServices.unsafeMap.get(tracerTag.key);
      this.currentSupervisor = this.getFiberRef(currentSupervisor);
      this.currentScheduler = this.getFiberRef(currentScheduler$1);
      this.currentContext = this.getFiberRef(currentContext$1);
      this.currentSpan = this.currentContext.unsafeMap.get(spanTag.key);
    }
    /**
     * Wholesale replaces all fiber refs of this fiber.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    setFiberRefs(fiberRefs2) {
      this._fiberRefs = fiberRefs2;
      this.refreshRefCache();
    }
    /**
     * Adds a reference to the specified fiber inside the children set.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    addChild(child) {
      this.getChildren().add(child);
    }
    /**
     * Removes a reference to the specified fiber inside the children set.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    removeChild(child) {
      this.getChildren().delete(child);
    }
    /**
     * Transfers all children of this fiber that are currently running to the
     * specified fiber scope.
     *
     * **NOTE**: This method must be invoked by the fiber itself after it has
     * evaluated the effects but prior to exiting.
     */
    transferChildren(scope2) {
      const children = this._children;
      this._children = null;
      if (children !== null && children.size > 0) {
        for (const child of children) {
          if (child._exitValue === null) {
            scope2.add(this.currentRuntimeFlags, child);
          }
        }
      }
    }
    /**
     * On the current thread, executes all messages in the fiber's inbox. This
     * method may return before all work is done, in the event the fiber executes
     * an asynchronous operation.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    drainQueueOnCurrentThread() {
      let recurse = true;
      while (recurse) {
        let evaluationSignal = EvaluationSignalContinue;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          while (evaluationSignal === EvaluationSignalContinue) {
            evaluationSignal = this._queue.length === 0 ? EvaluationSignalDone : this.evaluateMessageWhileSuspended(this._queue.splice(0, 1)[0]);
          }
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
        }
        if (this._queue.length > 0 && !this._running) {
          this._running = true;
          if (evaluationSignal === EvaluationSignalYieldNow) {
            this.drainQueueLaterOnExecutor();
            recurse = false;
          } else {
            recurse = true;
          }
        } else {
          recurse = false;
        }
      }
    }
    /**
     * Schedules the execution of all messages in the fiber's inbox.
     *
     * This method will return immediately after the scheduling
     * operation is completed, but potentially before such messages have been
     * executed.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    drainQueueLaterOnExecutor() {
      this.currentScheduler.scheduleTask(this.run, this.getFiberRef(currentSchedulingPriority$1));
    }
    /**
     * Drains the fiber's message queue while the fiber is actively running,
     * returning the next effect to execute, which may be the input effect if no
     * additional effect needs to be executed.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    drainQueueWhileRunning(runtimeFlags2, cur0) {
      let cur = cur0;
      while (this._queue.length > 0) {
        const message = this._queue.splice(0, 1)[0];
        cur = drainQueueWhileRunningTable[message._tag](this, runtimeFlags2, cur, message);
      }
      return cur;
    }
    /**
     * Determines if the fiber is interrupted.
     *
     * **NOTE**: This method is safe to invoke on any fiber, but if not invoked
     * on this fiber, then values derived from the fiber's state (including the
     * log annotations and log level) may not be up-to-date.
     */
    isInterrupted() {
      return !isEmpty$4(this.getFiberRef(currentInterruptedCause));
    }
    /**
     * Adds an interruptor to the set of interruptors that are interrupting this
     * fiber.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    addInterruptedCause(cause) {
      const oldSC = this.getFiberRef(currentInterruptedCause);
      this.setFiberRef(currentInterruptedCause, sequential$3(oldSC, cause));
    }
    /**
     * Processes a new incoming interrupt signal.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    processNewInterruptSignal(cause) {
      this.addInterruptedCause(cause);
      this.sendInterruptSignalToAllChildren();
    }
    /**
     * Interrupts all children of the current fiber, returning an effect that will
     * await the exit of the children. This method will return null if the fiber
     * has no children.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    sendInterruptSignalToAllChildren() {
      if (this._children === null || this._children.size === 0) {
        return false;
      }
      let told = false;
      for (const child of this._children) {
        child.tell(interruptSignal(interrupt$6(this.id())));
        told = true;
      }
      return told;
    }
    /**
     * Interrupts all children of the current fiber, returning an effect that will
     * await the exit of the children. This method will return null if the fiber
     * has no children.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    interruptAllChildren() {
      if (this.sendInterruptSignalToAllChildren()) {
        const it = this._children.values();
        this._children = null;
        let isDone2 = false;
        const body = () => {
          const next = it.next();
          if (!next.done) {
            return asVoid$1(next.value.await);
          } else {
            return sync$5(() => {
              isDone2 = true;
            });
          }
        };
        return whileLoop({
          while: () => !isDone2,
          body,
          step: () => {
          }
        });
      }
      return null;
    }
    reportExitValue(exit2) {
      if (runtimeMetrics(this.currentRuntimeFlags)) {
        const tags = this.getFiberRef(currentMetricLabels);
        const startTimeMillis = this.id().startTimeMillis;
        const endTimeMillis = Date.now();
        fiberLifetimes.unsafeUpdate(endTimeMillis - startTimeMillis, tags);
        fiberActive.unsafeUpdate(-1, tags);
        switch (exit2._tag) {
          case OP_SUCCESS: {
            fiberSuccesses.unsafeUpdate(1, tags);
            break;
          }
          case OP_FAILURE: {
            fiberFailures.unsafeUpdate(1, tags);
            break;
          }
        }
      }
      if (exit2._tag === "Failure") {
        const level = this.getFiberRef(currentUnhandledErrorLogLevel);
        if (!isInterruptedOnly$1(exit2.cause) && level._tag === "Some") {
          this.log("Fiber terminated with an unhandled error", exit2.cause, level);
        }
      }
    }
    setExitValue(exit2) {
      this._exitValue = exit2;
      this.reportExitValue(exit2);
      for (let i = this._observers.length - 1; i >= 0; i--) {
        this._observers[i](exit2);
      }
      this._observers = [];
    }
    getLoggers() {
      return this.getFiberRef(currentLoggers$1);
    }
    log(message, cause, overrideLogLevel) {
      const logLevel = isSome(overrideLogLevel) ? overrideLogLevel.value : this.getFiberRef(currentLogLevel);
      const minimumLogLevel = this.getFiberRef(currentMinimumLogLevel);
      if (greaterThan(minimumLogLevel, logLevel)) {
        return;
      }
      const spans = this.getFiberRef(currentLogSpan);
      const annotations2 = this.getFiberRef(currentLogAnnotations);
      const loggers = this.getLoggers();
      const contextMap = this.getFiberRefs();
      if (size$6(loggers) > 0) {
        const clockService = get$e(this.getFiberRef(currentServices), clockTag);
        const date = new Date(clockService.unsafeCurrentTimeMillis());
        withRedactableContext(contextMap, () => {
          for (const logger of loggers) {
            logger.log({
              fiberId: this.id(),
              logLevel,
              message,
              cause,
              context: contextMap,
              spans,
              annotations: annotations2,
              date
            });
          }
        });
      }
    }
    /**
     * Evaluates a single message on the current thread, while the fiber is
     * suspended. This method should only be called while evaluation of the
     * fiber's effect is suspended due to an asynchronous operation.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    evaluateMessageWhileSuspended(message) {
      switch (message._tag) {
        case OP_YIELD_NOW: {
          return EvaluationSignalYieldNow;
        }
        case OP_INTERRUPT_SIGNAL: {
          this.processNewInterruptSignal(message.cause);
          if (this._asyncInterruptor !== null) {
            this._asyncInterruptor(exitFailCause$1(message.cause));
            this._asyncInterruptor = null;
          }
          return EvaluationSignalContinue;
        }
        case OP_RESUME: {
          this._asyncInterruptor = null;
          this._asyncBlockingOn = null;
          this.evaluateEffect(message.effect);
          return EvaluationSignalContinue;
        }
        case OP_STATEFUL: {
          message.onFiber(this, this._exitValue !== null ? done$5 : suspended(this.currentRuntimeFlags, this._asyncBlockingOn));
          return EvaluationSignalContinue;
        }
        default: {
          return absurd(message);
        }
      }
    }
    /**
     * Evaluates an effect until completion, potentially asynchronously.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    evaluateEffect(effect0) {
      this.currentSupervisor.onResume(this);
      try {
        let effect2 = interruptible$3(this.currentRuntimeFlags) && this.isInterrupted() ? exitFailCause$1(this.getInterruptedCause()) : effect0;
        while (effect2 !== null) {
          const eff = effect2;
          const exit2 = this.runLoop(eff);
          if (exit2 === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            yieldedOpChannel.currentOp = null;
            if (op._op === OP_YIELD$1) {
              if (cooperativeYielding(this.currentRuntimeFlags)) {
                this.tell(yieldNow());
                this.tell(resume(exitVoid$1));
                effect2 = null;
              } else {
                effect2 = exitVoid$1;
              }
            } else if (op._op === OP_ASYNC) {
              effect2 = null;
            }
          } else {
            this.currentRuntimeFlags = pipe(this.currentRuntimeFlags, enable$1(WindDown));
            const interruption2 = this.interruptAllChildren();
            if (interruption2 !== null) {
              effect2 = flatMap$7(interruption2, () => exit2);
            } else {
              if (this._queue.length === 0) {
                this.setExitValue(exit2);
              } else {
                this.tell(resume(exit2));
              }
              effect2 = null;
            }
          }
        }
      } finally {
        this.currentSupervisor.onSuspend(this);
      }
    }
    /**
     * Begins execution of the effect associated with this fiber on the current
     * thread. This can be called to "kick off" execution of a fiber after it has
     * been created, in hopes that the effect can be executed synchronously.
     *
     * This is not the normal way of starting a fiber, but it is useful when the
     * express goal of executing the fiber is to synchronously produce its exit.
     */
    start(effect2) {
      if (!this._running) {
        this._running = true;
        const prev = globalThis[currentFiberURI];
        globalThis[currentFiberURI] = this;
        try {
          this.evaluateEffect(effect2);
        } finally {
          this._running = false;
          globalThis[currentFiberURI] = prev;
          if (this._queue.length > 0) {
            this.drainQueueLaterOnExecutor();
          }
        }
      } else {
        this.tell(resume(effect2));
      }
    }
    /**
     * Begins execution of the effect associated with this fiber on in the
     * background, and on the correct thread pool. This can be called to "kick
     * off" execution of a fiber after it has been created, in hopes that the
     * effect can be executed synchronously.
     */
    startFork(effect2) {
      this.tell(resume(effect2));
    }
    /**
     * Takes the current runtime flags, patches them to return the new runtime
     * flags, and then makes any changes necessary to fiber state based on the
     * specified patch.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    patchRuntimeFlags(oldRuntimeFlags, patch2) {
      const newRuntimeFlags = patch$6(oldRuntimeFlags, patch2);
      globalThis[currentFiberURI] = this;
      this.currentRuntimeFlags = newRuntimeFlags;
      return newRuntimeFlags;
    }
    /**
     * Initiates an asynchronous operation, by building a callback that will
     * resume execution, and then feeding that callback to the registration
     * function, handling error cases and repeated resumptions appropriately.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    initiateAsync(runtimeFlags2, asyncRegister) {
      let alreadyCalled = false;
      const callback = (effect2) => {
        if (!alreadyCalled) {
          alreadyCalled = true;
          this.tell(resume(effect2));
        }
      };
      if (interruptible$3(runtimeFlags2)) {
        this._asyncInterruptor = callback;
      }
      try {
        asyncRegister(callback);
      } catch (e) {
        callback(failCause$8(die$7(e)));
      }
    }
    pushStack(cont) {
      this._stack.push(cont);
      if (cont._op === "OnStep") {
        this._steps.push({
          refs: this.getFiberRefs(),
          flags: this.currentRuntimeFlags
        });
      }
    }
    popStack() {
      const item = this._stack.pop();
      if (item) {
        if (item._op === "OnStep") {
          this._steps.pop();
        }
        return item;
      }
      return;
    }
    getNextSuccessCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_FAILURE$1) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    getNextFailCont() {
      let frame = this.popStack();
      while (frame) {
        if (frame._op !== OP_ON_SUCCESS$1 && frame._op !== OP_WHILE && frame._op !== OP_ITERATOR) {
          return frame;
        }
        frame = this.popStack();
      }
    }
    [(_T = FiberTypeId, _S = RuntimeFiberTypeId, OP_TAG)](op) {
      return sync$5(() => unsafeGet$3(this.currentContext, op));
    }
    ["Left"](op) {
      return fail$b(op.left);
    }
    ["None"](_) {
      return fail$b(new NoSuchElementException$1());
    }
    ["Right"](op) {
      return exitSucceed$1(op.right);
    }
    ["Some"](op) {
      return exitSucceed$1(op.value);
    }
    ["Micro"](op) {
      return unsafeAsync((microResume) => {
        let resume2 = microResume;
        const fiber = runFork$2(provideContext$3(op, this.currentContext));
        fiber.addObserver((exit2) => {
          if (exit2._tag === "Success") {
            return resume2(exitSucceed$1(exit2.value));
          }
          switch (exit2.cause._tag) {
            case "Interrupt": {
              return resume2(exitFailCause$1(interrupt$6(none$2)));
            }
            case "Fail": {
              return resume2(fail$b(exit2.cause.error));
            }
            case "Die": {
              return resume2(die$6(exit2.cause.defect));
            }
          }
        });
        return unsafeAsync((abortResume) => {
          resume2 = (_) => {
            abortResume(void_$4);
          };
          fiber.unsafeInterrupt();
        });
      });
    }
    [OP_SYNC$1](op) {
      const value2 = internalCall(() => op.effect_instruction_i0());
      const cont = this.getNextSuccessCont();
      if (cont !== void 0) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, value2);
      } else {
        yieldedOpChannel.currentOp = exitSucceed$1(value2);
        return YieldedOp;
      }
    }
    [OP_SUCCESS](op) {
      const oldCur = op;
      const cont = this.getNextSuccessCont();
      if (cont !== void 0) {
        if (!(cont._op in contOpSuccess)) {
          absurd(cont);
        }
        return contOpSuccess[cont._op](this, cont, oldCur.effect_instruction_i0);
      } else {
        yieldedOpChannel.currentOp = oldCur;
        return YieldedOp;
      }
    }
    [OP_FAILURE](op) {
      const cause = op.effect_instruction_i0;
      const cont = this.getNextFailCont();
      if (cont !== void 0) {
        switch (cont._op) {
          case OP_ON_FAILURE$1:
          case OP_ON_SUCCESS_AND_FAILURE: {
            if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) {
              return internalCall(() => cont.effect_instruction_i1(cause));
            } else {
              return exitFailCause$1(stripFailures(cause));
            }
          }
          case "OnStep": {
            if (!(interruptible$3(this.currentRuntimeFlags) && this.isInterrupted())) {
              return exitSucceed$1(exitFailCause$1(cause));
            } else {
              return exitFailCause$1(stripFailures(cause));
            }
          }
          case OP_REVERT_FLAGS: {
            this.patchRuntimeFlags(this.currentRuntimeFlags, cont.patch);
            if (interruptible$3(this.currentRuntimeFlags) && this.isInterrupted()) {
              return exitFailCause$1(sequential$3(cause, this.getInterruptedCause()));
            } else {
              return exitFailCause$1(cause);
            }
          }
          default: {
            absurd(cont);
          }
        }
      } else {
        yieldedOpChannel.currentOp = exitFailCause$1(cause);
        return YieldedOp;
      }
    }
    [OP_WITH_RUNTIME](op) {
      return internalCall(() => op.effect_instruction_i0(this, running$1(this.currentRuntimeFlags)));
    }
    ["Blocked"](op) {
      const refs = this.getFiberRefs();
      const flags = this.currentRuntimeFlags;
      if (this._steps.length > 0) {
        const frames = [];
        const snap = this._steps[this._steps.length - 1];
        let frame = this.popStack();
        while (frame && frame._op !== "OnStep") {
          frames.push(frame);
          frame = this.popStack();
        }
        this.setFiberRefs(snap.refs);
        this.currentRuntimeFlags = snap.flags;
        const patchRefs = diff$1(snap.refs, refs);
        const patchFlags = diff$3(snap.flags, flags);
        return exitSucceed$1(blocked(op.effect_instruction_i0, withFiberRuntime$1((newFiber) => {
          while (frames.length > 0) {
            newFiber.pushStack(frames.pop());
          }
          newFiber.setFiberRefs(patch$3(newFiber.id(), newFiber.getFiberRefs())(patchRefs));
          newFiber.currentRuntimeFlags = patch$6(patchFlags)(newFiber.currentRuntimeFlags);
          return op.effect_instruction_i1;
        })));
      }
      return uninterruptibleMask$2((restore) => flatMap$7(forkDaemon$1(runRequestBlock(op.effect_instruction_i0)), () => restore(op.effect_instruction_i1)));
    }
    ["RunBlocked"](op) {
      return runBlockedRequests(op.effect_instruction_i0);
    }
    [OP_UPDATE_RUNTIME_FLAGS](op) {
      const updateFlags = op.effect_instruction_i0;
      const oldRuntimeFlags = this.currentRuntimeFlags;
      const newRuntimeFlags = patch$6(oldRuntimeFlags, updateFlags);
      if (interruptible$3(newRuntimeFlags) && this.isInterrupted()) {
        return exitFailCause$1(this.getInterruptedCause());
      } else {
        this.patchRuntimeFlags(this.currentRuntimeFlags, updateFlags);
        if (op.effect_instruction_i1) {
          const revertFlags = diff$3(newRuntimeFlags, oldRuntimeFlags);
          this.pushStack(new RevertFlags(revertFlags, op));
          return internalCall(() => op.effect_instruction_i1(oldRuntimeFlags));
        } else {
          return exitVoid$1;
        }
      }
    }
    [OP_ON_SUCCESS$1](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    ["OnStep"](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_FAILURE$1](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ON_SUCCESS_AND_FAILURE](op) {
      this.pushStack(op);
      return op.effect_instruction_i0;
    }
    [OP_ASYNC](op) {
      this._asyncBlockingOn = op.effect_instruction_i1;
      this.initiateAsync(this.currentRuntimeFlags, op.effect_instruction_i0);
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_YIELD$1](op) {
      this._isYielding = false;
      yieldedOpChannel.currentOp = op;
      return YieldedOp;
    }
    [OP_WHILE](op) {
      const check2 = op.effect_instruction_i0;
      const body = op.effect_instruction_i1;
      if (check2()) {
        this.pushStack(op);
        return body();
      } else {
        return exitVoid$1;
      }
    }
    [OP_ITERATOR](op) {
      return contOpSuccess[OP_ITERATOR](this, op, void 0);
    }
    [OP_COMMIT](op) {
      return internalCall(() => op.commit());
    }
    /**
     * The main run-loop for evaluating effects.
     *
     * **NOTE**: This method must be invoked by the fiber itself.
     */
    runLoop(effect0) {
      let cur = effect0;
      this.currentOpCount = 0;
      while (true) {
        if ((this.currentRuntimeFlags & OpSupervision) !== 0) {
          this.currentSupervisor.onEffect(this, cur);
        }
        if (this._queue.length > 0) {
          cur = this.drainQueueWhileRunning(this.currentRuntimeFlags, cur);
        }
        if (!this._isYielding) {
          this.currentOpCount += 1;
          const shouldYield = this.currentScheduler.shouldYield(this);
          if (shouldYield !== false) {
            this._isYielding = true;
            this.currentOpCount = 0;
            const oldCur = cur;
            cur = flatMap$7(yieldNow$2({
              priority: shouldYield
            }), () => oldCur);
          }
        }
        try {
          cur = this.currentTracer.context(() => {
            if (_version !== cur[EffectTypeId$1]._V) {
              return dieMessage$1(`Cannot execute an Effect versioned ${cur[EffectTypeId$1]._V} with a Runtime of version ${getCurrentVersion()}`);
            }
            return this[cur._op](cur);
          }, this);
          if (cur === YieldedOp) {
            const op = yieldedOpChannel.currentOp;
            if (op._op === OP_YIELD$1 || op._op === OP_ASYNC) {
              return YieldedOp;
            }
            yieldedOpChannel.currentOp = null;
            return op._op === OP_SUCCESS || op._op === OP_FAILURE ? op : exitFailCause$1(die$7(op));
          }
        } catch (e) {
          if (cur !== YieldedOp && !hasProperty(cur, "_op") || !(cur._op in this)) {
            cur = dieMessage$1(`Not a valid effect: ${toStringUnknown(cur)}`);
          } else if (isInterruptedException(e)) {
            cur = exitFailCause$1(sequential$3(die$7(e), interrupt$6(none$2)));
          } else {
            cur = die$6(e);
          }
        }
      }
    }
  }
  const currentMinimumLogLevel = /* @__PURE__ */ globalValue("effect/FiberRef/currentMinimumLogLevel", () => fiberRefUnsafeMake(fromLiteral("Info")));
  const loggerWithConsoleLog = (self2) => makeLogger((opts) => {
    const services = getOrDefault(opts.context, currentServices);
    get$e(services, consoleTag).unsafe.log(self2.log(opts));
  });
  const defaultLogger$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/defaultLogger"), () => loggerWithConsoleLog(stringLogger));
  const tracerLogger$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/Logger/tracerLogger"), () => makeLogger(({
    annotations: annotations2,
    cause,
    context: context2,
    fiberId: fiberId2,
    logLevel,
    message
  }) => {
    const span2 = getOption(getOrDefault$1(context2, currentContext$1), spanTag);
    if (span2._tag === "None" || span2.value._tag === "ExternalSpan") {
      return;
    }
    const clockService = unsafeGet$3(getOrDefault$1(context2, currentServices), clockTag);
    const attributes = {};
    for (const [key, value2] of annotations2) {
      attributes[key] = value2;
    }
    attributes["effect.fiberId"] = threadName(fiberId2);
    attributes["effect.logLevel"] = logLevel.label;
    if (cause !== null && cause._tag !== "Empty") {
      attributes["effect.cause"] = pretty$1(cause, {
        renderErrorCause: true
      });
    }
    span2.value.event(toStringUnknown(Array.isArray(message) ? message[0] : message), clockService.unsafeCurrentTimeNanos(), attributes);
  }));
  const currentLoggers$1 = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/FiberRef/currentLoggers"), () => fiberRefUnsafeMakeHashSet(make$U(defaultLogger$1, tracerLogger$1)));
  const acquireRelease$1 = /* @__PURE__ */ dual((args2) => isEffect$1(args2[0]), (acquire, release) => uninterruptible$1(tap$3(acquire, (a) => addFinalizer$2((exit2) => release(a, exit2)))));
  const addFinalizer$2 = (finalizer) => withFiberRuntime$1((runtime2) => {
    const acquireRefs = runtime2.getFiberRefs();
    const acquireFlags = runtime2.currentRuntimeFlags;
    return flatMap$7(scope$1, (scope2) => scopeAddFinalizerExit(scope2, (exit2) => withFiberRuntime$1((runtimeFinalizer) => {
      const preRefs = runtimeFinalizer.getFiberRefs();
      const preFlags = runtimeFinalizer.currentRuntimeFlags;
      const patchRefs = diff$1(preRefs, acquireRefs);
      const patchFlags = diff$3(preFlags, acquireFlags);
      const inverseRefs = diff$1(acquireRefs, preRefs);
      runtimeFinalizer.setFiberRefs(patch$3(patchRefs, runtimeFinalizer.id(), acquireRefs));
      return ensuring$4(withRuntimeFlags(finalizer(exit2), patchFlags), sync$5(() => {
        runtimeFinalizer.setFiberRefs(patch$3(inverseRefs, runtimeFinalizer.id(), runtimeFinalizer.getFiberRefs()));
      }));
    })));
  });
  const allResolveInput = (input) => {
    if (Array.isArray(input) || isIterable(input)) {
      return [input, none$4()];
    }
    const keys2 = Object.keys(input);
    const size2 = keys2.length;
    return [keys2.map((k) => input[k]), some((values) => {
      const res = {};
      for (let i = 0; i < size2; i++) {
        res[keys2[i]] = values[i];
      }
      return res;
    })];
  };
  const allValidate = (effects, reconcile, options2) => {
    const eitherEffects = [];
    for (const effect2 of effects) {
      eitherEffects.push(either$2(effect2));
    }
    return flatMap$7(forEach$1(eitherEffects, identity, {
      concurrency: options2 == null ? void 0 : options2.concurrency,
      batching: options2 == null ? void 0 : options2.batching,
      concurrentFinalizers: options2 == null ? void 0 : options2.concurrentFinalizers
    }), (eithers) => {
      const none2 = none$4();
      const size2 = eithers.length;
      const errors = new Array(size2);
      const successes = new Array(size2);
      let errored = false;
      for (let i = 0; i < size2; i++) {
        const either2 = eithers[i];
        if (either2._tag === "Left") {
          errors[i] = some(either2.left);
          errored = true;
        } else {
          successes[i] = either2.right;
          errors[i] = none2;
        }
      }
      if (errored) {
        return reconcile._tag === "Some" ? fail$b(reconcile.value(errors)) : fail$b(errors);
      } else if (options2 == null ? void 0 : options2.discard) {
        return void_$4;
      }
      return reconcile._tag === "Some" ? succeed$a(reconcile.value(successes)) : succeed$a(successes);
    });
  };
  const allEither = (effects, reconcile, options2) => {
    const eitherEffects = [];
    for (const effect2 of effects) {
      eitherEffects.push(either$2(effect2));
    }
    if (options2 == null ? void 0 : options2.discard) {
      return forEach$1(eitherEffects, identity, {
        concurrency: options2 == null ? void 0 : options2.concurrency,
        batching: options2 == null ? void 0 : options2.batching,
        discard: true,
        concurrentFinalizers: options2 == null ? void 0 : options2.concurrentFinalizers
      });
    }
    return map$9(forEach$1(eitherEffects, identity, {
      concurrency: options2 == null ? void 0 : options2.concurrency,
      batching: options2 == null ? void 0 : options2.batching,
      concurrentFinalizers: options2 == null ? void 0 : options2.concurrentFinalizers
    }), (eithers) => reconcile._tag === "Some" ? reconcile.value(eithers) : eithers);
  };
  const all$1 = (arg, options2) => {
    const [effects, reconcile] = allResolveInput(arg);
    if ((options2 == null ? void 0 : options2.mode) === "validate") {
      return allValidate(effects, reconcile, options2);
    } else if ((options2 == null ? void 0 : options2.mode) === "either") {
      return allEither(effects, reconcile, options2);
    }
    return (options2 == null ? void 0 : options2.discard) !== true && reconcile._tag === "Some" ? map$9(forEach$1(effects, identity, options2), reconcile.value) : forEach$1(effects, identity, options2);
  };
  const forEach$1 = /* @__PURE__ */ dual((args2) => isIterable(args2[0]), (self2, f, options2) => withFiberRuntime$1((r) => {
    const isRequestBatchingEnabled = (options2 == null ? void 0 : options2.batching) === true || (options2 == null ? void 0 : options2.batching) === "inherit" && r.getFiberRef(currentRequestBatching);
    if (options2 == null ? void 0 : options2.discard) {
      return match$4(options2.concurrency, () => finalizersMaskInternal(sequential$1, options2 == null ? void 0 : options2.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), true, false, 1) : forEachSequentialDiscard(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel$1, options2 == null ? void 0 : options2.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false)), (n) => finalizersMaskInternal(parallelN(n), options2 == null ? void 0 : options2.concurrentFinalizers)((restore) => forEachConcurrentDiscard(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled, false, n)));
    }
    return match$4(options2 == null ? void 0 : options2.concurrency, () => finalizersMaskInternal(sequential$1, options2 == null ? void 0 : options2.concurrentFinalizers)((restore) => isRequestBatchingEnabled ? forEachParN(self2, 1, (a, i) => restore(f(a, i)), true) : forEachSequential(self2, (a, i) => restore(f(a, i)))), () => finalizersMaskInternal(parallel$1, options2 == null ? void 0 : options2.concurrentFinalizers)((restore) => forEachParUnbounded(self2, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)), (n) => finalizersMaskInternal(parallelN(n), options2 == null ? void 0 : options2.concurrentFinalizers)((restore) => forEachParN(self2, n, (a, i) => restore(f(a, i)), isRequestBatchingEnabled)));
  }));
  const forEachParUnbounded = (self2, f, batching) => suspend$8(() => {
    const as2 = fromIterable$8(self2);
    const array2 = new Array(as2.length);
    const fn2 = (a, i) => flatMap$7(f(a, i), (b) => sync$5(() => array2[i] = b));
    return zipRight$4(forEachConcurrentDiscard(as2, fn2, batching, false), succeed$a(array2));
  });
  const forEachConcurrentDiscard = (self2, f, batching, processAll, n) => uninterruptibleMask$2((restore) => transplant((graft) => withFiberRuntime$1((parent) => {
    let todos = Array.from(self2).reverse();
    let target = todos.length;
    if (target === 0) {
      return void_$4;
    }
    let counter2 = 0;
    let interrupted2 = false;
    const fibersCount = n ? Math.min(todos.length, n) : todos.length;
    const fibers = /* @__PURE__ */ new Set();
    const results = new Array();
    const interruptAll = () => fibers.forEach((fiber) => {
      fiber.currentScheduler.scheduleTask(() => {
        fiber.unsafeInterruptAsFork(parent.id());
      }, 0);
    });
    const startOrder = new Array();
    const joinOrder = new Array();
    const residual = new Array();
    const collectExits = () => {
      const exits = results.filter(({
        exit: exit2
      }) => exit2._tag === "Failure").sort((a, b) => a.index < b.index ? -1 : a.index === b.index ? 0 : 1).map(({
        exit: exit2
      }) => exit2);
      if (exits.length === 0) {
        exits.push(exitVoid$1);
      }
      return exits;
    };
    const runFiber = (eff, interruptImmediately = false) => {
      const runnable = uninterruptible$1(graft(eff));
      const fiber = unsafeForkUnstarted(runnable, parent, parent.currentRuntimeFlags, globalScope);
      parent.currentScheduler.scheduleTask(() => {
        if (interruptImmediately) {
          fiber.unsafeInterruptAsFork(parent.id());
        }
        fiber.resume(runnable);
      }, 0);
      return fiber;
    };
    const onInterruptSignal = () => {
      if (!processAll) {
        target -= todos.length;
        todos = [];
      }
      interrupted2 = true;
      interruptAll();
    };
    const stepOrExit = batching ? step : exit$1;
    const processingFiber = runFiber(async_((resume2) => {
      const pushResult = (res, index) => {
        if (res._op === "Blocked") {
          residual.push(res);
        } else {
          results.push({
            index,
            exit: res
          });
          if (res._op === "Failure" && !interrupted2) {
            onInterruptSignal();
          }
        }
      };
      const next = () => {
        if (todos.length > 0) {
          const a = todos.pop();
          let index = counter2++;
          const returnNextElement = () => {
            const a2 = todos.pop();
            index = counter2++;
            return flatMap$7(yieldNow$2(), () => flatMap$7(stepOrExit(restore(f(a2, index))), onRes));
          };
          const onRes = (res) => {
            if (todos.length > 0) {
              pushResult(res, index);
              if (todos.length > 0) {
                return returnNextElement();
              }
            }
            return succeed$a(res);
          };
          const todo = flatMap$7(stepOrExit(restore(f(a, index))), onRes);
          const fiber = runFiber(todo);
          startOrder.push(fiber);
          fibers.add(fiber);
          if (interrupted2) {
            fiber.currentScheduler.scheduleTask(() => {
              fiber.unsafeInterruptAsFork(parent.id());
            }, 0);
          }
          fiber.addObserver((wrapped) => {
            let exit2;
            if (wrapped._op === "Failure") {
              exit2 = wrapped;
            } else {
              exit2 = wrapped.effect_instruction_i0;
            }
            joinOrder.push(fiber);
            fibers.delete(fiber);
            pushResult(exit2, index);
            if (results.length === target) {
              resume2(succeed$a(getOrElse(exitCollectAll(collectExits(), {
                parallel: true
              }), () => exitVoid$1)));
            } else if (residual.length + results.length === target) {
              const exits = collectExits();
              const requests = residual.map((blocked2) => blocked2.effect_instruction_i0).reduce(par);
              resume2(succeed$a(blocked(requests, forEachConcurrentDiscard([getOrElse(exitCollectAll(exits, {
                parallel: true
              }), () => exitVoid$1), ...residual.map((blocked2) => blocked2.effect_instruction_i1)], (i) => i, batching, true, n))));
            } else {
              next();
            }
          });
        }
      };
      for (let i = 0; i < fibersCount; i++) {
        next();
      }
    }));
    return asVoid$1(onExit$2(flatten$5(restore(join$1(processingFiber))), exitMatch({
      onFailure: (cause) => {
        onInterruptSignal();
        const target2 = residual.length + 1;
        const concurrency = Math.min(typeof n === "number" ? n : residual.length, residual.length);
        const toPop = Array.from(residual);
        return async_((cb) => {
          let count = 0;
          let index = 0;
          const check2 = (index2, hitNext) => (exit2) => {
            count++;
            if (count === target2) {
              cb(exitSucceed$1(exitFailCause$1(cause)));
            }
            if (toPop.length > 0 && hitNext) {
              next();
            }
          };
          const next = () => {
            runFiber(toPop.pop(), true).addObserver(check2(index, true));
            index++;
          };
          processingFiber.addObserver(check2(index, false));
          index++;
          for (let i = 0; i < concurrency; i++) {
            next();
          }
        });
      },
      onSuccess: () => forEachSequential(joinOrder, (f2) => f2.inheritAll)
    })));
  })));
  const forEachParN = (self2, n, f, batching) => suspend$8(() => {
    const as2 = fromIterable$8(self2);
    const array2 = new Array(as2.length);
    const fn2 = (a, i) => map$9(f(a, i), (b) => array2[i] = b);
    return zipRight$4(forEachConcurrentDiscard(as2, fn2, batching, false, n), succeed$a(array2));
  });
  const fork$2 = (self2) => withFiberRuntime$1((state2, status) => succeed$a(unsafeFork$1(self2, state2, status.runtimeFlags)));
  const forkDaemon$1 = (self2) => forkWithScopeOverride(self2, globalScope);
  const unsafeFork$1 = (effect2, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childFiber = unsafeMakeChildFiber(effect2, parentFiber, parentRuntimeFlags, overrideScope);
    childFiber.resume(effect2);
    return childFiber;
  };
  const unsafeForkUnstarted = (effect2, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childFiber = unsafeMakeChildFiber(effect2, parentFiber, parentRuntimeFlags, overrideScope);
    return childFiber;
  };
  const unsafeMakeChildFiber = (effect2, parentFiber, parentRuntimeFlags, overrideScope = null) => {
    const childId = unsafeMake$a();
    const parentFiberRefs = parentFiber.getFiberRefs();
    const childFiberRefs = forkAs(parentFiberRefs, childId);
    const childFiber = new FiberRuntime(childId, childFiberRefs, parentRuntimeFlags);
    const childContext = getOrDefault$1(childFiberRefs, currentContext$1);
    const supervisor = childFiber.currentSupervisor;
    supervisor.onStart(childContext, effect2, some(parentFiber), childFiber);
    childFiber.addObserver((exit2) => supervisor.onEnd(exit2, childFiber));
    const parentScope = overrideScope !== null ? overrideScope : pipe(parentFiber.getFiberRef(currentForkScopeOverride), getOrElse(() => parentFiber.scope()));
    parentScope.add(parentRuntimeFlags, childFiber);
    return childFiber;
  };
  const forkWithScopeOverride = (self2, scopeOverride) => withFiberRuntime$1((parentFiber, parentStatus) => succeed$a(unsafeFork$1(self2, parentFiber, parentStatus.runtimeFlags, scopeOverride)));
  const parallelFinalizers = (self2) => contextWithEffect((context2) => match$a(getOption(context2, scopeTag), {
    onNone: () => self2,
    onSome: (scope2) => {
      switch (scope2.strategy._tag) {
        case "Parallel":
          return self2;
        case "Sequential":
        case "ParallelN":
          return flatMap$7(scopeFork(scope2, parallel$1), (inner) => scopeExtend(self2, inner));
      }
    }
  }));
  const parallelNFinalizers = (parallelism) => (self2) => contextWithEffect((context2) => match$a(getOption(context2, scopeTag), {
    onNone: () => self2,
    onSome: (scope2) => {
      if (scope2.strategy._tag === "ParallelN" && scope2.strategy.parallelism === parallelism) {
        return self2;
      }
      return flatMap$7(scopeFork(scope2, parallelN(parallelism)), (inner) => scopeExtend(self2, inner));
    }
  }));
  const finalizersMaskInternal = (strategy, concurrentFinalizers) => (self2) => contextWithEffect((context2) => match$a(getOption(context2, scopeTag), {
    onNone: () => self2(identity),
    onSome: (scope2) => {
      if (concurrentFinalizers === true) {
        const patch2 = strategy._tag === "Parallel" ? parallelFinalizers : strategy._tag === "Sequential" ? sequentialFinalizers : parallelNFinalizers(strategy.parallelism);
        switch (scope2.strategy._tag) {
          case "Parallel":
            return patch2(self2(parallelFinalizers));
          case "Sequential":
            return patch2(self2(sequentialFinalizers));
          case "ParallelN":
            return patch2(self2(parallelNFinalizers(scope2.strategy.parallelism)));
        }
      } else {
        return self2(identity);
      }
    }
  }));
  const scopeWith$1 = (f) => flatMap$7(scopeTag, f);
  const scopedWith$3 = (f) => flatMap$7(scopeMake(), (scope2) => onExit$2(f(scope2), (exit2) => scope2.close(exit2)));
  const scopedEffect = (effect2) => flatMap$7(scopeMake(), (scope2) => scopeUse(effect2, scope2));
  const sequentialFinalizers = (self2) => contextWithEffect((context2) => match$a(getOption(context2, scopeTag), {
    onNone: () => self2,
    onSome: (scope2) => {
      switch (scope2.strategy._tag) {
        case "Sequential":
          return self2;
        case "Parallel":
        case "ParallelN":
          return flatMap$7(scopeFork(scope2, sequential$1), (inner) => scopeExtend(self2, inner));
      }
    }
  }));
  const zipOptions = /* @__PURE__ */ dual((args2) => isEffect$1(args2[1]), (self2, that, options2) => zipWithOptions(self2, that, (a, b) => [a, b], options2));
  const zipLeftOptions = /* @__PURE__ */ dual((args2) => isEffect$1(args2[1]), (self2, that, options2) => {
    if ((options2 == null ? void 0 : options2.concurrent) !== true && ((options2 == null ? void 0 : options2.batching) === void 0 || options2.batching === false)) {
      return zipLeft$1(self2, that);
    }
    return zipWithOptions(self2, that, (a, _) => a, options2);
  });
  const zipRightOptions = /* @__PURE__ */ dual((args2) => isEffect$1(args2[1]), (self2, that, options2) => {
    if ((options2 == null ? void 0 : options2.concurrent) !== true && ((options2 == null ? void 0 : options2.batching) === void 0 || options2.batching === false)) {
      return zipRight$4(self2, that);
    }
    return zipWithOptions(self2, that, (_, b) => b, options2);
  });
  const zipWithOptions = /* @__PURE__ */ dual((args2) => isEffect$1(args2[1]), (self2, that, f, options2) => map$9(all$1([self2, that], {
    concurrency: (options2 == null ? void 0 : options2.concurrent) ? 2 : 1,
    batching: options2 == null ? void 0 : options2.batching,
    concurrentFinalizers: options2 == null ? void 0 : options2.concurrentFinalizers
  }), ([a, a2]) => f(a, a2)));
  const scopeTag = /* @__PURE__ */ GenericTag("effect/Scope");
  const scope$1 = scopeTag;
  const scopeUnsafeAddFinalizer = (scope2, fin) => {
    if (scope2.state._tag === "Open") {
      scope2.state.finalizers.set({}, fin);
    }
  };
  const ScopeImplProto = {
    [ScopeTypeId]: ScopeTypeId,
    [CloseableScopeTypeId]: CloseableScopeTypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    fork(strategy) {
      return sync$5(() => {
        const newScope = scopeUnsafeMake(strategy);
        if (this.state._tag === "Closed") {
          newScope.state = this.state;
          return newScope;
        }
        const key = {};
        const fin = (exit2) => newScope.close(exit2);
        this.state.finalizers.set(key, fin);
        scopeUnsafeAddFinalizer(newScope, (_) => sync$5(() => {
          if (this.state._tag === "Open") {
            this.state.finalizers.delete(key);
          }
        }));
        return newScope;
      });
    },
    close(exit2) {
      return suspend$8(() => {
        if (this.state._tag === "Closed") {
          return void_$4;
        }
        const finalizers = Array.from(this.state.finalizers.values()).reverse();
        this.state = {
          _tag: "Closed",
          exit: exit2
        };
        if (finalizers.length === 0) {
          return void_$4;
        }
        return isSequential(this.strategy) ? pipe(forEachSequential(finalizers, (fin) => exit$1(fin(exit2))), flatMap$7((results) => pipe(exitCollectAll(results), map$h(exitAsVoid), getOrElse(() => exitVoid$1)))) : isParallel(this.strategy) ? pipe(forEachParUnbounded(finalizers, (fin) => exit$1(fin(exit2)), false), flatMap$7((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map$h(exitAsVoid), getOrElse(() => exitVoid$1)))) : pipe(forEachParN(finalizers, this.strategy.parallelism, (fin) => exit$1(fin(exit2)), false), flatMap$7((results) => pipe(exitCollectAll(results, {
          parallel: true
        }), map$h(exitAsVoid), getOrElse(() => exitVoid$1))));
      });
    },
    addFinalizer(fin) {
      return suspend$8(() => {
        if (this.state._tag === "Closed") {
          return fin(this.state.exit);
        }
        this.state.finalizers.set({}, fin);
        return void_$4;
      });
    }
  };
  const scopeUnsafeMake = (strategy = sequential$2) => {
    const scope2 = Object.create(ScopeImplProto);
    scope2.strategy = strategy;
    scope2.state = {
      _tag: "Open",
      finalizers: /* @__PURE__ */ new Map()
    };
    return scope2;
  };
  const scopeMake = (strategy = sequential$2) => sync$5(() => scopeUnsafeMake(strategy));
  const scopeExtend = /* @__PURE__ */ dual(2, (effect2, scope2) => mapInputContext$1(
    effect2,
    // @ts-expect-error
    merge$4(make$Z(scopeTag, scope2))
  ));
  const scopeUse = /* @__PURE__ */ dual(2, (effect2, scope2) => pipe(effect2, scopeExtend(scope2), onExit$2((exit2) => scope2.close(exit2))));
  const fiberRefUnsafeMakeSupervisor = (initial) => fiberRefUnsafeMakePatch(initial, {
    differ,
    fork: empty$a
  });
  const fiberRefLocallyScoped = /* @__PURE__ */ dual(2, (self2, value2) => asVoid$1(acquireRelease$1(flatMap$7(fiberRefGet(self2), (oldValue) => as$1(fiberRefSet(self2, value2), oldValue)), (oldValue) => fiberRefSet(self2, oldValue))));
  const fiberRefLocallyScopedWith = /* @__PURE__ */ dual(2, (self2, f) => fiberRefGetWith(self2, (a) => fiberRefLocallyScoped(self2, f(a))));
  const currentRuntimeFlags = /* @__PURE__ */ fiberRefUnsafeMakeRuntimeFlags(none$1);
  const currentSupervisor = /* @__PURE__ */ fiberRefUnsafeMakeSupervisor(none);
  const raceWith$1 = /* @__PURE__ */ dual(3, (self2, other, options2) => raceFibersWith(self2, other, {
    onSelfWin: (winner, loser) => flatMap$7(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap$7(winner.inheritAll, () => options2.onSelfDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options2.onSelfDone(exit2, loser);
        }
      }
    }),
    onOtherWin: (winner, loser) => flatMap$7(winner.await, (exit2) => {
      switch (exit2._tag) {
        case OP_SUCCESS: {
          return flatMap$7(winner.inheritAll, () => options2.onOtherDone(exit2, loser));
        }
        case OP_FAILURE: {
          return options2.onOtherDone(exit2, loser);
        }
      }
    })
  }));
  const disconnect$1 = (self2) => uninterruptibleMask$2((restore) => fiberIdWith$1((fiberId2) => flatMap$7(forkDaemon$1(restore(self2)), (fiber) => pipe(restore(join$1(fiber)), onInterrupt$1(() => pipe(fiber, interruptAsFork(fiberId2)))))));
  const race$1 = /* @__PURE__ */ dual(2, (self2, that) => fiberIdWith$1((parentFiberId) => raceWith$1(self2, that, {
    onSelfDone: (exit2, right2) => exitMatchEffect(exit2, {
      onFailure: (cause) => pipe(join$1(right2), mapErrorCause$1((cause2) => parallel$3(cause, cause2))),
      onSuccess: (value2) => pipe(right2, interruptAsFiber(parentFiberId), as$1(value2))
    }),
    onOtherDone: (exit2, left2) => exitMatchEffect(exit2, {
      onFailure: (cause) => pipe(join$1(left2), mapErrorCause$1((cause2) => parallel$3(cause2, cause))),
      onSuccess: (value2) => pipe(left2, interruptAsFiber(parentFiberId), as$1(value2))
    })
  })));
  const raceFibersWith = /* @__PURE__ */ dual(3, (self2, other, options2) => withFiberRuntime$1((parentFiber, parentStatus) => {
    const parentRuntimeFlags = parentStatus.runtimeFlags;
    const raceIndicator = make$T(true);
    const leftFiber = unsafeMakeChildFiber(self2, parentFiber, parentRuntimeFlags, options2.selfScope);
    const rightFiber = unsafeMakeChildFiber(other, parentFiber, parentRuntimeFlags, options2.otherScope);
    return async_((cb) => {
      leftFiber.addObserver(() => completeRace(leftFiber, rightFiber, options2.onSelfWin, raceIndicator, cb));
      rightFiber.addObserver(() => completeRace(rightFiber, leftFiber, options2.onOtherWin, raceIndicator, cb));
      leftFiber.startFork(self2);
      rightFiber.startFork(other);
    }, combine$5(leftFiber.id(), rightFiber.id()));
  }));
  const completeRace = (winner, loser, cont, ab, cb) => {
    if (compareAndSet(true, false)(ab)) {
      cb(cont(winner, loser));
    }
  };
  const ensuring$4 = /* @__PURE__ */ dual(2, (self2, finalizer) => uninterruptibleMask$2((restore) => matchCauseEffect$2(restore(self2), {
    onFailure: (cause1) => matchCauseEffect$2(finalizer, {
      onFailure: (cause2) => failCause$8(sequential$3(cause1, cause2)),
      onSuccess: () => failCause$8(cause1)
    }),
    onSuccess: (a) => as$1(finalizer, a)
  })));
  const invokeWithInterrupt = (self2, entries, onInterrupt2) => fiberIdWith$1((id2) => flatMap$7(flatMap$7(forkDaemon$1(interruptible$2(self2)), (processing) => async_((cb) => {
    const counts = entries.map((_) => _.listeners.count);
    const checkDone = () => {
      if (counts.every((count) => count === 0)) {
        if (entries.every((_) => {
          if (_.result.state.current._tag === "Pending") {
            return true;
          } else if (_.result.state.current._tag === "Done" && exitIsExit(_.result.state.current.effect) && _.result.state.current.effect._tag === "Failure" && isInterrupted$2(_.result.state.current.effect.cause)) {
            return true;
          } else {
            return false;
          }
        })) {
          cleanup.forEach((f) => f());
          onInterrupt2 == null ? void 0 : onInterrupt2();
          cb(interruptFiber(processing));
        }
      }
    };
    processing.addObserver((exit2) => {
      cleanup.forEach((f) => f());
      cb(exit2);
    });
    const cleanup = entries.map((r, i) => {
      const observer = (count) => {
        counts[i] = count;
        checkDone();
      };
      r.listeners.addObserver(observer);
      return () => r.listeners.removeObserver(observer);
    });
    checkDone();
    return sync$5(() => {
      cleanup.forEach((f) => f());
    });
  })), () => suspend$8(() => {
    const residual = entries.flatMap((entry) => {
      if (!entry.state.completed) {
        return [entry];
      }
      return [];
    });
    return forEachSequentialDiscard(residual, (entry) => complete(entry.request, exitInterrupt$1(id2)));
  })));
  const makeSpanScoped = (name, options2) => {
    options2 = addSpanStackTrace(options2);
    return uninterruptible$1(withFiberRuntime$1((fiber) => {
      const scope2 = unsafeGet$3(fiber.getFiberRef(currentContext$1), scopeTag);
      const span2 = unsafeMakeSpan(fiber, name, options2);
      const timingEnabled = fiber.getFiberRef(currentTracerTimingEnabled$1);
      const clock_ = get$e(fiber.getFiberRef(currentServices), clockTag);
      return as$1(scopeAddFinalizerExit(scope2, (exit2) => endSpan(span2, exit2, clock_, timingEnabled)), span2);
    }));
  };
  const withTracerScoped = (value2) => fiberRefLocallyScopedWith(currentServices, add$2(tracerTag, value2));
  const withSpanScoped$1 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options2 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return flatMap$7(makeSpanScoped(name, addSpanStackTrace(options2)), (span2) => provideService$1(self2, spanTag, span2));
    }
    return (self2) => flatMap$7(makeSpanScoped(name, addSpanStackTrace(options2)), (span2) => provideService$1(self2, spanTag, span2));
  };
  const empty$9 = empty$h;
  const fail$8 = fail$c;
  const die$4 = die$7;
  const interrupt$3 = interrupt$6;
  const parallel = parallel$3;
  const sequential = sequential$3;
  const isCause = isCause$1;
  const isFailType = isFailType$1;
  const isDieType = isDieType$1;
  const isInterrupted = isInterrupted$2;
  const isInterruptedOnly = isInterruptedOnly$1;
  const interruptors = interruptors$1;
  const failureOrCause = failureOrCause$1;
  const flipCauseOption = flipCauseOption$1;
  const map$7 = map$a;
  const squash = causeSquash;
  const reduceWithContext = reduceWithContext$1;
  const IllegalArgumentException = IllegalArgumentException$1;
  const NoSuchElementException = NoSuchElementException$1;
  const pretty = pretty$1;
  const prettyErrors = prettyErrors$1;
  const IntervalSymbolKey = "effect/ScheduleInterval";
  const IntervalTypeId = /* @__PURE__ */ Symbol.for(IntervalSymbolKey);
  const empty$8 = {
    [IntervalTypeId]: IntervalTypeId,
    startMillis: 0,
    endMillis: 0
  };
  const make$y = (startMillis, endMillis) => {
    if (startMillis > endMillis) {
      return empty$8;
    }
    return {
      [IntervalTypeId]: IntervalTypeId,
      startMillis,
      endMillis
    };
  };
  const lessThan$3 = /* @__PURE__ */ dual(2, (self2, that) => min(self2, that) === self2);
  const min = /* @__PURE__ */ dual(2, (self2, that) => {
    if (self2.endMillis <= that.startMillis) return self2;
    if (that.endMillis <= self2.startMillis) return that;
    if (self2.startMillis < that.startMillis) return self2;
    if (that.startMillis < self2.startMillis) return that;
    if (self2.endMillis <= that.endMillis) return self2;
    return that;
  });
  const isEmpty$1 = (self2) => {
    return self2.startMillis >= self2.endMillis;
  };
  const intersect$4 = /* @__PURE__ */ dual(2, (self2, that) => {
    const start2 = Math.max(self2.startMillis, that.startMillis);
    const end2 = Math.min(self2.endMillis, that.endMillis);
    return make$y(start2, end2);
  });
  const size$4 = (self2) => {
    return millis(self2.endMillis - self2.startMillis);
  };
  const after$1 = (startMilliseconds) => {
    return make$y(startMilliseconds, Number.POSITIVE_INFINITY);
  };
  const make$x = make$y;
  const empty$7 = empty$8;
  const lessThan$2 = lessThan$3;
  const isEmpty = isEmpty$1;
  const intersect$3 = intersect$4;
  const size$3 = size$4;
  const after = after$1;
  const IntervalsSymbolKey = "effect/ScheduleIntervals";
  const IntervalsTypeId = /* @__PURE__ */ Symbol.for(IntervalsSymbolKey);
  const make$w = (intervals) => {
    return {
      [IntervalsTypeId]: IntervalsTypeId,
      intervals
    };
  };
  const intersect$2 = /* @__PURE__ */ dual(2, (self2, that) => intersectLoop(self2.intervals, that.intervals, empty$r()));
  const intersectLoop = (_left, _right, _acc) => {
    let left2 = _left;
    let right2 = _right;
    let acc = _acc;
    while (isNonEmpty$2(left2) && isNonEmpty$2(right2)) {
      const interval = pipe(headNonEmpty(left2), intersect$3(headNonEmpty(right2)));
      const intervals = isEmpty(interval) ? acc : pipe(acc, prepend$1(interval));
      if (pipe(headNonEmpty(left2), lessThan$2(headNonEmpty(right2)))) {
        left2 = tailNonEmpty(left2);
      } else {
        right2 = tailNonEmpty(right2);
      }
      acc = intervals;
    }
    return make$w(reverse$1(acc));
  };
  const start$1 = (self2) => {
    return pipe(self2.intervals, head$3, getOrElse(() => empty$7)).startMillis;
  };
  const end$3 = (self2) => {
    return pipe(self2.intervals, head$3, getOrElse(() => empty$7)).endMillis;
  };
  const lessThan$1 = /* @__PURE__ */ dual(2, (self2, that) => start$1(self2) < start$1(that));
  const isNonEmpty$1 = (self2) => {
    return isNonEmpty$2(self2.intervals);
  };
  const make$v = make$w;
  const intersect$1 = intersect$2;
  const start = start$1;
  const end$2 = end$3;
  const lessThan = lessThan$1;
  const isNonEmpty = isNonEmpty$1;
  const OP_CONTINUE$1 = "Continue";
  const OP_DONE$4 = "Done";
  const _continue$1 = (intervals) => {
    return {
      _tag: OP_CONTINUE$1,
      intervals
    };
  };
  const continueWith$1 = (interval) => {
    return {
      _tag: OP_CONTINUE$1,
      intervals: make$v(of$2(interval))
    };
  };
  const done$4 = {
    _tag: OP_DONE$4
  };
  const isContinue$1 = (self2) => {
    return self2._tag === OP_CONTINUE$1;
  };
  const isDone$2 = (self2) => {
    return self2._tag === OP_DONE$4;
  };
  const _continue = _continue$1;
  const continueWith = continueWith$1;
  const done$3 = done$4;
  const isContinue = isContinue$1;
  const isDone$1 = isDone$2;
  const Scope = scopeTag;
  const addFinalizer$1 = scopeAddFinalizer;
  const addFinalizerExit = scopeAddFinalizerExit;
  const close = scopeClose;
  const extend$1 = scopeExtend;
  const fork$1 = scopeFork;
  const make$u = scopeMake;
  const Class$2 = Structural;
  const Error$1 = /* @__PURE__ */ function() {
    const plainArgsSymbol = /* @__PURE__ */ Symbol.for("effect/Data/Error/plainArgs");
    const O = {
      BaseEffectError: class extends YieldableError {
        constructor(args2) {
          super(args2 == null ? void 0 : args2.message, (args2 == null ? void 0 : args2.cause) ? {
            cause: args2.cause
          } : void 0);
          if (args2) {
            Object.assign(this, args2);
            Object.defineProperty(this, plainArgsSymbol, {
              value: args2,
              enumerable: false
            });
          }
        }
        toJSON() {
          return {
            ...this[plainArgsSymbol],
            ...this
          };
        }
      }
    };
    return O.BaseEffectError;
  }();
  const TaggedError$1 = (tag2) => {
    const O = {
      BaseEffectError: class extends Error$1 {
        constructor() {
          super(...arguments);
          __publicField(this, "_tag", tag2);
        }
      }
    };
    O.BaseEffectError.prototype.name = tag2;
    return O.BaseEffectError;
  };
  const ScheduleSymbolKey = "effect/Schedule";
  const ScheduleTypeId = /* @__PURE__ */ Symbol.for(ScheduleSymbolKey);
  const isSchedule = (u) => hasProperty(u, ScheduleTypeId);
  const ScheduleDriverSymbolKey = "effect/ScheduleDriver";
  const ScheduleDriverTypeId = /* @__PURE__ */ Symbol.for(ScheduleDriverSymbolKey);
  const scheduleVariance = {
    /* c8 ignore next */
    _Out: (_) => _,
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _R: (_) => _
  };
  const scheduleDriverVariance = {
    /* c8 ignore next */
    _Out: (_) => _,
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _R: (_) => _
  };
  _U = ScheduleTypeId;
  class ScheduleImpl {
    constructor(initial, step2) {
      __publicField(this, "initial");
      __publicField(this, "step");
      __publicField(this, _U, scheduleVariance);
      this.initial = initial;
      this.step = step2;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  _V = ScheduleDriverTypeId;
  class ScheduleDriverImpl {
    constructor(schedule, ref) {
      __publicField(this, "schedule");
      __publicField(this, "ref");
      __publicField(this, _V, scheduleDriverVariance);
      this.schedule = schedule;
      this.ref = ref;
    }
    get state() {
      return map$9(get$6(this.ref), (tuple) => tuple[1]);
    }
    get last() {
      return flatMap$7(get$6(this.ref), ([element, _]) => {
        switch (element._tag) {
          case "None": {
            return failSync$1(() => new NoSuchElementException$1());
          }
          case "Some": {
            return succeed$a(element.value);
          }
        }
      });
    }
    get reset() {
      return set$6(this.ref, [none$4(), this.schedule.initial]);
    }
    next(input) {
      return pipe(map$9(get$6(this.ref), (tuple) => tuple[1]), flatMap$7((state2) => pipe(currentTimeMillis, flatMap$7((now) => pipe(suspend$8(() => this.schedule.step(now, input, state2)), flatMap$7(([state3, out, decision]) => {
        const setState = set$6(this.ref, [some(out), state3]);
        if (isDone$1(decision)) {
          return zipRight$4(setState, fail$b(none$4()));
        }
        const millis$1 = start(decision.intervals) - now;
        if (millis$1 <= 0) {
          return as$1(setState, out);
        }
        return pipe(setState, zipRight$4(sleep$1(millis(millis$1))), as$1(out));
      }))))));
    }
  }
  const makeWithState = (initial, step2) => new ScheduleImpl(initial, step2);
  const addDelay = /* @__PURE__ */ dual(2, (self2, f) => addDelayEffect(self2, (out) => sync$5(() => f(out))));
  const addDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => modifyDelayEffect(self2, (out, duration) => map$9(f(out), (delay2) => sum(duration, decode$3(delay2)))));
  const check = /* @__PURE__ */ dual(2, (self2, test) => checkEffect(self2, (input, out) => sync$5(() => test(input, out))));
  const checkEffect = /* @__PURE__ */ dual(2, (self2, test) => makeWithState(self2.initial, (now, input, state2) => flatMap$7(self2.step(now, input, state2), ([state3, out, decision]) => {
    if (isDone$1(decision)) {
      return succeed$a([state3, out, done$3]);
    }
    return map$9(test(input, out), (cont) => cont ? [state3, out, decision] : [state3, out, done$3]);
  })));
  const delayedSchedule = (schedule) => addDelay(schedule, (x) => x);
  const driver = (self2) => pipe(make$H([none$4(), self2.initial]), map$9((ref) => new ScheduleDriverImpl(self2, ref)));
  const exponential$1 = (baseInput, factor = 2) => {
    const base = decode$3(baseInput);
    return delayedSchedule(map$6(forever$1, (i) => times(base, Math.pow(factor, i))));
  };
  const intersect = /* @__PURE__ */ dual(2, (self2, that) => intersectWith(self2, that, intersect$1));
  const intersectWith = /* @__PURE__ */ dual(3, (self2, that, f) => makeWithState([self2.initial, that.initial], (now, input, state2) => pipe(zipWith$2(self2.step(now, input, state2[0]), that.step(now, input, state2[1]), (a, b) => [a, b]), flatMap$7(([[lState, out, lDecision], [rState, out2, rDecision]]) => {
    if (isContinue(lDecision) && isContinue(rDecision)) {
      return intersectWithLoop(self2, that, input, lState, out, lDecision.intervals, rState, out2, rDecision.intervals, f);
    }
    return succeed$a([[lState, rState], [out, out2], done$3]);
  }))));
  const intersectWithLoop = (self2, that, input, lState, out, lInterval, rState, out2, rInterval, f) => {
    const combined = f(lInterval, rInterval);
    if (isNonEmpty(combined)) {
      return succeed$a([[lState, rState], [out, out2], _continue(combined)]);
    }
    if (pipe(lInterval, lessThan(rInterval))) {
      return flatMap$7(self2.step(end$2(lInterval), input, lState), ([lState2, out3, decision]) => {
        if (isDone$1(decision)) {
          return succeed$a([[lState2, rState], [out3, out2], done$3]);
        }
        return intersectWithLoop(self2, that, input, lState2, out3, decision.intervals, rState, out2, rInterval, f);
      });
    }
    return flatMap$7(that.step(end$2(rInterval), input, rState), ([rState2, out22, decision]) => {
      if (isDone$1(decision)) {
        return succeed$a([[lState, rState2], [out, out22], done$3]);
      }
      return intersectWithLoop(self2, that, input, lState, out, lInterval, rState2, out22, decision.intervals, f);
    });
  };
  const map$6 = /* @__PURE__ */ dual(2, (self2, f) => mapEffect$1(self2, (out) => sync$5(() => f(out))));
  const mapEffect$1 = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state2) => flatMap$7(self2.step(now, input, state2), ([state3, out, decision]) => map$9(f(out), (out2) => [state3, out2, decision]))));
  const modifyDelayEffect = /* @__PURE__ */ dual(2, (self2, f) => makeWithState(self2.initial, (now, input, state2) => flatMap$7(self2.step(now, input, state2), ([state3, out, decision]) => {
    if (isDone$1(decision)) {
      return succeed$a([state3, out, decision]);
    }
    const intervals = decision.intervals;
    const delay2 = size$3(make$x(now, start(intervals)));
    return map$9(f(out, delay2), (durationInput) => {
      const duration = decode$3(durationInput);
      const oldStart = start(intervals);
      const newStart = now + toMillis(duration);
      const delta = newStart - oldStart;
      const newEnd = Math.max(0, end$2(intervals) + delta);
      const newInterval = make$x(newStart, newEnd);
      return [state3, out, continueWith(newInterval)];
    });
  })));
  const passthrough = (self2) => makeWithState(self2.initial, (now, input, state2) => pipe(self2.step(now, input, state2), map$9(([state3, _, decision]) => [state3, input, decision])));
  const recurs = (n) => whileOutput(forever$1, (out) => out < n);
  const unfold = (initial, f) => makeWithState(initial, (now, _, state2) => sync$5(() => [f(state2), state2, continueWith(after(now))]));
  const untilInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => negate(f(input))));
  const whileInputEffect = /* @__PURE__ */ dual(2, (self2, f) => checkEffect(self2, (input, _) => f(input)));
  const whileOutput = /* @__PURE__ */ dual(2, (self2, f) => check(self2, (_, out) => f(out)));
  const ScheduleDefectTypeId = /* @__PURE__ */ Symbol.for("effect/Schedule/ScheduleDefect");
  _W = ScheduleDefectTypeId;
  class ScheduleDefect {
    constructor(error) {
      __publicField(this, "error");
      __publicField(this, _W);
      this.error = error;
      this[ScheduleDefectTypeId] = ScheduleDefectTypeId;
    }
  }
  const isScheduleDefect = (u) => hasProperty(u, ScheduleDefectTypeId);
  const scheduleDefectWrap = (self2) => catchAll$3(self2, (e) => die$6(new ScheduleDefect(e)));
  const scheduleDefectRefail = (self2) => catchAllCause$2(self2, (cause) => match$a(find(cause, (_) => isDieType$1(_) && isScheduleDefect(_.defect) ? some(_.defect) : none$4()), {
    onNone: () => failCause$8(cause),
    onSome: (error) => fail$b(error.error)
  }));
  const repeat_Effect = /* @__PURE__ */ dual(2, (self2, schedule) => repeatOrElse_Effect(self2, schedule, (e, _) => fail$b(e)));
  const repeat_combined = /* @__PURE__ */ dual(2, (self2, options2) => {
    if (isSchedule(options2)) {
      return repeat_Effect(self2, options2);
    }
    const base = options2.schedule ?? passthrough(forever$1);
    const withWhile = options2.while ? whileInputEffect(base, (a) => {
      const applied = options2.while(a);
      if (typeof applied === "boolean") {
        return succeed$a(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options2.until ? untilInputEffect(withWhile, (a) => {
      const applied = options2.until(a);
      if (typeof applied === "boolean") {
        return succeed$a(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options2.times ? intersect(withUntil, recurs(options2.times)).pipe(map$6((intersectionPair) => intersectionPair[0])) : withUntil;
    return scheduleDefectRefail(repeat_Effect(self2, withTimes));
  });
  const repeatOrElse_Effect = /* @__PURE__ */ dual(3, (self2, schedule, orElse2) => flatMap$7(driver(schedule), (driver2) => matchEffect(self2, {
    onFailure: (error) => orElse2(error, none$4()),
    onSuccess: (value2) => repeatOrElseEffectLoop(self2, driver2, orElse2, value2)
  })));
  const repeatOrElseEffectLoop = (self2, driver2, orElse2, value2) => {
    return matchEffect(driver2.next(value2), {
      onFailure: () => orDie$3(driver2.last),
      onSuccess: (b) => matchEffect(self2, {
        onFailure: (error) => orElse2(error, some(b)),
        onSuccess: (value3) => repeatOrElseEffectLoop(self2, driver2, orElse2, value3)
      })
    });
  };
  const retry_Effect = /* @__PURE__ */ dual(2, (self2, policy) => retryOrElse_Effect(self2, policy, (e, _) => fail$b(e)));
  const retry_combined = /* @__PURE__ */ dual(2, (self2, options2) => {
    if (isSchedule(options2)) {
      return retry_Effect(self2, options2);
    }
    const base = options2.schedule ?? forever$1;
    const withWhile = options2.while ? whileInputEffect(base, (e) => {
      const applied = options2.while(e);
      if (typeof applied === "boolean") {
        return succeed$a(applied);
      }
      return scheduleDefectWrap(applied);
    }) : base;
    const withUntil = options2.until ? untilInputEffect(withWhile, (e) => {
      const applied = options2.until(e);
      if (typeof applied === "boolean") {
        return succeed$a(applied);
      }
      return scheduleDefectWrap(applied);
    }) : withWhile;
    const withTimes = options2.times ? intersect(withUntil, recurs(options2.times)) : withUntil;
    return scheduleDefectRefail(retry_Effect(self2, withTimes));
  });
  const retryOrElse_Effect = /* @__PURE__ */ dual(3, (self2, policy, orElse2) => flatMap$7(driver(policy), (driver2) => retryOrElse_EffectLoop(self2, driver2, orElse2)));
  const retryOrElse_EffectLoop = (self2, driver2, orElse2) => {
    return catchAll$3(self2, (e) => matchEffect(driver2.next(e), {
      onFailure: () => pipe(driver2.last, orDie$3, flatMap$7((out) => orElse2(e, out))),
      onSuccess: () => retryOrElse_EffectLoop(self2, driver2, orElse2)
    }));
  };
  const forever$1 = /* @__PURE__ */ unfold(0, (n) => n + 1);
  class Semaphore {
    constructor(permits) {
      __publicField(this, "permits");
      __publicField(this, "waiters", /* @__PURE__ */ new Set());
      __publicField(this, "taken", 0);
      __publicField(this, "take", (n) => asyncInterrupt((resume2) => {
        if (this.free < n) {
          const observer = () => {
            if (this.free < n) {
              return;
            }
            this.waiters.delete(observer);
            this.taken += n;
            resume2(succeed$a(n));
          };
          this.waiters.add(observer);
          return sync$5(() => {
            this.waiters.delete(observer);
          });
        }
        this.taken += n;
        return resume2(succeed$a(n));
      }));
      __publicField(this, "updateTaken", (f) => withFiberRuntime$1((fiber) => {
        this.taken = f(this.taken);
        if (this.waiters.size > 0) {
          fiber.getFiberRef(currentScheduler$1).scheduleTask(() => {
            const iter = this.waiters.values();
            let item = iter.next();
            while (item.done === false && this.free > 0) {
              item.value();
              item = iter.next();
            }
          }, fiber.getFiberRef(currentSchedulingPriority$1));
        }
        return succeed$a(this.free);
      }));
      __publicField(this, "release", (n) => this.updateTaken((taken) => taken - n));
      __publicField(this, "releaseAll", /* @__PURE__ */ this.updateTaken((_) => 0));
      __publicField(this, "withPermits", (n) => (self2) => uninterruptibleMask$2((restore) => flatMap$7(restore(this.take(n)), (permits) => ensuring$4(restore(self2), this.release(permits)))));
      __publicField(this, "withPermitsIfAvailable", (n) => (self2) => uninterruptibleMask$2((restore) => suspend$8(() => {
        if (this.free < n) {
          return succeedNone;
        }
        this.taken += n;
        return ensuring$4(restore(asSome(self2)), this.release(n));
      })));
      this.permits = permits;
    }
    get free() {
      return this.permits - this.taken;
    }
  }
  const unsafeMakeSemaphore = (permits) => new Semaphore(permits);
  const makeSemaphore$1 = (permits) => sync$5(() => unsafeMakeSemaphore(permits));
  class Latch extends Class$4 {
    constructor(isOpen) {
      super();
      __publicField(this, "isOpen");
      __publicField(this, "waiters", []);
      __publicField(this, "scheduled", false);
      __publicField(this, "flushWaiters", () => {
        this.scheduled = false;
        const waiters = this.waiters;
        this.waiters = [];
        for (let i = 0; i < waiters.length; i++) {
          waiters[i](exitVoid$1);
        }
      });
      __publicField(this, "open", /* @__PURE__ */ withFiberRuntime$1((fiber) => {
        if (this.isOpen) {
          return void_$4;
        }
        this.isOpen = true;
        return this.unsafeSchedule(fiber);
      }));
      __publicField(this, "release", /* @__PURE__ */ withFiberRuntime$1((fiber) => {
        if (this.isOpen) {
          return void_$4;
        }
        return this.unsafeSchedule(fiber);
      }));
      __publicField(this, "await", /* @__PURE__ */ asyncInterrupt((resume2) => {
        if (this.isOpen) {
          return resume2(void_$4);
        }
        this.waiters.push(resume2);
        return sync$5(() => {
          const index = this.waiters.indexOf(resume2);
          if (index !== -1) {
            this.waiters.splice(index, 1);
          }
        });
      }));
      __publicField(this, "close", /* @__PURE__ */ sync$5(() => {
        this.isOpen = false;
      }));
      __publicField(this, "whenOpen", (self2) => {
        return zipRight$4(this.await, self2);
      });
      this.isOpen = isOpen;
    }
    commit() {
      return this.await;
    }
    unsafeSchedule(fiber) {
      if (this.scheduled || this.waiters.length === 0) {
        return void_$4;
      }
      this.scheduled = true;
      fiber.currentScheduler.scheduleTask(this.flushWaiters, fiber.getFiberRef(currentSchedulingPriority$1));
      return void_$4;
    }
    unsafeOpen() {
      if (this.isOpen) return;
      this.isOpen = true;
      this.flushWaiters();
    }
    unsafeClose() {
      this.isOpen = false;
    }
  }
  const unsafeMakeLatch$1 = (open) => new Latch(open ?? false);
  const makeLatch$1 = (open) => sync$5(() => unsafeMakeLatch$1(open));
  const forkIn$1 = /* @__PURE__ */ dual(2, (self2, scope2) => withFiberRuntime$1((parent, parentStatus) => {
    const scopeImpl = scope2;
    const fiber = unsafeFork$1(self2, parent, parentStatus.runtimeFlags, globalScope);
    if (scopeImpl.state._tag === "Open") {
      const finalizer = () => fiberIdWith$1((fiberId2) => equals$1(fiberId2, fiber.id()) ? void_$4 : asVoid$1(interruptFiber(fiber)));
      const key = {};
      scopeImpl.state.finalizers.set(key, finalizer);
      fiber.addObserver(() => {
        if (scopeImpl.state._tag === "Closed") return;
        scopeImpl.state.finalizers.delete(key);
      });
    } else {
      fiber.unsafeInterruptAsFork(parent.id());
    }
    return succeed$a(fiber);
  }));
  const forkScoped$1 = (self2) => scopeWith$1((scope2) => forkIn$1(self2, scope2));
  const raceFirst$1 = /* @__PURE__ */ dual(2, (self2, that) => pipe(exit$1(self2), race$1(exit$1(that)), (effect2) => flatten$5(effect2)));
  const timeout$1 = /* @__PURE__ */ dual(2, (self2, duration) => timeoutFail(self2, {
    onTimeout: () => timeoutExceptionFromDuration(duration),
    duration
  }));
  const timeoutFail = /* @__PURE__ */ dual(2, (self2, {
    duration,
    onTimeout
  }) => flatten$5(timeoutTo(self2, {
    onTimeout: () => failSync$1(onTimeout),
    onSuccess: succeed$a,
    duration
  })));
  const timeoutTo = /* @__PURE__ */ dual(2, (self2, {
    duration,
    onSuccess,
    onTimeout
  }) => fiberIdWith$1((parentFiberId) => uninterruptibleMask$2((restore) => raceFibersWith(restore(self2), interruptible$2(sleep$1(duration)), {
    onSelfWin: (winner, loser) => flatMap$7(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap$7(winner.inheritAll, () => as$1(interruptAsFiber(loser, parentFiberId), onSuccess(exit2.value)));
      } else {
        return flatMap$7(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit2.cause));
      }
    }),
    onOtherWin: (winner, loser) => flatMap$7(winner.await, (exit2) => {
      if (exit2._tag === "Success") {
        return flatMap$7(winner.inheritAll, () => as$1(interruptAsFiber(loser, parentFiberId), onTimeout()));
      } else {
        return flatMap$7(interruptAsFiber(loser, parentFiberId), () => exitFailCause$1(exit2.cause));
      }
    }),
    otherScope: globalScope
  }))));
  const SynchronizedSymbolKey = "effect/Ref/SynchronizedRef";
  const SynchronizedTypeId = /* @__PURE__ */ Symbol.for(SynchronizedSymbolKey);
  const synchronizedVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  class SynchronizedImpl extends (__ = Class$4, _Z = SynchronizedTypeId, _Y = RefTypeId$1, _X = TypeId$i, __) {
    constructor(ref, withLock) {
      super();
      __publicField(this, "ref");
      __publicField(this, "withLock");
      __publicField(this, _Z, synchronizedVariance);
      __publicField(this, _Y, refVariance);
      __publicField(this, _X, TypeId$i);
      __publicField(this, "get");
      this.ref = ref;
      this.withLock = withLock;
      this.get = get$6(this.ref);
    }
    commit() {
      return this.get;
    }
    modify(f) {
      return this.modifyEffect((a) => succeed$a(f(a)));
    }
    modifyEffect(f) {
      return this.withLock(pipe(flatMap$7(get$6(this.ref), f), flatMap$7(([b, a]) => as$1(set$6(this.ref, a), b))));
    }
  }
  const makeSynchronized = (value2) => sync$5(() => unsafeMakeSynchronized(value2));
  const unsafeMakeSynchronized = (value2) => {
    const ref = unsafeMake$7(value2);
    const sem = unsafeMakeSemaphore(1);
    return new SynchronizedImpl(ref, sem.withPermits(1));
  };
  const TypeId$g = /* @__PURE__ */ Symbol.for("effect/ManagedRuntime");
  const OP_FOLD$1 = "Fold";
  const OP_FRESH = "Fresh";
  const OP_FROM_EFFECT$2 = "FromEffect";
  const OP_SCOPED = "Scoped";
  const OP_SUSPEND$2 = "Suspend";
  const OP_PROVIDE$2 = "Provide";
  const OP_PROVIDE_MERGE = "ProvideMerge";
  const OP_ZIP_WITH = "ZipWith";
  const _await = _await$1;
  const getCurrentFiber = getCurrentFiber$1;
  const inheritAll = inheritAll$1;
  const interrupt$2 = interruptFiber;
  const interruptAs$1 = interruptAsFiber;
  const interruptAllAs = interruptAllAs$1;
  const join = join$1;
  const makeDual = (f) => function() {
    if (arguments.length === 1) {
      const runtime2 = arguments[0];
      return (effect2, ...args2) => f(runtime2, effect2, ...args2);
    }
    return f.apply(this, arguments);
  };
  const unsafeFork = /* @__PURE__ */ makeDual((runtime2, self2, options2) => {
    const fiberId2 = unsafeMake$a();
    const fiberRefUpdates = [[currentContext$1, [[fiberId2, runtime2.context]]]];
    if (options2 == null ? void 0 : options2.scheduler) {
      fiberRefUpdates.push([currentScheduler$1, [[fiberId2, options2.scheduler]]]);
    }
    let fiberRefs2 = updateManyAs(runtime2.fiberRefs, {
      entries: fiberRefUpdates,
      forkAs: fiberId2
    });
    if (options2 == null ? void 0 : options2.updateRefs) {
      fiberRefs2 = options2.updateRefs(fiberRefs2, fiberId2);
    }
    const fiberRuntime = new FiberRuntime(fiberId2, fiberRefs2, runtime2.runtimeFlags);
    let effect2 = self2;
    if (options2 == null ? void 0 : options2.scope) {
      effect2 = flatMap$7(fork$1(options2.scope, sequential$2), (closeableScope) => zipRight$4(scopeAddFinalizer(closeableScope, fiberIdWith$1((id2) => equals$1(id2, fiberRuntime.id()) ? void_$4 : interruptAsFiber(fiberRuntime, id2))), onExit$2(self2, (exit2) => close(closeableScope, exit2))));
    }
    const supervisor = fiberRuntime.currentSupervisor;
    if (supervisor !== none) {
      supervisor.onStart(runtime2.context, effect2, none$4(), fiberRuntime);
      fiberRuntime.addObserver((exit2) => supervisor.onEnd(exit2, fiberRuntime));
    }
    globalScope.add(runtime2.runtimeFlags, fiberRuntime);
    if ((options2 == null ? void 0 : options2.immediate) === false) {
      fiberRuntime.resume(effect2);
    } else {
      fiberRuntime.start(effect2);
    }
    return fiberRuntime;
  });
  const unsafeRunSync = /* @__PURE__ */ makeDual((runtime2, effect2) => {
    const result = unsafeRunSyncExit(runtime2)(effect2);
    if (result._tag === "Failure") {
      throw fiberFailure(result.effect_instruction_i0);
    }
    return result.effect_instruction_i0;
  });
  class AsyncFiberExceptionImpl extends Error {
    constructor(fiber) {
      super(`Fiber #${fiber.id().id} cannot be resolved synchronously. This is caused by using runSync on an effect that performs async work`);
      __publicField(this, "fiber");
      __publicField(this, "_tag", "AsyncFiberException");
      this.fiber = fiber;
      this.name = this._tag;
      this.stack = this.message;
    }
  }
  const asyncFiberException = (fiber) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new AsyncFiberExceptionImpl(fiber);
    Error.stackTraceLimit = limit;
    return error;
  };
  const FiberFailureId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure");
  const FiberFailureCauseId = /* @__PURE__ */ Symbol.for("effect/Runtime/FiberFailure/Cause");
  class FiberFailureImpl extends Error {
    constructor(cause) {
      const head2 = prettyErrors$1(cause)[0];
      super((head2 == null ? void 0 : head2.message) || "An error has occurred");
      __publicField(this, _aa);
      __publicField(this, _$);
      this[FiberFailureId] = FiberFailureId;
      this[FiberFailureCauseId] = cause;
      this.name = head2 ? `(FiberFailure) ${head2.name}` : "FiberFailure";
      if (head2 == null ? void 0 : head2.stack) {
        this.stack = head2.stack;
      }
    }
    toJSON() {
      return {
        _id: "FiberFailure",
        cause: this[FiberFailureCauseId].toJSON()
      };
    }
    toString() {
      return "(FiberFailure) " + pretty$1(this[FiberFailureCauseId], {
        renderErrorCause: true
      });
    }
    [(_aa = FiberFailureId, _$ = FiberFailureCauseId, NodeInspectSymbol)]() {
      return this.toString();
    }
  }
  const fiberFailure = (cause) => {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 0;
    const error = new FiberFailureImpl(cause);
    Error.stackTraceLimit = limit;
    return error;
  };
  const fastPath = (effect2) => {
    const op = effect2;
    switch (op._op) {
      case "Failure":
      case "Success": {
        return op;
      }
      case "Left": {
        return exitFail(op.left);
      }
      case "Right": {
        return exitSucceed$1(op.right);
      }
      case "Some": {
        return exitSucceed$1(op.value);
      }
      case "None": {
        return exitFail(NoSuchElementException$1());
      }
    }
  };
  const unsafeRunSyncExit = /* @__PURE__ */ makeDual((runtime2, effect2) => {
    const op = fastPath(effect2);
    if (op) {
      return op;
    }
    const scheduler = new SyncScheduler();
    const fiberRuntime = unsafeFork(runtime2)(effect2, {
      scheduler
    });
    scheduler.flush();
    const result = fiberRuntime.unsafePoll();
    if (result) {
      return result;
    }
    return exitDie$1(capture(asyncFiberException(fiberRuntime), currentSpanFromFiber(fiberRuntime)));
  });
  const unsafeRunPromise = /* @__PURE__ */ makeDual((runtime2, effect2, options2) => unsafeRunPromiseExit(runtime2, effect2, options2).then((result) => {
    switch (result._tag) {
      case OP_SUCCESS: {
        return result.effect_instruction_i0;
      }
      case OP_FAILURE: {
        throw fiberFailure(result.effect_instruction_i0);
      }
    }
  }));
  const unsafeRunPromiseExit = /* @__PURE__ */ makeDual((runtime2, effect2, options2) => new Promise((resolve) => {
    const op = fastPath(effect2);
    if (op) {
      resolve(op);
    }
    const fiber = unsafeFork(runtime2)(effect2);
    fiber.addObserver((exit2) => {
      resolve(exit2);
    });
    if ((options2 == null ? void 0 : options2.signal) !== void 0) {
      if (options2.signal.aborted) {
        fiber.unsafeInterruptAsFork(fiber.id());
      } else {
        options2.signal.addEventListener("abort", () => {
          fiber.unsafeInterruptAsFork(fiber.id());
        }, {
          once: true
        });
      }
    }
  }));
  class RuntimeImpl {
    constructor(context2, runtimeFlags2, fiberRefs2) {
      __publicField(this, "context");
      __publicField(this, "runtimeFlags");
      __publicField(this, "fiberRefs");
      this.context = context2;
      this.runtimeFlags = runtimeFlags2;
      this.fiberRefs = fiberRefs2;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const make$t = (options2) => new RuntimeImpl(options2.context, options2.runtimeFlags, options2.fiberRefs);
  const runtime$1 = () => withFiberRuntime$1((state2, status) => succeed$a(new RuntimeImpl(state2.getFiberRef(currentContext$1), status.runtimeFlags, state2.getFiberRefs())));
  const defaultRuntimeFlags = /* @__PURE__ */ make$O(Interruption, CooperativeYielding, RuntimeMetrics);
  const defaultRuntime = /* @__PURE__ */ make$t({
    context: /* @__PURE__ */ empty$s(),
    runtimeFlags: defaultRuntimeFlags,
    fiberRefs: /* @__PURE__ */ empty$c()
  });
  const updateContext$1 = /* @__PURE__ */ dual(2, (self2, f) => make$t({
    context: f(self2.context),
    runtimeFlags: self2.runtimeFlags,
    fiberRefs: self2.fiberRefs
  }));
  const unsafeForkEffect = /* @__PURE__ */ unsafeFork(defaultRuntime);
  const unsafeRunPromiseEffect = /* @__PURE__ */ unsafeRunPromise(defaultRuntime);
  const unsafeRunSyncEffect = /* @__PURE__ */ unsafeRunSync(defaultRuntime);
  const modifyEffect = /* @__PURE__ */ dual(2, (self2, f) => self2.modifyEffect(f));
  const LayerSymbolKey = "effect/Layer";
  const LayerTypeId = /* @__PURE__ */ Symbol.for(LayerSymbolKey);
  const layerVariance = {
    /* c8 ignore next */
    _RIn: (_) => _,
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _ROut: (_) => _
  };
  const proto$9 = {
    [LayerTypeId]: layerVariance,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const MemoMapTypeIdKey = "effect/Layer/MemoMap";
  const MemoMapTypeId = /* @__PURE__ */ Symbol.for(MemoMapTypeIdKey);
  const CurrentMemoMap = /* @__PURE__ */ Reference()("effect/Layer/CurrentMemoMap", {
    defaultValue: () => unsafeMakeMemoMap()
  });
  const isLayer$1 = (u) => hasProperty(u, LayerTypeId);
  const isFresh = (self2) => {
    return self2._op_layer === OP_FRESH;
  };
  _ba = MemoMapTypeId;
  class MemoMapImpl {
    constructor(ref) {
      __publicField(this, "ref");
      __publicField(this, _ba);
      this.ref = ref;
      this[MemoMapTypeId] = MemoMapTypeId;
    }
    /**
     * Checks the memo map to see if a layer exists. If it is, immediately
     * returns it. Otherwise, obtains the layer, stores it in the memo map,
     * and adds a finalizer to the `Scope`.
     */
    getOrElseMemoize(layer2, scope2) {
      return pipe(modifyEffect(this.ref, (map2) => {
        const inMap = map2.get(layer2);
        if (inMap !== void 0) {
          const [acquire, release] = inMap;
          const cached2 = pipe(acquire, flatMap$7(([patch2, b]) => pipe(patchFiberRefs(patch2), as$1(b))), onExit$2(exitMatch({
            onFailure: () => void_$4,
            onSuccess: () => scopeAddFinalizerExit(scope2, release)
          })));
          return succeed$a([cached2, map2]);
        }
        return pipe(make$H(0), flatMap$7((observers) => pipe(deferredMake(), flatMap$7((deferred) => pipe(make$H(() => void_$4), map$9((finalizerRef) => {
          const resource = uninterruptibleMask$2((restore) => pipe(scopeMake(), flatMap$7((innerScope) => pipe(restore(flatMap$7(makeBuilder(layer2, innerScope, true), (f) => diffFiberRefs(f(this)))), exit$1, flatMap$7((exit2) => {
            switch (exit2._tag) {
              case OP_FAILURE: {
                return pipe(deferredFailCause(deferred, exit2.effect_instruction_i0), zipRight$4(scopeClose(innerScope, exit2)), zipRight$4(failCause$8(exit2.effect_instruction_i0)));
              }
              case OP_SUCCESS: {
                return pipe(set$6(finalizerRef, (exit3) => pipe(scopeClose(innerScope, exit3), whenEffect(modify$2(observers, (n) => [n === 1, n - 1])), asVoid$1)), zipRight$4(update$4(observers, (n) => n + 1)), zipRight$4(scopeAddFinalizerExit(scope2, (exit3) => pipe(sync$5(() => map2.delete(layer2)), zipRight$4(get$6(finalizerRef)), flatMap$7((finalizer) => finalizer(exit3))))), zipRight$4(deferredSucceed(deferred, exit2.effect_instruction_i0)), as$1(exit2.effect_instruction_i0[1]));
              }
            }
          })))));
          const memoized = [pipe(deferredAwait(deferred), onExit$2(exitMatchEffect({
            onFailure: () => void_$4,
            onSuccess: () => update$4(observers, (n) => n + 1)
          }))), (exit2) => pipe(get$6(finalizerRef), flatMap$7((finalizer) => finalizer(exit2)))];
          return [resource, isFresh(layer2) ? map2 : map2.set(layer2, memoized)];
        }))))));
      }), flatten$5);
    }
  }
  const makeMemoMap = /* @__PURE__ */ suspend$8(() => map$9(makeSynchronized(/* @__PURE__ */ new Map()), (ref) => new MemoMapImpl(ref)));
  const unsafeMakeMemoMap = () => new MemoMapImpl(unsafeMakeSynchronized(/* @__PURE__ */ new Map()));
  const buildWithScope$1 = /* @__PURE__ */ dual(2, (self2, scope2) => flatMap$7(makeMemoMap, (memoMap) => buildWithMemoMap(self2, memoMap, scope2)));
  const buildWithMemoMap = /* @__PURE__ */ dual(3, (self2, memoMap, scope2) => flatMap$7(makeBuilder(self2, scope2), (run2) => provideService$1(run2(memoMap), CurrentMemoMap, memoMap)));
  const makeBuilder = (self2, scope2, inMemoMap = false) => {
    const op = self2;
    switch (op._op_layer) {
      case "Locally": {
        return sync$5(() => (memoMap) => op.f(memoMap.getOrElseMemoize(op.self, scope2)));
      }
      case "ExtendScope": {
        return sync$5(() => (memoMap) => scopeWith$1((scope3) => memoMap.getOrElseMemoize(op.layer, scope3)));
      }
      case "Fold": {
        return sync$5(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.layer, scope2), matchCauseEffect$2({
          onFailure: (cause) => memoMap.getOrElseMemoize(op.failureK(cause), scope2),
          onSuccess: (value2) => memoMap.getOrElseMemoize(op.successK(value2), scope2)
        })));
      }
      case "Fresh": {
        return sync$5(() => (_) => pipe(op.layer, buildWithScope$1(scope2)));
      }
      case "FromEffect": {
        return inMemoMap ? sync$5(() => (_) => op.effect) : sync$5(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
      }
      case "Provide": {
        return sync$5(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), flatMap$7((env2) => pipe(memoMap.getOrElseMemoize(op.second, scope2), provideContext$4(env2)))));
      }
      case "Scoped": {
        return inMemoMap ? sync$5(() => (_) => scopeExtend(op.effect, scope2)) : sync$5(() => (memoMap) => memoMap.getOrElseMemoize(self2, scope2));
      }
      case "Suspend": {
        return sync$5(() => (memoMap) => memoMap.getOrElseMemoize(op.evaluate(), scope2));
      }
      case "ProvideMerge": {
        return sync$5(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWith$2(memoMap.getOrElseMemoize(op.second, scope2), op.zipK)));
      }
      case "ZipWith": {
        return sync$5(() => (memoMap) => pipe(memoMap.getOrElseMemoize(op.first, scope2), zipWithOptions(memoMap.getOrElseMemoize(op.second, scope2), op.zipK, {
          concurrent: true
        })));
      }
    }
  };
  const context$2 = () => fromEffectContext(context$3());
  const fail$7 = (error) => failCause$4(fail$8(error));
  const failCause$4 = (cause) => fromEffectContext(failCause$8(cause));
  const flatMap$5 = /* @__PURE__ */ dual(2, (self2, f) => match$3(self2, {
    onFailure: fail$7,
    onSuccess: f
  }));
  const fromEffect$4 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag(a);
    const tag2 = tagFirst ? a : b;
    const effect2 = tagFirst ? b : a;
    return fromEffectContext(map$9(effect2, (service) => make$Z(tag2, service)));
  });
  function fromEffectContext(effect2) {
    const fromEffect2 = Object.create(proto$9);
    fromEffect2._op_layer = OP_FROM_EFFECT$2;
    fromEffect2.effect = effect2;
    return fromEffect2;
  }
  const matchCause$1 = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => {
    const fold = Object.create(proto$9);
    fold._op_layer = OP_FOLD$1;
    fold.layer = self2;
    fold.failureK = onFailure;
    fold.successK = onSuccess;
    return fold;
  });
  const match$3 = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => matchCause$1(self2, {
    onFailure: (cause) => {
      const failureOrCause$12 = failureOrCause(cause);
      switch (failureOrCause$12._tag) {
        case "Left": {
          return onFailure(failureOrCause$12.left);
        }
        case "Right": {
          return failCause$4(failureOrCause$12.right);
        }
      }
    },
    onSuccess
  }));
  const merge$2 = /* @__PURE__ */ dual(2, (self2, that) => zipWith$1(self2, that, (a, b) => merge$4(a, b)));
  const mergeAll$1 = (...layers) => {
    let final = layers[0];
    for (let i = 1; i < layers.length; i++) {
      final = merge$2(final, layers[i]);
    }
    return final;
  };
  const scoped$4 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag(a);
    const tag2 = tagFirst ? a : b;
    const effect2 = tagFirst ? b : a;
    return scopedContext(map$9(effect2, (service) => make$Z(tag2, service)));
  });
  const scopedDiscard$1 = (effect2) => scopedContext(pipe(effect2, as$1(empty$s())));
  const scopedContext = (effect2) => {
    const scoped2 = Object.create(proto$9);
    scoped2._op_layer = OP_SCOPED;
    scoped2.effect = effect2;
    return scoped2;
  };
  const succeed$6 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag(a);
    const tag2 = tagFirst ? a : b;
    const resource = tagFirst ? b : a;
    return fromEffectContext(succeed$a(make$Z(tag2, resource)));
  });
  const succeedContext = (context2) => {
    return fromEffectContext(succeed$a(context2));
  };
  const empty$6 = /* @__PURE__ */ succeedContext(/* @__PURE__ */ empty$s());
  const suspend$7 = (evaluate2) => {
    const suspend2 = Object.create(proto$9);
    suspend2._op_layer = OP_SUSPEND$2;
    suspend2.evaluate = evaluate2;
    return suspend2;
  };
  const sync$4 = /* @__PURE__ */ dual(2, (a, b) => {
    const tagFirst = isTag(a);
    const tag2 = tagFirst ? a : b;
    const evaluate2 = tagFirst ? b : a;
    return fromEffectContext(sync$5(() => make$Z(tag2, evaluate2())));
  });
  const provide$2 = /* @__PURE__ */ dual(2, (self2, that) => suspend$7(() => {
    const provideTo = Object.create(proto$9);
    provideTo._op_layer = OP_PROVIDE$2;
    provideTo.first = Object.create(proto$9, {
      _op_layer: {
        value: OP_PROVIDE_MERGE,
        enumerable: true
      },
      first: {
        value: context$2(),
        enumerable: true
      },
      second: {
        value: Array.isArray(that) ? mergeAll$1(...that) : that
      },
      zipK: {
        value: (a, b) => pipe(a, merge$4(b))
      }
    });
    provideTo.second = self2;
    return provideTo;
  }));
  const provideMerge$1 = /* @__PURE__ */ dual(2, (that, self2) => {
    const zipWith2 = Object.create(proto$9);
    zipWith2._op_layer = OP_PROVIDE_MERGE;
    zipWith2.first = self2;
    zipWith2.second = provide$2(that, self2);
    zipWith2.zipK = (a, b) => {
      return pipe(a, merge$4(b));
    };
    return zipWith2;
  });
  const zipWith$1 = /* @__PURE__ */ dual(3, (self2, that, f) => suspend$7(() => {
    const zipWith2 = Object.create(proto$9);
    zipWith2._op_layer = OP_ZIP_WITH;
    zipWith2.first = self2;
    zipWith2.second = that;
    zipWith2.zipK = f;
    return zipWith2;
  }));
  const unwrapEffect$1 = (self2) => {
    const tag2 = GenericTag("effect/Layer/unwrapEffect/Layer.Layer<R1, E1, A>");
    return flatMap$5(fromEffect$4(tag2, self2), (context2) => get$e(context2, tag2));
  };
  const unwrapScoped$4 = (self2) => {
    const tag2 = GenericTag("effect/Layer/unwrapScoped/Layer.Layer<R1, E1, A>");
    return flatMap$5(scoped$4(tag2, self2), (context2) => get$e(context2, tag2));
  };
  const provideSomeLayer = /* @__PURE__ */ dual(2, (self2, layer2) => scopedWith$3((scope2) => flatMap$7(buildWithScope$1(layer2, scope2), (context2) => provideSomeContext(self2, context2))));
  const provideSomeRuntime = /* @__PURE__ */ dual(2, (self2, rt) => {
    const patchRefs = diff$1(defaultRuntime.fiberRefs, rt.fiberRefs);
    const patchFlags = diff$3(defaultRuntime.runtimeFlags, rt.runtimeFlags);
    return uninterruptibleMask$2((restore) => withFiberRuntime$1((fiber) => {
      const oldContext = fiber.getFiberRef(currentContext$1);
      const oldRefs = fiber.getFiberRefs();
      const newRefs = patch$3(fiber.id(), oldRefs)(patchRefs);
      const oldFlags = fiber.currentRuntimeFlags;
      const newFlags = patch$6(patchFlags)(oldFlags);
      const rollbackRefs = diff$1(newRefs, oldRefs);
      const rollbackFlags = diff$3(newFlags, oldFlags);
      fiber.setFiberRefs(newRefs);
      fiber.currentRuntimeFlags = newFlags;
      return ensuring$4(provideSomeContext(restore(self2), merge$4(oldContext, rt.context)), withFiberRuntime$1((fiber2) => {
        fiber2.setFiberRefs(patch$3(fiber2.id(), fiber2.getFiberRefs())(rollbackRefs));
        fiber2.currentRuntimeFlags = patch$6(rollbackFlags)(fiber2.currentRuntimeFlags);
        return void_$4;
      }));
    }));
  });
  const effect_provide = /* @__PURE__ */ dual(2, (self2, source) => {
    if (Array.isArray(source)) {
      return provideSomeLayer(self2, mergeAll$1(...source));
    } else if (isLayer$1(source)) {
      return provideSomeLayer(self2, source);
    } else if (isContext(source)) {
      return provideSomeContext(self2, source);
    } else if (TypeId$g in source) {
      return flatMap$7(source.runtimeEffect, (rt) => provideSomeRuntime(self2, rt));
    } else {
      return provideSomeRuntime(self2, source);
    }
  });
  const Class$1 = Class$3;
  const EffectTypeId = EffectTypeId$1;
  const isEffect = isEffect$1;
  const cached = memoize;
  const all = all$1;
  const forEach = forEach$1;
  const async$1 = async_;
  const withFiberRuntime = withFiberRuntime$1;
  const fail$6 = fail$b;
  const failCause$3 = failCause$8;
  const die$3 = die$6;
  const dieMessage = dieMessage$1;
  const gen$2 = gen$3;
  const never$2 = never$3;
  const promise = promise$1;
  const succeed$5 = succeed$a;
  const suspend$6 = suspend$8;
  const sync$3 = sync$5;
  const _void = void_$4;
  const catchAll$2 = catchAll$3;
  const catchAllCause$1 = catchAllCause$2;
  const catchAllDefect = catchAllDefect$1;
  const catchIf = catchIf$1;
  const catchSomeCause = catchSomeCause$1;
  const catchTag = catchTag$1;
  const ignore = ignore$1;
  const ignoreLogged = ignoreLogged$1;
  const retry$3 = retry_combined;
  const try_ = try_$1;
  const tryMap = tryMap$1;
  const tryPromise = tryPromise$1;
  const disconnect = disconnect$1;
  const interrupt$1 = interrupt$5;
  const interruptible = interruptible$2;
  const onInterrupt = onInterrupt$1;
  const uninterruptible = uninterruptible$1;
  const uninterruptibleMask = uninterruptibleMask$2;
  const as = as$1;
  const asVoid = asVoid$1;
  const map$5 = map$9;
  const mapBoth$1 = mapBoth$3;
  const mapError$4 = mapError$5;
  const acquireRelease = acquireRelease$1;
  const acquireUseRelease$1 = acquireUseRelease$2;
  const addFinalizer = addFinalizer$2;
  const ensuring$3 = ensuring$4;
  const onError = onError$1;
  const onExit = onExit$2;
  const scope = scope$1;
  const scopeWith = scopeWith$1;
  const scopedWith$2 = scopedWith$3;
  const scoped$3 = scopedEffect;
  const fiberIdWith = fiberIdWith$1;
  const fork = fork$2;
  const forkDaemon = forkDaemon$1;
  const forkIn = forkIn$1;
  const forkScoped = forkScoped$1;
  const withScheduler = withScheduler$1;
  const withMaxOpsBeforeYield = withMaxOpsBeforeYield$1;
  const clock = clock$1;
  const delay = delay$1;
  const sleep = sleep$1;
  const timeout = timeout$1;
  const context$1 = context$3;
  const mapInputContext = mapInputContext$1;
  const provide$1 = effect_provide;
  const provideService = provideService$1;
  const serviceFunctions = serviceFunctions$1;
  const serviceOption = serviceOption$1;
  const either$1 = either$2;
  const exit = exit$1;
  const intoDeferred = intoDeferred$1;
  const when$2 = when$3;
  const flatMap$4 = flatMap$7;
  const andThen = andThen$1;
  const flatten$4 = flatten$5;
  const race = race$1;
  const raceFirst = raceFirst$1;
  const raceWith = raceWith$1;
  const tap$2 = tap$3;
  const tapErrorCause = tapErrorCause$1;
  const forever = forever$2;
  const repeat = repeat_combined;
  const locallyWith = fiberRefLocallyWith;
  const match$2 = match$5;
  const matchCause = matchCause$2;
  const matchCauseEffect = matchCauseEffect$2;
  const log = log$1;
  const logDebug = logDebug$1;
  const logWarning = logWarning$1;
  const logError = logError$1;
  const annotateLogs = annotateLogs$1;
  const withUnhandledErrorLogLevel = withUnhandledErrorLogLevel$1;
  const orDie$2 = orDie$3;
  const runtime = runtime$1;
  const makeSemaphore = makeSemaphore$1;
  const unsafeMakeLatch = unsafeMakeLatch$1;
  const makeLatch = makeLatch$1;
  const runFork$1 = unsafeForkEffect;
  const runPromise = unsafeRunPromiseEffect;
  const runSync = unsafeRunSyncEffect;
  const zip$1 = zipOptions;
  const zipLeft = zipLeftOptions;
  const zipRight$2 = zipRightOptions;
  const zipWith = zipWithOptions;
  const tracer = tracer$1;
  const annotateSpans = annotateSpans$1;
  const annotateCurrentSpan = annotateCurrentSpan$1;
  const currentSpan = currentSpan$1;
  const makeSpan = makeSpan$1;
  const useSpan = useSpan$1;
  const withSpan$3 = withSpan$4;
  const withSpanScoped = withSpanScoped$1;
  const withParentSpan = withParentSpan$1;
  const fn = function(nameOrBody, ...pipeables) {
    const limit = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    const errorDef = new Error();
    Error.stackTraceLimit = limit;
    if (typeof nameOrBody !== "string") {
      return defineLength(nameOrBody.length, function(...args2) {
        const limit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error();
        Error.stackTraceLimit = limit2;
        return fnApply({
          self: this,
          body: nameOrBody,
          args: args2,
          pipeables,
          spanName: "<anonymous>",
          spanOptions: {
            context: DisablePropagation.context(true)
          },
          errorDef,
          errorCall
        });
      });
    }
    const name = nameOrBody;
    const options2 = pipeables[0];
    return (body, ...pipeables2) => defineLength(body.length, {
      [name](...args2) {
        const limit2 = Error.stackTraceLimit;
        Error.stackTraceLimit = 2;
        const errorCall = new Error();
        Error.stackTraceLimit = limit2;
        return fnApply({
          self: this,
          body,
          args: args2,
          pipeables: pipeables2,
          spanName: name,
          spanOptions: options2,
          errorDef,
          errorCall
        });
      }
    }[name]);
  };
  function defineLength(length2, fn2) {
    return Object.defineProperty(fn2, "length", {
      value: length2,
      configurable: true
    });
  }
  function fnApply(options2) {
    let effect2;
    let fnError = void 0;
    if (isGeneratorFunction(options2.body)) {
      effect2 = fromIterator(() => options2.body.apply(options2.self, options2.args));
    } else {
      try {
        effect2 = options2.body.apply(options2.self, options2.args);
      } catch (error) {
        fnError = error;
        effect2 = die$3(error);
      }
    }
    if (options2.pipeables.length > 0) {
      try {
        for (const x of options2.pipeables) {
          effect2 = x(effect2, ...options2.args);
        }
      } catch (error) {
        effect2 = fnError ? failCause$3(sequential$3(die$7(fnError), die$7(error))) : die$3(error);
      }
    }
    let cache = false;
    const captureStackTrace = () => {
      if (cache !== false) {
        return cache;
      }
      if (options2.errorCall.stack) {
        const stackDef = options2.errorDef.stack.trim().split("\n");
        const stackCall = options2.errorCall.stack.trim().split("\n");
        let endStackDef = stackDef.slice(2).join("\n").trim();
        if (!endStackDef.includes(`(`)) {
          endStackDef = endStackDef.replace(/at (.*)/, "at ($1)");
        }
        let endStackCall = stackCall.slice(2).join("\n").trim();
        if (!endStackCall.includes(`(`)) {
          endStackCall = endStackCall.replace(/at (.*)/, "at ($1)");
        }
        cache = `${endStackDef}
${endStackCall}`;
        return cache;
      }
    };
    const opts = options2.spanOptions && "captureStackTrace" in options2.spanOptions ? options2.spanOptions : {
      captureStackTrace,
      ...options2.spanOptions
    };
    return withSpan$3(effect2, options2.spanName, opts);
  }
  const fnUntraced = fnUntraced$1;
  const unsafeMake$4 = fiberRefUnsafeMake;
  const get$4 = fiberRefGet;
  const getWith = fiberRefGetWith;
  const currentContext = currentContext$1;
  const currentSchedulingPriority = currentSchedulingPriority$1;
  const currentLoggers = currentLoggers$1;
  const currentScheduler = currentScheduler$1;
  const currentTracerEnabled = currentTracerEnabled$1;
  const currentTracerTimingEnabled = currentTracerTimingEnabled$1;
  const withMinimumLogLevel$1 = /* @__PURE__ */ dual(2, (self2, level) => fiberRefLocally(currentMinimumLogLevel, level)(self2));
  const addLogger = (logger) => scopedDiscard$1(fiberRefLocallyScopedWith(currentLoggers$1, add(logger)));
  const removeLogger = (logger) => scopedDiscard$1(fiberRefLocallyScopedWith(currentLoggers$1, remove$4(logger)));
  const replaceLogger = /* @__PURE__ */ dual(2, (self2, that) => flatMap$5(removeLogger(self2), () => addLogger(that)));
  const setTracer$1 = (tracer2) => scopedDiscard$1(withTracerScoped(tracer2));
  const isLayer = isLayer$1;
  const buildWithScope = buildWithScope$1;
  const effect$2 = fromEffect$4;
  const empty$5 = empty$6;
  const scoped$2 = scoped$4;
  const scopedDiscard = scopedDiscard$1;
  const succeed$4 = succeed$6;
  const sync$2 = sync$4;
  const provide = provide$2;
  const provideMerge = provideMerge$1;
  const unwrapEffect = unwrapEffect$1;
  const unwrapScoped$3 = unwrapScoped$4;
  const setTracer = setTracer$1;
  const EnqueueSymbolKey = "effect/QueueEnqueue";
  const EnqueueTypeId = /* @__PURE__ */ Symbol.for(EnqueueSymbolKey);
  const DequeueSymbolKey = "effect/QueueDequeue";
  const DequeueTypeId = /* @__PURE__ */ Symbol.for(DequeueSymbolKey);
  const QueueStrategySymbolKey = "effect/QueueStrategy";
  const QueueStrategyTypeId = /* @__PURE__ */ Symbol.for(QueueStrategySymbolKey);
  const BackingQueueSymbolKey = "effect/BackingQueue";
  const BackingQueueTypeId = /* @__PURE__ */ Symbol.for(BackingQueueSymbolKey);
  const queueStrategyVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  const backingQueueVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  const enqueueVariance = {
    /* c8 ignore next */
    _In: (_) => _
  };
  const dequeueVariance = {
    /* c8 ignore next */
    _Out: (_) => _
  };
  class QueueImpl extends (_ea = Class$4, _da = EnqueueTypeId, _ca = DequeueTypeId, _ea) {
    constructor(queue, takers, shutdownHook, shutdownFlag, strategy) {
      super();
      __publicField(this, "queue");
      __publicField(this, "takers");
      __publicField(this, "shutdownHook");
      __publicField(this, "shutdownFlag");
      __publicField(this, "strategy");
      __publicField(this, _da, enqueueVariance);
      __publicField(this, _ca, dequeueVariance);
      this.queue = queue;
      this.takers = takers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    commit() {
      return this.take;
    }
    capacity() {
      return this.queue.capacity();
    }
    get size() {
      return suspend$8(() => catchAll$3(this.unsafeSize(), () => interrupt$5));
    }
    unsafeSize() {
      if (get$b(this.shutdownFlag)) {
        return none$4();
      }
      return some(this.queue.length() - length(this.takers) + this.strategy.surplusSize());
    }
    get isEmpty() {
      return map$9(this.size, (size2) => size2 <= 0);
    }
    get isFull() {
      return map$9(this.size, (size2) => size2 >= this.capacity());
    }
    get shutdown() {
      return uninterruptible$1(withFiberRuntime$1((state2) => {
        pipe(this.shutdownFlag, set$9(true));
        return pipe(forEachConcurrentDiscard(unsafePollAll(this.takers), (d) => deferredInterruptWith(d, state2.id()), false, false), zipRight$4(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid$1);
      }));
    }
    get isShutdown() {
      return sync$5(() => get$b(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    isActive() {
      return !get$b(this.shutdownFlag);
    }
    unsafeOffer(value2) {
      if (get$b(this.shutdownFlag)) {
        return false;
      }
      let noRemaining;
      if (this.queue.length() === 0) {
        const taker = pipe(this.takers, poll(EmptyMutableQueue));
        if (taker !== EmptyMutableQueue) {
          unsafeCompleteDeferred$1(taker, value2);
          noRemaining = true;
        } else {
          noRemaining = false;
        }
      } else {
        noRemaining = false;
      }
      if (noRemaining) {
        return true;
      }
      const succeeded = this.queue.offer(value2);
      unsafeCompleteTakers(this.strategy, this.queue, this.takers);
      return succeeded;
    }
    offer(value2) {
      return suspend$8(() => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        let noRemaining;
        if (this.queue.length() === 0) {
          const taker = pipe(this.takers, poll(EmptyMutableQueue));
          if (taker !== EmptyMutableQueue) {
            unsafeCompleteDeferred$1(taker, value2);
            noRemaining = true;
          } else {
            noRemaining = false;
          }
        } else {
          noRemaining = false;
        }
        if (noRemaining) {
          return succeed$a(true);
        }
        const succeeded = this.queue.offer(value2);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return succeeded ? succeed$a(true) : this.strategy.handleSurplus([value2], this.queue, this.takers, this.shutdownFlag);
      });
    }
    offerAll(iterable) {
      return suspend$8(() => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        const values = fromIterable$8(iterable);
        const pTakers = this.queue.length() === 0 ? fromIterable$8(unsafePollN$1(this.takers, values.length)) : empty$u;
        const [forTakers, remaining] = pipe(values, splitAt$1(pTakers.length));
        for (let i = 0; i < pTakers.length; i++) {
          const taker = pTakers[i];
          const item = forTakers[i];
          unsafeCompleteDeferred$1(taker, item);
        }
        if (remaining.length === 0) {
          return succeed$a(true);
        }
        const surplus = this.queue.offerAll(remaining);
        unsafeCompleteTakers(this.strategy, this.queue, this.takers);
        return isEmpty$7(surplus) ? succeed$a(true) : this.strategy.handleSurplus(surplus, this.queue, this.takers, this.shutdownFlag);
      });
    }
    get take() {
      return withFiberRuntime$1((state2) => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        const item = this.queue.poll(EmptyMutableQueue);
        if (item !== EmptyMutableQueue) {
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return succeed$a(item);
        } else {
          const deferred = deferredUnsafeMake(state2.id());
          return pipe(suspend$8(() => {
            pipe(this.takers, offer$4(deferred));
            unsafeCompleteTakers(this.strategy, this.queue, this.takers);
            return get$b(this.shutdownFlag) ? interrupt$5 : deferredAwait(deferred);
          }), onInterrupt$1(() => {
            return sync$5(() => unsafeRemove$1(this.takers, deferred));
          }));
        }
      });
    }
    get takeAll() {
      return suspend$8(() => {
        return get$b(this.shutdownFlag) ? interrupt$5 : sync$5(() => {
          const values = this.queue.pollUpTo(Number.POSITIVE_INFINITY);
          this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
          return fromIterable$7(values);
        });
      });
    }
    takeUpTo(max2) {
      return suspend$8(() => get$b(this.shutdownFlag) ? interrupt$5 : sync$5(() => {
        const values = this.queue.pollUpTo(max2);
        this.strategy.unsafeOnQueueEmptySpace(this.queue, this.takers);
        return fromIterable$7(values);
      }));
    }
    takeBetween(min2, max2) {
      return suspend$8(() => takeRemainderLoop$1(this, min2, max2, empty$r()));
    }
  }
  const takeRemainderLoop$1 = (self2, min2, max2, acc) => {
    if (max2 < min2) {
      return succeed$a(acc);
    }
    return pipe(takeUpTo(self2, max2), flatMap$7((bs) => {
      const remaining = min2 - bs.length;
      if (remaining === 1) {
        return pipe(take$5(self2), map$9((b) => pipe(acc, appendAll$1(bs), append$1(b))));
      }
      if (remaining > 1) {
        return pipe(take$5(self2), flatMap$7((b) => takeRemainderLoop$1(self2, remaining - 1, max2 - bs.length - 1, pipe(acc, appendAll$1(bs), append$1(b)))));
      }
      return succeed$a(pipe(acc, appendAll$1(bs)));
    }));
  };
  const bounded$1 = (requestedCapacity) => pipe(sync$5(() => bounded$2(requestedCapacity)), flatMap$7((queue) => make$s(backingQueueFromMutableQueue(queue), backPressureStrategy())));
  const dropping$1 = (requestedCapacity) => pipe(sync$5(() => bounded$2(requestedCapacity)), flatMap$7((queue) => make$s(backingQueueFromMutableQueue(queue), droppingStrategy())));
  const sliding$1 = (requestedCapacity) => pipe(sync$5(() => bounded$2(requestedCapacity)), flatMap$7((queue) => make$s(backingQueueFromMutableQueue(queue), slidingStrategy())));
  const unbounded$5 = () => pipe(sync$5(() => unbounded$6()), flatMap$7((queue) => make$s(backingQueueFromMutableQueue(queue), droppingStrategy())));
  const unsafeMake$3 = (queue, takers, shutdownHook, shutdownFlag, strategy) => {
    return new QueueImpl(queue, takers, shutdownHook, shutdownFlag, strategy);
  };
  const make$s = (queue, strategy) => pipe(deferredMake(), map$9((deferred) => unsafeMake$3(queue, unbounded$6(), deferred, make$T(false), strategy)));
  _fa = BackingQueueTypeId;
  class BackingQueueFromMutableQueue {
    constructor(mutable2) {
      __publicField(this, "mutable");
      __publicField(this, _fa, backingQueueVariance);
      this.mutable = mutable2;
    }
    poll(def) {
      return poll(this.mutable, def);
    }
    pollUpTo(limit) {
      return pollUpTo(this.mutable, limit);
    }
    offerAll(elements) {
      return offerAll$3(this.mutable, elements);
    }
    offer(element) {
      return offer$4(this.mutable, element);
    }
    capacity() {
      return capacity(this.mutable);
    }
    length() {
      return length(this.mutable);
    }
  }
  const backingQueueFromMutableQueue = (mutable2) => new BackingQueueFromMutableQueue(mutable2);
  const size$2 = (self2) => self2.size;
  const isShutdown$1 = (self2) => self2.isShutdown;
  const shutdown$3 = (self2) => self2.shutdown;
  const offer$3 = /* @__PURE__ */ dual(2, (self2, value2) => self2.offer(value2));
  const offerAll$2 = /* @__PURE__ */ dual(2, (self2, iterable) => self2.offerAll(iterable));
  const take$5 = (self2) => self2.take;
  const takeAll$1 = (self2) => self2.takeAll;
  const takeUpTo = /* @__PURE__ */ dual(2, (self2, max2) => self2.takeUpTo(max2));
  const takeBetween$2 = /* @__PURE__ */ dual(3, (self2, min2, max2) => self2.takeBetween(min2, max2));
  const backPressureStrategy = () => new BackPressureStrategy();
  const droppingStrategy = () => new DroppingStrategy$1();
  const slidingStrategy = () => new SlidingStrategy();
  _ga = QueueStrategyTypeId;
  class BackPressureStrategy {
    constructor() {
      __publicField(this, _ga, queueStrategyVariance);
      __publicField(this, "putters", /* @__PURE__ */ unbounded$6());
    }
    surplusSize() {
      return length(this.putters);
    }
    onCompleteTakersWithEmptyQueue(takers) {
      while (!isEmpty$2(this.putters) && !isEmpty$2(takers)) {
        const taker = poll(takers, void 0);
        const putter = poll(this.putters, void 0);
        if (putter[2]) {
          unsafeCompleteDeferred$1(putter[1], true);
        }
        unsafeCompleteDeferred$1(taker, putter[0]);
      }
    }
    get shutdown() {
      return pipe(fiberId, flatMap$7((fiberId2) => pipe(sync$5(() => unsafePollAll(this.putters)), flatMap$7((putters) => forEachConcurrentDiscard(putters, ([_, deferred, isLastItem]) => isLastItem ? pipe(deferredInterruptWith(deferred, fiberId2), asVoid$1) : void_$4, false, false)))));
    }
    handleSurplus(iterable, queue, takers, isShutdown2) {
      return withFiberRuntime$1((state2) => {
        const deferred = deferredUnsafeMake(state2.id());
        return pipe(suspend$8(() => {
          this.unsafeOffer(iterable, deferred);
          this.unsafeOnQueueEmptySpace(queue, takers);
          unsafeCompleteTakers(this, queue, takers);
          return get$b(isShutdown2) ? interrupt$5 : deferredAwait(deferred);
        }), onInterrupt$1(() => sync$5(() => this.unsafeRemove(deferred))));
      });
    }
    unsafeOnQueueEmptySpace(queue, takers) {
      let keepPolling = true;
      while (keepPolling && (queue.capacity() === Number.POSITIVE_INFINITY || queue.length() < queue.capacity())) {
        const putter = pipe(this.putters, poll(EmptyMutableQueue));
        if (putter === EmptyMutableQueue) {
          keepPolling = false;
        } else {
          const offered = queue.offer(putter[0]);
          if (offered && putter[2]) {
            unsafeCompleteDeferred$1(putter[1], true);
          } else if (!offered) {
            unsafeOfferAll$1(this.putters, pipe(unsafePollAll(this.putters), prepend$1(putter)));
          }
          unsafeCompleteTakers(this, queue, takers);
        }
      }
    }
    unsafeOffer(iterable, deferred) {
      const stuff = fromIterable$8(iterable);
      for (let i = 0; i < stuff.length; i++) {
        const value2 = stuff[i];
        if (i === stuff.length - 1) {
          pipe(this.putters, offer$4([value2, deferred, true]));
        } else {
          pipe(this.putters, offer$4([value2, deferred, false]));
        }
      }
    }
    unsafeRemove(deferred) {
      unsafeOfferAll$1(this.putters, pipe(unsafePollAll(this.putters), filter$3(([, _]) => _ !== deferred)));
    }
  }
  let DroppingStrategy$1 = (_ha = QueueStrategyTypeId, class DroppingStrategy {
    constructor() {
      __publicField(this, _ha, queueStrategyVariance);
    }
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_$4;
    }
    onCompleteTakersWithEmptyQueue() {
    }
    handleSurplus(_iterable, _queue, _takers, _isShutdown) {
      return succeed$a(false);
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {
    }
  });
  _ia = QueueStrategyTypeId;
  class SlidingStrategy {
    constructor() {
      __publicField(this, _ia, queueStrategyVariance);
    }
    surplusSize() {
      return 0;
    }
    get shutdown() {
      return void_$4;
    }
    onCompleteTakersWithEmptyQueue() {
    }
    handleSurplus(iterable, queue, takers, _isShutdown) {
      return sync$5(() => {
        this.unsafeOffer(queue, iterable);
        unsafeCompleteTakers(this, queue, takers);
        return true;
      });
    }
    unsafeOnQueueEmptySpace(_queue, _takers) {
    }
    unsafeOffer(queue, iterable) {
      const iterator = iterable[Symbol.iterator]();
      let next;
      let offering = true;
      while (!(next = iterator.next()).done && offering) {
        if (queue.capacity() === 0) {
          return;
        }
        queue.poll(EmptyMutableQueue);
        offering = queue.offer(next.value);
      }
    }
  }
  const unsafeCompleteDeferred$1 = (deferred, a) => {
    return deferredUnsafeDone(deferred, succeed$a(a));
  };
  const unsafeOfferAll$1 = (queue, as2) => {
    return pipe(queue, offerAll$3(as2));
  };
  const unsafePollAll = (queue) => {
    return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
  };
  const unsafePollN$1 = (queue, max2) => {
    return pipe(queue, pollUpTo(max2));
  };
  const unsafeRemove$1 = (queue, a) => {
    unsafeOfferAll$1(queue, pipe(unsafePollAll(queue), filter$3((b) => a !== b)));
  };
  const unsafeCompleteTakers = (strategy, queue, takers) => {
    let keepPolling = true;
    while (keepPolling && queue.length() !== 0) {
      const taker = pipe(takers, poll(EmptyMutableQueue));
      if (taker !== EmptyMutableQueue) {
        const element = queue.poll(EmptyMutableQueue);
        if (element !== EmptyMutableQueue) {
          unsafeCompleteDeferred$1(taker, element);
          strategy.unsafeOnQueueEmptySpace(queue, takers);
        } else {
          unsafeOfferAll$1(takers, pipe(unsafePollAll(takers), prepend$1(taker)));
        }
        keepPolling = true;
      } else {
        keepPolling = false;
      }
    }
    if (keepPolling && queue.length() === 0 && !isEmpty$2(takers)) {
      strategy.onCompleteTakersWithEmptyQueue(takers);
    }
  };
  const AbsentValue = /* @__PURE__ */ Symbol.for("effect/PubSub/AbsentValue");
  const addSubscribers = (subscription, pollers) => (subscribers) => {
    if (!subscribers.has(subscription)) {
      subscribers.set(subscription, /* @__PURE__ */ new Set());
    }
    const set2 = subscribers.get(subscription);
    set2.add(pollers);
  };
  const removeSubscribers = (subscription, pollers) => (subscribers) => {
    if (!subscribers.has(subscription)) {
      return;
    }
    const set2 = subscribers.get(subscription);
    set2.delete(pollers);
    if (set2.size === 0) {
      subscribers.delete(subscription);
    }
  };
  const unbounded$4 = (options2) => suspend$8(() => {
    const pubsub = makeUnboundedPubSub(options2);
    return makePubSub(pubsub, new DroppingStrategy());
  });
  const shutdown$2 = (self2) => self2.shutdown;
  const publish$1 = /* @__PURE__ */ dual(2, (self2, value2) => self2.publish(value2));
  const subscribe$1 = (self2) => self2.subscribe;
  const makeUnboundedPubSub = (options2) => new UnboundedPubSub((options2 == null ? void 0 : options2.replay) ? new ReplayBuffer(options2.replay) : void 0);
  const makeSubscription = (pubsub, subscribers, strategy) => map$9(deferredMake(), (deferred) => unsafeMakeSubscription(pubsub, subscribers, pubsub.subscribe(), unbounded$6(), deferred, make$T(false), strategy));
  const unsafeMakeSubscription = (pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy) => new SubscriptionImpl(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, pubsub.replayWindow());
  class UnboundedPubSub {
    constructor(replayBuffer) {
      __publicField(this, "replayBuffer");
      __publicField(this, "publisherHead", {
        value: AbsentValue,
        subscribers: 0,
        next: null
      });
      __publicField(this, "publisherTail", this.publisherHead);
      __publicField(this, "publisherIndex", 0);
      __publicField(this, "subscribersIndex", 0);
      __publicField(this, "capacity", Number.MAX_SAFE_INTEGER);
      this.replayBuffer = replayBuffer;
    }
    replayWindow() {
      return this.replayBuffer ? new ReplayWindowImpl(this.replayBuffer) : emptyReplayWindow;
    }
    isEmpty() {
      return this.publisherHead === this.publisherTail;
    }
    isFull() {
      return false;
    }
    size() {
      return this.publisherIndex - this.subscribersIndex;
    }
    publish(value2) {
      const subscribers = this.publisherTail.subscribers;
      if (subscribers !== 0) {
        this.publisherTail.next = {
          value: value2,
          subscribers,
          next: null
        };
        this.publisherTail = this.publisherTail.next;
        this.publisherIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.offer(value2);
      }
      return true;
    }
    publishAll(elements) {
      if (this.publisherTail.subscribers !== 0) {
        for (const a of elements) {
          this.publish(a);
        }
      } else if (this.replayBuffer) {
        this.replayBuffer.offerAll(elements);
      }
      return empty$r();
    }
    slide() {
      if (this.publisherHead !== this.publisherTail) {
        this.publisherHead = this.publisherHead.next;
        this.publisherHead.value = AbsentValue;
        this.subscribersIndex += 1;
      }
      if (this.replayBuffer) {
        this.replayBuffer.slide();
      }
    }
    subscribe() {
      this.publisherTail.subscribers += 1;
      return new UnboundedPubSubSubscription(this, this.publisherTail, this.publisherIndex, false);
    }
  }
  class UnboundedPubSubSubscription {
    constructor(self2, subscriberHead, subscriberIndex, unsubscribed) {
      __publicField(this, "self");
      __publicField(this, "subscriberHead");
      __publicField(this, "subscriberIndex");
      __publicField(this, "unsubscribed");
      this.self = self2;
      this.subscriberHead = subscriberHead;
      this.subscriberIndex = subscriberIndex;
      this.unsubscribed = unsubscribed;
    }
    isEmpty() {
      if (this.unsubscribed) {
        return true;
      }
      let empty2 = true;
      let loop = true;
      while (loop) {
        if (this.subscriberHead === this.self.publisherTail) {
          loop = false;
        } else {
          if (this.subscriberHead.next.value !== AbsentValue) {
            empty2 = false;
            loop = false;
          } else {
            this.subscriberHead = this.subscriberHead.next;
            this.subscriberIndex += 1;
          }
        }
      }
      return empty2;
    }
    size() {
      if (this.unsubscribed) {
        return 0;
      }
      return this.self.publisherIndex - Math.max(this.subscriberIndex, this.self.subscribersIndex);
    }
    poll(default_) {
      if (this.unsubscribed) {
        return default_;
      }
      let loop = true;
      let polled = default_;
      while (loop) {
        if (this.subscriberHead === this.self.publisherTail) {
          loop = false;
        } else {
          const elem = this.subscriberHead.next.value;
          if (elem !== AbsentValue) {
            polled = elem;
            this.subscriberHead.subscribers -= 1;
            if (this.subscriberHead.subscribers === 0) {
              this.self.publisherHead = this.self.publisherHead.next;
              this.self.publisherHead.value = AbsentValue;
              this.self.subscribersIndex += 1;
            }
            loop = false;
          }
          this.subscriberHead = this.subscriberHead.next;
          this.subscriberIndex += 1;
        }
      }
      return polled;
    }
    pollUpTo(n) {
      const builder = [];
      const default_ = AbsentValue;
      let i = 0;
      while (i !== n) {
        const a = this.poll(default_);
        if (a === default_) {
          i = n;
        } else {
          builder.push(a);
          i += 1;
        }
      }
      return fromIterable$7(builder);
    }
    unsubscribe() {
      if (!this.unsubscribed) {
        this.unsubscribed = true;
        this.self.publisherTail.subscribers -= 1;
        while (this.subscriberHead !== this.self.publisherTail) {
          if (this.subscriberHead.next.value !== AbsentValue) {
            this.subscriberHead.subscribers -= 1;
            if (this.subscriberHead.subscribers === 0) {
              this.self.publisherHead = this.self.publisherHead.next;
              this.self.publisherHead.value = AbsentValue;
              this.self.subscribersIndex += 1;
            }
          }
          this.subscriberHead = this.subscriberHead.next;
        }
      }
    }
  }
  class SubscriptionImpl extends (_ka = Class$4, _ja = DequeueTypeId, _ka) {
    constructor(pubsub, subscribers, subscription, pollers, shutdownHook, shutdownFlag, strategy, replayWindow) {
      super();
      __publicField(this, "pubsub");
      __publicField(this, "subscribers");
      __publicField(this, "subscription");
      __publicField(this, "pollers");
      __publicField(this, "shutdownHook");
      __publicField(this, "shutdownFlag");
      __publicField(this, "strategy");
      __publicField(this, "replayWindow");
      __publicField(this, _ja, dequeueVariance);
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.subscription = subscription;
      this.pollers = pollers;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
      this.replayWindow = replayWindow;
    }
    commit() {
      return this.take;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    capacity() {
      return this.pubsub.capacity;
    }
    isActive() {
      return !get$b(this.shutdownFlag);
    }
    get size() {
      return suspend$8(() => get$b(this.shutdownFlag) ? interrupt$5 : succeed$a(this.subscription.size() + this.replayWindow.remaining));
    }
    unsafeSize() {
      if (get$b(this.shutdownFlag)) {
        return none$4();
      }
      return some(this.subscription.size() + this.replayWindow.remaining);
    }
    get isFull() {
      return suspend$8(() => get$b(this.shutdownFlag) ? interrupt$5 : succeed$a(this.subscription.size() === this.capacity()));
    }
    get isEmpty() {
      return map$9(this.size, (size2) => size2 === 0);
    }
    get shutdown() {
      return uninterruptible$1(withFiberRuntime$1((state2) => {
        set$9(this.shutdownFlag, true);
        return pipe(forEachParUnbounded(unsafePollAllQueue(this.pollers), (d) => deferredInterruptWith(d, state2.id()), false), zipRight$4(sync$5(() => {
          this.subscribers.delete(this.subscription);
          this.subscription.unsubscribe();
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        })), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid$1);
      }));
    }
    get isShutdown() {
      return sync$5(() => get$b(this.shutdownFlag));
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get take() {
      return withFiberRuntime$1((state2) => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        if (this.replayWindow.remaining > 0) {
          const message2 = this.replayWindow.take();
          return succeed$a(message2);
        }
        const message = isEmpty$2(this.pollers) ? this.subscription.poll(EmptyMutableQueue) : EmptyMutableQueue;
        if (message === EmptyMutableQueue) {
          const deferred = deferredUnsafeMake(state2.id());
          return pipe(suspend$8(() => {
            pipe(this.pollers, offer$4(deferred));
            pipe(this.subscribers, addSubscribers(this.subscription, this.pollers));
            this.strategy.unsafeCompletePollers(this.pubsub, this.subscribers, this.subscription, this.pollers);
            return get$b(this.shutdownFlag) ? interrupt$5 : deferredAwait(deferred);
          }), onInterrupt$1(() => sync$5(() => unsafeRemove(this.pollers, deferred))));
        } else {
          this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
          return succeed$a(message);
        }
      });
    }
    get takeAll() {
      return suspend$8(() => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        const as2 = isEmpty$2(this.pollers) ? unsafePollAllSubscription(this.subscription) : empty$r();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        if (this.replayWindow.remaining > 0) {
          return succeed$a(appendAll$1(this.replayWindow.takeAll(), as2));
        }
        return succeed$a(as2);
      });
    }
    takeUpTo(max2) {
      return suspend$8(() => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        let replay = void 0;
        if (this.replayWindow.remaining >= max2) {
          const as3 = this.replayWindow.takeN(max2);
          return succeed$a(as3);
        } else if (this.replayWindow.remaining > 0) {
          replay = this.replayWindow.takeAll();
          max2 = max2 - replay.length;
        }
        const as2 = isEmpty$2(this.pollers) ? unsafePollN(this.subscription, max2) : empty$r();
        this.strategy.unsafeOnPubSubEmptySpace(this.pubsub, this.subscribers);
        return replay ? succeed$a(appendAll$1(replay, as2)) : succeed$a(as2);
      });
    }
    takeBetween(min2, max2) {
      return suspend$8(() => takeRemainderLoop(this, min2, max2, empty$r()));
    }
  }
  const takeRemainderLoop = (self2, min2, max2, acc) => {
    if (max2 < min2) {
      return succeed$a(acc);
    }
    return pipe(self2.takeUpTo(max2), flatMap$7((bs) => {
      const remaining = min2 - bs.length;
      if (remaining === 1) {
        return pipe(self2.take, map$9((b) => pipe(acc, appendAll$1(bs), append$1(b))));
      }
      if (remaining > 1) {
        return pipe(self2.take, flatMap$7((b) => takeRemainderLoop(self2, remaining - 1, max2 - bs.length - 1, pipe(acc, appendAll$1(bs), append$1(b)))));
      }
      return succeed$a(pipe(acc, appendAll$1(bs)));
    }));
  };
  _ma = EnqueueTypeId, _la = DequeueTypeId;
  class PubSubImpl {
    constructor(pubsub, subscribers, scope2, shutdownHook, shutdownFlag, strategy) {
      __publicField(this, "pubsub");
      __publicField(this, "subscribers");
      __publicField(this, "scope");
      __publicField(this, "shutdownHook");
      __publicField(this, "shutdownFlag");
      __publicField(this, "strategy");
      __publicField(this, _ma, enqueueVariance);
      __publicField(this, _la, dequeueVariance);
      this.pubsub = pubsub;
      this.subscribers = subscribers;
      this.scope = scope2;
      this.shutdownHook = shutdownHook;
      this.shutdownFlag = shutdownFlag;
      this.strategy = strategy;
    }
    capacity() {
      return this.pubsub.capacity;
    }
    get size() {
      return suspend$8(() => get$b(this.shutdownFlag) ? interrupt$5 : sync$5(() => this.pubsub.size()));
    }
    unsafeSize() {
      if (get$b(this.shutdownFlag)) {
        return none$4();
      }
      return some(this.pubsub.size());
    }
    get isFull() {
      return map$9(this.size, (size2) => size2 === this.capacity());
    }
    get isEmpty() {
      return map$9(this.size, (size2) => size2 === 0);
    }
    get awaitShutdown() {
      return deferredAwait(this.shutdownHook);
    }
    get isShutdown() {
      return sync$5(() => get$b(this.shutdownFlag));
    }
    get shutdown() {
      return uninterruptible$1(withFiberRuntime$1((state2) => {
        pipe(this.shutdownFlag, set$9(true));
        return pipe(this.scope.close(exitInterrupt$1(state2.id())), zipRight$4(this.strategy.shutdown), whenEffect(deferredSucceed(this.shutdownHook, void 0)), asVoid$1);
      }));
    }
    publish(value2) {
      return suspend$8(() => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        if (this.pubsub.publish(value2)) {
          this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
          return succeed$a(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, of$2(value2), this.shutdownFlag);
      });
    }
    isActive() {
      return !get$b(this.shutdownFlag);
    }
    unsafeOffer(value2) {
      if (get$b(this.shutdownFlag)) {
        return false;
      }
      if (this.pubsub.publish(value2)) {
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        return true;
      }
      return false;
    }
    publishAll(elements) {
      return suspend$8(() => {
        if (get$b(this.shutdownFlag)) {
          return interrupt$5;
        }
        const surplus = unsafePublishAll(this.pubsub, elements);
        this.strategy.unsafeCompleteSubscribers(this.pubsub, this.subscribers);
        if (isEmpty$7(surplus)) {
          return succeed$a(true);
        }
        return this.strategy.handleSurplus(this.pubsub, this.subscribers, surplus, this.shutdownFlag);
      });
    }
    get subscribe() {
      const acquire = tap$3(all$1([this.scope.fork(sequential$2), makeSubscription(this.pubsub, this.subscribers, this.strategy)]), (tuple) => tuple[0].addFinalizer(() => tuple[1].shutdown));
      return map$9(acquireRelease$1(acquire, (tuple, exit2) => tuple[0].close(exit2)), (tuple) => tuple[1]);
    }
    offer(value2) {
      return this.publish(value2);
    }
    offerAll(elements) {
      return this.publishAll(elements);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const makePubSub = (pubsub, strategy) => flatMap$7(scopeMake(), (scope2) => map$9(deferredMake(), (deferred) => unsafeMakePubSub(pubsub, /* @__PURE__ */ new Map(), scope2, deferred, make$T(false), strategy)));
  const unsafeMakePubSub = (pubsub, subscribers, scope2, shutdownHook, shutdownFlag, strategy) => new PubSubImpl(pubsub, subscribers, scope2, shutdownHook, shutdownFlag, strategy);
  const unsafeCompleteDeferred = (deferred, a) => {
    deferredUnsafeDone(deferred, succeed$a(a));
  };
  const unsafeOfferAll = (queue, as2) => {
    return pipe(queue, offerAll$3(as2));
  };
  const unsafePollAllQueue = (queue) => {
    return pipe(queue, pollUpTo(Number.POSITIVE_INFINITY));
  };
  const unsafePollAllSubscription = (subscription) => {
    return subscription.pollUpTo(Number.POSITIVE_INFINITY);
  };
  const unsafePollN = (subscription, max2) => {
    return subscription.pollUpTo(max2);
  };
  const unsafePublishAll = (pubsub, as2) => {
    return pubsub.publishAll(as2);
  };
  const unsafeRemove = (queue, value2) => {
    unsafeOfferAll(queue, pipe(unsafePollAllQueue(queue), filter$3((elem) => elem !== value2)));
  };
  class DroppingStrategy {
    get shutdown() {
      return void_$4;
    }
    handleSurplus(_pubsub, _subscribers, _elements, _isShutdown) {
      return succeed$a(false);
    }
    unsafeOnPubSubEmptySpace(_pubsub, _subscribers) {
    }
    unsafeCompletePollers(pubsub, subscribers, subscription, pollers) {
      return unsafeStrategyCompletePollers(this, pubsub, subscribers, subscription, pollers);
    }
    unsafeCompleteSubscribers(pubsub, subscribers) {
      return unsafeStrategyCompleteSubscribers(this, pubsub, subscribers);
    }
  }
  const unsafeStrategyCompletePollers = (strategy, pubsub, subscribers, subscription, pollers) => {
    let keepPolling = true;
    while (keepPolling && !subscription.isEmpty()) {
      const poller = pipe(pollers, poll(EmptyMutableQueue));
      if (poller === EmptyMutableQueue) {
        pipe(subscribers, removeSubscribers(subscription, pollers));
        if (isEmpty$2(pollers)) {
          keepPolling = false;
        } else {
          pipe(subscribers, addSubscribers(subscription, pollers));
        }
      } else {
        const pollResult = subscription.poll(EmptyMutableQueue);
        if (pollResult === EmptyMutableQueue) {
          unsafeOfferAll(pollers, pipe(unsafePollAllQueue(pollers), prepend$1(poller)));
        } else {
          unsafeCompleteDeferred(poller, pollResult);
          strategy.unsafeOnPubSubEmptySpace(pubsub, subscribers);
        }
      }
    }
  };
  const unsafeStrategyCompleteSubscribers = (strategy, pubsub, subscribers) => {
    for (const [subscription, pollersSet] of subscribers) {
      for (const pollers of pollersSet) {
        strategy.unsafeCompletePollers(pubsub, subscribers, subscription, pollers);
      }
    }
  };
  class ReplayBuffer {
    constructor(capacity2) {
      __publicField(this, "capacity");
      __publicField(this, "head", {
        value: AbsentValue,
        next: null
      });
      __publicField(this, "tail", this.head);
      __publicField(this, "size", 0);
      __publicField(this, "index", 0);
      this.capacity = capacity2;
    }
    slide() {
      this.index++;
    }
    offer(a) {
      this.tail.value = a;
      this.tail.next = {
        value: AbsentValue,
        next: null
      };
      this.tail = this.tail.next;
      if (this.size === this.capacity) {
        this.head = this.head.next;
      } else {
        this.size += 1;
      }
    }
    offerAll(as2) {
      for (const a of as2) {
        this.offer(a);
      }
    }
  }
  class ReplayWindowImpl {
    constructor(buffer) {
      __publicField(this, "buffer");
      __publicField(this, "head");
      __publicField(this, "index");
      __publicField(this, "remaining");
      this.buffer = buffer;
      this.index = buffer.index;
      this.remaining = buffer.size;
      this.head = buffer.head;
    }
    fastForward() {
      while (this.index < this.buffer.index) {
        this.head = this.head.next;
        this.index++;
      }
    }
    take() {
      if (this.remaining === 0) {
        return void 0;
      } else if (this.index < this.buffer.index) {
        this.fastForward();
      }
      this.remaining--;
      const value2 = this.head.value;
      this.head = this.head.next;
      return value2;
    }
    takeN(n) {
      if (this.remaining === 0) {
        return empty$r();
      } else if (this.index < this.buffer.index) {
        this.fastForward();
      }
      const len = Math.min(n, this.remaining);
      const items = new Array(len);
      for (let i = 0; i < len; i++) {
        const value2 = this.head.value;
        this.head = this.head.next;
        items[i] = value2;
      }
      this.remaining -= len;
      return unsafeFromArray(items);
    }
    takeAll() {
      return this.takeN(this.remaining);
    }
  }
  const emptyReplayWindow = {
    remaining: 0,
    take: () => void 0,
    takeN: () => empty$r(),
    takeAll: () => empty$r()
  };
  const unbounded$3 = unbounded$4;
  const shutdown$1 = shutdown$2;
  const publish = publish$1;
  const subscribe = subscribe$1;
  const bounded = bounded$1;
  const dropping = dropping$1;
  const sliding = sliding$1;
  const unbounded$2 = unbounded$5;
  const size$1 = size$2;
  const isShutdown = isShutdown$1;
  const shutdown = shutdown$3;
  const offer$2 = offer$3;
  const offerAll$1 = offerAll$2;
  const take$4 = take$5;
  const takeAll = takeAll$1;
  const takeBetween$1 = takeBetween$2;
  const OP_CONTINUE = "Continue";
  const OP_CLOSE = "Close";
  const OP_YIELD = "Yield";
  const ChildExecutorDecisionSymbolKey = "effect/ChannelChildExecutorDecision";
  const ChildExecutorDecisionTypeId = /* @__PURE__ */ Symbol.for(ChildExecutorDecisionSymbolKey);
  const proto$8 = {
    [ChildExecutorDecisionTypeId]: ChildExecutorDecisionTypeId
  };
  const Continue = (_) => {
    const op = Object.create(proto$8);
    op._tag = OP_CONTINUE;
    return op;
  };
  const OP_CONTINUATION_K = "ContinuationK";
  const OP_CONTINUATION_FINALIZER = "ContinuationFinalizer";
  const ContinuationTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelContinuation");
  const continuationVariance = {
    /* c8 ignore next */
    _Env: (_) => _,
    /* c8 ignore next */
    _InErr: (_) => _,
    /* c8 ignore next */
    _InElem: (_) => _,
    /* c8 ignore next */
    _InDone: (_) => _,
    /* c8 ignore next */
    _OutErr: (_) => _,
    /* c8 ignore next */
    _OutDone: (_) => _,
    /* c8 ignore next */
    _OutErr2: (_) => _,
    /* c8 ignore next */
    _OutElem: (_) => _,
    /* c8 ignore next */
    _OutDone2: (_) => _
  };
  _na = ContinuationTypeId;
  class ContinuationKImpl {
    constructor(onSuccess, onHalt) {
      __publicField(this, "onSuccess");
      __publicField(this, "onHalt");
      __publicField(this, "_tag", OP_CONTINUATION_K);
      __publicField(this, _na, continuationVariance);
      this.onSuccess = onSuccess;
      this.onHalt = onHalt;
    }
    onExit(exit2) {
      return isFailure(exit2) ? this.onHalt(exit2.cause) : this.onSuccess(exit2.value);
    }
  }
  _oa = ContinuationTypeId;
  class ContinuationFinalizerImpl {
    constructor(finalizer) {
      __publicField(this, "finalizer");
      __publicField(this, "_tag", OP_CONTINUATION_FINALIZER);
      __publicField(this, _oa, continuationVariance);
      this.finalizer = finalizer;
    }
  }
  const OP_PULL_AFTER_NEXT = "PullAfterNext";
  const OP_PULL_AFTER_ALL_ENQUEUED = "PullAfterAllEnqueued";
  const UpstreamPullStrategySymbolKey = "effect/ChannelUpstreamPullStrategy";
  const UpstreamPullStrategyTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullStrategySymbolKey);
  const upstreamPullStrategyVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  const proto$7 = {
    [UpstreamPullStrategyTypeId]: upstreamPullStrategyVariance
  };
  const PullAfterNext = (emitSeparator) => {
    const op = Object.create(proto$7);
    op._tag = OP_PULL_AFTER_NEXT;
    op.emitSeparator = emitSeparator;
    return op;
  };
  const OP_BRACKET_OUT = "BracketOut";
  const OP_BRIDGE = "Bridge";
  const OP_CONCAT_ALL = "ConcatAll";
  const OP_EMIT$2 = "Emit";
  const OP_ENSURING = "Ensuring";
  const OP_FAIL$2 = "Fail";
  const OP_FOLD = "Fold";
  const OP_FROM_EFFECT$1 = "FromEffect";
  const OP_PIPE_TO = "PipeTo";
  const OP_PROVIDE$1 = "Provide";
  const OP_READ$1 = "Read";
  const OP_SUCCEED$2 = "Succeed";
  const OP_SUCCEED_NOW = "SucceedNow";
  const OP_SUSPEND$1 = "Suspend";
  const ChannelSymbolKey = "effect/Channel";
  const ChannelTypeId = /* @__PURE__ */ Symbol.for(ChannelSymbolKey);
  const channelVariance = {
    /* c8 ignore next */
    _Env: (_) => _,
    /* c8 ignore next */
    _InErr: (_) => _,
    /* c8 ignore next */
    _InElem: (_) => _,
    /* c8 ignore next */
    _InDone: (_) => _,
    /* c8 ignore next */
    _OutErr: (_) => _,
    /* c8 ignore next */
    _OutElem: (_) => _,
    /* c8 ignore next */
    _OutDone: (_) => _
  };
  const proto$6 = {
    [ChannelTypeId]: channelVariance,
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const isChannel = (u) => hasProperty(u, ChannelTypeId) || isEffect(u);
  const acquireReleaseOut = /* @__PURE__ */ dual(2, (self2, release) => {
    const op = Object.create(proto$6);
    op._tag = OP_BRACKET_OUT;
    op.acquire = () => self2;
    op.finalizer = release;
    return op;
  });
  const catchAllCause = /* @__PURE__ */ dual(2, (self2, f) => {
    const op = Object.create(proto$6);
    op._tag = OP_FOLD;
    op.channel = self2;
    op.k = new ContinuationKImpl(succeed$3, f);
    return op;
  });
  const concatAllWith = (channels, f, g) => {
    const op = Object.create(proto$6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = f;
    op.combineAll = g;
    op.onPull = () => PullAfterNext(none$4());
    op.onEmit = () => Continue;
    op.value = () => channels;
    op.k = identity;
    return op;
  };
  const concatMapWith = /* @__PURE__ */ dual(4, (self2, f, g, h) => {
    const op = Object.create(proto$6);
    op._tag = OP_CONCAT_ALL;
    op.combineInners = g;
    op.combineAll = h;
    op.onPull = () => PullAfterNext(none$4());
    op.onEmit = () => Continue;
    op.value = () => self2;
    op.k = f;
    return op;
  });
  const embedInput = /* @__PURE__ */ dual(2, (self2, input) => {
    const op = Object.create(proto$6);
    op._tag = OP_BRIDGE;
    op.input = input;
    op.channel = self2;
    return op;
  });
  const ensuringWith$2 = /* @__PURE__ */ dual(2, (self2, finalizer) => {
    const op = Object.create(proto$6);
    op._tag = OP_ENSURING;
    op.channel = self2;
    op.finalizer = finalizer;
    return op;
  });
  const fail$5 = (error) => failCause$2(fail$8(error));
  const failCause$2 = (cause) => failCauseSync(() => cause);
  const failCauseSync = (evaluate2) => {
    const op = Object.create(proto$6);
    op._tag = OP_FAIL$2;
    op.error = evaluate2;
    return op;
  };
  const flatMap$3 = /* @__PURE__ */ dual(2, (self2, f) => {
    const op = Object.create(proto$6);
    op._tag = OP_FOLD;
    op.channel = self2;
    op.k = new ContinuationKImpl(f, failCause$2);
    return op;
  });
  const fromEffect$3 = (effect2) => {
    const op = Object.create(proto$6);
    op._tag = OP_FROM_EFFECT$1;
    op.effect = () => effect2;
    return op;
  };
  const pipeTo = /* @__PURE__ */ dual(2, (self2, that) => {
    const op = Object.create(proto$6);
    op._tag = OP_PIPE_TO;
    op.left = () => self2;
    op.right = () => that;
    return op;
  });
  const provideContext$2 = /* @__PURE__ */ dual(2, (self2, env2) => {
    const op = Object.create(proto$6);
    op._tag = OP_PROVIDE$1;
    op.context = () => env2;
    op.inner = self2;
    return op;
  });
  const readWith = (options2) => readWithCause({
    onInput: options2.onInput,
    onFailure: (cause) => match$b(failureOrCause(cause), {
      onLeft: options2.onFailure,
      onRight: failCause$2
    }),
    onDone: options2.onDone
  });
  const readWithCause = (options2) => {
    const op = Object.create(proto$6);
    op._tag = OP_READ$1;
    op.more = options2.onInput;
    op.done = new ContinuationKImpl(options2.onDone, options2.onFailure);
    return op;
  };
  const succeed$3 = (value2) => sync$1(() => value2);
  const succeedNow = (result) => {
    const op = Object.create(proto$6);
    op._tag = OP_SUCCEED_NOW;
    op.terminal = result;
    return op;
  };
  const suspend$5 = (evaluate2) => {
    const op = Object.create(proto$6);
    op._tag = OP_SUSPEND$1;
    op.channel = evaluate2;
    return op;
  };
  const sync$1 = (evaluate2) => {
    const op = Object.create(proto$6);
    op._tag = OP_SUCCEED$2;
    op.evaluate = evaluate2;
    return op;
  };
  const void_$1 = /* @__PURE__ */ succeedNow(void 0);
  const write = (out) => {
    const op = Object.create(proto$6);
    op._tag = OP_EMIT$2;
    op.out = out;
    return op;
  };
  const OP_DONE$3 = "Done";
  const OP_EMIT$1 = "Emit";
  const OP_FROM_EFFECT = "FromEffect";
  const OP_READ = "Read";
  const ChannelStateTypeId = /* @__PURE__ */ Symbol.for("effect/ChannelState");
  const channelStateVariance = {
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _R: (_) => _
  };
  const proto$5 = {
    [ChannelStateTypeId]: channelStateVariance
  };
  const Done$2 = () => {
    const op = Object.create(proto$5);
    op._tag = OP_DONE$3;
    return op;
  };
  const Emit$1 = () => {
    const op = Object.create(proto$5);
    op._tag = OP_EMIT$1;
    return op;
  };
  const fromEffect$2 = (effect2) => {
    const op = Object.create(proto$5);
    op._tag = OP_FROM_EFFECT;
    op.effect = effect2;
    return op;
  };
  const Read = (upstream, onEffect, onEmit, onDone) => {
    const op = Object.create(proto$5);
    op._tag = OP_READ;
    op.upstream = upstream;
    op.onEffect = onEffect;
    op.onEmit = onEmit;
    op.onDone = onDone;
    return op;
  };
  const isFromEffect = (self2) => self2._tag === OP_FROM_EFFECT;
  const effect$1 = (self2) => isFromEffect(self2) ? self2.effect : _void;
  const effectOrUndefinedIgnored = (self2) => isFromEffect(self2) ? ignore(self2.effect) : void 0;
  const OP_PULL_FROM_CHILD = "PullFromChild";
  const OP_PULL_FROM_UPSTREAM = "PullFromUpstream";
  const OP_DRAIN_CHILD_EXECUTORS = "DrainChildExecutors";
  const OP_EMIT = "Emit";
  class PullFromChild {
    constructor(childExecutor, parentSubexecutor, onEmit) {
      __publicField(this, "childExecutor");
      __publicField(this, "parentSubexecutor");
      __publicField(this, "onEmit");
      __publicField(this, "_tag", OP_PULL_FROM_CHILD);
      this.childExecutor = childExecutor;
      this.parentSubexecutor = parentSubexecutor;
      this.onEmit = onEmit;
    }
    close(exit$12) {
      const fin1 = this.childExecutor.close(exit$12);
      const fin2 = this.parentSubexecutor.close(exit$12);
      if (fin1 !== void 0 && fin2 !== void 0) {
        return zipWith(exit(fin1), exit(fin2), (exit1, exit2) => pipe(exit1, zipRight$3(exit2)));
      } else if (fin1 !== void 0) {
        return fin1;
      } else if (fin2 !== void 0) {
        return fin2;
      } else {
        return void 0;
      }
    }
    enqueuePullFromChild(_child) {
      return this;
    }
  }
  class PullFromUpstream {
    constructor(upstreamExecutor, createChild, lastDone, activeChildExecutors, combineChildResults, combineWithChildResult, onPull, onEmit) {
      __publicField(this, "upstreamExecutor");
      __publicField(this, "createChild");
      __publicField(this, "lastDone");
      __publicField(this, "activeChildExecutors");
      __publicField(this, "combineChildResults");
      __publicField(this, "combineWithChildResult");
      __publicField(this, "onPull");
      __publicField(this, "onEmit");
      __publicField(this, "_tag", OP_PULL_FROM_UPSTREAM);
      this.upstreamExecutor = upstreamExecutor;
      this.createChild = createChild;
      this.lastDone = lastDone;
      this.activeChildExecutors = activeChildExecutors;
      this.combineChildResults = combineChildResults;
      this.combineWithChildResult = combineWithChildResult;
      this.onPull = onPull;
      this.onEmit = onEmit;
    }
    close(exit$12) {
      const fin1 = this.upstreamExecutor.close(exit$12);
      const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit$12) : void 0), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== void 0 && next !== void 0) {
          return zipWith(acc, exit(next), (exit1, exit2) => zipRight$3(exit1, exit2));
        } else if (acc !== void 0) {
          return acc;
        } else if (next !== void 0) {
          return exit(next);
        } else {
          return void 0;
        }
      }, void 0);
      return result === void 0 ? result : result;
    }
    enqueuePullFromChild(child) {
      return new PullFromUpstream(this.upstreamExecutor, this.createChild, this.lastDone, [...this.activeChildExecutors, child], this.combineChildResults, this.combineWithChildResult, this.onPull, this.onEmit);
    }
  }
  class DrainChildExecutors {
    constructor(upstreamExecutor, lastDone, activeChildExecutors, upstreamDone, combineChildResults, combineWithChildResult, onPull) {
      __publicField(this, "upstreamExecutor");
      __publicField(this, "lastDone");
      __publicField(this, "activeChildExecutors");
      __publicField(this, "upstreamDone");
      __publicField(this, "combineChildResults");
      __publicField(this, "combineWithChildResult");
      __publicField(this, "onPull");
      __publicField(this, "_tag", OP_DRAIN_CHILD_EXECUTORS);
      this.upstreamExecutor = upstreamExecutor;
      this.lastDone = lastDone;
      this.activeChildExecutors = activeChildExecutors;
      this.upstreamDone = upstreamDone;
      this.combineChildResults = combineChildResults;
      this.combineWithChildResult = combineWithChildResult;
      this.onPull = onPull;
    }
    close(exit$12) {
      const fin1 = this.upstreamExecutor.close(exit$12);
      const fins = [...this.activeChildExecutors.map((child) => child !== void 0 ? child.childExecutor.close(exit$12) : void 0), fin1];
      const result = fins.reduce((acc, next) => {
        if (acc !== void 0 && next !== void 0) {
          return zipWith(acc, exit(next), (exit1, exit2) => zipRight$3(exit1, exit2));
        } else if (acc !== void 0) {
          return acc;
        } else if (next !== void 0) {
          return exit(next);
        } else {
          return void 0;
        }
      }, void 0);
      return result === void 0 ? result : result;
    }
    enqueuePullFromChild(child) {
      return new DrainChildExecutors(this.upstreamExecutor, this.lastDone, [...this.activeChildExecutors, child], this.upstreamDone, this.combineChildResults, this.combineWithChildResult, this.onPull);
    }
  }
  class Emit {
    constructor(value2, next) {
      __publicField(this, "value");
      __publicField(this, "next");
      __publicField(this, "_tag", OP_EMIT);
      this.value = value2;
      this.next = next;
    }
    close(exit2) {
      const result = this.next.close(exit2);
      return result === void 0 ? result : result;
    }
    enqueuePullFromChild(_child) {
      return this;
    }
  }
  const OP_PULLED = "Pulled";
  const OP_NO_UPSTREAM = "NoUpstream";
  const UpstreamPullRequestSymbolKey = "effect/ChannelUpstreamPullRequest";
  const UpstreamPullRequestTypeId = /* @__PURE__ */ Symbol.for(UpstreamPullRequestSymbolKey);
  const upstreamPullRequestVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  const proto$4 = {
    [UpstreamPullRequestTypeId]: upstreamPullRequestVariance
  };
  const Pulled = (value2) => {
    const op = Object.create(proto$4);
    op._tag = OP_PULLED;
    op.value = value2;
    return op;
  };
  const NoUpstream = (activeDownstreamCount) => {
    const op = Object.create(proto$4);
    op._tag = OP_NO_UPSTREAM;
    op.activeDownstreamCount = activeDownstreamCount;
    return op;
  };
  class ChannelExecutor {
    constructor(initialChannel, providedEnv, executeCloseLastSubstream) {
      __publicField(this, "_activeSubexecutor");
      __publicField(this, "_cancelled");
      __publicField(this, "_closeLastSubstream");
      __publicField(this, "_currentChannel");
      __publicField(this, "_done");
      __publicField(this, "_doneStack", []);
      __publicField(this, "_emitted");
      __publicField(this, "_executeCloseLastSubstream");
      __publicField(this, "_input");
      __publicField(this, "_inProgressFinalizer");
      __publicField(this, "_providedEnv");
      this._currentChannel = initialChannel;
      this._executeCloseLastSubstream = executeCloseLastSubstream;
      this._providedEnv = providedEnv;
    }
    run() {
      let result = void 0;
      while (result === void 0) {
        if (this._cancelled !== void 0) {
          result = this.processCancellation();
        } else if (this._activeSubexecutor !== void 0) {
          result = this.runSubexecutor();
        } else {
          try {
            if (this._currentChannel === void 0) {
              result = Done$2();
            } else {
              if (isEffect(this._currentChannel)) {
                this._currentChannel = fromEffect$3(this._currentChannel);
              }
              switch (this._currentChannel._tag) {
                case OP_BRACKET_OUT: {
                  result = this.runBracketOut(this._currentChannel);
                  break;
                }
                case OP_BRIDGE: {
                  const bridgeInput = this._currentChannel.input;
                  this._currentChannel = this._currentChannel.channel;
                  if (this._input !== void 0) {
                    const inputExecutor = this._input;
                    this._input = void 0;
                    const drainer = () => flatMap$4(bridgeInput.awaitRead(), () => suspend$6(() => {
                      const state2 = inputExecutor.run();
                      switch (state2._tag) {
                        case OP_DONE$3: {
                          return match$6(inputExecutor.getDone(), {
                            onFailure: (cause) => bridgeInput.error(cause),
                            onSuccess: (value2) => bridgeInput.done(value2)
                          });
                        }
                        case OP_EMIT$1: {
                          return flatMap$4(bridgeInput.emit(inputExecutor.getEmit()), () => drainer());
                        }
                        case OP_FROM_EFFECT: {
                          return matchCauseEffect(state2.effect, {
                            onFailure: (cause) => bridgeInput.error(cause),
                            onSuccess: () => drainer()
                          });
                        }
                        case OP_READ: {
                          return readUpstream(state2, () => drainer(), (cause) => bridgeInput.error(cause));
                        }
                      }
                    }));
                    result = fromEffect$2(flatMap$4(forkDaemon(interruptible(drainer())), (fiber) => sync$3(() => this.addFinalizer((exit2) => flatMap$4(interrupt$2(fiber), () => suspend$6(() => {
                      const effect2 = this.restorePipe(exit2, inputExecutor);
                      return effect2 !== void 0 ? effect2 : _void;
                    }))))));
                  }
                  break;
                }
                case OP_CONCAT_ALL: {
                  const executor = new ChannelExecutor(this._currentChannel.value(), this._providedEnv, (effect2) => sync$3(() => {
                    const prevLastClose = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
                    this._closeLastSubstream = pipe(prevLastClose, zipRight$2(effect2));
                  }));
                  executor._input = this._input;
                  const channel = this._currentChannel;
                  this._activeSubexecutor = new PullFromUpstream(executor, (value2) => channel.k(value2), void 0, [], (x, y) => channel.combineInners(x, y), (x, y) => channel.combineAll(x, y), (request) => channel.onPull(request), (value2) => channel.onEmit(value2));
                  this._closeLastSubstream = void 0;
                  this._currentChannel = void 0;
                  break;
                }
                case OP_EMIT$2: {
                  this._emitted = this._currentChannel.out;
                  this._currentChannel = this._activeSubexecutor !== void 0 ? void 0 : void_$1;
                  result = Emit$1();
                  break;
                }
                case OP_ENSURING: {
                  this.runEnsuring(this._currentChannel);
                  break;
                }
                case OP_FAIL$2: {
                  result = this.doneHalt(this._currentChannel.error());
                  break;
                }
                case OP_FOLD: {
                  this._doneStack.push(this._currentChannel.k);
                  this._currentChannel = this._currentChannel.channel;
                  break;
                }
                case OP_FROM_EFFECT$1: {
                  const effect2 = this._providedEnv === void 0 ? this._currentChannel.effect() : pipe(this._currentChannel.effect(), provide$1(this._providedEnv));
                  result = fromEffect$2(matchCauseEffect(effect2, {
                    onFailure: (cause) => {
                      const state2 = this.doneHalt(cause);
                      return state2 !== void 0 && isFromEffect(state2) ? state2.effect : _void;
                    },
                    onSuccess: (value2) => {
                      const state2 = this.doneSucceed(value2);
                      return state2 !== void 0 && isFromEffect(state2) ? state2.effect : _void;
                    }
                  }));
                  break;
                }
                case OP_PIPE_TO: {
                  const previousInput = this._input;
                  const leftExec = new ChannelExecutor(this._currentChannel.left(), this._providedEnv, (effect2) => this._executeCloseLastSubstream(effect2));
                  leftExec._input = previousInput;
                  this._input = leftExec;
                  this.addFinalizer((exit2) => {
                    const effect2 = this.restorePipe(exit2, previousInput);
                    return effect2 !== void 0 ? effect2 : _void;
                  });
                  this._currentChannel = this._currentChannel.right();
                  break;
                }
                case OP_PROVIDE$1: {
                  const previousEnv = this._providedEnv;
                  this._providedEnv = this._currentChannel.context();
                  this._currentChannel = this._currentChannel.inner;
                  this.addFinalizer(() => sync$3(() => {
                    this._providedEnv = previousEnv;
                  }));
                  break;
                }
                case OP_READ$1: {
                  const read = this._currentChannel;
                  result = Read(this._input, identity, (emitted) => {
                    try {
                      this._currentChannel = read.more(emitted);
                    } catch (error) {
                      this._currentChannel = read.done.onExit(die$5(error));
                    }
                    return void 0;
                  }, (exit2) => {
                    const onExit2 = (exit3) => {
                      return read.done.onExit(exit3);
                    };
                    this._currentChannel = onExit2(exit2);
                    return void 0;
                  });
                  break;
                }
                case OP_SUCCEED$2: {
                  result = this.doneSucceed(this._currentChannel.evaluate());
                  break;
                }
                case OP_SUCCEED_NOW: {
                  result = this.doneSucceed(this._currentChannel.terminal);
                  break;
                }
                case OP_SUSPEND$1: {
                  this._currentChannel = this._currentChannel.channel();
                  break;
                }
              }
            }
          } catch (error) {
            this._currentChannel = failCause$2(die$4(error));
          }
        }
      }
      return result;
    }
    getDone() {
      return this._done;
    }
    getEmit() {
      return this._emitted;
    }
    cancelWith(exit2) {
      this._cancelled = exit2;
    }
    clearInProgressFinalizer() {
      this._inProgressFinalizer = void 0;
    }
    storeInProgressFinalizer(finalizer) {
      this._inProgressFinalizer = finalizer;
    }
    popAllFinalizers(exit2) {
      const finalizers = [];
      let next = this._doneStack.pop();
      while (next) {
        if (next._tag === "ContinuationFinalizer") {
          finalizers.push(next.finalizer);
        }
        next = this._doneStack.pop();
      }
      const effect2 = finalizers.length === 0 ? _void : runFinalizers(finalizers, exit2);
      this.storeInProgressFinalizer(effect2);
      return effect2;
    }
    popNextFinalizers() {
      const builder = [];
      while (this._doneStack.length !== 0) {
        const cont = this._doneStack[this._doneStack.length - 1];
        if (cont._tag === OP_CONTINUATION_K) {
          return builder;
        }
        builder.push(cont);
        this._doneStack.pop();
      }
      return builder;
    }
    restorePipe(exit2, prev) {
      const currInput = this._input;
      this._input = prev;
      if (currInput !== void 0) {
        const effect2 = currInput.close(exit2);
        return effect2;
      }
      return _void;
    }
    close(exit$12) {
      let runInProgressFinalizers = void 0;
      const finalizer = this._inProgressFinalizer;
      if (finalizer !== void 0) {
        runInProgressFinalizers = pipe(finalizer, ensuring$3(sync$3(() => this.clearInProgressFinalizer())));
      }
      let closeSelf = void 0;
      const selfFinalizers = this.popAllFinalizers(exit$12);
      if (selfFinalizers !== void 0) {
        closeSelf = pipe(selfFinalizers, ensuring$3(sync$3(() => this.clearInProgressFinalizer())));
      }
      const closeSubexecutors = this._activeSubexecutor === void 0 ? void 0 : this._activeSubexecutor.close(exit$12);
      if (closeSubexecutors === void 0 && runInProgressFinalizers === void 0 && closeSelf === void 0) {
        return void 0;
      }
      return pipe(
        exit(ifNotNull(closeSubexecutors)),
        zip$1(exit(ifNotNull(runInProgressFinalizers))),
        zip$1(exit(ifNotNull(closeSelf))),
        map$5(([[exit1, exit2], exit3]) => pipe(exit1, zipRight$3(exit2), zipRight$3(exit3))),
        uninterruptible,
        // TODO: remove
        flatMap$4((exit2) => suspend$6(() => exit2))
      );
    }
    doneSucceed(value2) {
      if (this._doneStack.length === 0) {
        this._done = succeed$8(value2);
        this._currentChannel = void 0;
        return Done$2();
      }
      const head2 = this._doneStack[this._doneStack.length - 1];
      if (head2._tag === OP_CONTINUATION_K) {
        this._doneStack.pop();
        this._currentChannel = head2.onSuccess(value2);
        return void 0;
      }
      const finalizers = this.popNextFinalizers();
      if (this._doneStack.length === 0) {
        this._doneStack = finalizers.reverse();
        this._done = succeed$8(value2);
        this._currentChannel = void 0;
        return Done$2();
      }
      const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), succeed$8(value2));
      this.storeInProgressFinalizer(finalizerEffect);
      const effect2 = pipe(finalizerEffect, ensuring$3(sync$3(() => this.clearInProgressFinalizer())), uninterruptible, flatMap$4(() => sync$3(() => this.doneSucceed(value2))));
      return fromEffect$2(effect2);
    }
    doneHalt(cause) {
      if (this._doneStack.length === 0) {
        this._done = failCause$6(cause);
        this._currentChannel = void 0;
        return Done$2();
      }
      const head2 = this._doneStack[this._doneStack.length - 1];
      if (head2._tag === OP_CONTINUATION_K) {
        this._doneStack.pop();
        try {
          this._currentChannel = head2.onHalt(cause);
        } catch (error) {
          this._currentChannel = failCause$2(die$4(error));
        }
        return void 0;
      }
      const finalizers = this.popNextFinalizers();
      if (this._doneStack.length === 0) {
        this._doneStack = finalizers.reverse();
        this._done = failCause$6(cause);
        this._currentChannel = void 0;
        return Done$2();
      }
      const finalizerEffect = runFinalizers(finalizers.map((f) => f.finalizer), failCause$6(cause));
      this.storeInProgressFinalizer(finalizerEffect);
      const effect2 = pipe(finalizerEffect, ensuring$3(sync$3(() => this.clearInProgressFinalizer())), uninterruptible, flatMap$4(() => sync$3(() => this.doneHalt(cause))));
      return fromEffect$2(effect2);
    }
    processCancellation() {
      this._currentChannel = void 0;
      this._done = this._cancelled;
      this._cancelled = void 0;
      return Done$2();
    }
    runBracketOut(bracketOut) {
      const effect2 = uninterruptible(matchCauseEffect(this.provide(bracketOut.acquire()), {
        onFailure: (cause) => sync$3(() => {
          this._currentChannel = failCause$2(cause);
        }),
        onSuccess: (out) => sync$3(() => {
          this.addFinalizer((exit2) => this.provide(bracketOut.finalizer(out, exit2)));
          this._currentChannel = write(out);
        })
      }));
      return fromEffect$2(effect2);
    }
    provide(effect2) {
      if (this._providedEnv === void 0) {
        return effect2;
      }
      return pipe(effect2, provide$1(this._providedEnv));
    }
    runEnsuring(ensuring2) {
      this.addFinalizer(ensuring2.finalizer);
      this._currentChannel = ensuring2.channel;
    }
    addFinalizer(f) {
      this._doneStack.push(new ContinuationFinalizerImpl(f));
    }
    runSubexecutor() {
      const subexecutor = this._activeSubexecutor;
      switch (subexecutor._tag) {
        case OP_PULL_FROM_CHILD: {
          return this.pullFromChild(subexecutor.childExecutor, subexecutor.parentSubexecutor, subexecutor.onEmit, subexecutor);
        }
        case OP_PULL_FROM_UPSTREAM: {
          return this.pullFromUpstream(subexecutor);
        }
        case OP_DRAIN_CHILD_EXECUTORS: {
          return this.drainChildExecutors(subexecutor);
        }
        case OP_EMIT: {
          this._emitted = subexecutor.value;
          this._activeSubexecutor = subexecutor.next;
          return Emit$1();
        }
      }
    }
    replaceSubexecutor(nextSubExec) {
      this._currentChannel = void 0;
      this._activeSubexecutor = nextSubExec;
    }
    finishWithExit(exit2) {
      const state2 = match$6(exit2, {
        onFailure: (cause) => this.doneHalt(cause),
        onSuccess: (value2) => this.doneSucceed(value2)
      });
      this._activeSubexecutor = void 0;
      return state2 === void 0 ? _void : effect$1(state2);
    }
    finishSubexecutorWithCloseEffect(subexecutorDone, ...closeFuncs) {
      this.addFinalizer(() => pipe(closeFuncs, forEach((closeFunc) => pipe(sync$3(() => closeFunc(subexecutorDone)), flatMap$4((closeEffect) => closeEffect !== void 0 ? closeEffect : _void)), {
        discard: true
      })));
      const state2 = pipe(subexecutorDone, match$6({
        onFailure: (cause) => this.doneHalt(cause),
        onSuccess: (value2) => this.doneSucceed(value2)
      }));
      this._activeSubexecutor = void 0;
      return state2;
    }
    applyUpstreamPullStrategy(upstreamFinished, queue, strategy) {
      switch (strategy._tag) {
        case OP_PULL_AFTER_NEXT: {
          const shouldPrepend = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
          return [strategy.emitSeparator, shouldPrepend ? [void 0, ...queue] : queue];
        }
        case OP_PULL_AFTER_ALL_ENQUEUED: {
          const shouldEnqueue = !upstreamFinished || queue.some((subexecutor) => subexecutor !== void 0);
          return [strategy.emitSeparator, shouldEnqueue ? [...queue, void 0] : queue];
        }
      }
    }
    pullFromChild(childExecutor, parentSubexecutor, onEmitted, subexecutor) {
      return Read(childExecutor, identity, (emitted) => {
        const childExecutorDecision = onEmitted(emitted);
        switch (childExecutorDecision._tag) {
          case OP_CONTINUE: {
            break;
          }
          case OP_CLOSE: {
            this.finishWithDoneValue(childExecutor, parentSubexecutor, childExecutorDecision.value);
            break;
          }
          case OP_YIELD: {
            const modifiedParent = parentSubexecutor.enqueuePullFromChild(subexecutor);
            this.replaceSubexecutor(modifiedParent);
            break;
          }
        }
        this._activeSubexecutor = new Emit(emitted, this._activeSubexecutor);
        return void 0;
      }, match$6({
        onFailure: (cause) => {
          const state2 = this.handleSubexecutorFailure(childExecutor, parentSubexecutor, cause);
          return state2 === void 0 ? void 0 : effectOrUndefinedIgnored(state2);
        },
        onSuccess: (doneValue) => {
          this.finishWithDoneValue(childExecutor, parentSubexecutor, doneValue);
          return void 0;
        }
      }));
    }
    finishWithDoneValue(childExecutor, parentSubexecutor, doneValue) {
      const subexecutor = parentSubexecutor;
      switch (subexecutor._tag) {
        case OP_PULL_FROM_UPSTREAM: {
          const modifiedParent = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
          this._closeLastSubstream = childExecutor.close(succeed$8(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
        case OP_DRAIN_CHILD_EXECUTORS: {
          const modifiedParent = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone !== void 0 ? subexecutor.combineChildResults(subexecutor.lastDone, doneValue) : doneValue, subexecutor.activeChildExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          this._closeLastSubstream = childExecutor.close(succeed$8(doneValue));
          this.replaceSubexecutor(modifiedParent);
          break;
        }
      }
    }
    handleSubexecutorFailure(childExecutor, parentSubexecutor, cause) {
      return this.finishSubexecutorWithCloseEffect(failCause$6(cause), (exit2) => parentSubexecutor.close(exit2), (exit2) => childExecutor.close(exit2));
    }
    pullFromUpstream(subexecutor) {
      if (subexecutor.activeChildExecutors.length === 0) {
        return this.performPullFromUpstream(subexecutor);
      }
      const activeChild = subexecutor.activeChildExecutors[0];
      const parentSubexecutor = new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, subexecutor.activeChildExecutors.slice(1), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit);
      if (activeChild === void 0) {
        return this.performPullFromUpstream(parentSubexecutor);
      }
      this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
      return void 0;
    }
    performPullFromUpstream(subexecutor) {
      return Read(subexecutor.upstreamExecutor, (effect2) => {
        const closeLastSubstream = this._closeLastSubstream === void 0 ? _void : this._closeLastSubstream;
        this._closeLastSubstream = void 0;
        return pipe(this._executeCloseLastSubstream(closeLastSubstream), zipRight$2(effect2));
      }, (emitted) => {
        if (this._closeLastSubstream !== void 0) {
          const closeLastSubstream = this._closeLastSubstream;
          this._closeLastSubstream = void 0;
          return pipe(this._executeCloseLastSubstream(closeLastSubstream), map$5(() => {
            const childExecutor2 = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
            childExecutor2._input = this._input;
            const [emitSeparator2, updatedChildExecutors2] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
            this._activeSubexecutor = new PullFromChild(childExecutor2, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors2, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
            if (isSome(emitSeparator2)) {
              this._activeSubexecutor = new Emit(emitSeparator2.value, this._activeSubexecutor);
            }
            return void 0;
          }));
        }
        const childExecutor = new ChannelExecutor(subexecutor.createChild(emitted), this._providedEnv, this._executeCloseLastSubstream);
        childExecutor._input = this._input;
        const [emitSeparator, updatedChildExecutors] = this.applyUpstreamPullStrategy(false, subexecutor.activeChildExecutors, subexecutor.onPull(Pulled(emitted)));
        this._activeSubexecutor = new PullFromChild(childExecutor, new PullFromUpstream(subexecutor.upstreamExecutor, subexecutor.createChild, subexecutor.lastDone, updatedChildExecutors, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull, subexecutor.onEmit), subexecutor.onEmit);
        if (isSome(emitSeparator)) {
          this._activeSubexecutor = new Emit(emitSeparator.value, this._activeSubexecutor);
        }
        return void 0;
      }, (exit2) => {
        if (subexecutor.activeChildExecutors.some((subexecutor2) => subexecutor2 !== void 0)) {
          const drain2 = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, [void 0, ...subexecutor.activeChildExecutors], subexecutor.upstreamExecutor.getDone(), subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
          if (this._closeLastSubstream !== void 0) {
            const closeLastSubstream2 = this._closeLastSubstream;
            this._closeLastSubstream = void 0;
            return pipe(this._executeCloseLastSubstream(closeLastSubstream2), map$5(() => this.replaceSubexecutor(drain2)));
          }
          this.replaceSubexecutor(drain2);
          return void 0;
        }
        const closeLastSubstream = this._closeLastSubstream;
        const state2 = this.finishSubexecutorWithCloseEffect(pipe(exit2, map$8((a) => subexecutor.combineWithChildResult(subexecutor.lastDone, a))), () => closeLastSubstream, (exit3) => subexecutor.upstreamExecutor.close(exit3));
        return state2 === void 0 ? void 0 : (
          // NOTE: assuming finalizers cannot fail
          effectOrUndefinedIgnored(state2)
        );
      });
    }
    drainChildExecutors(subexecutor) {
      if (subexecutor.activeChildExecutors.length === 0) {
        const lastClose = this._closeLastSubstream;
        if (lastClose !== void 0) {
          this.addFinalizer(() => succeed$5(lastClose));
        }
        return this.finishSubexecutorWithCloseEffect(subexecutor.upstreamDone, () => lastClose, (exit2) => subexecutor.upstreamExecutor.close(exit2));
      }
      const activeChild = subexecutor.activeChildExecutors[0];
      const rest = subexecutor.activeChildExecutors.slice(1);
      if (activeChild === void 0) {
        const [emitSeparator, remainingExecutors] = this.applyUpstreamPullStrategy(true, rest, subexecutor.onPull(NoUpstream(rest.reduce((n, curr) => curr !== void 0 ? n + 1 : n, 0))));
        this.replaceSubexecutor(new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, remainingExecutors, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull));
        if (isSome(emitSeparator)) {
          this._emitted = emitSeparator.value;
          return Emit$1();
        }
        return void 0;
      }
      const parentSubexecutor = new DrainChildExecutors(subexecutor.upstreamExecutor, subexecutor.lastDone, rest, subexecutor.upstreamDone, subexecutor.combineChildResults, subexecutor.combineWithChildResult, subexecutor.onPull);
      this.replaceSubexecutor(new PullFromChild(activeChild.childExecutor, parentSubexecutor, activeChild.onEmit));
      return void 0;
    }
  }
  const ifNotNull = (effect2) => effect2 !== void 0 ? effect2 : _void;
  const runFinalizers = (finalizers, exit$12) => {
    return pipe(forEach(finalizers, (fin) => exit(fin(exit$12))), map$5((exits) => pipe(all$2(exits), getOrElse(() => void_$3))), flatMap$4((exit2) => suspend$6(() => exit2)));
  };
  const readUpstream = (r, onSuccess, onFailure) => {
    const readStack = [r];
    const read = () => {
      const current = readStack.pop();
      if (current === void 0 || current.upstream === void 0) {
        return dieMessage("Unexpected end of input for channel execution");
      }
      const state2 = current.upstream.run();
      switch (state2._tag) {
        case OP_EMIT$1: {
          const emitEffect = current.onEmit(current.upstream.getEmit());
          if (readStack.length === 0) {
            if (emitEffect === void 0) {
              return suspend$6(onSuccess);
            }
            return pipe(emitEffect, matchCauseEffect({
              onFailure,
              onSuccess
            }));
          }
          if (emitEffect === void 0) {
            return suspend$6(() => read());
          }
          return pipe(emitEffect, matchCauseEffect({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_DONE$3: {
          const doneEffect = current.onDone(current.upstream.getDone());
          if (readStack.length === 0) {
            if (doneEffect === void 0) {
              return suspend$6(onSuccess);
            }
            return pipe(doneEffect, matchCauseEffect({
              onFailure,
              onSuccess
            }));
          }
          if (doneEffect === void 0) {
            return suspend$6(() => read());
          }
          return pipe(doneEffect, matchCauseEffect({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_FROM_EFFECT: {
          readStack.push(current);
          return pipe(current.onEffect(state2.effect), catchAllCause$1((cause) => suspend$6(() => {
            const doneEffect = current.onDone(failCause$6(cause));
            return doneEffect === void 0 ? _void : doneEffect;
          })), matchCauseEffect({
            onFailure,
            onSuccess: () => read()
          }));
        }
        case OP_READ: {
          readStack.push(current);
          readStack.push(state2);
          return suspend$6(() => read());
        }
      }
    };
    return read();
  };
  const runIn = /* @__PURE__ */ dual(2, (self2, scope2) => {
    const run2 = (channelDeferred, scopeDeferred, scope3) => acquireUseRelease$1(sync$3(() => new ChannelExecutor(self2, void 0, identity)), (exec) => suspend$6(() => runScopedInterpret(exec.run(), exec).pipe(intoDeferred(channelDeferred), zipRight$2(_await$2(channelDeferred)), zipLeft(_await$2(scopeDeferred)))), (exec, exit2) => {
      const finalize = exec.close(exit2);
      if (finalize === void 0) {
        return _void;
      }
      return tapErrorCause(finalize, (cause) => addFinalizer$1(scope3, failCause$3(cause)));
    });
    return uninterruptibleMask((restore) => all([fork$1(scope2, sequential$1), make$N(), make$N()]).pipe(flatMap$4(([child, channelDeferred, scopeDeferred]) => restore(run2(channelDeferred, scopeDeferred, child)).pipe(forkIn(scope2), flatMap$4((fiber) => scope2.addFinalizer((exit2) => {
      const interruptors$12 = isFailure(exit2) ? interruptors(exit2.cause) : void 0;
      return isDone$5(channelDeferred).pipe(flatMap$4((isDone2) => isDone2 ? succeed$9(scopeDeferred, void 0).pipe(zipRight$2(_await(fiber)), zipRight$2(inheritAll(fiber))) : succeed$9(scopeDeferred, void 0).pipe(zipRight$2(interruptors$12 && size$6(interruptors$12) > 0 ? interruptAs$1(fiber, combineAll(interruptors$12)) : interrupt$2(fiber)), zipRight$2(inheritAll(fiber)))));
    }).pipe(zipRight$2(restore(_await$2(channelDeferred)))))))));
  });
  const runScopedInterpret = (channelState, exec) => {
    const op = channelState;
    switch (op._tag) {
      case OP_FROM_EFFECT: {
        return pipe(op.effect, flatMap$4(() => runScopedInterpret(exec.run(), exec)));
      }
      case OP_EMIT$1: {
        return runScopedInterpret(exec.run(), exec);
      }
      case OP_DONE$3: {
        return suspend$6(() => exec.getDone());
      }
      case OP_READ: {
        return readUpstream(op, () => runScopedInterpret(exec.run(), exec), failCause$3);
      }
    }
  };
  const OP_DONE$2 = "Done";
  const OP_AWAIT = "Await";
  const MergeDecisionSymbolKey = "effect/ChannelMergeDecision";
  const MergeDecisionTypeId = /* @__PURE__ */ Symbol.for(MergeDecisionSymbolKey);
  const proto$3 = {
    [MergeDecisionTypeId]: {
      _R: (_) => _,
      _E0: (_) => _,
      _Z0: (_) => _,
      _E: (_) => _,
      _Z: (_) => _
    }
  };
  const Done$1 = (effect2) => {
    const op = Object.create(proto$3);
    op._tag = OP_DONE$2;
    op.effect = effect2;
    return op;
  };
  const Await$1 = (f) => {
    const op = Object.create(proto$3);
    op._tag = OP_AWAIT;
    op.f = f;
    return op;
  };
  const OP_BOTH_RUNNING = "BothRunning";
  const OP_LEFT_DONE = "LeftDone";
  const OP_RIGHT_DONE = "RightDone";
  const MergeStateSymbolKey = "effect/ChannelMergeState";
  const MergeStateTypeId = /* @__PURE__ */ Symbol.for(MergeStateSymbolKey);
  const proto$2 = {
    [MergeStateTypeId]: MergeStateTypeId
  };
  const BothRunning = (left2, right2) => {
    const op = Object.create(proto$2);
    op._tag = OP_BOTH_RUNNING;
    op.left = left2;
    op.right = right2;
    return op;
  };
  const LeftDone = (f) => {
    const op = Object.create(proto$2);
    op._tag = OP_LEFT_DONE;
    op.f = f;
    return op;
  };
  const RightDone = (f) => {
    const op = Object.create(proto$2);
    op._tag = OP_RIGHT_DONE;
    op.f = f;
    return op;
  };
  const OP_BACK_PRESSURE = "BackPressure";
  const OP_BUFFER_SLIDING = "BufferSliding";
  const MergeStrategySymbolKey = "effect/ChannelMergeStrategy";
  const MergeStrategyTypeId = /* @__PURE__ */ Symbol.for(MergeStrategySymbolKey);
  const proto$1 = {
    [MergeStrategyTypeId]: MergeStrategyTypeId
  };
  const BackPressure = (_) => {
    const op = Object.create(proto$1);
    op._tag = OP_BACK_PRESSURE;
    return op;
  };
  const BufferSliding = (_) => {
    const op = Object.create(proto$1);
    op._tag = OP_BUFFER_SLIDING;
    return op;
  };
  const match$1 = /* @__PURE__ */ dual(2, (self2, {
    onBackPressure,
    onBufferSliding
  }) => {
    switch (self2._tag) {
      case OP_BACK_PRESSURE: {
        return onBackPressure();
      }
      case OP_BUFFER_SLIDING: {
        return onBufferSliding();
      }
    }
  });
  const OP_STATE_EMPTY = "Empty";
  const OP_STATE_EMIT = "Emit";
  const OP_STATE_ERROR = "Error";
  const OP_STATE_DONE = "Done";
  const stateEmpty = (notifyProducer) => ({
    _tag: OP_STATE_EMPTY,
    notifyProducer
  });
  const stateEmit = (notifyConsumers) => ({
    _tag: OP_STATE_EMIT,
    notifyConsumers
  });
  const stateError = (cause) => ({
    _tag: OP_STATE_ERROR,
    cause
  });
  const stateDone = (done2) => ({
    _tag: OP_STATE_DONE,
    done: done2
  });
  class SingleProducerAsyncInputImpl {
    constructor(ref) {
      __publicField(this, "ref");
      this.ref = ref;
    }
    awaitRead() {
      return flatten$4(modify$1(this.ref, (state2) => state2._tag === OP_STATE_EMPTY ? [_await$2(state2.notifyProducer), state2] : [_void, state2]));
    }
    get close() {
      return fiberIdWith((fiberId2) => this.error(interrupt$3(fiberId2)));
    }
    done(value2) {
      return flatten$4(modify$1(this.ref, (state2) => {
        switch (state2._tag) {
          case OP_STATE_EMPTY: {
            return [_await$2(state2.notifyProducer), state2];
          }
          case OP_STATE_EMIT: {
            return [forEach(state2.notifyConsumers, (deferred) => succeed$9(deferred, left(value2)), {
              discard: true
            }), stateDone(value2)];
          }
          case OP_STATE_ERROR: {
            return [interrupt$1, state2];
          }
          case OP_STATE_DONE: {
            return [interrupt$1, state2];
          }
        }
      }));
    }
    emit(element) {
      return flatMap$4(make$N(), (deferred) => flatten$4(modify$1(this.ref, (state2) => {
        switch (state2._tag) {
          case OP_STATE_EMPTY: {
            return [_await$2(state2.notifyProducer), state2];
          }
          case OP_STATE_EMIT: {
            const notifyConsumer = state2.notifyConsumers[0];
            const notifyConsumers = state2.notifyConsumers.slice(1);
            if (notifyConsumer !== void 0) {
              return [succeed$9(notifyConsumer, right(element)), notifyConsumers.length === 0 ? stateEmpty(deferred) : stateEmit(notifyConsumers)];
            }
            throw new Error("Bug: Channel.SingleProducerAsyncInput.emit - Queue was empty! please report an issue at https://github.com/Effect-TS/effect/issues");
          }
          case OP_STATE_ERROR: {
            return [interrupt$1, state2];
          }
          case OP_STATE_DONE: {
            return [interrupt$1, state2];
          }
        }
      })));
    }
    error(cause) {
      return flatten$4(modify$1(this.ref, (state2) => {
        switch (state2._tag) {
          case OP_STATE_EMPTY: {
            return [_await$2(state2.notifyProducer), state2];
          }
          case OP_STATE_EMIT: {
            return [forEach(state2.notifyConsumers, (deferred) => failCause$7(deferred, cause), {
              discard: true
            }), stateError(cause)];
          }
          case OP_STATE_ERROR: {
            return [interrupt$1, state2];
          }
          case OP_STATE_DONE: {
            return [interrupt$1, state2];
          }
        }
      }));
    }
    get take() {
      return this.takeWith((cause) => failCause$6(map$7(cause, left)), (elem) => succeed$8(elem), (done2) => fail$9(right(done2)));
    }
    takeWith(onError2, onElement, onDone) {
      return flatMap$4(make$N(), (deferred) => flatten$4(modify$1(this.ref, (state2) => {
        switch (state2._tag) {
          case OP_STATE_EMPTY: {
            return [zipRight$2(succeed$9(state2.notifyProducer, void 0), matchCause(_await$2(deferred), {
              onFailure: onError2,
              onSuccess: match$b({
                onLeft: onDone,
                onRight: onElement
              })
            })), stateEmit([deferred])];
          }
          case OP_STATE_EMIT: {
            return [matchCause(_await$2(deferred), {
              onFailure: onError2,
              onSuccess: match$b({
                onLeft: onDone,
                onRight: onElement
              })
            }), stateEmit([...state2.notifyConsumers, deferred])];
          }
          case OP_STATE_ERROR: {
            return [succeed$5(onError2(state2.cause)), state2];
          }
          case OP_STATE_DONE: {
            return [succeed$5(onDone(state2.done)), state2];
          }
        }
      })));
    }
  }
  const make$r = () => pipe(make$N(), flatMap$4((deferred) => make$G(stateEmpty(deferred))), map$5((ref) => new SingleProducerAsyncInputImpl(ref)));
  const acquireUseRelease = (acquire, use, release) => flatMap$3(fromEffect$3(make$G(() => _void)), (ref) => pipe(fromEffect$3(uninterruptible(tap$2(acquire, (a) => set$5(ref, (exit2) => release(a, exit2))))), flatMap$3(use), ensuringWith$2((exit2) => flatMap$4(get$5(ref), (f) => f(exit2)))));
  const catchAll$1 = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => match$b(failureOrCause(cause), {
    onLeft: f,
    onRight: failCause$2
  })));
  const concatMap = /* @__PURE__ */ dual(2, (self2, f) => concatMapWith(self2, f, () => void 0, () => void 0));
  const drain$1 = (self2) => {
    const drainer = readWithCause({
      onInput: () => drainer,
      onFailure: failCause$2,
      onDone: succeed$3
    });
    return pipeTo(self2, drainer);
  };
  const ensuring$2 = /* @__PURE__ */ dual(2, (self2, finalizer) => ensuringWith$2(self2, () => finalizer));
  const flatten$3 = (self2) => flatMap$3(self2, identity);
  const fromInput$3 = (input) => unwrap$2(input.takeWith(failCause$2, (elem) => flatMap$3(write(elem), () => fromInput$3(input)), succeed$3));
  const identityChannel = () => readWith({
    onInput: (input) => flatMap$3(write(input), () => identityChannel()),
    onFailure: fail$5,
    onDone: succeedNow
  });
  const map$4 = /* @__PURE__ */ dual(2, (self2, f) => flatMap$3(self2, (a) => sync$1(() => f(a))));
  const mapError$3 = /* @__PURE__ */ dual(2, (self2, f) => mapErrorCause(self2, map$7(f)));
  const mapErrorCause = /* @__PURE__ */ dual(2, (self2, f) => catchAllCause(self2, (cause) => failCause$2(f(cause))));
  const mapOut = /* @__PURE__ */ dual(2, (self2, f) => {
    const reader = readWith({
      onInput: (outElem) => flatMap$3(write(f(outElem)), () => reader),
      onFailure: fail$5,
      onDone: succeedNow
    });
    return pipeTo(self2, reader);
  });
  const mapOutEffect = /* @__PURE__ */ dual(2, (self2, f) => {
    const reader = readWithCause({
      onInput: (outElem) => pipe(fromEffect$3(f(outElem)), flatMap$3(write), flatMap$3(() => reader)),
      onFailure: failCause$2,
      onDone: succeedNow
    });
    return pipeTo(self2, reader);
  });
  const mapOutEffectPar = /* @__PURE__ */ dual(3, (self2, f, n) => unwrapScopedWith$1((scope2) => gen$2(function* () {
    const input = yield* make$r();
    const queueReader = fromInput$3(input);
    const queue = yield* bounded(n);
    yield* addFinalizer$1(scope2, shutdown(queue));
    const errorSignal = yield* make$N();
    const withPermits = n === Number.POSITIVE_INFINITY ? (_) => identity : (yield* makeSemaphore(n)).withPermits;
    const pull = yield* queueReader.pipe(pipeTo(self2), toPullIn(scope2));
    yield* pull.pipe(matchCauseEffect({
      onFailure: (cause) => offer$2(queue, failCause$3(cause)),
      onSuccess: match$b({
        onLeft: (outDone) => zipRight$2(interruptible(withPermits(n)(_void)), asVoid(offer$2(queue, succeed$5(left(outDone))))),
        onRight: (outElem) => gen$2(function* () {
          const deferred = yield* make$N();
          const latch = yield* make$N();
          yield* offer$2(queue, map$5(_await$2(deferred), right));
          yield* succeed$9(latch, void 0).pipe(zipRight$2(uninterruptibleMask((restore) => exit(restore(_await$2(errorSignal))).pipe(raceFirst(exit(restore(f(outElem)))), flatMap$4(identity))).pipe(tapErrorCause((cause) => failCause$7(errorSignal, cause)), intoDeferred(deferred))), withPermits(1), forkIn(scope2));
          yield* _await$2(latch);
        })
      })
    }), forever, interruptible, forkIn(scope2));
    const consumer = unwrap$2(matchCause(flatten$4(take$4(queue)), {
      onFailure: failCause$2,
      onSuccess: match$b({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap$3(write(outElem), () => consumer)
      })
    }));
    return embedInput(consumer, input);
  })));
  const mergeAll = (options2) => {
    return (channels) => mergeAllWith(options2)(channels, constVoid);
  };
  const mergeAllWith = ({
    bufferSize = 16,
    concurrency,
    mergeStrategy = BackPressure()
  }) => (channels, f) => unwrapScopedWith$1((scope2) => gen$2(function* () {
    const concurrencyN = concurrency === "unbounded" ? Number.MAX_SAFE_INTEGER : concurrency;
    const input = yield* make$r();
    const queueReader = fromInput$3(input);
    const queue = yield* bounded(bufferSize);
    yield* addFinalizer$1(scope2, shutdown(queue));
    const cancelers = yield* unbounded$2();
    yield* addFinalizer$1(scope2, shutdown(cancelers));
    const lastDone = yield* make$G(none$4());
    const errorSignal = yield* make$N();
    const withPermits = (yield* makeSemaphore(concurrencyN)).withPermits;
    const pull = yield* toPullIn(pipeTo(queueReader, channels), scope2);
    function evaluatePull(pull2) {
      return pull2.pipe(flatMap$4(match$b({
        onLeft: (done2) => succeed$5(some(done2)),
        onRight: (outElem) => as(offer$2(queue, succeed$5(right(outElem))), none$4())
      })), repeat({
        until: (_) => isSome(_)
      }), flatMap$4((outDone) => update$3(lastDone, match$a({
        onNone: () => some(outDone.value),
        onSome: (lastDone2) => some(f(lastDone2, outDone.value))
      }))), catchAllCause$1((cause) => isInterrupted(cause) ? failCause$3(cause) : offer$2(queue, failCause$3(cause)).pipe(zipRight$2(succeed$9(errorSignal, void 0)), asVoid)));
    }
    yield* pull.pipe(matchCauseEffect({
      onFailure: (cause) => offer$2(queue, failCause$3(cause)).pipe(zipRight$2(succeed$5(false))),
      onSuccess: match$b({
        onLeft: (outDone) => raceWith(interruptible(_await$2(errorSignal)), interruptible(withPermits(concurrencyN)(_void)), {
          onSelfDone: (_, permitAcquisition) => as(interrupt$2(permitAcquisition), false),
          onOtherDone: (_, failureAwait) => zipRight$2(interrupt$2(failureAwait), get$5(lastDone).pipe(flatMap$4(match$a({
            onNone: () => offer$2(queue, succeed$5(left(outDone))),
            onSome: (lastDone2) => offer$2(queue, succeed$5(left(f(lastDone2, outDone))))
          })), as(false)))
        }),
        onRight: (channel) => match$1(mergeStrategy, {
          onBackPressure: () => gen$2(function* () {
            const latch = yield* make$N();
            const raceEffects = scopedWith$2((scope3) => toPullIn(pipeTo(queueReader, channel), scope3).pipe(flatMap$4((pull2) => race(exit(evaluatePull(pull2)), exit(interruptible(_await$2(errorSignal))))), flatMap$4(identity)));
            yield* succeed$9(latch, void 0).pipe(zipRight$2(raceEffects), withPermits(1), forkIn(scope2));
            yield* _await$2(latch);
            const errored = yield* isDone$5(errorSignal);
            return !errored;
          }),
          onBufferSliding: () => gen$2(function* () {
            const canceler = yield* make$N();
            const latch = yield* make$N();
            const size2 = yield* size$1(cancelers);
            yield* take$4(cancelers).pipe(flatMap$4((canceler2) => succeed$9(canceler2, void 0)), when$2(() => size2 >= concurrencyN));
            yield* offer$2(cancelers, canceler);
            const raceEffects = scopedWith$2((scope3) => toPullIn(pipeTo(queueReader, channel), scope3).pipe(flatMap$4((pull2) => exit(evaluatePull(pull2)).pipe(race(exit(interruptible(_await$2(errorSignal)))), race(exit(interruptible(_await$2(canceler)))))), flatMap$4(identity)));
            yield* succeed$9(latch, void 0).pipe(zipRight$2(raceEffects), withPermits(1), forkIn(scope2));
            yield* _await$2(latch);
            const errored = yield* isDone$5(errorSignal);
            return !errored;
          })
        })
      })
    }), repeat({
      while: (_) => _
    }), forkIn(scope2));
    const consumer = pipe(take$4(queue), flatten$4, matchCause({
      onFailure: failCause$2,
      onSuccess: match$b({
        onLeft: succeedNow,
        onRight: (outElem) => flatMap$3(write(outElem), () => consumer)
      })
    }), unwrap$2);
    return embedInput(consumer, input);
  }));
  const mergeMap = /* @__PURE__ */ dual(3, (self2, f, options2) => mergeAll(options2)(mapOut(self2, f)));
  const mergeWith$1 = /* @__PURE__ */ dual(2, (self2, options2) => {
    function merge2(scope2) {
      return gen$2(function* () {
        const input = yield* make$r();
        const queueReader = fromInput$3(input);
        const pullL = yield* toPullIn(pipeTo(queueReader, self2), scope2);
        const pullR = yield* toPullIn(pipeTo(queueReader, options2.other), scope2);
        function handleSide(exit2, fiber, pull) {
          return (done2, both, single) => {
            function onDecision(decision) {
              const op = decision;
              if (op._tag === OP_DONE$2) {
                return succeed$5(fromEffect$3(zipRight$2(interrupt$2(fiber), op.effect)));
              }
              return map$5(_await(fiber), match$6({
                onFailure: (cause) => fromEffect$3(op.f(failCause$6(cause))),
                onSuccess: match$b({
                  onLeft: (done3) => fromEffect$3(op.f(succeed$8(done3))),
                  onRight: (elem) => zipRight$1(write(elem), go2(single(op.f)))
                })
              }));
            }
            return match$6(exit2, {
              onFailure: (cause) => onDecision(done2(failCause$6(cause))),
              onSuccess: match$b({
                onLeft: (z) => onDecision(done2(succeed$8(z))),
                onRight: (elem) => succeed$5(flatMap$3(write(elem), () => flatMap$3(fromEffect$3(forkIn(interruptible(pull), scope2)), (leftFiber) => go2(both(leftFiber, fiber)))))
              })
            });
          };
        }
        function go2(state2) {
          switch (state2._tag) {
            case OP_BOTH_RUNNING: {
              const leftJoin = interruptible(join(state2.left));
              const rightJoin = interruptible(join(state2.right));
              return unwrap$2(raceWith(leftJoin, rightJoin, {
                onSelfDone: (leftExit, rf) => zipRight$2(interrupt$2(rf), handleSide(leftExit, state2.right, pullL)(options2.onSelfDone, BothRunning, (f) => LeftDone(f))),
                onOtherDone: (rightExit, lf) => zipRight$2(interrupt$2(lf), handleSide(rightExit, state2.left, pullR)(options2.onOtherDone, (left2, right2) => BothRunning(right2, left2), (f) => RightDone(f)))
              }));
            }
            case OP_LEFT_DONE: {
              return unwrap$2(map$5(exit(pullR), match$6({
                onFailure: (cause) => fromEffect$3(state2.f(failCause$6(cause))),
                onSuccess: match$b({
                  onLeft: (done2) => fromEffect$3(state2.f(succeed$8(done2))),
                  onRight: (elem) => flatMap$3(write(elem), () => go2(LeftDone(state2.f)))
                })
              })));
            }
            case OP_RIGHT_DONE: {
              return unwrap$2(map$5(exit(pullL), match$6({
                onFailure: (cause) => fromEffect$3(state2.f(failCause$6(cause))),
                onSuccess: match$b({
                  onLeft: (done2) => fromEffect$3(state2.f(succeed$8(done2))),
                  onRight: (elem) => flatMap$3(write(elem), () => go2(RightDone(state2.f)))
                })
              })));
            }
          }
        }
        return fromEffect$3(withFiberRuntime((parent) => {
          const inherit = withFiberRuntime((state2) => {
            state2.transferChildren(parent.scope());
            return _void;
          });
          const leftFiber = interruptible(pullL).pipe(ensuring$3(inherit), forkIn(scope2));
          const rightFiber = interruptible(pullR).pipe(ensuring$3(inherit), forkIn(scope2));
          return zipWith(leftFiber, rightFiber, (left2, right2) => BothRunning(left2, right2));
        })).pipe(flatMap$3(go2), embedInput(input));
      });
    }
    return unwrapScopedWith$1(merge2);
  });
  const orDieWith$1 = /* @__PURE__ */ dual(2, (self2, f) => catchAll$1(self2, (e) => failCauseSync(() => die$4(f(e)))));
  const pipeToOrFail = /* @__PURE__ */ dual(2, (self2, that) => suspend$5(() => {
    let channelException = void 0;
    const reader = readWith({
      onInput: (outElem) => flatMap$3(write(outElem), () => reader),
      onFailure: (outErr) => {
        channelException = ChannelException(outErr);
        return failCause$2(die$4(channelException));
      },
      onDone: succeedNow
    });
    const writer = readWithCause({
      onInput: (outElem) => pipe(write(outElem), flatMap$3(() => writer)),
      onFailure: (cause) => isDieType(cause) && isChannelException(cause.defect) && equals$1(cause.defect, channelException) ? fail$5(cause.defect.error) : failCause$2(cause),
      onDone: succeedNow
    });
    return pipeTo(pipeTo(pipeTo(self2, reader), that), writer);
  }));
  const run$3 = (self2) => scopedWith$2((scope2) => runIn(self2, scope2));
  const runDrain$2 = (self2) => run$3(drain$1(self2));
  const runScoped = (self2) => scopeWith((scope2) => runIn(self2, scope2));
  const scoped$1 = (effect2) => unwrap$2(uninterruptibleMask((restore) => map$5(make$u(), (scope2) => acquireReleaseOut(tapErrorCause(restore(extend$1(effect2, scope2)), (cause) => close(scope2, failCause$6(cause))), (_, exit2) => close(scope2, exit2)))));
  const scopedWith$1 = (f) => unwrapScoped$2(map$5(scope, (scope2) => flatMap$3(fromEffect$3(f(scope2)), write)));
  const toPull$1 = (self2) => flatMap$4(scope, (scope2) => toPullIn(self2, scope2));
  const toPullIn = /* @__PURE__ */ dual(2, (self2, scope2) => zip$1(sync$3(() => new ChannelExecutor(self2, void 0, identity)), runtime()).pipe(tap$2(([executor, runtime2]) => addFinalizerExit(scope2, (exit2) => {
    const finalizer = executor.close(exit2);
    return finalizer !== void 0 ? provide$1(finalizer, runtime2) : _void;
  })), uninterruptible, map$5(([executor]) => suspend$6(() => interpretToPull(executor.run(), executor)))));
  const interpretToPull = (channelState, exec) => {
    const state2 = channelState;
    switch (state2._tag) {
      case OP_DONE$3: {
        return match$6(exec.getDone(), {
          onFailure: failCause$3,
          onSuccess: (done2) => succeed$5(left(done2))
        });
      }
      case OP_EMIT$1: {
        return succeed$5(right(exec.getEmit()));
      }
      case OP_FROM_EFFECT: {
        return pipe(state2.effect, flatMap$4(() => interpretToPull(exec.run(), exec)));
      }
      case OP_READ: {
        return readUpstream(state2, () => interpretToPull(exec.run(), exec), (cause) => failCause$3(cause));
      }
    }
  };
  const unwrap$2 = (channel) => flatten$3(fromEffect$3(channel));
  const unwrapScoped$2 = (self2) => concatAllWith(scoped$1(self2), (d, _) => d, (d, _) => d);
  const unwrapScopedWith$1 = (f) => concatAllWith(scopedWith$1(f), (d, _) => d, (d, _) => d);
  const withSpan$2 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options2 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    const acquire = all([makeSpan(name, options2), context$1(), clock, get$4(currentTracerTimingEnabled)]);
    if (dataFirst) {
      const self2 = arguments[0];
      return acquireUseRelease(acquire, ([span2, context2]) => provideContext$2(self2, add$2(context2, spanTag, span2)), ([span2, , clock2, timingEnabled], exit2) => endSpan(span2, exit2, clock2, timingEnabled));
    }
    return (self2) => acquireUseRelease(acquire, ([span2, context2]) => provideContext$2(self2, add$2(context2, spanTag, span2)), ([span2, , clock2, timingEnabled], exit2) => endSpan(span2, exit2, clock2, timingEnabled));
  };
  const writeChunk = (outs) => writeChunkWriter(0, outs.length, outs);
  const writeChunkWriter = (idx, len, chunk2) => {
    return idx === len ? void_$1 : pipe(write(pipe(chunk2, unsafeGet$2(idx))), flatMap$3(() => writeChunkWriter(idx + 1, len, chunk2)));
  };
  const zip = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options2) => (options2 == null ? void 0 : options2.concurrent) ? mergeWith$1(self2, {
    other: that,
    onSelfDone: (exit1) => Await$1((exit2) => suspend$6(() => zip$2(exit1, exit2))),
    onOtherDone: (exit2) => Await$1((exit1) => suspend$6(() => zip$2(exit1, exit2)))
  }) : flatMap$3(self2, (a) => map$4(that, (b) => [a, b])));
  const zipRight$1 = /* @__PURE__ */ dual((args2) => isChannel(args2[1]), (self2, that, options2) => (options2 == null ? void 0 : options2.concurrent) ? map$4(zip(self2, that, {
    concurrent: true
  }), (tuple) => tuple[1]) : flatMap$3(self2, () => that));
  const ChannelExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Channel/ChannelException");
  const ChannelException = (error) => ({
    _tag: "ChannelException",
    [ChannelExceptionTypeId]: ChannelExceptionTypeId,
    error
  });
  const isChannelException = (u) => hasProperty(u, ChannelExceptionTypeId);
  const SinkTypeId = /* @__PURE__ */ Symbol.for("effect/Sink");
  const sinkVariance = {
    /* c8 ignore next */
    _A: (_) => _,
    /* c8 ignore next */
    _In: (_) => _,
    /* c8 ignore next */
    _L: (_) => _,
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _R: (_) => _
  };
  _pa = SinkTypeId;
  class SinkImpl {
    constructor(channel) {
      __publicField(this, "channel");
      __publicField(this, _pa, sinkVariance);
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const collectAll = () => new SinkImpl(collectAllLoop(empty$r()));
  const collectAllLoop = (acc) => readWithCause({
    onInput: (chunk2) => collectAllLoop(pipe(acc, appendAll$1(chunk2))),
    onFailure: failCause$2,
    onDone: () => succeed$3(acc)
  });
  const drain = /* @__PURE__ */ new SinkImpl(/* @__PURE__ */ drain$1(/* @__PURE__ */ identityChannel()));
  const forEachChunk = (f) => {
    const process2 = readWithCause({
      onInput: (input) => pipe(fromEffect$3(f(input)), flatMap$3(() => process2)),
      onFailure: failCause$2,
      onDone: () => void_$1
    });
    return new SinkImpl(process2);
  };
  const fromEffect$1 = (effect2) => new SinkImpl(fromEffect$3(effect2));
  const toChannel$1 = (self2) => isEffect(self2) ? toChannel$1(fromEffect$1(self2)) : self2.channel;
  const Done = Done$1;
  const Await = Await$1;
  const runFork = unsafeFork;
  const runPromiseExit = unsafeRunPromiseExit;
  const updateContext = updateContext$1;
  const exponential = exponential$1;
  const OP_LEFT = "Left";
  const OP_RIGHT = "Right";
  const OP_BOTH = "Both";
  const OP_EITHER = "Either";
  const Left = {
    _tag: OP_LEFT
  };
  const Right = {
    _tag: OP_RIGHT
  };
  const Both$1 = {
    _tag: OP_BOTH
  };
  const Either = {
    _tag: OP_EITHER
  };
  const fromInput$2 = (input) => {
    switch (input) {
      case "left":
        return Left;
      case "right":
        return Right;
      case "both":
        return Both$1;
      case "either":
        return Either;
      default:
        return input;
    }
  };
  const Both = Both$1;
  class Versioned {
    constructor(value2) {
      __publicField(this, "value");
      this.value = value2;
    }
  }
  const make$q = (ref, isNew) => ({
    ref,
    isNew,
    isChanged: false,
    expected: ref.versioned,
    newValue: ref.versioned.value
  });
  const unsafeGet$1 = (self2) => {
    return self2.newValue;
  };
  const unsafeSet$3 = (self2, value2) => {
    self2.isChanged = true;
    self2.newValue = value2;
  };
  const commit = (self2) => {
    self2.ref.versioned = new Versioned(self2.newValue);
  };
  const isInvalid = (self2) => {
    return self2.ref.versioned !== self2.expected;
  };
  const isChanged = (self2) => {
    return self2.isChanged;
  };
  const JournalAnalysisInvalid = "Invalid";
  const JournalAnalysisReadWrite = "ReadWrite";
  const JournalAnalysisReadOnly = "ReadOnly";
  const commitJournal = (journal) => {
    for (const entry of journal) {
      commit(entry[1]);
    }
  };
  const analyzeJournal = (journal) => {
    let val = JournalAnalysisReadOnly;
    for (const [, entry] of journal) {
      val = isInvalid(entry) ? JournalAnalysisInvalid : isChanged(entry) ? JournalAnalysisReadWrite : val;
      if (val === JournalAnalysisInvalid) {
        return val;
      }
    }
    return val;
  };
  const collectTodos = (journal) => {
    const allTodos = /* @__PURE__ */ new Map();
    for (const [, entry] of journal) {
      for (const todo of entry.ref.todos) {
        allTodos.set(todo[0], todo[1]);
      }
      entry.ref.todos = /* @__PURE__ */ new Map();
    }
    return allTodos;
  };
  const execTodos = (todos) => {
    const todosSorted = Array.from(todos.entries()).sort((x, y) => x[0] - y[0]);
    for (const [_, todo] of todosSorted) {
      todo();
    }
  };
  const addTodo = (txnId, journal, todoEffect) => {
    let added = false;
    for (const [, entry] of journal) {
      if (!entry.ref.todos.has(txnId)) {
        entry.ref.todos.set(txnId, todoEffect);
        added = true;
      }
    }
    return added;
  };
  const OP_WITH_STM_RUNTIME = "WithSTMRuntime";
  const OP_ON_FAILURE = "OnFailure";
  const OP_ON_RETRY = "OnRetry";
  const OP_ON_SUCCESS = "OnSuccess";
  const OP_PROVIDE = "Provide";
  const OP_SYNC = "Sync";
  const OP_SUCCEED$1 = "Succeed";
  const OP_RETRY$1 = "Retry";
  const OP_FAIL$1 = "Fail";
  const OP_DIE$1 = "Die";
  const OP_INTERRUPT$1 = "Interrupt";
  const OP_FAIL = "Fail";
  const OP_DIE = "Die";
  const OP_INTERRUPT = "Interrupt";
  const OP_SUCCEED = "Succeed";
  const OP_RETRY = "Retry";
  const OP_DONE$1 = "Done";
  const OP_SUSPEND = "Suspend";
  const OP_DONE = "Done";
  const OP_INTERRUPTED = "Interrupted";
  const OP_RUNNING = "Running";
  const STMStateSymbolKey = "effect/STM/State";
  const STMStateTypeId = /* @__PURE__ */ Symbol.for(STMStateSymbolKey);
  const isSTMState = (u) => hasProperty(u, STMStateTypeId);
  const isRunning = (self2) => {
    return self2._tag === OP_RUNNING;
  };
  const isDone = (self2) => {
    return self2._tag === OP_DONE;
  };
  const done$2 = (exit2) => {
    return {
      [STMStateTypeId]: STMStateTypeId,
      _tag: OP_DONE,
      exit: exit2,
      [symbol$1]() {
        return pipe(hash$2(STMStateSymbolKey), combine$7(hash$2(OP_DONE)), combine$7(hash$2(exit2)), cached$1(this));
      },
      [symbol](that) {
        return isSTMState(that) && that._tag === OP_DONE && equals$1(exit2, that.exit);
      }
    };
  };
  const interruptedHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash$2(STMStateSymbolKey), /* @__PURE__ */ combine$7(/* @__PURE__ */ hash$2(OP_INTERRUPTED)), /* @__PURE__ */ combine$7(/* @__PURE__ */ hash$2("interrupted")));
  const interrupted = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_INTERRUPTED,
    [symbol$1]() {
      return interruptedHash;
    },
    [symbol](that) {
      return isSTMState(that) && that._tag === OP_INTERRUPTED;
    }
  };
  const runningHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash$2(STMStateSymbolKey), /* @__PURE__ */ combine$7(/* @__PURE__ */ hash$2(OP_RUNNING)), /* @__PURE__ */ combine$7(/* @__PURE__ */ hash$2("running")));
  const running = {
    [STMStateTypeId]: STMStateTypeId,
    _tag: OP_RUNNING,
    [symbol$1]() {
      return runningHash;
    },
    [symbol](that) {
      return isSTMState(that) && that._tag === OP_RUNNING;
    }
  };
  const fromTExit = (tExit) => {
    switch (tExit._tag) {
      case OP_FAIL: {
        return done$2(fail$9(tExit.error));
      }
      case OP_DIE: {
        return done$2(die$5(tExit.defect));
      }
      case OP_INTERRUPT: {
        return done$2(interrupt$4(tExit.fiberId));
      }
      case OP_SUCCEED: {
        return done$2(succeed$8(tExit.value));
      }
      case OP_RETRY: {
        throw new Error("BUG: STM.STMState.fromTExit - please report an issue at https://github.com/Effect-TS/effect/issues");
      }
    }
  };
  const TExitSymbolKey = "effect/TExit";
  const TExitTypeId = /* @__PURE__ */ Symbol.for(TExitSymbolKey);
  const variance$1 = {
    /* c8 ignore next */
    _A: (_) => _,
    /* c8 ignore next */
    _E: (_) => _
  };
  const isExit = (u) => hasProperty(u, TExitTypeId);
  const isSuccess = (self2) => {
    return self2._tag === OP_SUCCEED;
  };
  const isRetry = (self2) => {
    return self2._tag === OP_RETRY;
  };
  const fail$4 = (error) => ({
    [TExitTypeId]: variance$1,
    _tag: OP_FAIL,
    error,
    [symbol$1]() {
      return pipe(hash$2(TExitSymbolKey), combine$7(hash$2(OP_FAIL)), combine$7(hash$2(error)), cached$1(this));
    },
    [symbol](that) {
      return isExit(that) && that._tag === OP_FAIL && equals$1(error, that.error);
    }
  });
  const die$2 = (defect) => ({
    [TExitTypeId]: variance$1,
    _tag: OP_DIE,
    defect,
    [symbol$1]() {
      return pipe(hash$2(TExitSymbolKey), combine$7(hash$2(OP_DIE)), combine$7(hash$2(defect)), cached$1(this));
    },
    [symbol](that) {
      return isExit(that) && that._tag === OP_DIE && equals$1(defect, that.defect);
    }
  });
  const interrupt = (fiberId2) => ({
    [TExitTypeId]: variance$1,
    _tag: OP_INTERRUPT,
    fiberId: fiberId2,
    [symbol$1]() {
      return pipe(hash$2(TExitSymbolKey), combine$7(hash$2(OP_INTERRUPT)), combine$7(hash$2(fiberId2)), cached$1(this));
    },
    [symbol](that) {
      return isExit(that) && that._tag === OP_INTERRUPT && equals$1(fiberId2, that.fiberId);
    }
  });
  const succeed$2 = (value2) => ({
    [TExitTypeId]: variance$1,
    _tag: OP_SUCCEED,
    value: value2,
    [symbol$1]() {
      return pipe(hash$2(TExitSymbolKey), combine$7(hash$2(OP_SUCCEED)), combine$7(hash$2(value2)), cached$1(this));
    },
    [symbol](that) {
      return isExit(that) && that._tag === OP_SUCCEED && equals$1(value2, that.value);
    }
  });
  const retryHash = /* @__PURE__ */ pipe(/* @__PURE__ */ hash$2(TExitSymbolKey), /* @__PURE__ */ combine$7(/* @__PURE__ */ hash$2(OP_RETRY)), /* @__PURE__ */ combine$7(/* @__PURE__ */ hash$2("retry")));
  const retry$2 = {
    [TExitTypeId]: variance$1,
    _tag: OP_RETRY,
    [symbol$1]() {
      return retryHash;
    },
    [symbol](that) {
      return isExit(that) && isRetry(that);
    }
  };
  const done$1 = (exit2) => {
    return {
      _tag: OP_DONE$1,
      exit: exit2
    };
  };
  const suspend$4 = (journal) => {
    return {
      _tag: OP_SUSPEND,
      journal
    };
  };
  const txnCounter = {
    ref: 0
  };
  const make$p = () => {
    const newId = txnCounter.ref + 1;
    txnCounter.ref = newId;
    return newId;
  };
  const STMSymbolKey = "effect/STM";
  const STMTypeId = /* @__PURE__ */ Symbol.for(STMSymbolKey);
  const stmVariance = {
    /* c8 ignore next */
    _R: (_) => _,
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _A: (_) => _
  };
  class STMPrimitive {
    constructor(effect_instruction_i0) {
      __publicField(this, "effect_instruction_i0");
      __publicField(this, "_op", OP_COMMIT);
      __publicField(this, "effect_instruction_i1");
      __publicField(this, "effect_instruction_i2");
      __publicField(this, _ta);
      __publicField(this, _sa);
      __publicField(this, _ra);
      __publicField(this, _qa);
      this.effect_instruction_i0 = effect_instruction_i0;
      this[EffectTypeId] = effectVariance;
      this[StreamTypeId$1] = stmVariance;
      this[SinkTypeId] = stmVariance;
      this[ChannelTypeId] = stmVariance;
    }
    get [(_ta = EffectTypeId, _sa = StreamTypeId$1, _ra = SinkTypeId, _qa = ChannelTypeId, STMTypeId)]() {
      return stmVariance;
    }
    [symbol](that) {
      return this === that;
    }
    [symbol$1]() {
      return cached$1(this, random(this));
    }
    [Symbol.iterator]() {
      return new SingleShotGen(new YieldWrap(this));
    }
    commit() {
      return unsafeAtomically(this, constVoid);
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const unsafeAtomically = (self2, onDone, onInterrupt2) => withFiberRuntime$1((state2) => {
    const fiberId2 = state2.id();
    const env2 = state2.getFiberRef(currentContext);
    const scheduler = state2.getFiberRef(currentScheduler);
    const priority = state2.getFiberRef(currentSchedulingPriority);
    const commitResult = tryCommitSync(fiberId2, self2, env2, scheduler, priority);
    switch (commitResult._tag) {
      case OP_DONE$1: {
        onDone(commitResult.exit);
        return commitResult.exit;
      }
      case OP_SUSPEND: {
        const txnId = make$p();
        const state3 = {
          value: running
        };
        const effect2 = async$1((k) => tryCommitAsync(fiberId2, self2, txnId, state3, env2, scheduler, priority, k));
        return uninterruptibleMask((restore) => pipe(restore(effect2), catchAllCause$1((cause) => {
          let currentState = state3.value;
          if (isRunning(currentState)) {
            state3.value = interrupted;
          }
          currentState = state3.value;
          if (isDone(currentState)) {
            onDone(currentState.exit);
            return currentState.exit;
          }
          return failCause$3(cause);
        })));
      }
    }
  });
  const tryCommit = (fiberId2, stm, state2, env2, scheduler, priority) => {
    const journal = /* @__PURE__ */ new Map();
    const tExit = new STMDriver(stm, journal, fiberId2, env2).run();
    const analysis = analyzeJournal(journal);
    if (analysis === JournalAnalysisReadWrite) {
      commitJournal(journal);
    } else if (analysis === JournalAnalysisInvalid) {
      throw new Error("BUG: STM.TryCommit.tryCommit - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    switch (tExit._tag) {
      case OP_SUCCEED: {
        state2.value = fromTExit(tExit);
        return completeTodos(succeed$8(tExit.value), journal, scheduler, priority);
      }
      case OP_FAIL: {
        state2.value = fromTExit(tExit);
        const cause = fail$8(tExit.error);
        return completeTodos(failCause$6(cause), journal, scheduler, priority);
      }
      case OP_DIE: {
        state2.value = fromTExit(tExit);
        const cause = die$4(tExit.defect);
        return completeTodos(failCause$6(cause), journal, scheduler, priority);
      }
      case OP_INTERRUPT: {
        state2.value = fromTExit(tExit);
        const cause = interrupt$3(fiberId2);
        return completeTodos(failCause$6(cause), journal, scheduler, priority);
      }
      case OP_RETRY: {
        return suspend$4(journal);
      }
    }
  };
  const tryCommitSync = (fiberId2, stm, env2, scheduler, priority) => {
    const journal = /* @__PURE__ */ new Map();
    const tExit = new STMDriver(stm, journal, fiberId2, env2).run();
    const analysis = analyzeJournal(journal);
    if (analysis === JournalAnalysisReadWrite && isSuccess(tExit)) {
      commitJournal(journal);
    } else if (analysis === JournalAnalysisInvalid) {
      throw new Error("BUG: STM.TryCommit.tryCommitSync - please report an issue at https://github.com/Effect-TS/effect/issues");
    }
    switch (tExit._tag) {
      case OP_SUCCEED: {
        return completeTodos(succeed$8(tExit.value), journal, scheduler, priority);
      }
      case OP_FAIL: {
        const cause = fail$8(tExit.error);
        return completeTodos(failCause$6(cause), journal, scheduler, priority);
      }
      case OP_DIE: {
        const cause = die$4(tExit.defect);
        return completeTodos(failCause$6(cause), journal, scheduler, priority);
      }
      case OP_INTERRUPT: {
        const cause = interrupt$3(fiberId2);
        return completeTodos(failCause$6(cause), journal, scheduler, priority);
      }
      case OP_RETRY: {
        return suspend$4(journal);
      }
    }
  };
  const tryCommitAsync = (fiberId2, self2, txnId, state2, context2, scheduler, priority, k) => {
    if (isRunning(state2.value)) {
      const result = tryCommit(fiberId2, self2, state2, context2, scheduler, priority);
      switch (result._tag) {
        case OP_DONE$1: {
          completeTryCommit(result.exit, k);
          break;
        }
        case OP_SUSPEND: {
          addTodo(txnId, result.journal, () => tryCommitAsync(fiberId2, self2, txnId, state2, context2, scheduler, priority, k));
          break;
        }
      }
    }
  };
  const completeTodos = (exit2, journal, scheduler, priority) => {
    const todos = collectTodos(journal);
    if (todos.size > 0) {
      scheduler.scheduleTask(() => execTodos(todos), priority);
    }
    return done$1(exit2);
  };
  const completeTryCommit = (exit2, k) => {
    k(exit2);
  };
  class STMDriver {
    constructor(self2, journal, fiberId2, r0) {
      __publicField(this, "self");
      __publicField(this, "journal");
      __publicField(this, "fiberId");
      __publicField(this, "contStack", []);
      __publicField(this, "env");
      this.self = self2;
      this.journal = journal;
      this.fiberId = fiberId2;
      this.env = r0;
    }
    getEnv() {
      return this.env;
    }
    pushStack(cont) {
      this.contStack.push(cont);
    }
    popStack() {
      return this.contStack.pop();
    }
    nextSuccess() {
      let current = this.popStack();
      while (current !== void 0 && current.effect_instruction_i0 !== OP_ON_SUCCESS) {
        current = this.popStack();
      }
      return current;
    }
    nextFailure() {
      let current = this.popStack();
      while (current !== void 0 && current.effect_instruction_i0 !== OP_ON_FAILURE) {
        current = this.popStack();
      }
      return current;
    }
    nextRetry() {
      let current = this.popStack();
      while (current !== void 0 && current.effect_instruction_i0 !== OP_ON_RETRY) {
        current = this.popStack();
      }
      return current;
    }
    run() {
      let curr = this.self;
      let exit2 = void 0;
      while (exit2 === void 0 && curr !== void 0) {
        try {
          const current = curr;
          if (current) {
            switch (current._op) {
              case "Tag": {
                curr = effect((_, __2, env2) => unsafeGet$3(env2, current));
                break;
              }
              case "Left": {
                curr = fail$3(current.left);
                break;
              }
              case "None": {
                curr = fail$3(new NoSuchElementException());
                break;
              }
              case "Right": {
                curr = succeed$1(current.right);
                break;
              }
              case "Some": {
                curr = succeed$1(current.value);
                break;
              }
              case "Commit": {
                switch (current.effect_instruction_i0) {
                  case OP_DIE$1: {
                    exit2 = die$2(internalCall(() => current.effect_instruction_i1()));
                    break;
                  }
                  case OP_FAIL$1: {
                    const cont = this.nextFailure();
                    if (cont === void 0) {
                      exit2 = fail$4(internalCall(() => current.effect_instruction_i1()));
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(internalCall(() => current.effect_instruction_i1())));
                    }
                    break;
                  }
                  case OP_RETRY$1: {
                    const cont = this.nextRetry();
                    if (cont === void 0) {
                      exit2 = retry$2;
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2());
                    }
                    break;
                  }
                  case OP_INTERRUPT$1: {
                    exit2 = interrupt(this.fiberId);
                    break;
                  }
                  case OP_WITH_STM_RUNTIME: {
                    curr = internalCall(() => current.effect_instruction_i1(this));
                    break;
                  }
                  case OP_ON_SUCCESS:
                  case OP_ON_FAILURE:
                  case OP_ON_RETRY: {
                    this.pushStack(current);
                    curr = current.effect_instruction_i1;
                    break;
                  }
                  case OP_PROVIDE: {
                    const env2 = this.env;
                    this.env = internalCall(() => current.effect_instruction_i2(env2));
                    curr = pipe(current.effect_instruction_i1, ensuring$1(sync(() => this.env = env2)));
                    break;
                  }
                  case OP_SUCCEED$1: {
                    const value2 = current.effect_instruction_i1;
                    const cont = this.nextSuccess();
                    if (cont === void 0) {
                      exit2 = succeed$2(value2);
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(value2));
                    }
                    break;
                  }
                  case OP_SYNC: {
                    const value2 = internalCall(() => current.effect_instruction_i1());
                    const cont = this.nextSuccess();
                    if (cont === void 0) {
                      exit2 = succeed$2(value2);
                    } else {
                      curr = internalCall(() => cont.effect_instruction_i2(value2));
                    }
                    break;
                  }
                }
                break;
              }
            }
          }
        } catch (e) {
          curr = die$1(e);
        }
      }
      return exit2;
    }
  }
  const catchAll = /* @__PURE__ */ dual(2, (self2, f) => {
    const stm = new STMPrimitive(OP_ON_FAILURE);
    stm.effect_instruction_i1 = self2;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  const die$1 = (defect) => dieSync(() => defect);
  const dieSync = (evaluate2) => {
    const stm = new STMPrimitive(OP_DIE$1);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  const effect = (f) => withSTMRuntime((_) => succeed$1(f(_.journal, _.fiberId, _.getEnv())));
  const ensuring$1 = /* @__PURE__ */ dual(2, (self2, finalizer) => matchSTM(self2, {
    onFailure: (e) => zipRight(finalizer, fail$3(e)),
    onSuccess: (a) => zipRight(finalizer, succeed$1(a))
  }));
  const fail$3 = (error) => failSync(() => error);
  const failSync = (evaluate2) => {
    const stm = new STMPrimitive(OP_FAIL$1);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  const flatMap$2 = /* @__PURE__ */ dual(2, (self2, f) => {
    const stm = new STMPrimitive(OP_ON_SUCCESS);
    stm.effect_instruction_i1 = self2;
    stm.effect_instruction_i2 = f;
    return stm;
  });
  const matchSTM = /* @__PURE__ */ dual(2, (self2, {
    onFailure,
    onSuccess
  }) => pipe(self2, map$3(right), catchAll((e) => pipe(onFailure(e), map$3(left))), flatMap$2((either2) => {
    switch (either2._tag) {
      case "Left": {
        return succeed$1(either2.left);
      }
      case "Right": {
        return onSuccess(either2.right);
      }
    }
  })));
  const withSTMRuntime = (f) => {
    const stm = new STMPrimitive(OP_WITH_STM_RUNTIME);
    stm.effect_instruction_i1 = f;
    return stm;
  };
  const interruptAs = (fiberId2) => {
    const stm = new STMPrimitive(OP_INTERRUPT$1);
    stm.effect_instruction_i1 = fiberId2;
    return stm;
  };
  const map$3 = /* @__PURE__ */ dual(2, (self2, f) => pipe(self2, flatMap$2((a) => sync(() => f(a)))));
  const retry$1 = /* @__PURE__ */ new STMPrimitive(OP_RETRY$1);
  const succeed$1 = (value2) => {
    const stm = new STMPrimitive(OP_SUCCEED$1);
    stm.effect_instruction_i1 = value2;
    return stm;
  };
  const sync = (evaluate2) => {
    const stm = new STMPrimitive(OP_SYNC);
    stm.effect_instruction_i1 = evaluate2;
    return stm;
  };
  const zipRight = /* @__PURE__ */ dual(2, (self2, that) => pipe(self2, flatMap$2(() => that)));
  const OP_BACKPRESSURE_STRATEGY = "BackPressure";
  const OP_DROPPING_STRATEGY = "Dropping";
  const OP_SLIDING_STRATEGY = "Sliding";
  const flatten$2 = (self2) => flatMap$2(self2, identity);
  const gen$1 = (...args2) => suspend$3(() => {
    const f = args2.length === 1 ? args2[0] : args2[1].bind(args2[0]);
    const iterator = f(pipe);
    const state2 = iterator.next();
    const run2 = (state3) => state3.done ? succeed$1(state3.value) : flatMap$2(yieldWrapGet(state3.value), (val) => run2(iterator.next(val)));
    return run2(state2);
  });
  const suspend$3 = (evaluate2) => flatten$2(sync(evaluate2));
  const void_ = /* @__PURE__ */ succeed$1(void 0);
  const TRefSymbolKey = "effect/TRef";
  const TRefTypeId = /* @__PURE__ */ Symbol.for(TRefSymbolKey);
  const tRefVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  _ua = TRefTypeId;
  class TRefImpl {
    constructor(value2) {
      __publicField(this, _ua, tRefVariance);
      /** @internal */
      __publicField(this, "todos");
      /** @internal */
      __publicField(this, "versioned");
      this.versioned = new Versioned(value2);
      this.todos = /* @__PURE__ */ new Map();
    }
    modify(f) {
      return effect((journal) => {
        const entry = getOrMakeEntry(this, journal);
        const [retValue, newValue] = f(unsafeGet$1(entry));
        unsafeSet$3(entry, newValue);
        return retValue;
      });
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const make$o = (value2) => effect((journal) => {
    const ref = new TRefImpl(value2);
    journal.set(ref, make$q(ref, true));
    return ref;
  });
  const get$3 = (self2) => self2.modify((a) => [a, a]);
  const set$4 = /* @__PURE__ */ dual(2, (self2, value2) => self2.modify(() => [void 0, value2]));
  const update$1 = /* @__PURE__ */ dual(2, (self2, f) => self2.modify((a) => [void 0, f(a)]));
  const getOrMakeEntry = (self2, journal) => {
    if (journal.has(self2)) {
      return journal.get(self2);
    }
    const entry = make$q(self2, false);
    journal.set(self2, entry);
    return entry;
  };
  const unsafeGet = /* @__PURE__ */ dual(2, (self2, journal) => unsafeGet$1(getOrMakeEntry(self2, journal)));
  const unsafeSet$2 = /* @__PURE__ */ dual(3, (self2, value2, journal) => {
    const entry = getOrMakeEntry(self2, journal);
    unsafeSet$3(entry, value2);
    return void 0;
  });
  const TEnqueueSymbolKey = "effect/TQueue/TEnqueue";
  const TEnqueueTypeId = /* @__PURE__ */ Symbol.for(TEnqueueSymbolKey);
  const TDequeueSymbolKey = "effect/TQueue/TDequeue";
  const TDequeueTypeId = /* @__PURE__ */ Symbol.for(TDequeueSymbolKey);
  const Dropping = {
    _tag: OP_DROPPING_STRATEGY
  };
  const tDequeueVariance = {
    /* c8 ignore next */
    _Out: (_) => _
  };
  const tEnqueueVariance = {
    /* c8 ignore next */
    _In: (_) => _
  };
  _wa = TDequeueTypeId, _va = TEnqueueTypeId;
  class TQueueImpl {
    constructor(ref, requestedCapacity, strategy) {
      __publicField(this, "ref");
      __publicField(this, "requestedCapacity");
      __publicField(this, "strategy");
      __publicField(this, _wa, tDequeueVariance);
      __publicField(this, _va, tEnqueueVariance);
      __publicField(this, "size", /* @__PURE__ */ withSTMRuntime((runtime2) => {
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        return succeed$1(queue.length);
      }));
      __publicField(this, "isFull", /* @__PURE__ */ map$3(this.size, (size2) => size2 === this.requestedCapacity));
      __publicField(this, "isEmpty", /* @__PURE__ */ map$3(this.size, (size2) => size2 === 0));
      __publicField(this, "shutdown", /* @__PURE__ */ withSTMRuntime((runtime2) => {
        unsafeSet$2(this.ref, void 0, runtime2.journal);
        return void_;
      }));
      __publicField(this, "isShutdown", /* @__PURE__ */ effect((journal) => {
        const queue = unsafeGet(this.ref, journal);
        return queue === void 0;
      }));
      __publicField(this, "awaitShutdown", /* @__PURE__ */ flatMap$2(this.isShutdown, (isShutdown2) => isShutdown2 ? void_ : retry$1));
      __publicField(this, "peek", /* @__PURE__ */ withSTMRuntime((runtime2) => {
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        if (queue.length === 0) {
          return retry$1;
        }
        return succeed$1(queue[0]);
      }));
      __publicField(this, "peekOption", /* @__PURE__ */ withSTMRuntime((runtime2) => {
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        return succeed$1(fromNullable(queue[0]));
      }));
      __publicField(this, "take", /* @__PURE__ */ withSTMRuntime((runtime2) => {
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        if (queue.length === 0) {
          return retry$1;
        }
        const dequeued = queue.shift();
        unsafeSet$2(this.ref, queue, runtime2.journal);
        return succeed$1(dequeued);
      }));
      __publicField(this, "takeAll", /* @__PURE__ */ withSTMRuntime((runtime2) => {
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        unsafeSet$2(this.ref, [], runtime2.journal);
        return succeed$1(queue);
      }));
      this.ref = ref;
      this.requestedCapacity = requestedCapacity;
      this.strategy = strategy;
    }
    capacity() {
      return this.requestedCapacity;
    }
    offer(value2) {
      return withSTMRuntime((runtime2) => {
        const queue = pipe(this.ref, unsafeGet(runtime2.journal));
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        if (queue.length < this.requestedCapacity) {
          queue.push(value2);
          unsafeSet$2(this.ref, queue, runtime2.journal);
          return succeed$1(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry$1;
          }
          case OP_DROPPING_STRATEGY: {
            return succeed$1(false);
          }
          case OP_SLIDING_STRATEGY: {
            if (queue.length === 0) {
              return succeed$1(true);
            }
            queue.shift();
            queue.push(value2);
            unsafeSet$2(this.ref, queue, runtime2.journal);
            return succeed$1(true);
          }
        }
      });
    }
    offerAll(iterable) {
      return withSTMRuntime((runtime2) => {
        const as2 = Array.from(iterable);
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        if (queue.length + as2.length <= this.requestedCapacity) {
          unsafeSet$2(this.ref, [...queue, ...as2], runtime2.journal);
          return succeed$1(true);
        }
        switch (this.strategy._tag) {
          case OP_BACKPRESSURE_STRATEGY: {
            return retry$1;
          }
          case OP_DROPPING_STRATEGY: {
            const forQueue = as2.slice(0, this.requestedCapacity - queue.length);
            unsafeSet$2(this.ref, [...queue, ...forQueue], runtime2.journal);
            return succeed$1(false);
          }
          case OP_SLIDING_STRATEGY: {
            const forQueue = as2.slice(0, this.requestedCapacity - queue.length);
            const toDrop = queue.length + forQueue.length - this.requestedCapacity;
            const newQueue = queue.slice(toDrop);
            unsafeSet$2(this.ref, [...newQueue, ...forQueue], runtime2.journal);
            return succeed$1(true);
          }
        }
      });
    }
    takeUpTo(max2) {
      return withSTMRuntime((runtime2) => {
        const queue = unsafeGet(this.ref, runtime2.journal);
        if (queue === void 0) {
          return interruptAs(runtime2.fiberId);
        }
        const [toTake, remaining] = splitAt(unsafeFromArray(queue), max2);
        unsafeSet$2(this.ref, Array.from(remaining), runtime2.journal);
        return succeed$1(Array.from(toTake));
      });
    }
  }
  const offer$1 = /* @__PURE__ */ dual(2, (self2, value2) => self2.offer(value2));
  const peek$1 = (self2) => self2.peek;
  const take$3 = (self2) => self2.take;
  const unbounded$1 = () => makeQueue(Number.MAX_SAFE_INTEGER, Dropping);
  const makeQueue = (requestedCapacity, strategy) => map$3(make$o([]), (ref) => new TQueueImpl(ref, requestedCapacity, strategy));
  const offer = offer$1;
  const peek = peek$1;
  const take$2 = take$3;
  const unbounded = unbounded$1;
  const make$n = (emit) => {
    const ops = {
      chunk(as2) {
        return this(succeed$5(as2));
      },
      die(defect) {
        return this(die$3(defect));
      },
      dieMessage(message) {
        return this(dieMessage(message));
      },
      done(exit2) {
        return this(suspend$6(() => mapBoth$2(exit2, {
          onFailure: some,
          onSuccess: of$2
        })));
      },
      end() {
        return this(fail$6(none$4()));
      },
      fail(e) {
        return this(fail$6(some(e)));
      },
      fromEffect(effect2) {
        return this(mapBoth$1(effect2, {
          onFailure: some,
          onSuccess: of$2
        }));
      },
      fromEffectChunk(effect2) {
        return this(pipe(effect2, mapError$4(some)));
      },
      halt(cause) {
        return this(failCause$3(pipe(cause, map$7(some))));
      },
      single(value2) {
        return this(succeed$5(of$2(value2)));
      }
    };
    return Object.assign(emit, ops);
  };
  const makePush = (queue, scheduler) => {
    let finished = false;
    let buffer = [];
    let running2 = false;
    function array2(items) {
      if (finished) return false;
      if (items.length <= 5e4) {
        buffer.push.apply(buffer, items);
      } else {
        for (let i = 0; i < items.length; i++) {
          buffer.push(items[0]);
        }
      }
      if (!running2) {
        running2 = true;
        scheduler.scheduleTask(flush, 0);
      }
      return true;
    }
    function flush() {
      running2 = false;
      if (buffer.length > 0) {
        queue.unsafeOffer(buffer);
        buffer = [];
      }
    }
    function done2(exit2) {
      if (finished) return;
      finished = true;
      if (exit2._tag === "Success") {
        buffer.push(exit2.value);
      }
      flush();
      queue.unsafeOffer(exit2._tag === "Success" ? void_$3 : exit2);
    }
    return {
      single(value2) {
        if (finished) return false;
        buffer.push(value2);
        if (!running2) {
          running2 = true;
          scheduler.scheduleTask(flush, 0);
        }
        return true;
      },
      array: array2,
      chunk(chunk2) {
        return array2(toReadonlyArray(chunk2));
      },
      done: done2,
      end() {
        if (finished) return;
        finished = true;
        flush();
        queue.unsafeOffer(void_$3);
      },
      halt(cause) {
        return done2(failCause$6(cause));
      },
      fail(error) {
        return done2(fail$9(error));
      },
      die(defect) {
        return done2(die$5(defect));
      },
      dieMessage(message) {
        return done2(die$5(new Error(message)));
      }
    };
  };
  const TakeSymbolKey = "effect/Take";
  const TakeTypeId = /* @__PURE__ */ Symbol.for(TakeSymbolKey);
  const takeVariance = {
    /* c8 ignore next */
    _A: (_) => _,
    /* c8 ignore next */
    _E: (_) => _
  };
  _xa = TakeTypeId;
  class TakeImpl {
    constructor(exit2) {
      __publicField(this, "exit");
      __publicField(this, _xa, takeVariance);
      this.exit = exit2;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const chunk = (chunk2) => new TakeImpl(succeed$8(chunk2));
  const done = (self2) => suspend$6(() => self2.exit);
  const end$1 = /* @__PURE__ */ new TakeImpl(/* @__PURE__ */ fail$9(/* @__PURE__ */ none$4()));
  const failCause$1 = (cause) => new TakeImpl(failCause$6(pipe(cause, map$7(some))));
  const fromPull$1 = (pull) => matchCause(pull, {
    onFailure: (cause) => match$a(flipCauseOption(cause), {
      onNone: () => end$1,
      onSome: failCause$1
    }),
    onSuccess: chunk
  });
  const match = /* @__PURE__ */ dual(2, (self2, {
    onEnd,
    onFailure,
    onSuccess
  }) => match$6(self2.exit, {
    onFailure: (cause) => match$a(flipCauseOption(cause), {
      onNone: onEnd,
      onSome: onFailure
    }),
    onSuccess
  }));
  const of = (value2) => new TakeImpl(succeed$8(of$2(value2)));
  const end = () => fail$6(none$4());
  const failCause = (cause) => mapError$4(failCause$3(cause), some);
  const StreamSymbolKey = "effect/Stream";
  const StreamTypeId = /* @__PURE__ */ Symbol.for(StreamSymbolKey);
  const streamVariance = {
    _R: (_) => _,
    _E: (_) => _,
    _A: (_) => _
  };
  _ya = StreamTypeId;
  class StreamImpl {
    constructor(channel) {
      __publicField(this, "channel");
      __publicField(this, _ya, streamVariance);
      this.channel = channel;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
  }
  const isStream = (u) => hasProperty(u, StreamTypeId) || isEffect(u);
  const DefaultChunkSize = 4096;
  const queueFromBufferOptions = (bufferSize) => {
    if (bufferSize === "unbounded") {
      return unbounded$2();
    } else if (typeof bufferSize === "number" || bufferSize === void 0) {
      return bounded(bufferSize ?? 16);
    }
    switch (bufferSize.strategy) {
      case "dropping":
        return dropping(bufferSize.bufferSize ?? 16);
      case "sliding":
        return sliding(bufferSize.bufferSize ?? 16);
      default:
        return bounded(bufferSize.bufferSize ?? 16);
    }
  };
  const queueFromBufferOptionsPush = (options2) => {
    if ((options2 == null ? void 0 : options2.bufferSize) === "unbounded" || (options2 == null ? void 0 : options2.bufferSize) === void 0 && (options2 == null ? void 0 : options2.strategy) === void 0) {
      return unbounded$2();
    }
    switch (options2 == null ? void 0 : options2.strategy) {
      case "sliding":
        return sliding(options2.bufferSize ?? 16);
      default:
        return dropping((options2 == null ? void 0 : options2.bufferSize) ?? 16);
    }
  };
  const asyncPush = (register, options2) => acquireRelease(queueFromBufferOptionsPush(options2), shutdown).pipe(tap$2((queue) => getWith(currentScheduler, (scheduler) => register(makePush(queue, scheduler)))), map$5((queue) => {
    const loop = flatMap$3(take$4(queue), (item) => isExit$1(item) ? isSuccess$1(item) ? void_$1 : failCause$2(item.cause) : zipRight$1(write(unsafeFromArray(item)), loop));
    return loop;
  }), unwrapScoped$2, fromChannel);
  const asyncScoped$1 = (register, bufferSize) => pipe(acquireRelease(queueFromBufferOptions(bufferSize), (queue) => shutdown(queue)), flatMap$4((output) => pipe(runtime(), flatMap$4((runtime2) => pipe(register(make$n((k) => pipe(fromPull$1(k), flatMap$4((take2) => offer$2(output, take2)), asVoid, runPromiseExit(runtime2)).then((exit2) => {
    if (isFailure(exit2)) {
      if (!isInterrupted(exit2.cause)) {
        throw squash(exit2.cause);
      }
    }
  }))), zipRight$2(make$G(false)), flatMap$4((ref) => pipe(get$5(ref), map$5((isDone2) => isDone2 ? end() : pipe(take$4(output), flatMap$4(done), onError(() => pipe(set$5(ref, true), zipRight$2(shutdown(output)))))))))))), scoped, flatMap$1(repeatEffectChunkOption));
  const bufferChunks$1 = /* @__PURE__ */ dual(2, (self2, options2) => {
    if (options2.strategy === "dropping") {
      return bufferChunksDropping(self2, options2.capacity);
    } else if (options2.strategy === "sliding") {
      return bufferChunksSliding(self2, options2.capacity);
    }
    const queue = toQueue(self2, options2);
    return new StreamImpl(unwrapScoped$2(map$5(queue, (queue2) => {
      const process2 = pipe(fromEffect$3(take$4(queue2)), flatMap$3(match({
        onEnd: () => void_$1,
        onFailure: failCause$2,
        onSuccess: (value2) => pipe(write(value2), flatMap$3(() => process2))
      })));
      return process2;
    })));
  });
  const bufferChunksDropping = /* @__PURE__ */ dual(2, (self2, capacity2) => {
    const queue = acquireRelease(dropping(capacity2), (queue2) => shutdown(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel(self2)));
  });
  const bufferChunksSliding = /* @__PURE__ */ dual(2, (self2, capacity2) => {
    const queue = acquireRelease(sliding(capacity2), (queue2) => shutdown(queue2));
    return new StreamImpl(bufferSignal(queue, toChannel(self2)));
  });
  const bufferSignal = (scoped2, bufferChannel) => {
    const producer = (queue, ref) => {
      const terminate = (take2) => pipe(get$5(ref), tap$2(_await$2), zipRight$2(make$N()), flatMap$4((deferred) => pipe(offer$2(queue, [take2, deferred]), zipRight$2(set$5(ref, deferred)), zipRight$2(_await$2(deferred)))), asVoid, fromEffect$3);
      return readWithCause({
        onInput: (input) => pipe(make$N(), flatMap$4((deferred) => pipe(offer$2(queue, [chunk(input), deferred]), flatMap$4((added) => pipe(set$5(ref, deferred), when$2(() => added))))), asVoid, fromEffect$3, flatMap$3(() => producer(queue, ref))),
        onFailure: (error) => terminate(failCause$1(error)),
        onDone: () => terminate(end$1)
      });
    };
    const consumer = (queue) => {
      const process2 = pipe(fromEffect$3(take$4(queue)), flatMap$3(([take2, deferred]) => zipRight$1(fromEffect$3(succeed$9(deferred, void 0)), match(take2, {
        onEnd: () => void_$1,
        onFailure: failCause$2,
        onSuccess: (value2) => pipe(write(value2), flatMap$3(() => process2))
      }))));
      return process2;
    };
    return unwrapScoped$2(pipe(scoped2, flatMap$4((queue) => pipe(make$N(), tap$2((start2) => succeed$9(start2, void 0)), flatMap$4((start2) => pipe(make$G(start2), flatMap$4((ref) => pipe(bufferChannel, pipeTo(producer(queue, ref)), runScoped, forkScoped)), as(consumer(queue))))))));
  };
  const concat = /* @__PURE__ */ dual(2, (self2, that) => new StreamImpl(pipe(toChannel(self2), zipRight$1(toChannel(that)))));
  const die = (defect) => fromEffect(die$3(defect));
  const ensuring = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(pipe(toChannel(self2), ensuring$2(finalizer))));
  const ensuringWith$1 = /* @__PURE__ */ dual(2, (self2, finalizer) => new StreamImpl(ensuringWith$2(toChannel(self2), finalizer)));
  const fail$2 = (error) => fromEffectOption(fail$6(some(error)));
  const filter$2 = /* @__PURE__ */ dual(2, (self2, predicate) => mapChunks(self2, filter$3(predicate)));
  const filterEffect$1 = /* @__PURE__ */ dual(2, (self2, f) => {
    const loop = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (input) => loop(input[Symbol.iterator]()),
          onFailure: failCause$2,
          onDone: succeed$3
        });
      } else {
        return pipe(f(next.value), map$5((bool) => bool ? pipe(write(of$2(next.value)), flatMap$3(() => loop(iterator))) : loop(iterator)), unwrap$2);
      }
    };
    return new StreamImpl(suspend$5(() => pipe(toChannel(self2), pipeTo(loop(empty$r()[Symbol.iterator]())))));
  });
  const filterMap$1 = /* @__PURE__ */ dual(2, (self2, pf) => mapChunks(self2, filterMap$2(pf)));
  const flatMap$1 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, f, options2) => {
    const bufferSize = (options2 == null ? void 0 : options2.bufferSize) ?? 16;
    if (options2 == null ? void 0 : options2.switch) {
      return matchConcurrency(options2 == null ? void 0 : options2.concurrency, () => flatMapParSwitchBuffer(self2, 1, bufferSize, f), (n) => flatMapParSwitchBuffer(self2, n, bufferSize, f));
    }
    return matchConcurrency(options2 == null ? void 0 : options2.concurrency, () => new StreamImpl(concatMap(toChannel(self2), (as2) => pipe(as2, map$d((a) => toChannel(f(a))), reduce$6(void_$1, (left2, right2) => pipe(left2, zipRight$1(right2)))))), (_) => new StreamImpl(pipe(toChannel(self2), concatMap(writeChunk), mergeMap((out) => toChannel(f(out)), options2))));
  });
  const matchConcurrency = (concurrency, sequential2, bounded2) => {
    switch (concurrency) {
      case void 0:
        return sequential2();
      case "unbounded":
        return bounded2(Number.MAX_SAFE_INTEGER);
      default:
        return concurrency > 1 ? bounded2(concurrency) : sequential2();
    }
  };
  const flatMapParSwitchBuffer = /* @__PURE__ */ dual(4, (self2, n, bufferSize, f) => new StreamImpl(pipe(toChannel(self2), concatMap(writeChunk), mergeMap((out) => toChannel(f(out)), {
    concurrency: n,
    mergeStrategy: BufferSliding(),
    bufferSize
  }))));
  const flatten$1 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options2) => flatMap$1(self2, identity, options2));
  const flattenChunks = (self2) => {
    const flatten2 = readWithCause({
      onInput: (chunks) => flatMap$3(writeChunk(chunks), () => flatten2),
      onFailure: failCause$2,
      onDone: () => void_$1
    });
    return new StreamImpl(pipe(toChannel(self2), pipeTo(flatten2)));
  };
  const flattenExitOption = (self2) => {
    const processChunk = (chunk2, cont) => {
      const [toEmit, rest] = pipe(chunk2, splitWhere((exit2) => !isSuccess$1(exit2)));
      const next = pipe(head$3(rest), match$a({
        onNone: () => cont,
        onSome: match$6({
          onFailure: (cause) => match$a(flipCauseOption(cause), {
            onNone: () => void_$1,
            onSome: failCause$2
          }),
          onSuccess: () => void_$1
        })
      }));
      return pipe(write(pipe(toEmit, filterMap$2((exit2) => isSuccess$1(exit2) ? some(exit2.value) : none$4()))), flatMap$3(() => next));
    };
    const process2 = readWithCause({
      onInput: (chunk2) => processChunk(chunk2, process2),
      onFailure: (cause) => failCause$2(cause),
      onDone: () => void_$1
    });
    return new StreamImpl(pipe(toChannel(self2), pipeTo(process2)));
  };
  const flattenIterables$1 = (self2) => pipe(self2, map$2(fromIterable$7), flattenChunks);
  const flattenTake = (self2) => flattenChunks(flattenExitOption(pipe(self2, map$2((take2) => take2.exit))));
  const fromChannel = (channel) => new StreamImpl(channel);
  const toChannel = (stream) => {
    if ("channel" in stream) {
      return stream.channel;
    } else if (isEffect(stream)) {
      return toChannel(fromEffect(stream));
    } else {
      throw new TypeError(`Expected a Stream.`);
    }
  };
  const fromChunk = (chunk2) => new StreamImpl(isEmpty$7(chunk2) ? void_$1 : write(chunk2));
  const fromEffect = (effect2) => pipe(effect2, mapError$4(some), fromEffectOption);
  const fromEffectOption = (effect2) => new StreamImpl(unwrap$2(match$2(effect2, {
    onFailure: match$a({
      onNone: () => void_$1,
      onSome: fail$5
    }),
    onSuccess: (a) => write(of$2(a))
  })));
  const fromPubSub$1 = (pubsub, options2) => {
    const maxChunkSize = (options2 == null ? void 0 : options2.maxChunkSize) ?? DefaultChunkSize;
    if (options2 == null ? void 0 : options2.scoped) {
      const effect2 = map$5(subscribe(pubsub), (queue) => fromQueue$1(queue, {
        maxChunkSize,
        shutdown: true
      }));
      return options2.shutdown ? map$5(effect2, ensuring(shutdown$1(pubsub))) : effect2;
    }
    const stream = flatMap$1(scoped(subscribe(pubsub)), (queue) => fromQueue$1(queue, {
      maxChunkSize
    }));
    return (options2 == null ? void 0 : options2.shutdown) ? ensuring(stream, shutdown$1(pubsub)) : stream;
  };
  const fromIterable$1 = (iterable) => suspend$2(() => isChunk(iterable) ? fromChunk(iterable) : fromIteratorSucceed(iterable[Symbol.iterator]()));
  const fromIteratorSucceed = (iterator, maxChunkSize = DefaultChunkSize) => {
    return pipe(sync$3(() => {
      let builder = [];
      const loop = (iterator2) => pipe(sync$3(() => {
        let next = iterator2.next();
        if (maxChunkSize === 1) {
          if (next.done) {
            return void_$1;
          }
          return pipe(write(of$2(next.value)), flatMap$3(() => loop(iterator2)));
        }
        builder = [];
        let count = 0;
        while (next.done === false) {
          builder.push(next.value);
          count = count + 1;
          if (count >= maxChunkSize) {
            break;
          }
          next = iterator2.next();
        }
        if (count > 0) {
          return pipe(write(unsafeFromArray(builder)), flatMap$3(() => loop(iterator2)));
        }
        return void_$1;
      }), unwrap$2);
      return new StreamImpl(loop(iterator));
    }), unwrap$1);
  };
  const fromPull = (effect2) => pipe(effect2, map$5(repeatEffectChunkOption), unwrapScoped$1);
  const fromQueue$1 = (queue, options2) => pipe(takeBetween$1(queue, 1, (options2 == null ? void 0 : options2.maxChunkSize) ?? DefaultChunkSize), catchAllCause$1((cause) => pipe(isShutdown(queue), flatMap$4((isShutdown2) => isShutdown2 && isInterrupted(cause) ? end() : failCause(cause)))), repeatEffectChunkOption, (options2 == null ? void 0 : options2.shutdown) ? ensuring(shutdown(queue)) : identity);
  const fromReadableStream$1 = (...args2) => {
    const evaluate2 = args2.length === 1 ? args2[0].evaluate : args2[0];
    const onError2 = args2.length === 1 ? args2[0].onError : args2[1];
    const releaseLockOnEnd = args2.length === 1 ? args2[0].releaseLockOnEnd === true : false;
    return unwrapScoped$1(map$5(acquireRelease(sync$3(() => evaluate2().getReader()), (reader) => releaseLockOnEnd ? sync$3(() => reader.releaseLock()) : promise(() => reader.cancel())), (reader) => repeatEffectOption(flatMap$4(tryPromise({
      try: () => reader.read(),
      catch: (reason) => some(onError2(reason))
    }), ({
      done: done2,
      value: value2
    }) => done2 ? fail$6(none$4()) : succeed$5(value2)))));
  };
  const make$m = (...as2) => fromIterable$1(as2);
  const map$2 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel(self2), mapOut(map$d(f)))));
  const mapChunks = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel(self2), mapOut(f))));
  const mapChunksEffect$1 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel(self2), mapOutEffect(f))));
  const mapEffectSequential = /* @__PURE__ */ dual(2, (self2, f) => {
    const loop = (iterator) => {
      const next = iterator.next();
      if (next.done) {
        return readWithCause({
          onInput: (elem) => loop(elem[Symbol.iterator]()),
          onFailure: failCause$2,
          onDone: succeed$3
        });
      } else {
        const value2 = next.value;
        return unwrap$2(map$5(f(value2), (a2) => flatMap$3(write(of$2(a2)), () => loop(iterator))));
      }
    };
    return new StreamImpl(pipe(toChannel(self2), pipeTo(suspend$5(() => loop(empty$r()[Symbol.iterator]())))));
  });
  const mapEffectPar = /* @__PURE__ */ dual(3, (self2, n, f) => new StreamImpl(pipe(toChannel(self2), concatMap(writeChunk), mapOutEffectPar(f, n), mapOut(of$2))));
  const mapError$2 = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel(self2), mapError$3(f))));
  const mergeEither = /* @__PURE__ */ dual(2, (self2, that) => mergeWith(self2, that, {
    onSelf: left,
    onOther: right
  }));
  const mergeWith = /* @__PURE__ */ dual(3, (self2, other, options2) => {
    const strategy = options2.haltStrategy ? fromInput$2(options2.haltStrategy) : Both;
    const handler = (terminate) => (exit2) => terminate || !isSuccess$1(exit2) ? (
      // TODO: remove
      Done(suspend$6(() => exit2))
    ) : Await((exit3) => suspend$6(() => exit3));
    return new StreamImpl(mergeWith$1(toChannel(map$2(self2, options2.onSelf)), {
      other: toChannel(map$2(other, options2.onOther)),
      onSelfDone: handler(strategy._tag === "Either" || strategy._tag === "Left"),
      onOtherDone: handler(strategy._tag === "Either" || strategy._tag === "Right")
    }));
  });
  const never$1 = /* @__PURE__ */ fromEffect(never$2);
  const orDie$1 = (self2) => pipe(self2, orDieWith(identity));
  const orDieWith = /* @__PURE__ */ dual(2, (self2, f) => new StreamImpl(pipe(toChannel(self2), orDieWith$1(f))));
  const provideContext$1 = /* @__PURE__ */ dual(2, (self2, context2) => new StreamImpl(pipe(toChannel(self2), provideContext$2(context2))));
  const repeatEffectChunkOption = (effect2) => unfoldChunkEffect(effect2, (effect3) => pipe(map$5(effect3, (chunk2) => some([chunk2, effect3])), catchAll$2(match$a({
    onNone: () => succeed$5(none$4()),
    onSome: fail$6
  }))));
  const repeatEffectOption = (effect2) => repeatEffectChunkOption(pipe(effect2, map$5(of$2)));
  const run$2 = /* @__PURE__ */ dual(2, (self2, sink) => toChannel(self2).pipe(pipeToOrFail(toChannel$1(sink)), runDrain$2));
  const runCollect$1 = (self2) => run$2(self2, collectAll());
  const runDrain$1 = (self2) => run$2(self2, drain);
  const runForEachChunk$1 = /* @__PURE__ */ dual(2, (self2, f) => run$2(self2, forEachChunk(f)));
  const runIntoQueueScoped = /* @__PURE__ */ dual(2, (self2, queue) => {
    const writer = readWithCause({
      onInput: (input) => flatMap$3(write(chunk(input)), () => writer),
      onFailure: (cause) => write(failCause$1(cause)),
      onDone: () => write(end$1)
    });
    return pipe(pipeTo(toChannel(self2), writer), mapOutEffect((take2) => offer$2(queue, take2)), drain$1, runScoped, asVoid);
  });
  const scoped = (effect2) => new StreamImpl(ensuring$2(scoped$1(pipe(effect2, map$5(of$2))), _void));
  const scopedWith = (f) => new StreamImpl(scopedWith$1((scope2) => f(scope2).pipe(map$5(of$2))));
  const suspend$2 = (stream) => new StreamImpl(suspend$5(() => toChannel(stream())));
  const take$1 = /* @__PURE__ */ dual(2, (self2, n) => {
    if (!Number.isInteger(n)) {
      return die(new IllegalArgumentException(`${n} must be an integer`));
    }
    const loop = (n2) => readWith({
      onInput: (input) => {
        const taken = pipe(input, take$6(Math.min(n2, Number.POSITIVE_INFINITY)));
        const leftover = Math.max(0, n2 - taken.length);
        const more = leftover > 0;
        if (more) {
          return pipe(write(taken), flatMap$3(() => loop(leftover)));
        }
        return write(taken);
      },
      onFailure: fail$5,
      onDone: succeed$3
    });
    return new StreamImpl(pipe(toChannel(self2), pipeToOrFail(0 < n ? loop(n) : void_$1)));
  });
  const tap$1 = /* @__PURE__ */ dual(2, (self2, f) => mapEffectSequential(self2, (a) => as(f(a), a)));
  const toPull = (self2) => map$5(toPull$1(toChannel(self2)), (pull) => pipe(pull, mapError$4(some), flatMap$4(match$b({
    onLeft: () => fail$6(none$4()),
    onRight: succeed$5
  }))));
  const toQueue = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options2) => tap$2(acquireRelease((options2 == null ? void 0 : options2.strategy) === "unbounded" ? unbounded$2() : (options2 == null ? void 0 : options2.strategy) === "dropping" ? dropping(options2.capacity ?? 2) : (options2 == null ? void 0 : options2.strategy) === "sliding" ? sliding(options2.capacity ?? 2) : bounded((options2 == null ? void 0 : options2.capacity) ?? 2), (queue) => shutdown(queue)), (queue) => forkScoped(runIntoQueueScoped(self2, queue))));
  const toReadableStreamEffect$1 = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, options2) => map$5(runtime(), (runtime2) => toReadableStreamRuntime(self2, runtime2, options2)));
  const toReadableStreamRuntime = /* @__PURE__ */ dual((args2) => isStream(args2[0]), (self2, runtime2, options2) => {
    const runFork$12 = runFork(runtime2);
    let currentResolve = void 0;
    let fiber = void 0;
    const latch = unsafeMakeLatch(false);
    return new ReadableStream({
      start(controller) {
        fiber = runFork$12(runForEachChunk$1(self2, (chunk2) => latch.whenOpen(sync$3(() => {
          latch.unsafeClose();
          for (const item of chunk2) {
            controller.enqueue(item);
          }
          currentResolve();
          currentResolve = void 0;
        }))));
        fiber.addObserver((exit2) => {
          if (exit2._tag === "Failure") {
            controller.error(squash(exit2.cause));
          } else {
            controller.close();
          }
        });
      },
      pull() {
        return new Promise((resolve) => {
          currentResolve = resolve;
          runSync(latch.open);
        });
      },
      cancel() {
        if (!fiber) return;
        return runPromise(asVoid(interrupt$2(fiber)));
      }
    }, options2 == null ? void 0 : options2.strategy);
  });
  const unfoldChunk$1 = (s, f) => {
    const loop = (s2) => match$a(f(s2), {
      onNone: () => void_$1,
      onSome: ([chunk2, s3]) => flatMap$3(write(chunk2), () => loop(s3))
    });
    return new StreamImpl(suspend$5(() => loop(s)));
  };
  const unfoldChunkEffect = (s, f) => suspend$2(() => {
    const loop = (s2) => unwrap$2(map$5(f(s2), match$a({
      onNone: () => void_$1,
      onSome: ([chunk2, s3]) => flatMap$3(write(chunk2), () => loop(s3))
    })));
    return new StreamImpl(loop(s));
  });
  const unwrap$1 = (effect2) => flatten$1(fromEffect(effect2));
  const unwrapScoped$1 = (effect2) => flatten$1(scoped(effect2));
  const unwrapScopedWith = (f) => flatten$1(scopedWith((scope2) => f(scope2)));
  const withSpan$1 = function() {
    const dataFirst = typeof arguments[0] !== "string";
    const name = dataFirst ? arguments[1] : arguments[0];
    const options2 = addSpanStackTrace(dataFirst ? arguments[2] : arguments[1]);
    if (dataFirst) {
      const self2 = arguments[0];
      return new StreamImpl(withSpan$2(toChannel(self2), name, options2));
    }
    return (self2) => new StreamImpl(withSpan$2(toChannel(self2), name, options2));
  };
  const zipLatest$1 = /* @__PURE__ */ dual(2, (left2, right2) => pipe(left2, zipLatestWith(right2, (a, a2) => [a, a2])));
  const zipLatestWith = /* @__PURE__ */ dual(3, (left2, right2, f) => {
    const pullNonEmpty = (pull) => pipe(pull, flatMap$4((chunk2) => isEmpty$7(chunk2) ? pullNonEmpty(pull) : succeed$5(chunk2)));
    return pipe(toPull(left2), map$5(pullNonEmpty), zip$1(pipe(toPull(right2), map$5(pullNonEmpty))), flatMap$4(([left3, right3]) => pipe(fromEffectOption(raceWith(left3, right3, {
      onSelfDone: (leftDone, rightFiber) => pipe(suspend$6(() => leftDone), zipWith(join(rightFiber), (l, r) => [l, r, true])),
      onOtherDone: (rightDone, leftFiber) => pipe(suspend$6(() => rightDone), zipWith(join(leftFiber), (l, r) => [r, l, false]))
    })), flatMap$1(([l, r, leftFirst]) => pipe(fromEffect(make$G([unsafeLast(l), unsafeLast(r)])), flatMap$1((latest) => pipe(fromChunk(leftFirst ? pipe(r, map$d((a2) => f(unsafeLast(l), a2))) : pipe(l, map$d((a) => f(a, unsafeLast(r))))), concat(pipe(repeatEffectOption(left3), mergeEither(repeatEffectOption(right3)), mapEffectSequential(match$b({
      onLeft: (leftChunk) => pipe(modify$1(latest, ([_, rightLatest]) => [pipe(leftChunk, map$d((a) => f(a, rightLatest))), [unsafeLast(leftChunk), rightLatest]])),
      onRight: (rightChunk) => pipe(modify$1(latest, ([leftLatest, _]) => [pipe(rightChunk, map$d((a2) => f(leftLatest, a2))), [leftLatest, unsafeLast(rightChunk)]]))
    })), flatMap$1(fromChunk))))))), toPull)), fromPull);
  });
  const fromEventListener$1 = (target, type, options2) => asyncPush((emit) => acquireRelease(sync$3(() => target.addEventListener(type, emit.single, options2)), () => sync$3(() => target.removeEventListener(type, emit.single, options2))), {
    bufferSize: typeof options2 === "object" ? options2.bufferSize : void 0
  });
  const RedactedSymbolKey = "effect/Redacted";
  const redactedRegistry = /* @__PURE__ */ globalValue("effect/Redacted/redactedRegistry", () => /* @__PURE__ */ new WeakMap());
  const RedactedTypeId = /* @__PURE__ */ Symbol.for(RedactedSymbolKey);
  const proto = {
    [RedactedTypeId]: {
      _A: (_) => _
    },
    pipe() {
      return pipeArguments(this, arguments);
    },
    toString() {
      return "<redacted>";
    },
    toJSON() {
      return "<redacted>";
    },
    [NodeInspectSymbol]() {
      return "<redacted>";
    },
    [symbol$1]() {
      return pipe(hash$2(RedactedSymbolKey), combine$7(hash$2(redactedRegistry.get(this))), cached$1(this));
    },
    [symbol](that) {
      return isRedacted(that) && equals$1(redactedRegistry.get(this), redactedRegistry.get(that));
    }
  };
  const isRedacted = (u) => hasProperty(u, RedactedTypeId);
  const make$l = (value2) => {
    const redacted = Object.create(proto);
    redactedRegistry.set(redacted, value2);
    return redacted;
  };
  const DecodeExceptionTypeId = /* @__PURE__ */ Symbol.for("effect/Encoding/errors/Decode");
  const DecodeException = (input, message) => {
    const out = {
      _tag: "DecodeException",
      [DecodeExceptionTypeId]: DecodeExceptionTypeId,
      input
    };
    if (isString(message)) {
      out.message = message;
    }
    return out;
  };
  const encoder = /* @__PURE__ */ new TextEncoder();
  const encode$2 = (bytes) => {
    const length2 = bytes.length;
    let result = "";
    let i;
    for (i = 2; i < length2; i += 3) {
      result += base64abc[bytes[i - 2] >> 2];
      result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
      result += base64abc[(bytes[i - 1] & 15) << 2 | bytes[i] >> 6];
      result += base64abc[bytes[i] & 63];
    }
    if (i === length2 + 1) {
      result += base64abc[bytes[i - 2] >> 2];
      result += base64abc[(bytes[i - 2] & 3) << 4];
      result += "==";
    }
    if (i === length2) {
      result += base64abc[bytes[i - 2] >> 2];
      result += base64abc[(bytes[i - 2] & 3) << 4 | bytes[i - 1] >> 4];
      result += base64abc[(bytes[i - 1] & 15) << 2];
      result += "=";
    }
    return result;
  };
  const decode$2 = (str) => {
    const stripped = stripCrlf(str);
    const length2 = stripped.length;
    if (length2 % 4 !== 0) {
      return left(DecodeException(stripped, `Length must be a multiple of 4, but is ${length2}`));
    }
    const index = stripped.indexOf("=");
    if (index !== -1 && (index < length2 - 2 || index === length2 - 2 && stripped[length2 - 1] !== "=")) {
      return left(DecodeException(stripped, "Found a '=' character, but it is not at the end"));
    }
    try {
      const missingOctets = stripped.endsWith("==") ? 2 : stripped.endsWith("=") ? 1 : 0;
      const result = new Uint8Array(3 * (length2 / 4) - missingOctets);
      for (let i = 0, j = 0; i < length2; i += 4, j += 3) {
        const buffer = getBase64Code(stripped.charCodeAt(i)) << 18 | getBase64Code(stripped.charCodeAt(i + 1)) << 12 | getBase64Code(stripped.charCodeAt(i + 2)) << 6 | getBase64Code(stripped.charCodeAt(i + 3));
        result[j] = buffer >> 16;
        result[j + 1] = buffer >> 8 & 255;
        result[j + 2] = buffer & 255;
      }
      return right(result);
    } catch (e) {
      return left(DecodeException(stripped, e instanceof Error ? e.message : "Invalid input"));
    }
  };
  const stripCrlf = (str) => str.replace(/[\n\r]/g, "");
  function getBase64Code(charCode) {
    if (charCode >= base64codes.length) {
      throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
    }
    const code = base64codes[charCode];
    if (code === 255) {
      throw new TypeError(`Invalid character ${String.fromCharCode(charCode)}`);
    }
    return code;
  }
  const base64abc = ["A", "B", "C", "D", "E", "F", "G", "H", "I", "J", "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T", "U", "V", "W", "X", "Y", "Z", "a", "b", "c", "d", "e", "f", "g", "h", "i", "j", "k", "l", "m", "n", "o", "p", "q", "r", "s", "t", "u", "v", "w", "x", "y", "z", "0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "+", "/"];
  const base64codes = [255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 62, 255, 255, 255, 63, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 255, 255, 255, 0, 255, 255, 255, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 255, 255, 255, 255, 255, 255, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51];
  const encodeBase64 = (input) => typeof input === "string" ? encode$2(encoder.encode(input)) : encode$2(input);
  const decodeBase64 = (str) => decode$2(str);
  const TypeId$f = /* @__PURE__ */ Symbol.for("effect/FiberHandle");
  const isFiberHandle = (u) => hasProperty(u, TypeId$f);
  const Proto$5 = {
    [TypeId$f]: TypeId$f,
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberHandle",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const unsafeMake$2 = (deferred) => {
    const self2 = Object.create(Proto$5);
    self2.state = {
      _tag: "Open",
      fiber: void 0
    };
    self2.deferred = deferred;
    return self2;
  };
  const make$k = () => acquireRelease(map$5(make$N(), (deferred) => unsafeMake$2(deferred)), (handle) => withFiberRuntime((parent) => {
    const state2 = handle.state;
    if (state2._tag === "Closed") return _void;
    handle.state = {
      _tag: "Closed"
    };
    return state2.fiber ? intoDeferred(asVoid(interruptAs$1(state2.fiber, combine$5(parent.id(), internalFiberId$2))), handle.deferred) : done$7(handle.deferred, void_$3);
  }));
  const internalFiberIdId$2 = -1;
  const internalFiberId$2 = /* @__PURE__ */ make$R(internalFiberIdId$2, 0);
  const isInternalInterruption$2 = /* @__PURE__ */ reduceWithContext(void 0, {
    emptyCase: constFalse,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: (_, fiberId2) => has$1(ids(fiberId2), internalFiberIdId$2),
    sequentialCase: (_, left2, right2) => left2 || right2,
    parallelCase: (_, left2, right2) => left2 || right2
  });
  const unsafeSet$1 = /* @__PURE__ */ dual((args2) => isFiberHandle(args2[0]), (self2, fiber, options2) => {
    if (self2.state._tag === "Closed") {
      fiber.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId$2));
      return;
    } else if (self2.state.fiber !== void 0) {
      if ((options2 == null ? void 0 : options2.onlyIfMissing) === true) {
        fiber.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId$2));
        return;
      } else if (self2.state.fiber === fiber) {
        return;
      }
      self2.state.fiber.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId$2));
      self2.state.fiber = void 0;
    }
    self2.state.fiber = fiber;
    fiber.addObserver((exit2) => {
      if (self2.state._tag === "Open" && fiber === self2.state.fiber) {
        self2.state.fiber = void 0;
      }
      if (isFailure(exit2) && ((options2 == null ? void 0 : options2.propagateInterruption) === true ? !isInternalInterruption$2(exit2.cause) : !isInterruptedOnly(exit2.cause))) {
        unsafeDone(self2.deferred, exit2);
      }
    });
  });
  const clear$1 = (self2) => uninterruptibleMask((restore) => withFiberRuntime((fiber) => {
    if (self2.state._tag === "Closed" || self2.state.fiber === void 0) {
      return _void;
    }
    return zipRight$2(restore(interruptAs$1(self2.state.fiber, combine$5(fiber.id(), internalFiberId$2))), sync$3(() => {
      if (self2.state._tag === "Open") {
        self2.state.fiber = void 0;
      }
    }));
  }));
  const constInterruptedFiber$1 = /* @__PURE__ */ function() {
    let fiber = void 0;
    return () => {
      if (fiber === void 0) {
        fiber = runFork$1(interrupt$1);
      }
      return fiber;
    };
  }();
  const run$1 = function() {
    const self2 = arguments[0];
    if (isEffect(arguments[1])) {
      return runImpl$1(self2, arguments[1], arguments[2]);
    }
    const options2 = arguments[1];
    return (effect2) => runImpl$1(self2, effect2, options2);
  };
  const runImpl$1 = (self2, effect2, options2) => fiberIdWith((fiberId2) => {
    if (self2.state._tag === "Closed") {
      return interrupt$1;
    } else if (self2.state.fiber !== void 0 && (options2 == null ? void 0 : options2.onlyIfMissing) === true) {
      return sync$3(constInterruptedFiber$1);
    }
    return tap$2(forkDaemon(effect2), (fiber) => unsafeSet$1(self2, fiber, {
      ...options2,
      interruptAs: fiberId2
    }));
  });
  const TypeId$e = /* @__PURE__ */ Symbol.for("effect/FiberMap");
  const isFiberMap = (u) => hasProperty(u, TypeId$e);
  const Proto$4 = {
    [TypeId$e]: TypeId$e,
    [Symbol.iterator]() {
      if (this.state._tag === "Closed") {
        return empty$v();
      }
      return this.state.backing[Symbol.iterator]();
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberMap",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const unsafeMake$1 = (backing, deferred) => {
    const self2 = Object.create(Proto$4);
    self2.state = {
      _tag: "Open",
      backing
    };
    self2.deferred = deferred;
    return self2;
  };
  const make$j = () => acquireRelease(map$5(make$N(), (deferred) => unsafeMake$1(empty$g(), deferred)), (map2) => withFiberRuntime((parent) => {
    const state2 = map2.state;
    if (state2._tag === "Closed") return _void;
    map2.state = {
      _tag: "Closed"
    };
    return interruptAllAs(map$g(state2.backing, ([, fiber]) => fiber), combine$5(parent.id(), internalFiberId$1)).pipe(intoDeferred(map2.deferred));
  }));
  const internalFiberIdId$1 = -1;
  const internalFiberId$1 = /* @__PURE__ */ make$R(internalFiberIdId$1, 0);
  const isInternalInterruption$1 = /* @__PURE__ */ reduceWithContext(void 0, {
    emptyCase: constFalse,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: (_, fiberId2) => has$1(ids(fiberId2), internalFiberIdId$1),
    sequentialCase: (_, left2, right2) => left2 || right2,
    parallelCase: (_, left2, right2) => left2 || right2
  });
  const unsafeSet = /* @__PURE__ */ dual((args2) => isFiberMap(args2[0]), (self2, key, fiber, options2) => {
    if (self2.state._tag === "Closed") {
      fiber.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId$1));
      return;
    }
    const previous = get$9(self2.state.backing, key);
    if (previous._tag === "Some") {
      if ((options2 == null ? void 0 : options2.onlyIfMissing) === true) {
        fiber.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId$1));
        return;
      } else if (previous.value === fiber) {
        return;
      }
      previous.value.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId$1));
    }
    set$7(self2.state.backing, key, fiber);
    fiber.addObserver((exit2) => {
      if (self2.state._tag === "Closed") {
        return;
      }
      const current = get$9(self2.state.backing, key);
      if (isSome(current) && fiber === current.value) {
        remove$3(self2.state.backing, key);
      }
      if (isFailure(exit2) && ((options2 == null ? void 0 : options2.propagateInterruption) === true ? !isInternalInterruption$1(exit2.cause) : !isInterruptedOnly(exit2.cause))) {
        unsafeDone(self2.deferred, exit2);
      }
    });
  });
  const unsafeHas = /* @__PURE__ */ dual(2, (self2, key) => self2.state._tag === "Closed" ? false : has(self2.state.backing, key));
  const remove$1 = /* @__PURE__ */ dual(2, (self2, key) => withFiberRuntime((removeFiber) => {
    if (self2.state._tag === "Closed") {
      return _void;
    }
    const fiber = get$9(self2.state.backing, key);
    if (fiber._tag === "None") {
      return _void;
    }
    return interruptAs$1(fiber.value, combine$5(removeFiber.id(), internalFiberId$1));
  }));
  const constInterruptedFiber = /* @__PURE__ */ function() {
    let fiber = void 0;
    return () => {
      if (fiber === void 0) {
        fiber = runFork$1(interrupt$1);
      }
      return fiber;
    };
  }();
  const run = function() {
    const self2 = arguments[0];
    if (isEffect(arguments[2])) {
      return runImpl(self2, arguments[1], arguments[2], arguments[3]);
    }
    const key = arguments[1];
    const options2 = arguments[2];
    return (effect2) => runImpl(self2, key, effect2, options2);
  };
  const runImpl = (self2, key, effect2, options2) => fiberIdWith((fiberId2) => {
    if (self2.state._tag === "Closed") {
      return interrupt$1;
    } else if ((options2 == null ? void 0 : options2.onlyIfMissing) === true && unsafeHas(self2, key)) {
      return sync$3(constInterruptedFiber);
    }
    return tap$2(forkDaemon(effect2), (fiber) => unsafeSet(self2, key, fiber, {
      ...options2,
      interruptAs: fiberId2
    }));
  });
  const TypeId$d = /* @__PURE__ */ Symbol.for("effect/FiberSet");
  const isFiberSet = (u) => hasProperty(u, TypeId$d);
  const Proto$3 = {
    [TypeId$d]: TypeId$d,
    [Symbol.iterator]() {
      if (this.state._tag === "Closed") {
        return empty$v();
      }
      return this.state.backing[Symbol.iterator]();
    },
    toString() {
      return format$3(this.toJSON());
    },
    toJSON() {
      return {
        _id: "FiberMap",
        state: this.state
      };
    },
    [NodeInspectSymbol]() {
      return this.toJSON();
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const unsafeMake = (backing, deferred) => {
    const self2 = Object.create(Proto$3);
    self2.state = {
      _tag: "Open",
      backing
    };
    self2.deferred = deferred;
    return self2;
  };
  const make$i = () => acquireRelease(map$5(make$N(), (deferred) => unsafeMake(/* @__PURE__ */ new Set(), deferred)), (set2) => withFiberRuntime((parent) => {
    const state2 = set2.state;
    if (state2._tag === "Closed") return _void;
    set2.state = {
      _tag: "Closed"
    };
    const fibers = state2.backing;
    return interruptAllAs(fibers, combine$5(parent.id(), internalFiberId)).pipe(intoDeferred(set2.deferred));
  }));
  const internalFiberIdId = -1;
  const internalFiberId = /* @__PURE__ */ make$R(internalFiberIdId, 0);
  const isInternalInterruption = /* @__PURE__ */ reduceWithContext(void 0, {
    emptyCase: constFalse,
    failCase: constFalse,
    dieCase: constFalse,
    interruptCase: (_, fiberId2) => has$1(ids(fiberId2), internalFiberIdId),
    sequentialCase: (_, left2, right2) => left2 || right2,
    parallelCase: (_, left2, right2) => left2 || right2
  });
  const unsafeAdd = /* @__PURE__ */ dual((args2) => isFiberSet(args2[0]), (self2, fiber, options2) => {
    if (self2.state._tag === "Closed") {
      fiber.unsafeInterruptAsFork(combine$5((options2 == null ? void 0 : options2.interruptAs) ?? none$2, internalFiberId));
      return;
    } else if (self2.state.backing.has(fiber)) {
      return;
    }
    self2.state.backing.add(fiber);
    fiber.addObserver((exit2) => {
      if (self2.state._tag === "Closed") {
        return;
      }
      self2.state.backing.delete(fiber);
      if (isFailure(exit2) && ((options2 == null ? void 0 : options2.propagateInterruption) === true ? !isInternalInterruption(exit2.cause) : !isInterruptedOnly(exit2.cause))) {
        unsafeDone(self2.deferred, exit2);
      }
    });
  });
  const GroupBySymbolKey = "effect/GroupBy";
  const GroupByTypeId = /* @__PURE__ */ Symbol.for(GroupBySymbolKey);
  const groupByVariance = {
    /* c8 ignore next */
    _R: (_) => _,
    /* c8 ignore next */
    _E: (_) => _,
    /* c8 ignore next */
    _K: (_) => _,
    /* c8 ignore next */
    _V: (_) => _
  };
  const isGroupBy = (u) => hasProperty(u, GroupByTypeId);
  const evaluate = /* @__PURE__ */ dual((args2) => isGroupBy(args2[0]), (self2, f, options2) => flatMap$1(self2.grouped, ([key, queue]) => f(key, flattenTake(fromQueue$1(queue, {
    shutdown: true
  }))), {
    concurrency: "unbounded",
    bufferSize: (options2 == null ? void 0 : options2.bufferSize) ?? 16
  }));
  const make$h = (grouped) => ({
    [GroupByTypeId]: groupByVariance,
    pipe() {
      return pipeArguments(this, arguments);
    },
    grouped
  });
  const mapEffectOptions = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options2) => {
    if (options2 == null ? void 0 : options2.key) {
      return evaluate(groupByKey(self2, options2.key, {
        bufferSize: options2.bufferSize
      }), (_, s) => mapEffectSequential(s, f));
    }
    return matchConcurrency(options2 == null ? void 0 : options2.concurrency, () => mapEffectSequential(self2, f), (n) => (options2 == null ? void 0 : options2.unordered) ? flatMap$1(self2, (a) => fromEffect(f(a)), {
      concurrency: n
    }) : mapEffectPar(self2, n, f));
  });
  const groupByKey = /* @__PURE__ */ dual((args2) => typeof args2[0] !== "function", (self2, f, options2) => {
    const loop = (map2, outerQueue) => readWithCause({
      onInput: (input) => flatMap$3(fromEffect$3(forEach(groupByIterable(input, f), ([key, values]) => {
        const innerQueue = map2.get(key);
        if (innerQueue === void 0) {
          return pipe(bounded((options2 == null ? void 0 : options2.bufferSize) ?? 16), flatMap$4((innerQueue2) => pipe(sync$3(() => {
            map2.set(key, innerQueue2);
          }), zipRight$2(offer$2(outerQueue, of([key, innerQueue2]))), zipRight$2(pipe(offer$2(innerQueue2, chunk(values)), catchSomeCause((cause) => isInterruptedOnly(cause) ? some(_void) : none$4()))))));
        }
        return catchSomeCause(offer$2(innerQueue, chunk(values)), (cause) => isInterruptedOnly(cause) ? some(_void) : none$4());
      }, {
        discard: true
      })), () => loop(map2, outerQueue)),
      onFailure: (cause) => fromEffect$3(offer$2(outerQueue, failCause$1(cause))),
      onDone: () => pipe(fromEffect$3(pipe(forEach(map2.entries(), ([_, innerQueue]) => pipe(offer$2(innerQueue, end$1), catchSomeCause((cause) => isInterruptedOnly(cause) ? some(_void) : none$4())), {
        discard: true
      }), zipRight$2(offer$2(outerQueue, end$1)))))
    });
    return make$h(unwrapScopedWith((scope2) => gen$2(function* () {
      const map2 = /* @__PURE__ */ new Map();
      const queue = yield* unbounded$2();
      yield* addFinalizer$1(scope2, shutdown(queue));
      return yield* toChannel(self2).pipe(pipeTo(loop(map2, queue)), drain$1, runIn(scope2), forkIn(scope2), as(flattenTake(fromQueue$1(queue, {
        shutdown: true
      }))));
    })));
  });
  const groupByIterable = /* @__PURE__ */ dual(2, (iterable, f) => {
    const builder = [];
    const iterator = iterable[Symbol.iterator]();
    const map2 = /* @__PURE__ */ new Map();
    let next;
    while ((next = iterator.next()) && !next.done) {
      const value2 = next.value;
      const key = f(value2);
      if (map2.has(key)) {
        const innerBuilder = map2.get(key);
        innerBuilder.push(value2);
      } else {
        const innerBuilder = [value2];
        builder.push([key, innerBuilder]);
        map2.set(key, innerBuilder);
      }
    }
    return unsafeFromArray(builder.map((tuple) => [tuple[0], unsafeFromArray(tuple[1])]));
  });
  class Pointer {
    constructor(path, actual, issue) {
      __publicField(this, "path");
      __publicField(this, "actual");
      __publicField(this, "issue");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Pointer");
      this.path = path;
      this.actual = actual;
      this.issue = issue;
    }
  }
  class Unexpected {
    constructor(actual, message) {
      __publicField(this, "actual");
      __publicField(this, "message");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Unexpected");
      this.actual = actual;
      this.message = message;
    }
  }
  class Missing {
    constructor(ast, message) {
      __publicField(this, "ast");
      __publicField(this, "message");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Missing");
      /**
       * @since 3.10.0
       */
      __publicField(this, "actual");
      this.ast = ast;
      this.message = message;
    }
  }
  class Composite {
    constructor(ast, actual, issues, output) {
      __publicField(this, "ast");
      __publicField(this, "actual");
      __publicField(this, "issues");
      __publicField(this, "output");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Composite");
      this.ast = ast;
      this.actual = actual;
      this.issues = issues;
      this.output = output;
    }
  }
  class Refinement {
    constructor(ast, actual, kind, issue) {
      __publicField(this, "ast");
      __publicField(this, "actual");
      __publicField(this, "kind");
      __publicField(this, "issue");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Refinement");
      this.ast = ast;
      this.actual = actual;
      this.kind = kind;
      this.issue = issue;
    }
  }
  class Transformation {
    constructor(ast, actual, kind, issue) {
      __publicField(this, "ast");
      __publicField(this, "actual");
      __publicField(this, "kind");
      __publicField(this, "issue");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Transformation");
      this.ast = ast;
      this.actual = actual;
      this.kind = kind;
      this.issue = issue;
    }
  }
  class Type {
    constructor(ast, actual, message) {
      __publicField(this, "ast");
      __publicField(this, "actual");
      __publicField(this, "message");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Type");
      this.ast = ast;
      this.actual = actual;
      this.message = message;
    }
  }
  class Forbidden {
    constructor(ast, actual, message) {
      __publicField(this, "ast");
      __publicField(this, "actual");
      __publicField(this, "message");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "Forbidden");
      this.ast = ast;
      this.actual = actual;
      this.message = message;
    }
  }
  const ParseErrorTypeId = /* @__PURE__ */ Symbol.for("effect/Schema/ParseErrorTypeId");
  class ParseError extends (/* @__PURE__ */ TaggedError$1("ParseError")) {
    constructor() {
      super(...arguments);
      /**
       * @since 3.10.0
       */
      __publicField(this, _za, ParseErrorTypeId);
    }
    get message() {
      return this.toString();
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return TreeFormatter.formatIssueSync(this.issue);
    }
    /**
     * @since 3.10.0
     */
    toJSON() {
      return {
        _id: "ParseError",
        message: this.toString()
      };
    }
    /**
     * @since 3.10.0
     */
    [(_za = ParseErrorTypeId, NodeInspectSymbol)]() {
      return this.toJSON();
    }
  }
  const parseError = (issue) => new ParseError({
    issue
  });
  const succeed = right;
  const fail$1 = left;
  const _try = try_$2;
  const isEither = isEither$1;
  const flatMap = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither(self2) ? match$b(self2, {
      onLeft: left,
      onRight: f
    }) : flatMap$4(self2, f);
  });
  const map$1 = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither(self2) ? map$i(self2, f) : map$5(self2, f);
  });
  const mapError$1 = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither(self2) ? mapLeft(self2, f) : mapError$4(self2, f);
  });
  const mapBoth = /* @__PURE__ */ dual(2, (self2, options2) => {
    return isEither(self2) ? mapBoth$4(self2, {
      onLeft: options2.onFailure,
      onRight: options2.onSuccess
    }) : mapBoth$1(self2, options2);
  });
  const orElse = /* @__PURE__ */ dual(2, (self2, f) => {
    return isEither(self2) ? match$b(self2, {
      onLeft: f,
      onRight: right
    }) : catchAll$2(self2, f);
  });
  const mergeInternalOptions = (options2, overrideOptions) => {
    if (overrideOptions === void 0 || isNumber(overrideOptions)) {
      return options2;
    }
    if (options2 === void 0) {
      return overrideOptions;
    }
    return {
      ...options2,
      ...overrideOptions
    };
  };
  const getEither = (ast, isDecoding, options2) => {
    const parser = goMemo(ast, isDecoding);
    return (u, overrideOptions) => parser(u, mergeInternalOptions(options2, overrideOptions));
  };
  const getSync = (ast, isDecoding, options2) => {
    const parser = getEither(ast, isDecoding, options2);
    return (input, overrideOptions) => getOrThrowWith(parser(input, overrideOptions), parseError);
  };
  const getEffect = (ast, isDecoding, options2) => {
    const parser = goMemo(ast, isDecoding);
    return (input, overrideOptions) => parser(input, {
      ...mergeInternalOptions(options2, overrideOptions),
      isEffectAllowed: true
    });
  };
  const decodeUnknownSync = (schema2, options2) => getSync(schema2.ast, true, options2);
  const decodeUnknownEither$1 = (schema2, options2) => getEither(schema2.ast, true, options2);
  const decodeUnknown$1 = (schema2, options2) => getEffect(schema2.ast, true, options2);
  const encodeUnknownSync = (schema2, options2) => getSync(schema2.ast, false, options2);
  const encodeUnknownEither$1 = (schema2, options2) => getEither(schema2.ast, false, options2);
  const encodeUnknown$1 = (schema2, options2) => getEffect(schema2.ast, false, options2);
  const decodeSync = decodeUnknownSync;
  const decode$1 = decodeUnknown$1;
  const validateSync = (schema2, options2) => getSync(typeAST(schema2.ast), true, options2);
  const validateEither$1 = (schema2, options2) => getEither(typeAST(schema2.ast), true, options2);
  const is = (schema2, options2) => {
    const parser = goMemo(typeAST(schema2.ast), true);
    return (u, overrideOptions) => isRight(parser(u, {
      exact: true,
      ...mergeInternalOptions(options2, overrideOptions)
    }));
  };
  const encodeSync = encodeUnknownSync;
  const encode$1 = encodeUnknown$1;
  const decodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/decodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
  const encodeMemoMap = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("effect/ParseResult/encodeMemoMap"), () => /* @__PURE__ */ new WeakMap());
  const goMemo = (ast, isDecoding) => {
    const memoMap = isDecoding ? decodeMemoMap : encodeMemoMap;
    const memo = memoMap.get(ast);
    if (memo) {
      return memo;
    }
    const raw = go(ast, isDecoding);
    const parseOptionsAnnotation = getParseOptionsAnnotation(ast);
    const parserWithOptions = isSome(parseOptionsAnnotation) ? (i, options2) => raw(i, mergeInternalOptions(options2, parseOptionsAnnotation.value)) : raw;
    const decodingFallbackAnnotation = getDecodingFallbackAnnotation(ast);
    const parser = isDecoding && isSome(decodingFallbackAnnotation) ? (i, options2) => handleForbidden(orElse(parserWithOptions(i, options2), decodingFallbackAnnotation.value), ast, i, options2) : parserWithOptions;
    memoMap.set(ast, parser);
    return parser;
  };
  const getConcurrency = (ast) => getOrUndefined(getConcurrencyAnnotation(ast));
  const getBatching = (ast) => getOrUndefined(getBatchingAnnotation(ast));
  const go = (ast, isDecoding) => {
    switch (ast._tag) {
      case "Refinement": {
        if (isDecoding) {
          const from = goMemo(ast.from, true);
          return (i, options2) => {
            options2 = options2 ?? defaultParseOption;
            const allErrors = (options2 == null ? void 0 : options2.errors) === "all";
            const result = flatMap(orElse(from(i, options2), (ef) => {
              const issue = new Refinement(ast, i, "From", ef);
              if (allErrors && hasStableFilter(ast) && isComposite(ef)) {
                return match$a(ast.filter(i, options2, ast), {
                  onNone: () => left(issue),
                  onSome: (ep) => left(new Composite(ast, i, [issue, new Refinement(ast, i, "Predicate", ep)]))
                });
              }
              return left(issue);
            }), (a) => match$a(ast.filter(a, options2, ast), {
              onNone: () => right(a),
              onSome: (ep) => left(new Refinement(ast, i, "Predicate", ep))
            }));
            return handleForbidden(result, ast, i, options2);
          };
        } else {
          const from = goMemo(typeAST(ast), true);
          const to = goMemo(dropRightRefinement(ast.from), false);
          return (i, options2) => handleForbidden(flatMap(from(i, options2), (a) => to(a, options2)), ast, i, options2);
        }
      }
      case "Transformation": {
        const transform2 = getFinalTransformation(ast.transformation, isDecoding);
        const from = isDecoding ? goMemo(ast.from, true) : goMemo(ast.to, false);
        const to = isDecoding ? goMemo(ast.to, true) : goMemo(ast.from, false);
        return (i, options2) => handleForbidden(flatMap(mapError$1(from(i, options2), (e) => new Transformation(ast, i, isDecoding ? "Encoded" : "Type", e)), (a) => flatMap(mapError$1(transform2(a, options2 ?? defaultParseOption, ast, i), (e) => new Transformation(ast, i, "Transformation", e)), (i2) => mapError$1(to(i2, options2), (e) => new Transformation(ast, i, isDecoding ? "Type" : "Encoded", e)))), ast, i, options2);
      }
      case "Declaration": {
        const parse = isDecoding ? ast.decodeUnknown(...ast.typeParameters) : ast.encodeUnknown(...ast.typeParameters);
        return (i, options2) => handleForbidden(parse(i, options2 ?? defaultParseOption, ast), ast, i, options2);
      }
      case "Literal":
        return fromRefinement(ast, (u) => u === ast.literal);
      case "UniqueSymbol":
        return fromRefinement(ast, (u) => u === ast.symbol);
      case "UndefinedKeyword":
        return fromRefinement(ast, isUndefined);
      case "NeverKeyword":
        return fromRefinement(ast, isNever);
      case "UnknownKeyword":
      case "AnyKeyword":
      case "VoidKeyword":
        return right;
      case "StringKeyword":
        return fromRefinement(ast, isString);
      case "NumberKeyword":
        return fromRefinement(ast, isNumber);
      case "BooleanKeyword":
        return fromRefinement(ast, isBoolean);
      case "BigIntKeyword":
        return fromRefinement(ast, isBigInt);
      case "SymbolKeyword":
        return fromRefinement(ast, isSymbol);
      case "ObjectKeyword":
        return fromRefinement(ast, isObject);
      case "Enums":
        return fromRefinement(ast, (u) => ast.enums.some(([_, value2]) => value2 === u));
      case "TemplateLiteral": {
        const regex = getTemplateLiteralRegExp(ast);
        return fromRefinement(ast, (u) => isString(u) && regex.test(u));
      }
      case "TupleType": {
        const elements = ast.elements.map((e) => goMemo(e.type, isDecoding));
        const rest = ast.rest.map((annotatedAST) => goMemo(annotatedAST.type, isDecoding));
        let requiredTypes = ast.elements.filter((e) => !e.isOptional);
        if (ast.rest.length > 0) {
          requiredTypes = requiredTypes.concat(ast.rest.slice(1));
        }
        const requiredLen = requiredTypes.length;
        const expectedIndexes = ast.elements.length > 0 ? ast.elements.map((_, i) => i).join(" | ") : "never";
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options2) => {
          if (!isArray(input)) {
            return left(new Type(ast, input));
          }
          const allErrors = (options2 == null ? void 0 : options2.errors) === "all";
          const es = [];
          let stepKey = 0;
          const output = [];
          const len = input.length;
          for (let i2 = len; i2 <= requiredLen - 1; i2++) {
            const e = new Pointer(i2, input, new Missing(requiredTypes[i2 - len]));
            if (allErrors) {
              es.push([stepKey++, e]);
              continue;
            } else {
              return left(new Composite(ast, input, e, output));
            }
          }
          if (ast.rest.length === 0) {
            for (let i2 = ast.elements.length; i2 <= len - 1; i2++) {
              const e = new Pointer(i2, input, new Unexpected(input[i2], `is unexpected, expected: ${expectedIndexes}`));
              if (allErrors) {
                es.push([stepKey++, e]);
                continue;
              } else {
                return left(new Composite(ast, input, e, output));
              }
            }
          }
          let i = 0;
          let queue = void 0;
          for (; i < elements.length; i++) {
            if (len < i + 1) {
              if (ast.elements[i].isOptional) {
                continue;
              }
            } else {
              const parser = elements[i];
              const te = parser(input[i], options2);
              if (isEither(te)) {
                if (isLeft(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left(new Composite(ast, input, e, sortByIndex(output)));
                  }
                }
                output.push([stepKey++, te.right]);
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap$4(either$1(te), (t) => {
                  if (isLeft(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left(new Composite(ast, input, e, sortByIndex(output2)));
                    }
                  }
                  output2.push([nk, t.right]);
                  return _void;
                }));
              }
            }
          }
          if (isNonEmptyReadonlyArray(rest)) {
            const [head2, ...tail] = rest;
            for (; i < len - tail.length; i++) {
              const te = head2(input[i], options2);
              if (isEither(te)) {
                if (isLeft(te)) {
                  const e = new Pointer(i, input, te.left);
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left(new Composite(ast, input, e, sortByIndex(output)));
                  }
                } else {
                  output.push([stepKey++, te.right]);
                }
              } else {
                const nk = stepKey++;
                const index = i;
                if (!queue) {
                  queue = [];
                }
                queue.push(({
                  es: es2,
                  output: output2
                }) => flatMap$4(either$1(te), (t) => {
                  if (isLeft(t)) {
                    const e = new Pointer(index, input, t.left);
                    if (allErrors) {
                      es2.push([nk, e]);
                      return _void;
                    } else {
                      return left(new Composite(ast, input, e, sortByIndex(output2)));
                    }
                  } else {
                    output2.push([nk, t.right]);
                    return _void;
                  }
                }));
              }
            }
            for (let j = 0; j < tail.length; j++) {
              i += j;
              if (len < i + 1) {
                continue;
              } else {
                const te = tail[j](input[i], options2);
                if (isEither(te)) {
                  if (isLeft(te)) {
                    const e = new Pointer(i, input, te.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left(new Composite(ast, input, e, sortByIndex(output)));
                    }
                  }
                  output.push([stepKey++, te.right]);
                } else {
                  const nk = stepKey++;
                  const index = i;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap$4(either$1(te), (t) => {
                    if (isLeft(t)) {
                      const e = new Pointer(index, input, t.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left(new Composite(ast, input, e, sortByIndex(output2)));
                      }
                    }
                    output2.push([nk, t.right]);
                    return _void;
                  }));
                }
              }
            }
          }
          const computeResult = ({
            es: es2,
            output: output2
          }) => isNonEmptyArray(es2) ? left(new Composite(ast, input, sortByIndex(es2), sortByIndex(output2))) : right(sortByIndex(output2));
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend$6(() => {
              const state2 = {
                es: copy$1(es),
                output: copy$1(output)
              };
              return flatMap$4(forEach(cqueue, (f) => f(state2), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state2));
            });
          }
          return computeResult({
            output,
            es
          });
        };
      }
      case "TypeLiteral": {
        if (ast.propertySignatures.length === 0 && ast.indexSignatures.length === 0) {
          return fromRefinement(ast, isNotNullable);
        }
        const propertySignatures = [];
        const expectedKeysMap = {};
        const expectedKeys = [];
        for (const ps of ast.propertySignatures) {
          propertySignatures.push([goMemo(ps.type, isDecoding), ps]);
          expectedKeysMap[ps.name] = null;
          expectedKeys.push(ps.name);
        }
        const indexSignatures = ast.indexSignatures.map((is2) => [goMemo(is2.parameter, isDecoding), goMemo(is2.type, isDecoding), is2.parameter]);
        const expectedAST = Union$1.make(ast.indexSignatures.map((is2) => is2.parameter).concat(expectedKeys.map((key) => isSymbol(key) ? new UniqueSymbol(key) : new Literal$1(key))));
        const expected = goMemo(expectedAST, isDecoding);
        const concurrency = getConcurrency(ast);
        const batching = getBatching(ast);
        return (input, options2) => {
          if (!isRecord(input)) {
            return left(new Type(ast, input));
          }
          const allErrors = (options2 == null ? void 0 : options2.errors) === "all";
          const es = [];
          let stepKey = 0;
          const onExcessPropertyError = (options2 == null ? void 0 : options2.onExcessProperty) === "error";
          const onExcessPropertyPreserve = (options2 == null ? void 0 : options2.onExcessProperty) === "preserve";
          const output = {};
          let inputKeys;
          if (onExcessPropertyError || onExcessPropertyPreserve) {
            inputKeys = ownKeys(input);
            for (const key of inputKeys) {
              const te = expected(key, options2);
              if (isEither(te) && isLeft(te)) {
                if (onExcessPropertyError) {
                  const e = new Pointer(key, input, new Unexpected(input[key], `is unexpected, expected: ${String(expectedAST)}`));
                  if (allErrors) {
                    es.push([stepKey++, e]);
                    continue;
                  } else {
                    return left(new Composite(ast, input, e, output));
                  }
                } else {
                  output[key] = input[key];
                }
              }
            }
          }
          let queue = void 0;
          const isExact = (options2 == null ? void 0 : options2.exact) === true;
          for (let i = 0; i < propertySignatures.length; i++) {
            const ps = propertySignatures[i][1];
            const name = ps.name;
            const hasKey = Object.prototype.hasOwnProperty.call(input, name);
            if (!hasKey) {
              if (ps.isOptional) {
                continue;
              } else if (isExact) {
                const e = new Pointer(name, input, new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left(new Composite(ast, input, e, output));
                }
              }
            }
            const parser = propertySignatures[i][0];
            const te = parser(input[name], options2);
            if (isEither(te)) {
              if (isLeft(te)) {
                const e = new Pointer(name, input, hasKey ? te.left : new Missing(ps));
                if (allErrors) {
                  es.push([stepKey++, e]);
                  continue;
                } else {
                  return left(new Composite(ast, input, e, output));
                }
              }
              output[name] = te.right;
            } else {
              const nk = stepKey++;
              const index = name;
              if (!queue) {
                queue = [];
              }
              queue.push(({
                es: es2,
                output: output2
              }) => flatMap$4(either$1(te), (t) => {
                if (isLeft(t)) {
                  const e = new Pointer(index, input, hasKey ? t.left : new Missing(ps));
                  if (allErrors) {
                    es2.push([nk, e]);
                    return _void;
                  } else {
                    return left(new Composite(ast, input, e, output2));
                  }
                }
                output2[index] = t.right;
                return _void;
              }));
            }
          }
          for (let i = 0; i < indexSignatures.length; i++) {
            const indexSignature = indexSignatures[i];
            const parameter = indexSignature[0];
            const type = indexSignature[1];
            const keys2 = getKeysForIndexSignature(input, indexSignature[2]);
            for (const key of keys2) {
              const keu = parameter(key, options2);
              if (isEither(keu) && isRight(keu)) {
                const vpr = type(input[key], options2);
                if (isEither(vpr)) {
                  if (isLeft(vpr)) {
                    const e = new Pointer(key, input, vpr.left);
                    if (allErrors) {
                      es.push([stepKey++, e]);
                      continue;
                    } else {
                      return left(new Composite(ast, input, e, output));
                    }
                  } else {
                    if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                      output[key] = vpr.right;
                    }
                  }
                } else {
                  const nk = stepKey++;
                  const index = key;
                  if (!queue) {
                    queue = [];
                  }
                  queue.push(({
                    es: es2,
                    output: output2
                  }) => flatMap$4(either$1(vpr), (tv) => {
                    if (isLeft(tv)) {
                      const e = new Pointer(index, input, tv.left);
                      if (allErrors) {
                        es2.push([nk, e]);
                        return _void;
                      } else {
                        return left(new Composite(ast, input, e, output2));
                      }
                    } else {
                      if (!Object.prototype.hasOwnProperty.call(expectedKeysMap, key)) {
                        output2[key] = tv.right;
                      }
                      return _void;
                    }
                  }));
                }
              }
            }
          }
          const computeResult = ({
            es: es2,
            output: output2
          }) => {
            if (isNonEmptyArray(es2)) {
              return left(new Composite(ast, input, sortByIndex(es2), output2));
            }
            if ((options2 == null ? void 0 : options2.propertyOrder) === "original") {
              const keys2 = inputKeys || ownKeys(input);
              for (const name of expectedKeys) {
                if (keys2.indexOf(name) === -1) {
                  keys2.push(name);
                }
              }
              const out = {};
              for (const key of keys2) {
                if (Object.prototype.hasOwnProperty.call(output2, key)) {
                  out[key] = output2[key];
                }
              }
              return right(out);
            }
            return right(output2);
          };
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend$6(() => {
              const state2 = {
                es: copy$1(es),
                output: Object.assign({}, output)
              };
              return flatMap$4(forEach(cqueue, (f) => f(state2), {
                concurrency,
                batching,
                discard: true
              }), () => computeResult(state2));
            });
          }
          return computeResult({
            es,
            output
          });
        };
      }
      case "Union": {
        const searchTree = getSearchTree(ast.types, isDecoding);
        const ownKeys$1 = ownKeys(searchTree.keys);
        const ownKeysLen = ownKeys$1.length;
        const astTypesLen = ast.types.length;
        const map2 = /* @__PURE__ */ new Map();
        for (let i = 0; i < astTypesLen; i++) {
          map2.set(ast.types[i], goMemo(ast.types[i], isDecoding));
        }
        const concurrency = getConcurrency(ast) ?? 1;
        const batching = getBatching(ast);
        return (input, options2) => {
          const es = [];
          let stepKey = 0;
          let candidates = [];
          if (ownKeysLen > 0) {
            if (isRecordOrArray(input)) {
              for (let i = 0; i < ownKeysLen; i++) {
                const name = ownKeys$1[i];
                const buckets = searchTree.keys[name].buckets;
                if (Object.prototype.hasOwnProperty.call(input, name)) {
                  const literal = String(input[name]);
                  if (Object.prototype.hasOwnProperty.call(buckets, literal)) {
                    candidates = candidates.concat(buckets[literal]);
                  } else {
                    const {
                      candidates: candidates2,
                      literals
                    } = searchTree.keys[name];
                    const literalsUnion = Union$1.make(literals);
                    const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([new PropertySignature(name, literalsUnion, false, true)], []) : Union$1.make(candidates2);
                    es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Type(literalsUnion, input[name])))]);
                  }
                } else {
                  const {
                    candidates: candidates2,
                    literals
                  } = searchTree.keys[name];
                  const fakePropertySignature = new PropertySignature(name, Union$1.make(literals), false, true);
                  const errorAst = candidates2.length === astTypesLen ? new TypeLiteral([fakePropertySignature], []) : Union$1.make(candidates2);
                  es.push([stepKey++, new Composite(errorAst, input, new Pointer(name, input, new Missing(fakePropertySignature)))]);
                }
              }
            } else {
              const errorAst = searchTree.candidates.length === astTypesLen ? ast : Union$1.make(searchTree.candidates);
              es.push([stepKey++, new Type(errorAst, input)]);
            }
          }
          if (searchTree.otherwise.length > 0) {
            candidates = candidates.concat(searchTree.otherwise);
          }
          let queue = void 0;
          for (let i = 0; i < candidates.length; i++) {
            const candidate = candidates[i];
            const pr = map2.get(candidate)(input, options2);
            if (isEither(pr) && (!queue || queue.length === 0)) {
              if (isRight(pr)) {
                return pr;
              } else {
                es.push([stepKey++, pr.left]);
              }
            } else {
              const nk = stepKey++;
              if (!queue) {
                queue = [];
              }
              queue.push((state2) => suspend$6(() => {
                if ("finalResult" in state2) {
                  return _void;
                } else {
                  return flatMap$4(either$1(pr), (t) => {
                    if (isRight(t)) {
                      state2.finalResult = t;
                    } else {
                      state2.es.push([nk, t.left]);
                    }
                    return _void;
                  });
                }
              }));
            }
          }
          const computeResult = (es2) => isNonEmptyArray(es2) ? es2.length === 1 && es2[0][1]._tag === "Type" ? left(es2[0][1]) : left(new Composite(ast, input, sortByIndex(es2))) : (
            // this should never happen
            left(new Type(ast, input))
          );
          if (queue && queue.length > 0) {
            const cqueue = queue;
            return suspend$6(() => {
              const state2 = {
                es: copy$1(es)
              };
              return flatMap$4(forEach(cqueue, (f) => f(state2), {
                concurrency,
                batching,
                discard: true
              }), () => {
                if ("finalResult" in state2) {
                  return state2.finalResult;
                }
                return computeResult(state2.es);
              });
            });
          }
          return computeResult(es);
        };
      }
      case "Suspend": {
        const get2 = memoizeThunk(() => goMemo(annotations$1(ast.f(), ast.annotations), isDecoding));
        return (a, options2) => get2()(a, options2);
      }
    }
  };
  const fromRefinement = (ast, refinement) => (u) => refinement(u) ? right(u) : left(new Type(ast, u));
  const getLiterals = (ast, isDecoding) => {
    switch (ast._tag) {
      case "Declaration": {
        const annotation = getSurrogateAnnotation(ast);
        if (isSome(annotation)) {
          return getLiterals(annotation.value, isDecoding);
        }
        break;
      }
      case "TypeLiteral": {
        const out = [];
        for (let i = 0; i < ast.propertySignatures.length; i++) {
          const propertySignature2 = ast.propertySignatures[i];
          const type = isDecoding ? encodedAST(propertySignature2.type) : typeAST(propertySignature2.type);
          if (isLiteral(type) && !propertySignature2.isOptional) {
            out.push([propertySignature2.name, type]);
          }
        }
        return out;
      }
      case "TupleType": {
        const out = [];
        for (let i = 0; i < ast.elements.length; i++) {
          const element = ast.elements[i];
          const type = isDecoding ? encodedAST(element.type) : typeAST(element.type);
          if (isLiteral(type) && !element.isOptional) {
            out.push([i, type]);
          }
        }
        return out;
      }
      case "Refinement":
        return getLiterals(ast.from, isDecoding);
      case "Suspend":
        return getLiterals(ast.f(), isDecoding);
      case "Transformation":
        return getLiterals(isDecoding ? ast.from : ast.to, isDecoding);
    }
    return [];
  };
  const getSearchTree = (members, isDecoding) => {
    const keys2 = {};
    const otherwise = [];
    const candidates = [];
    for (let i = 0; i < members.length; i++) {
      const member = members[i];
      const tags = getLiterals(member, isDecoding);
      if (tags.length > 0) {
        candidates.push(member);
        for (let j = 0; j < tags.length; j++) {
          const [key, literal] = tags[j];
          const hash2 = String(literal.literal);
          keys2[key] = keys2[key] || {
            buckets: {},
            literals: [],
            candidates: []
          };
          const buckets = keys2[key].buckets;
          if (Object.prototype.hasOwnProperty.call(buckets, hash2)) {
            if (j < tags.length - 1) {
              continue;
            }
            buckets[hash2].push(member);
            keys2[key].literals.push(literal);
            keys2[key].candidates.push(member);
          } else {
            buckets[hash2] = [member];
            keys2[key].literals.push(literal);
            keys2[key].candidates.push(member);
            break;
          }
        }
      } else {
        otherwise.push(member);
      }
    }
    return {
      keys: keys2,
      otherwise,
      candidates
    };
  };
  const dropRightRefinement = (ast) => isRefinement$1(ast) ? dropRightRefinement(ast.from) : ast;
  const handleForbidden = (effect2, ast, actual, options2) => {
    if ((options2 == null ? void 0 : options2.isEffectAllowed) === true) {
      return effect2;
    }
    if (isEither(effect2)) {
      return effect2;
    }
    const scheduler = new SyncScheduler();
    const fiber = runFork$1(effect2, {
      scheduler
    });
    scheduler.flush();
    const exit2 = fiber.unsafePoll();
    if (exit2) {
      if (isSuccess$1(exit2)) {
        return right(exit2.value);
      }
      const cause = exit2.cause;
      if (isFailType(cause)) {
        return left(cause.error);
      }
      return left(new Forbidden(ast, actual, pretty(cause)));
    }
    return left(new Forbidden(ast, actual, "cannot be be resolved synchronously, this is caused by using runSync on an effect that performs async work"));
  };
  const compare$1 = ([a], [b]) => a > b ? 1 : a < b ? -1 : 0;
  function sortByIndex(es) {
    return es.sort(compare$1).map((t) => t[1]);
  }
  const getFinalTransformation = (transformation, isDecoding) => {
    switch (transformation._tag) {
      case "FinalTransformation":
        return isDecoding ? transformation.decode : transformation.encode;
      case "ComposeTransformation":
        return right;
      case "TypeLiteralTransformation":
        return (input) => {
          let out = right(input);
          for (const pst of transformation.propertySignatureTransformations) {
            const [from, to] = isDecoding ? [pst.from, pst.to] : [pst.to, pst.from];
            const transformation2 = isDecoding ? pst.decode : pst.encode;
            const f = (input2) => {
              const o = transformation2(Object.prototype.hasOwnProperty.call(input2, from) ? some(input2[from]) : none$4());
              delete input2[from];
              if (isSome(o)) {
                input2[to] = o.value;
              }
              return input2;
            };
            out = map$1(out, f);
          }
          return out;
        };
    }
  };
  const makeTree = (value2, forest = []) => ({
    value: value2,
    forest
  });
  const TreeFormatter = {
    formatIssue: (issue) => map$1(formatTree(issue), drawTree),
    formatIssueSync: (issue) => {
      const e = TreeFormatter.formatIssue(issue);
      return isEither(e) ? getOrThrow(e) : runSync(e);
    },
    formatError: (error) => TreeFormatter.formatIssue(error.issue),
    formatErrorSync: (error) => TreeFormatter.formatIssueSync(error.issue)
  };
  const drawTree = (tree) => tree.value + draw("\n", tree.forest);
  const draw = (indentation, forest) => {
    let r = "";
    const len = forest.length;
    let tree;
    for (let i = 0; i < len; i++) {
      tree = forest[i];
      const isLast = i === len - 1;
      r += indentation + (isLast ? "└" : "├") + "─ " + tree.value;
      r += draw(indentation + (len > 1 && !isLast ? "│  " : "   "), tree.forest);
    }
    return r;
  };
  const formatTransformationKind = (kind) => {
    switch (kind) {
      case "Encoded":
        return "Encoded side transformation failure";
      case "Transformation":
        return "Transformation process failure";
      case "Type":
        return "Type side transformation failure";
    }
  };
  const formatRefinementKind = (kind) => {
    switch (kind) {
      case "From":
        return "From side refinement failure";
      case "Predicate":
        return "Predicate refinement failure";
    }
  };
  const getAnnotated = (issue) => "ast" in issue ? some(issue.ast) : none$4();
  const Either_void = /* @__PURE__ */ right(void 0);
  const getCurrentMessage = (issue) => getAnnotated(issue).pipe(flatMap$a(getMessageAnnotation), match$a({
    onNone: () => Either_void,
    onSome: (messageAnnotation) => {
      const union2 = messageAnnotation(issue);
      if (isString(union2)) {
        return right({
          message: union2,
          override: false
        });
      }
      if (isEffect(union2)) {
        return map$5(union2, (message) => ({
          message,
          override: false
        }));
      }
      if (isString(union2.message)) {
        return right({
          message: union2.message,
          override: union2.override
        });
      }
      return map$5(union2.message, (message) => ({
        message,
        override: union2.override
      }));
    }
  }));
  const createParseIssueGuard = (tag2) => (issue) => issue._tag === tag2;
  const isComposite = /* @__PURE__ */ createParseIssueGuard("Composite");
  const isRefinement = /* @__PURE__ */ createParseIssueGuard("Refinement");
  const isTransformation = /* @__PURE__ */ createParseIssueGuard("Transformation");
  const getMessage = (issue) => flatMap(getCurrentMessage(issue), (currentMessage) => {
    if (currentMessage !== void 0) {
      const useInnerMessage = !currentMessage.override && (isComposite(issue) || isRefinement(issue) && issue.kind === "From" || isTransformation(issue) && issue.kind !== "Transformation");
      return useInnerMessage ? isTransformation(issue) || isRefinement(issue) ? getMessage(issue.issue) : Either_void : right(currentMessage.message);
    }
    return Either_void;
  });
  const getParseIssueTitleAnnotation = (issue) => getAnnotated(issue).pipe(flatMap$a(getParseIssueTitleAnnotation$1), flatMapNullable((annotation) => annotation(issue)), getOrUndefined);
  function getRefinementExpected(ast) {
    return getDescriptionAnnotation(ast).pipe(orElse$1(() => getTitleAnnotation(ast)), orElse$1(() => getAutoTitleAnnotation(ast)), orElse$1(() => getIdentifierAnnotation(ast)), getOrElse(() => `{ ${ast.from} | filter }`));
  }
  function getDefaultTypeMessage(issue) {
    if (issue.message !== void 0) {
      return issue.message;
    }
    const expected = isRefinement$1(issue.ast) ? getRefinementExpected(issue.ast) : String(issue.ast);
    return `Expected ${expected}, actual ${formatUnknown(issue.actual)}`;
  }
  const formatTypeMessage = (issue) => map$1(getMessage(issue), (message) => message ?? getParseIssueTitleAnnotation(issue) ?? getDefaultTypeMessage(issue));
  const getParseIssueTitle = (issue) => getParseIssueTitleAnnotation(issue) ?? String(issue.ast);
  const formatForbiddenMessage = (issue) => issue.message ?? "is forbidden";
  const formatUnexpectedMessage = (issue) => issue.message ?? "is unexpected";
  const formatMissingMessage = (issue) => {
    const missingMessageAnnotation = getMissingMessageAnnotation(issue.ast);
    if (isSome(missingMessageAnnotation)) {
      const annotation = missingMessageAnnotation.value();
      return isString(annotation) ? right(annotation) : annotation;
    }
    return right(issue.message ?? "is missing");
  };
  const formatTree = (issue) => {
    switch (issue._tag) {
      case "Type":
        return map$1(formatTypeMessage(issue), makeTree);
      case "Forbidden":
        return right(makeTree(getParseIssueTitle(issue), [makeTree(formatForbiddenMessage(issue))]));
      case "Unexpected":
        return right(makeTree(formatUnexpectedMessage(issue)));
      case "Missing":
        return map$1(formatMissingMessage(issue), makeTree);
      case "Transformation":
        return flatMap(getMessage(issue), (message) => {
          if (message !== void 0) {
            return right(makeTree(message));
          }
          return map$1(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatTransformationKind(issue.kind), [tree])]));
        });
      case "Refinement":
        return flatMap(getMessage(issue), (message) => {
          if (message !== void 0) {
            return right(makeTree(message));
          }
          return map$1(formatTree(issue.issue), (tree) => makeTree(getParseIssueTitle(issue), [makeTree(formatRefinementKind(issue.kind), [tree])]));
        });
      case "Pointer":
        return map$1(formatTree(issue.issue), (tree) => makeTree(formatPath(issue.path), [tree]));
      case "Composite":
        return flatMap(getMessage(issue), (message) => {
          if (message !== void 0) {
            return right(makeTree(message));
          }
          const parseIssueTitle = getParseIssueTitle(issue);
          return isNonEmpty$3(issue.issues) ? map$1(forEach(issue.issues, formatTree), (forest) => makeTree(parseIssueTitle, forest)) : map$1(formatTree(issue.issues), (tree) => makeTree(parseIssueTitle, [tree]));
        });
    }
  };
  const replace = replaceLogger;
  const withMinimumLogLevel = withMinimumLogLevel$1;
  const defaultLogger = defaultLogger$1;
  const prettyLogger = prettyLogger$1;
  const tracerLogger = tracerLogger$1;
  const TypeId$c = /* @__PURE__ */ Symbol.for("effect/Mailbox");
  const ReadonlyTypeId = /* @__PURE__ */ Symbol.for("effect/Mailbox/ReadonlyMailbox");
  const empty$4 = /* @__PURE__ */ empty$r();
  const exitEmpty = /* @__PURE__ */ exitSucceed$1(empty$4);
  const exitFalse = /* @__PURE__ */ exitSucceed$1(false);
  const exitTrue = /* @__PURE__ */ exitSucceed$1(true);
  const constDone = [empty$4, true];
  class MailboxImpl extends Class$4 {
    constructor(scheduler, capacity2, strategy) {
      super();
      __publicField(this, "scheduler");
      __publicField(this, "capacity");
      __publicField(this, "strategy");
      __publicField(this, _Ba, TypeId$c);
      __publicField(this, _Aa, ReadonlyTypeId);
      __publicField(this, "state", {
        _tag: "Open",
        takers: /* @__PURE__ */ new Set(),
        offers: /* @__PURE__ */ new Set(),
        awaiters: /* @__PURE__ */ new Set()
      });
      __publicField(this, "messages", []);
      __publicField(this, "messagesChunk", /* @__PURE__ */ empty$r());
      __publicField(this, "shutdown", /* @__PURE__ */ sync$5(() => {
        if (this.state._tag === "Done") {
          return true;
        }
        this.messages = [];
        this.messagesChunk = empty$4;
        const offers = this.state.offers;
        this.finalize(this.state._tag === "Open" ? exitVoid$1 : this.state.exit);
        if (offers.size > 0) {
          for (const entry of offers) {
            if (entry._tag === "Single") {
              entry.resume(exitFalse);
            } else {
              entry.resume(exitSucceed$1(unsafeFromArray(entry.remaining.slice(entry.offset))));
            }
          }
          offers.clear();
        }
        return true;
      }));
      __publicField(this, "end", /* @__PURE__ */ this.done(exitVoid$1));
      __publicField(this, "clear", /* @__PURE__ */ suspend$8(() => {
        if (this.state._tag === "Done") {
          return exitAs(this.state.exit, empty$4);
        }
        const messages = this.unsafeTakeAll();
        this.releaseCapacity();
        return succeed$a(messages);
      }));
      __publicField(this, "takeAll", /* @__PURE__ */ suspend$8(() => {
        if (this.state._tag === "Done") {
          return exitAs(this.state.exit, constDone);
        }
        const messages = this.unsafeTakeAll();
        if (messages.length === 0) {
          return zipRight$4(this.awaitTake, this.takeAll);
        }
        return succeed$a([messages, this.releaseCapacity()]);
      }));
      __publicField(this, "take", /* @__PURE__ */ suspend$8(() => this.unsafeTake() ?? zipRight$4(this.awaitTake, this.take)));
      __publicField(this, "await", /* @__PURE__ */ asyncInterrupt((resume2) => {
        if (this.state._tag === "Done") {
          return resume2(this.state.exit);
        }
        this.state.awaiters.add(resume2);
        return sync$5(() => {
          if (this.state._tag !== "Done") {
            this.state.awaiters.delete(resume2);
          }
        });
      }));
      __publicField(this, "size", /* @__PURE__ */ sync$5(() => this.unsafeSize()));
      __publicField(this, "awaitTake", /* @__PURE__ */ asyncInterrupt((resume2) => {
        if (this.state._tag === "Done") {
          return resume2(this.state.exit);
        }
        this.state.takers.add(resume2);
        return sync$5(() => {
          if (this.state._tag !== "Done") {
            this.state.takers.delete(resume2);
          }
        });
      }));
      __publicField(this, "scheduleRunning", false);
      __publicField(this, "releaseTaker", () => {
        this.scheduleRunning = false;
        if (this.state._tag === "Done") {
          return;
        } else if (this.state.takers.size === 0) {
          return;
        }
        const taker = unsafeHead$1(this.state.takers);
        this.state.takers.delete(taker);
        taker(exitVoid$1);
      });
      this.scheduler = scheduler;
      this.capacity = capacity2;
      this.strategy = strategy;
    }
    offer(message) {
      return suspend$8(() => {
        if (this.state._tag !== "Open") {
          return exitFalse;
        } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
          switch (this.strategy) {
            case "dropping":
              return exitFalse;
            case "suspend":
              if (this.capacity <= 0 && this.state.takers.size > 0) {
                this.messages.push(message);
                this.releaseTaker();
                return exitTrue;
              }
              return this.offerRemainingSingle(message);
            case "sliding":
              this.unsafeTake();
              this.messages.push(message);
              return exitTrue;
          }
        }
        this.messages.push(message);
        this.scheduleReleaseTaker();
        return exitTrue;
      });
    }
    unsafeOffer(message) {
      if (this.state._tag !== "Open") {
        return false;
      } else if (this.messages.length + this.messagesChunk.length >= this.capacity) {
        if (this.strategy === "sliding") {
          this.unsafeTake();
          this.messages.push(message);
          return true;
        } else if (this.capacity <= 0 && this.state.takers.size > 0) {
          this.messages.push(message);
          this.releaseTaker();
          return true;
        }
        return false;
      }
      this.messages.push(message);
      this.scheduleReleaseTaker();
      return true;
    }
    offerAll(messages) {
      return suspend$8(() => {
        if (this.state._tag !== "Open") {
          return succeed$a(fromIterable$7(messages));
        }
        const remaining = this.unsafeOfferAllArray(messages);
        if (remaining.length === 0) {
          return exitEmpty;
        } else if (this.strategy === "dropping") {
          return succeed$a(unsafeFromArray(remaining));
        }
        return this.offerRemainingArray(remaining);
      });
    }
    unsafeOfferAll(messages) {
      return unsafeFromArray(this.unsafeOfferAllArray(messages));
    }
    unsafeOfferAllArray(messages) {
      if (this.state._tag !== "Open") {
        return fromIterable$8(messages);
      } else if (this.capacity === Number.POSITIVE_INFINITY || this.strategy === "sliding") {
        if (this.messages.length > 0) {
          this.messagesChunk = appendAll$1(this.messagesChunk, unsafeFromArray(this.messages));
        }
        if (this.strategy === "sliding") {
          this.messagesChunk = this.messagesChunk.pipe(appendAll$1(fromIterable$7(messages)), takeRight(this.capacity));
        } else if (isChunk(messages)) {
          this.messagesChunk = appendAll$1(this.messagesChunk, messages);
        } else {
          this.messages = fromIterable$8(messages);
        }
        this.scheduleReleaseTaker();
        return [];
      }
      const free = this.capacity <= 0 ? this.state.takers.size : this.capacity - this.messages.length - this.messagesChunk.length;
      if (free === 0) {
        return fromIterable$8(messages);
      }
      const remaining = [];
      let i = 0;
      for (const message of messages) {
        if (i < free) {
          this.messages.push(message);
        } else {
          remaining.push(message);
        }
        i++;
      }
      this.scheduleReleaseTaker();
      return remaining;
    }
    fail(error) {
      return this.done(exitFail(error));
    }
    failCause(cause) {
      return this.done(exitFailCause$1(cause));
    }
    unsafeDone(exit2) {
      if (this.state._tag !== "Open") {
        return false;
      } else if (this.state.offers.size === 0 && this.messages.length === 0 && this.messagesChunk.length === 0) {
        this.finalize(exit2);
        return true;
      }
      this.state = {
        ...this.state,
        _tag: "Closing",
        exit: exit2
      };
      return true;
    }
    done(exit2) {
      return sync$5(() => this.unsafeDone(exit2));
    }
    takeN(n) {
      return suspend$8(() => {
        if (this.state._tag === "Done") {
          return exitAs(this.state.exit, constDone);
        } else if (n <= 0) {
          return succeed$a([empty$4, false]);
        }
        n = Math.min(n, this.capacity);
        let messages;
        if (n <= this.messagesChunk.length) {
          messages = take$6(this.messagesChunk, n);
          this.messagesChunk = drop(this.messagesChunk, n);
        } else if (n <= this.messages.length + this.messagesChunk.length) {
          this.messagesChunk = appendAll$1(this.messagesChunk, unsafeFromArray(this.messages));
          this.messages = [];
          messages = take$6(this.messagesChunk, n);
          this.messagesChunk = drop(this.messagesChunk, n);
        } else {
          return zipRight$4(this.awaitTake, this.takeN(n));
        }
        return succeed$a([messages, this.releaseCapacity()]);
      });
    }
    unsafeTake() {
      if (this.state._tag === "Done") {
        return exitZipRight(this.state.exit, exitFail(new NoSuchElementException()));
      }
      let message;
      if (this.messagesChunk.length > 0) {
        message = unsafeHead(this.messagesChunk);
        this.messagesChunk = drop(this.messagesChunk, 1);
      } else if (this.messages.length > 0) {
        message = this.messages[0];
        this.messagesChunk = drop(unsafeFromArray(this.messages), 1);
        this.messages = [];
      } else if (this.capacity <= 0 && this.state.offers.size > 0) {
        this.capacity = 1;
        this.releaseCapacity();
        this.capacity = 0;
        return this.messages.length > 0 ? exitSucceed$1(this.messages.pop()) : void 0;
      } else {
        return void 0;
      }
      this.releaseCapacity();
      return exitSucceed$1(message);
    }
    unsafeSize() {
      const size2 = this.messages.length + this.messagesChunk.length;
      return this.state._tag === "Done" ? none$4() : some(size2);
    }
    commit() {
      return this.takeAll;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    toJSON() {
      return {
        _id: "effect/Mailbox",
        state: this.state._tag,
        size: this.unsafeSize().toJSON()
      };
    }
    toString() {
      return format$3(this);
    }
    [(_Ba = TypeId$c, _Aa = ReadonlyTypeId, NodeInspectSymbol)]() {
      return format$3(this);
    }
    offerRemainingSingle(message) {
      return asyncInterrupt((resume2) => {
        if (this.state._tag !== "Open") {
          return resume2(exitFalse);
        }
        const entry = {
          _tag: "Single",
          message,
          resume: resume2
        };
        this.state.offers.add(entry);
        return sync$5(() => {
          if (this.state._tag === "Open") {
            this.state.offers.delete(entry);
          }
        });
      });
    }
    offerRemainingArray(remaining) {
      return asyncInterrupt((resume2) => {
        if (this.state._tag !== "Open") {
          return resume2(exitSucceed$1(unsafeFromArray(remaining)));
        }
        const entry = {
          _tag: "Array",
          remaining,
          offset: 0,
          resume: resume2
        };
        this.state.offers.add(entry);
        return sync$5(() => {
          if (this.state._tag === "Open") {
            this.state.offers.delete(entry);
          }
        });
      });
    }
    releaseCapacity() {
      if (this.state._tag === "Done") {
        return this.state.exit._tag === "Success";
      } else if (this.state.offers.size === 0) {
        if (this.state._tag === "Closing" && this.messages.length === 0 && this.messagesChunk.length === 0) {
          this.finalize(this.state.exit);
          return this.state.exit._tag === "Success";
        }
        return false;
      }
      let n = this.capacity - this.messages.length - this.messagesChunk.length;
      for (const entry of this.state.offers) {
        if (n === 0) return false;
        else if (entry._tag === "Single") {
          this.messages.push(entry.message);
          n--;
          entry.resume(exitTrue);
          this.state.offers.delete(entry);
        } else {
          for (; entry.offset < entry.remaining.length; entry.offset++) {
            if (n === 0) return false;
            this.messages.push(entry.remaining[entry.offset]);
            n--;
          }
          entry.resume(exitEmpty);
          this.state.offers.delete(entry);
        }
      }
      return false;
    }
    scheduleReleaseTaker() {
      if (this.scheduleRunning) {
        return;
      }
      this.scheduleRunning = true;
      this.scheduler.scheduleTask(this.releaseTaker, 0);
    }
    unsafeTakeAll() {
      if (this.messagesChunk.length > 0) {
        const messages = this.messages.length > 0 ? appendAll$1(this.messagesChunk, unsafeFromArray(this.messages)) : this.messagesChunk;
        this.messagesChunk = empty$4;
        this.messages = [];
        return messages;
      } else if (this.messages.length > 0) {
        const messages = unsafeFromArray(this.messages);
        this.messages = [];
        return messages;
      } else if (this.state._tag !== "Done" && this.state.offers.size > 0) {
        this.capacity = 1;
        this.releaseCapacity();
        this.capacity = 0;
        return of$2(this.messages.pop());
      }
      return empty$4;
    }
    finalize(exit2) {
      if (this.state._tag === "Done") {
        return;
      }
      const openState = this.state;
      this.state = {
        _tag: "Done",
        exit: exit2
      };
      for (const taker of openState.takers) {
        taker(exit2);
      }
      openState.takers.clear();
      for (const awaiter of openState.awaiters) {
        awaiter(exit2);
      }
      openState.awaiters.clear();
    }
  }
  const make$g = (capacity2) => withFiberRuntime$1((fiber) => succeed$a(new MailboxImpl(fiber.currentScheduler, typeof capacity2 === "number" ? capacity2 : (capacity2 == null ? void 0 : capacity2.capacity) ?? Number.POSITIVE_INFINITY, typeof capacity2 === "number" ? "suspend" : (capacity2 == null ? void 0 : capacity2.strategy) ?? "suspend")));
  const make$f = make$g;
  const TypeId$b = /* @__PURE__ */ Symbol.for("@effect/matcher/Matcher");
  const ValueMatcherProto = {
    [TypeId$b]: {
      _input: identity,
      _filters: identity,
      _result: identity,
      _return: identity
    },
    _tag: "ValueMatcher",
    add(_case) {
      if (this.value._tag === "Right") {
        return this;
      }
      if (_case._tag === "When" && _case.guard(this.provided) === true) {
        return makeValueMatcher(this.provided, right(_case.evaluate(this.provided)));
      } else if (_case._tag === "Not" && _case.guard(this.provided) === false) {
        return makeValueMatcher(this.provided, right(_case.evaluate(this.provided)));
      }
      return this;
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  function makeValueMatcher(provided, value2) {
    const matcher = Object.create(ValueMatcherProto);
    matcher.provided = provided;
    matcher.value = value2;
    return matcher;
  }
  const makeWhen = (guard, evaluate2) => ({
    _tag: "When",
    guard,
    evaluate: evaluate2
  });
  const makePredicate = (pattern) => {
    if (typeof pattern === "function") {
      return pattern;
    } else if (Array.isArray(pattern)) {
      const predicates = pattern.map(makePredicate);
      const len = predicates.length;
      return (u) => {
        if (!Array.isArray(u)) {
          return false;
        }
        for (let i = 0; i < len; i++) {
          if (predicates[i](u[i]) === false) {
            return false;
          }
        }
        return true;
      };
    } else if (pattern !== null && typeof pattern === "object") {
      const keysAndPredicates = Object.entries(pattern).map(([k, p]) => [k, makePredicate(p)]);
      const len = keysAndPredicates.length;
      return (u) => {
        if (typeof u !== "object" || u === null) {
          return false;
        }
        for (let i = 0; i < len; i++) {
          const [key, predicate] = keysAndPredicates[i];
          if (!(key in u) || predicate(u[key]) === false) {
            return false;
          }
        }
        return true;
      };
    }
    return (u) => u === pattern;
  };
  const value$1 = (i) => makeValueMatcher(i, left(i));
  const when$1 = (pattern, f) => (self2) => self2.add(makeWhen(makePredicate(pattern), f));
  const discriminator = (field) => (...pattern) => {
    const f = pattern[pattern.length - 1];
    const values = pattern.slice(0, -1);
    const pred = values.length === 1 ? (_) => _[field] === values[0] : (_) => values.includes(_[field]);
    return (self2) => self2.add(makeWhen(pred, f));
  };
  const tag$3 = /* @__PURE__ */ discriminator("_tag");
  const either = (self2) => {
    if (self2._tag === "ValueMatcher") {
      return self2.value;
    }
    const len = self2.cases.length;
    if (len === 1) {
      const _case = self2.cases[0];
      return (input) => {
        if (_case._tag === "When" && _case.guard(input) === true) {
          return right(_case.evaluate(input));
        } else if (_case._tag === "Not" && _case.guard(input) === false) {
          return right(_case.evaluate(input));
        }
        return left(input);
      };
    }
    return (input) => {
      for (let i = 0; i < len; i++) {
        const _case = self2.cases[i];
        if (_case._tag === "When" && _case.guard(input) === true) {
          return right(_case.evaluate(input));
        } else if (_case._tag === "Not" && _case.guard(input) === false) {
          return right(_case.evaluate(input));
        }
      }
      return left(input);
    };
  };
  const getExhaustiveAbsurdErrorMessage = "effect/Match/exhaustive: absurd";
  const exhaustive$1 = (self2) => {
    const toEither = either(self2);
    if (isEither$1(toEither)) {
      if (toEither._tag === "Right") {
        return toEither.right;
      }
      throw new Error(getExhaustiveAbsurdErrorMessage);
    }
    return (u) => {
      const result = toEither(u);
      if (result._tag === "Right") {
        return result.right;
      }
      throw new Error(getExhaustiveAbsurdErrorMessage);
    };
  };
  const value = value$1;
  const when = when$1;
  const tag$2 = tag$3;
  const exhaustive = exhaustive$1;
  const make$e = make$l;
  const gen = gen$1;
  const retry = retry$1;
  const pick$1 = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys2) => {
    const out = {};
    for (const k of keys2) {
      if (k in s) {
        out[k] = s[k];
      }
    }
    return out;
  });
  const omit = /* @__PURE__ */ dual((args2) => isObject(args2[0]), (s, ...keys2) => {
    const out = {
      ...s
    };
    for (const k of keys2) {
      delete out[k];
    }
    return out;
  });
  const TypeId$a = /* @__PURE__ */ Symbol.for("effect/Schema");
  function make$d(ast) {
    var _a2, _b2, _c2;
    return _b2 = TypeId$a, _a2 = TypeId$a, _c2 = class {
      constructor() {
        __publicField(this, _b2, variance);
      }
      static annotations(annotations2) {
        return make$d(mergeSchemaAnnotations(this.ast, annotations2));
      }
      static pipe() {
        return pipeArguments(this, arguments);
      }
      static toString() {
        return String(ast);
      }
    }, __publicField(_c2, "ast", ast), __publicField(_c2, "Type"), __publicField(_c2, "Encoded"), __publicField(_c2, "Context"), __publicField(_c2, _a2, variance), _c2;
  }
  const variance = {
    /* c8 ignore next */
    _A: (_) => _,
    /* c8 ignore next */
    _I: (_) => _,
    /* c8 ignore next */
    _R: (_) => _
  };
  const builtInAnnotations = {
    schemaId: SchemaIdAnnotationId,
    message: MessageAnnotationId,
    missingMessage: MissingMessageAnnotationId,
    identifier: IdentifierAnnotationId,
    title: TitleAnnotationId,
    description: DescriptionAnnotationId,
    examples: ExamplesAnnotationId,
    default: DefaultAnnotationId,
    documentation: DocumentationAnnotationId,
    jsonSchema: JSONSchemaAnnotationId,
    arbitrary: ArbitraryAnnotationId,
    pretty: PrettyAnnotationId,
    equivalence: EquivalenceAnnotationId,
    concurrency: ConcurrencyAnnotationId,
    batching: BatchingAnnotationId,
    parseIssueTitle: ParseIssueTitleAnnotationId,
    parseOptions: ParseOptionsAnnotationId,
    decodingFallback: DecodingFallbackAnnotationId
  };
  const toASTAnnotations = (annotations2) => {
    if (!annotations2) {
      return {};
    }
    const out = {
      ...annotations2
    };
    for (const key in builtInAnnotations) {
      if (key in annotations2) {
        const id2 = builtInAnnotations[key];
        out[id2] = annotations2[key];
        delete out[key];
      }
    }
    return out;
  };
  const mergeSchemaAnnotations = (ast, annotations2) => annotations$1(ast, toASTAnnotations(annotations2));
  function asSchema(schema2) {
    return schema2;
  }
  const format = (schema2) => String(schema2.ast);
  const encodedSchema = (schema2) => make$d(encodedAST(schema2.ast));
  const typeSchema = (schema2) => make$d(typeAST(schema2.ast));
  const encodeUnknown = (schema2, options2) => {
    const encodeUnknown2 = encodeUnknown$1(schema2, options2);
    return (u, overrideOptions) => mapError$1(encodeUnknown2(u, overrideOptions), parseError);
  };
  const encodeUnknownEither = (schema2, options2) => {
    const encodeUnknownEither2 = encodeUnknownEither$1(schema2, options2);
    return (u, overrideOptions) => mapLeft(encodeUnknownEither2(u, overrideOptions), parseError);
  };
  const encode = encodeUnknown;
  const encodeEither = encodeUnknownEither;
  const decodeUnknown = (schema2, options2) => {
    const decodeUnknown2 = decodeUnknown$1(schema2, options2);
    return (u, overrideOptions) => mapError$1(decodeUnknown2(u, overrideOptions), parseError);
  };
  const decodeUnknownEither = (schema2, options2) => {
    const decodeUnknownEither2 = decodeUnknownEither$1(schema2, options2);
    return (u, overrideOptions) => mapLeft(decodeUnknownEither2(u, overrideOptions), parseError);
  };
  const decode = decodeUnknown;
  const decodeEither = decodeUnknownEither;
  const validateEither = (schema2, options2) => {
    const validateEither2 = validateEither$1(schema2, options2);
    return (u, overrideOptions) => mapLeft(validateEither2(u, overrideOptions), parseError);
  };
  const isSchema = (u) => hasProperty(u, TypeId$a) && isObject(u[TypeId$a]);
  function getDefaultLiteralAST(literals) {
    return isMembers(literals) ? Union$1.make(mapMembers(literals, (literal) => new Literal$1(literal))) : new Literal$1(literals[0]);
  }
  function makeLiteralClass(literals, ast = getDefaultLiteralAST(literals)) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeLiteralClass(this.literals, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "literals", [...literals]), _a2;
  }
  function Literal(...literals) {
    return isNonEmptyReadonlyArray(literals) ? makeLiteralClass(literals) : Never;
  }
  const UniqueSymbolFromSelf = (symbol2) => make$d(new UniqueSymbol(symbol2));
  const declareConstructor = (typeParameters, options2, annotations2) => makeDeclareClass(typeParameters, new Declaration(typeParameters.map((tp) => tp.ast), (...typeParameters2) => options2.decode(...typeParameters2.map(make$d)), (...typeParameters2) => options2.encode(...typeParameters2.map(make$d)), toASTAnnotations(annotations2)));
  const declarePrimitive = (is2, annotations2) => {
    const decodeUnknown2 = () => (input, _, ast) => is2(input) ? succeed(input) : fail$1(new Type(ast, input));
    const encodeUnknown2 = decodeUnknown2;
    return makeDeclareClass([], new Declaration([], decodeUnknown2, encodeUnknown2, toASTAnnotations(annotations2)));
  };
  function makeDeclareClass(typeParameters, ast) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeDeclareClass(this.typeParameters, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "typeParameters", [...typeParameters]), _a2;
  }
  const declare = function() {
    if (Array.isArray(arguments[0])) {
      const typeParameters = arguments[0];
      const options2 = arguments[1];
      const annotations3 = arguments[2];
      return declareConstructor(typeParameters, options2, annotations3);
    }
    const is2 = arguments[0];
    const annotations2 = arguments[1];
    return declarePrimitive(is2, annotations2);
  };
  const BrandSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Brand");
  const fromBrand = (constructor, annotations2) => (self2) => {
    const out = makeBrandClass(self2, new Refinement$1(self2.ast, function predicate(a, _, ast) {
      const either2 = constructor.either(a);
      return isLeft(either2) ? some(new Type(ast, a, either2.left.map((v) => v.message).join(", "))) : none$4();
    }, toASTAnnotations({
      schemaId: BrandSchemaId,
      [BrandSchemaId]: {
        constructor
      },
      ...annotations2
    })));
    return out;
  };
  class Undefined extends (/* @__PURE__ */ make$d(undefinedKeyword)) {
  }
  class Void extends (/* @__PURE__ */ make$d(voidKeyword)) {
  }
  class Null extends (/* @__PURE__ */ make$d($null)) {
  }
  class Never extends (/* @__PURE__ */ make$d(neverKeyword)) {
  }
  class Unknown extends (/* @__PURE__ */ make$d(unknownKeyword)) {
  }
  class Any extends (/* @__PURE__ */ make$d(anyKeyword)) {
  }
  class String$ extends (/* @__PURE__ */ make$d(stringKeyword)) {
  }
  class Number$ extends (/* @__PURE__ */ make$d(numberKeyword)) {
  }
  class Boolean$ extends (/* @__PURE__ */ make$d(booleanKeyword)) {
  }
  const getDefaultUnionAST = (members) => Union$1.make(members.map((m) => m.ast));
  function makeUnionClass(members, ast = getDefaultUnionAST(members)) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeUnionClass(this.members, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "members", [...members]), _a2;
  }
  function Union(...members) {
    return isMembers(members) ? makeUnionClass(members) : isNonEmptyReadonlyArray(members) ? members[0] : Never;
  }
  const NullOr = (self2) => Union(self2, Null);
  const UndefinedOr = (self2) => Union(self2, Undefined);
  const getDefaultTupleTypeAST = (elements, rest) => new TupleType(elements.map((el) => isSchema(el) ? new OptionalType(el.ast, false) : el.ast), rest.map((el) => isSchema(el) ? new Type$1(el.ast) : el.ast), true);
  function makeTupleTypeClass(elements, rest, ast = getDefaultTupleTypeAST(elements, rest)) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeTupleTypeClass(this.elements, this.rest, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "elements", [...elements]), __publicField(_a2, "rest", [...rest]), _a2;
  }
  function Tuple(...args2) {
    return Array.isArray(args2[0]) ? makeTupleTypeClass(args2[0], args2.slice(1)) : makeTupleTypeClass(args2, []);
  }
  function makeArrayClass(value2, ast) {
    var _a2;
    return _a2 = class extends makeTupleTypeClass([], [value2], ast) {
      static annotations(annotations2) {
        return makeArrayClass(this.value, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "value", value2), _a2;
  }
  const Array$ = (value2) => makeArrayClass(value2);
  const formatPropertySignatureToken = (isOptional) => isOptional ? '"?:"' : '":"';
  class PropertySignatureDeclaration extends OptionalType {
    constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
      super(type, isOptional, annotations2);
      __publicField(this, "isReadonly");
      __publicField(this, "defaultValue");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "PropertySignatureDeclaration");
      this.isReadonly = isReadonly;
      this.defaultValue = defaultValue;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      const token = formatPropertySignatureToken(this.isOptional);
      const type = String(this.type);
      return `PropertySignature<${token}, ${type}, never, ${token}, ${type}>`;
    }
  }
  class FromPropertySignature extends OptionalType {
    constructor(type, isOptional, isReadonly, annotations2, fromKey) {
      super(type, isOptional, annotations2);
      __publicField(this, "isReadonly");
      __publicField(this, "fromKey");
      this.isReadonly = isReadonly;
      this.fromKey = fromKey;
    }
  }
  class ToPropertySignature extends OptionalType {
    constructor(type, isOptional, isReadonly, annotations2, defaultValue) {
      super(type, isOptional, annotations2);
      __publicField(this, "isReadonly");
      __publicField(this, "defaultValue");
      this.isReadonly = isReadonly;
      this.defaultValue = defaultValue;
    }
  }
  const formatPropertyKey = (p) => {
    if (p === void 0) {
      return "never";
    }
    if (isString(p)) {
      return JSON.stringify(p);
    }
    return String(p);
  };
  class PropertySignatureTransformation {
    constructor(from, to, decode2, encode2) {
      __publicField(this, "from");
      __publicField(this, "to");
      __publicField(this, "decode");
      __publicField(this, "encode");
      /**
       * @since 3.10.0
       */
      __publicField(this, "_tag", "PropertySignatureTransformation");
      this.from = from;
      this.to = to;
      this.decode = decode2;
      this.encode = encode2;
    }
    /**
     * @since 3.10.0
     */
    toString() {
      return `PropertySignature<${formatPropertySignatureToken(this.to.isOptional)}, ${this.to.type}, ${formatPropertyKey(this.from.fromKey)}, ${formatPropertySignatureToken(this.from.isOptional)}, ${this.from.type}>`;
    }
  }
  const mergeSignatureAnnotations = (ast, annotations2) => {
    switch (ast._tag) {
      case "PropertySignatureDeclaration": {
        return new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, {
          ...ast.annotations,
          ...annotations2
        }, ast.defaultValue);
      }
      case "PropertySignatureTransformation": {
        return new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, {
          ...ast.to.annotations,
          ...annotations2
        }, ast.to.defaultValue), ast.decode, ast.encode);
      }
    }
  };
  const PropertySignatureTypeId = /* @__PURE__ */ Symbol.for("effect/PropertySignature");
  const isPropertySignature = (u) => hasProperty(u, PropertySignatureTypeId);
  _Da = TypeId$a, _Ca = PropertySignatureTypeId;
  const _PropertySignatureImpl = class _PropertySignatureImpl {
    constructor(ast) {
      __publicField(this, "ast");
      __publicField(this, _Da);
      __publicField(this, _Ca, null);
      __publicField(this, "_TypeToken");
      __publicField(this, "_Key");
      __publicField(this, "_EncodedToken");
      __publicField(this, "_HasDefault");
      this.ast = ast;
    }
    pipe() {
      return pipeArguments(this, arguments);
    }
    annotations(annotations2) {
      return new _PropertySignatureImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)));
    }
    toString() {
      return String(this.ast);
    }
  };
  let PropertySignatureImpl = _PropertySignatureImpl;
  const makePropertySignature = (ast) => new PropertySignatureImpl(ast);
  class PropertySignatureWithFromImpl extends PropertySignatureImpl {
    constructor(ast, from) {
      super(ast);
      __publicField(this, "from");
      this.from = from;
    }
    annotations(annotations2) {
      return new PropertySignatureWithFromImpl(mergeSignatureAnnotations(this.ast, toASTAnnotations(annotations2)), this.from);
    }
  }
  const propertySignature = (self2) => new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(self2.ast, false, true, {}, void 0), self2);
  const withConstructorDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
    const ast = self2.ast;
    switch (ast._tag) {
      case "PropertySignatureDeclaration":
        return makePropertySignature(new PropertySignatureDeclaration(ast.type, ast.isOptional, ast.isReadonly, ast.annotations, defaultValue));
      case "PropertySignatureTransformation":
        return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(ast.to.type, ast.to.isOptional, ast.to.isReadonly, ast.to.annotations, defaultValue), ast.decode, ast.encode));
    }
  });
  const applyDefaultValue = (o, defaultValue) => match$a(o, {
    onNone: () => some(defaultValue()),
    onSome: (value2) => some(value2 === void 0 ? defaultValue() : value2)
  });
  const pruneUndefined = (ast) => pruneUndefined$1(ast, pruneUndefined, (ast2) => {
    const pruned = pruneUndefined(ast2.to);
    if (pruned) {
      return new Transformation$1(ast2.from, pruned, ast2.transformation);
    }
  });
  const withDecodingDefault = /* @__PURE__ */ dual(2, (self2, defaultValue) => {
    const ast = self2.ast;
    switch (ast._tag) {
      case "PropertySignatureDeclaration": {
        const to = typeAST(ast.type);
        return makePropertySignature(new PropertySignatureTransformation(new FromPropertySignature(ast.type, ast.isOptional, ast.isReadonly, ast.annotations), new ToPropertySignature(pruneUndefined(to) ?? to, false, true, {}, ast.defaultValue), (o) => applyDefaultValue(o, defaultValue), identity));
      }
      case "PropertySignatureTransformation": {
        const to = ast.to.type;
        return makePropertySignature(new PropertySignatureTransformation(ast.from, new ToPropertySignature(pruneUndefined(to) ?? to, false, ast.to.isReadonly, ast.to.annotations, ast.to.defaultValue), (o) => applyDefaultValue(ast.decode(o), defaultValue), ast.encode));
      }
    }
  });
  const withDefaults = /* @__PURE__ */ dual(2, (self2, defaults) => self2.pipe(withDecodingDefault(defaults.decoding), withConstructorDefault(defaults.constructor)));
  const optional = (self2) => {
    const ast = self2.ast === undefinedKeyword || self2.ast === neverKeyword ? undefinedKeyword : UndefinedOr(self2).ast;
    return new PropertySignatureWithFromImpl(new PropertySignatureDeclaration(ast, true, true, {}, void 0), self2);
  };
  const preserveMissingMessageAnnotation = /* @__PURE__ */ pickAnnotations([MissingMessageAnnotationId]);
  const getDefaultTypeLiteralAST = (fields, records) => {
    const ownKeys$1 = ownKeys(fields);
    const pss = [];
    if (ownKeys$1.length > 0) {
      const from = [];
      const to = [];
      const transformations = [];
      for (let i = 0; i < ownKeys$1.length; i++) {
        const key = ownKeys$1[i];
        const field = fields[key];
        if (isPropertySignature(field)) {
          const ast = field.ast;
          switch (ast._tag) {
            case "PropertySignatureDeclaration": {
              const type = ast.type;
              const isOptional = ast.isOptional;
              const toAnnotations = ast.annotations;
              from.push(new PropertySignature(key, type, isOptional, true, preserveMissingMessageAnnotation(ast)));
              to.push(new PropertySignature(key, typeAST(type), isOptional, true, toAnnotations));
              pss.push(new PropertySignature(key, type, isOptional, true, toAnnotations));
              break;
            }
            case "PropertySignatureTransformation": {
              const fromKey = ast.from.fromKey ?? key;
              from.push(new PropertySignature(fromKey, ast.from.type, ast.from.isOptional, true, ast.from.annotations));
              to.push(new PropertySignature(key, ast.to.type, ast.to.isOptional, true, ast.to.annotations));
              transformations.push(new PropertySignatureTransformation$1(fromKey, key, ast.decode, ast.encode));
              break;
            }
          }
        } else {
          from.push(new PropertySignature(key, field.ast, false, true));
          to.push(new PropertySignature(key, typeAST(field.ast), false, true));
          pss.push(new PropertySignature(key, field.ast, false, true));
        }
      }
      if (isNonEmptyReadonlyArray(transformations)) {
        const issFrom = [];
        const issTo = [];
        for (const r of records) {
          const {
            indexSignatures,
            propertySignatures
          } = record(r.key.ast, r.value.ast);
          propertySignatures.forEach((ps) => {
            from.push(ps);
            to.push(new PropertySignature(ps.name, typeAST(ps.type), ps.isOptional, ps.isReadonly, ps.annotations));
          });
          indexSignatures.forEach((is2) => {
            issFrom.push(is2);
            issTo.push(new IndexSignature(is2.parameter, typeAST(is2.type), is2.isReadonly));
          });
        }
        return new Transformation$1(new TypeLiteral(from, issFrom, {
          [AutoTitleAnnotationId]: "Struct (Encoded side)"
        }), new TypeLiteral(to, issTo, {
          [AutoTitleAnnotationId]: "Struct (Type side)"
        }), new TypeLiteralTransformation(transformations));
      }
    }
    const iss = [];
    for (const r of records) {
      const {
        indexSignatures,
        propertySignatures
      } = record(r.key.ast, r.value.ast);
      propertySignatures.forEach((ps) => pss.push(ps));
      indexSignatures.forEach((is2) => iss.push(is2));
    }
    return new TypeLiteral(pss, iss);
  };
  const lazilyMergeDefaults = (fields, out) => {
    const ownKeys$1 = ownKeys(fields);
    for (const key of ownKeys$1) {
      const field = fields[key];
      if (out[key] === void 0 && isPropertySignature(field)) {
        const ast = field.ast;
        const defaultValue = ast._tag === "PropertySignatureDeclaration" ? ast.defaultValue : ast.to.defaultValue;
        if (defaultValue !== void 0) {
          out[key] = defaultValue();
        }
      }
    }
    return out;
  };
  function makeTypeLiteralClass(fields, records, ast = getDefaultTypeLiteralAST(fields, records)) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeTypeLiteralClass(this.fields, this.records, mergeSchemaAnnotations(this.ast, annotations2));
      }
      static pick(...keys2) {
        return Struct(pick$1(fields, ...keys2));
      }
      static omit(...keys2) {
        return Struct(omit(fields, ...keys2));
      }
    }, __publicField(_a2, "fields", {
      ...fields
    }), __publicField(_a2, "records", [...records]), __publicField(_a2, "make", (props, options2) => {
      const propsWithDefaults = lazilyMergeDefaults(fields, {
        ...props
      });
      return getDisableValidationMakeOption(options2) ? propsWithDefaults : validateSync(_a2)(propsWithDefaults);
    }), _a2;
  }
  function Struct(fields, ...records) {
    return makeTypeLiteralClass(fields, records);
  }
  const tag$1 = (tag2) => Literal(tag2).pipe(propertySignature, withConstructorDefault(() => tag2));
  const TaggedStruct = (value2, fields) => Struct({
    _tag: tag$1(value2),
    ...fields
  });
  function makeRecordClass(key, value2, ast) {
    var _a2;
    return _a2 = class extends makeTypeLiteralClass({}, [{
      key,
      value: value2
    }], ast) {
      static annotations(annotations2) {
        return makeRecordClass(key, value2, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "key", key), __publicField(_a2, "value", value2), _a2;
  }
  const Record = (options2) => makeRecordClass(options2.key, options2.value);
  const pick = (...keys2) => (self2) => make$d(pick$2(self2.ast, keys2));
  const pluck = /* @__PURE__ */ dual(2, (schema2, key) => {
    const ps = getPropertyKeyIndexedAccess(typeAST(schema2.ast), key);
    const value2 = make$d(ps.isOptional ? orUndefined(ps.type) : ps.type);
    const out = transform(schema2.pipe(pick(key)), value2, {
      strict: true,
      decode: (i) => i[key],
      encode: (a) => ps.isOptional && a === void 0 ? {} : {
        [key]: a
      }
    });
    return out;
  });
  function makeBrandClass(from, ast) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeBrandClass(this.from, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "make", (a, options2) => {
      return getDisableValidationMakeOption(options2) ? a : validateSync(_a2)(a);
    }), __publicField(_a2, "from", from), _a2;
  }
  const brand = (brand2, annotations2) => (self2) => {
    const annotation = match$a(getBrandAnnotation(self2.ast), {
      onNone: () => [brand2],
      onSome: (brands) => [...brands, brand2]
    });
    const ast = annotations$1(self2.ast, toASTAnnotations({
      [BrandAnnotationId]: annotation,
      ...annotations2
    }));
    return makeBrandClass(self2, ast);
  };
  const partial = (self2) => make$d(partial$1(self2.ast));
  const mutable = (schema2) => make$d(mutable$1(schema2.ast));
  const intersectTypeLiterals = (x, y, path) => {
    if (isTypeLiteral(x) && isTypeLiteral(y)) {
      const propertySignatures = [...x.propertySignatures];
      for (const ps of y.propertySignatures) {
        const name = ps.name;
        const i = propertySignatures.findIndex((ps2) => ps2.name === name);
        if (i === -1) {
          propertySignatures.push(ps);
        } else {
          const {
            isOptional,
            type
          } = propertySignatures[i];
          propertySignatures[i] = new PropertySignature(name, extendAST(type, ps.type, path.concat(name)), isOptional, true);
        }
      }
      return new TypeLiteral(propertySignatures, x.indexSignatures.concat(y.indexSignatures));
    }
    throw new Error(getSchemaExtendErrorMessage(x, y, path));
  };
  const preserveRefinementAnnotations = /* @__PURE__ */ omitAnnotations([IdentifierAnnotationId]);
  const addRefinementToMembers = (refinement, asts) => asts.map((ast) => new Refinement$1(ast, refinement.filter, preserveRefinementAnnotations(refinement)));
  const extendAST = (x, y, path) => Union$1.make(intersectUnionMembers([x], [y], path));
  const getTypes = (ast) => isUnion(ast) ? ast.types : [ast];
  const intersectUnionMembers = (xs, ys, path) => flatMap$9(xs, (x) => flatMap$9(ys, (y) => {
    switch (y._tag) {
      case "Literal": {
        if (isString(y.literal) && isStringKeyword(x) || isNumber(y.literal) && isNumberKeyword(x) || isBoolean(y.literal) && isBooleanKeyword(x)) {
          return [y];
        }
        break;
      }
      case "StringKeyword": {
        if (y === stringKeyword) {
          if (isStringKeyword(x) || isLiteral(x) && isString(x.literal)) {
            return [x];
          } else if (isRefinement$1(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === stringKeyword) {
          return [y];
        }
        break;
      }
      case "NumberKeyword": {
        if (y === numberKeyword) {
          if (isNumberKeyword(x) || isLiteral(x) && isNumber(x.literal)) {
            return [x];
          } else if (isRefinement$1(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === numberKeyword) {
          return [y];
        }
        break;
      }
      case "BooleanKeyword": {
        if (y === booleanKeyword) {
          if (isBooleanKeyword(x) || isLiteral(x) && isBoolean(x.literal)) {
            return [x];
          } else if (isRefinement$1(x)) {
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          }
        } else if (x === booleanKeyword) {
          return [y];
        }
        break;
      }
      case "Union":
        return intersectUnionMembers(getTypes(x), y.types, path);
      case "Suspend":
        return [new Suspend(() => extendAST(x, y.f(), path))];
      case "Refinement":
        return addRefinementToMembers(y, intersectUnionMembers(getTypes(x), getTypes(y.from), path));
      case "TypeLiteral": {
        switch (x._tag) {
          case "Union":
            return intersectUnionMembers(x.types, [y], path);
          case "Suspend":
            return [new Suspend(() => extendAST(x.f(), y, path))];
          case "Refinement":
            return addRefinementToMembers(x, intersectUnionMembers(getTypes(x.from), [y], path));
          case "TypeLiteral":
            return [intersectTypeLiterals(x, y, path)];
          case "Transformation": {
            const transformation = x.transformation;
            const from = intersectTypeLiterals(x.from, y, path);
            const to = intersectTypeLiterals(x.to, typeAST(y), path);
            switch (transformation._tag) {
              case "TypeLiteralTransformation":
                return [new Transformation$1(from, to, new TypeLiteralTransformation(transformation.propertySignatureTransformations))];
              case "ComposeTransformation":
                return [new Transformation$1(from, to, composeTransformation)];
              case "FinalTransformation":
                return [new Transformation$1(from, to, new FinalTransformation((fromA, options2, ast, fromI) => map$1(transformation.decode(fromA, options2, ast, fromI), (partial2) => ({
                  ...fromA,
                  ...partial2
                })), (toI, options2, ast, toA) => map$1(transformation.encode(toI, options2, ast, toA), (partial2) => ({
                  ...toI,
                  ...partial2
                }))))];
            }
          }
        }
        break;
      }
      case "Transformation": {
        if (isTransformation$1(x)) {
          if (isTypeLiteralTransformation(y.transformation) && isTypeLiteralTransformation(x.transformation)) {
            return [new Transformation$1(intersectTypeLiterals(x.from, y.from, path), intersectTypeLiterals(x.to, y.to, path), new TypeLiteralTransformation(y.transformation.propertySignatureTransformations.concat(x.transformation.propertySignatureTransformations)))];
          }
        } else {
          return intersectUnionMembers([y], [x], path);
        }
        break;
      }
    }
    throw new Error(getSchemaExtendErrorMessage(x, y, path));
  }));
  const extend = /* @__PURE__ */ dual(2, (self2, that) => make$d(extendAST(self2.ast, that.ast, [])));
  const compose = /* @__PURE__ */ dual((args2) => isSchema(args2[1]), (from, to) => makeTransformationClass(from, to, compose$1(from.ast, to.ast)));
  const suspend$1 = (f) => make$d(new Suspend(() => f().ast));
  const RefineSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/Refine");
  function makeRefineClass(from, filter2, ast) {
    var _a2, _b2, _c2;
    return _c2 = class extends (_b2 = make$d(ast), _a2 = RefineSchemaId, _b2) {
      static annotations(annotations2) {
        return makeRefineClass(this.from, this.filter, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_c2, _a2, from), __publicField(_c2, "from", from), __publicField(_c2, "filter", filter2), __publicField(_c2, "make", (a, options2) => {
      return getDisableValidationMakeOption(options2) ? a : validateSync(_c2)(a);
    }), _c2;
  }
  const fromFilterPredicateReturnTypeItem = (item, ast, input) => {
    if (isBoolean(item)) {
      return item ? none$4() : some(new Type(ast, input));
    }
    if (isString(item)) {
      return some(new Type(ast, input, item));
    }
    if (item !== void 0) {
      if ("_tag" in item) {
        return some(item);
      }
      const issue = new Type(ast, input, item.message);
      return some(isNonEmptyReadonlyArray(item.path) ? new Pointer(item.path, input, issue) : issue);
    }
    return none$4();
  };
  const toFilterParseIssue = (out, ast, input) => {
    if (isSingle(out)) {
      return fromFilterPredicateReturnTypeItem(out, ast, input);
    }
    if (isNonEmptyReadonlyArray(out)) {
      const issues = filterMap$3(out, (issue) => fromFilterPredicateReturnTypeItem(issue, ast, input));
      if (isNonEmptyReadonlyArray(issues)) {
        return some(issues.length === 1 ? issues[0] : new Composite(ast, input, issues));
      }
    }
    return none$4();
  };
  function filter$1(predicate, annotations2) {
    return (self2) => {
      function filter2(input, options2, ast2) {
        return toFilterParseIssue(predicate(input, options2, ast2), ast2, input);
      }
      const ast = new Refinement$1(self2.ast, filter2, toASTAnnotations(annotations2));
      return makeRefineClass(self2, filter2, ast);
    };
  }
  function makeTransformationClass(from, to, ast) {
    var _a2;
    return _a2 = class extends make$d(ast) {
      static annotations(annotations2) {
        return makeTransformationClass(this.from, this.to, mergeSchemaAnnotations(this.ast, annotations2));
      }
    }, __publicField(_a2, "from", from), __publicField(_a2, "to", to), _a2;
  }
  const transformOrFail = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options2) => makeTransformationClass(from, to, new Transformation$1(from.ast, to.ast, new FinalTransformation(options2.decode, options2.encode))));
  const transform = /* @__PURE__ */ dual((args2) => isSchema(args2[0]) && isSchema(args2[1]), (from, to, options2) => transformOrFail(from, to, {
    strict: true,
    decode: (fromA, _options, _ast, toA) => succeed(options2.decode(fromA, toA)),
    encode: (toI, _options, _ast, toA) => succeed(options2.encode(toI, toA))
  }));
  const annotations = /* @__PURE__ */ dual(2, (self2, annotations2) => self2.annotations(annotations2));
  const getErrorMessage = (e) => e instanceof Error ? e.message : String(e);
  const getParseJsonTransformation = (options2) => transformOrFail(String$.annotations({
    description: "a string to be decoded into JSON"
  }), Unknown, {
    strict: true,
    decode: (i, _, ast) => _try({
      try: () => JSON.parse(i, options2 == null ? void 0 : options2.reviver),
      catch: (e) => new Type(ast, i, getErrorMessage(e))
    }),
    encode: (a, _, ast) => _try({
      try: () => JSON.stringify(a, options2 == null ? void 0 : options2.replacer, options2 == null ? void 0 : options2.space),
      catch: (e) => new Type(ast, a, getErrorMessage(e))
    })
  }).annotations({
    title: "parseJson",
    schemaId: ParseJsonSchemaId
  });
  const parseJson = (schemaOrOptions, o) => isSchema(schemaOrOptions) ? compose(parseJson(o), schemaOrOptions) : getParseJsonTransformation(schemaOrOptions);
  const GreaterThanOrEqualToSchemaId = GreaterThanOrEqualToSchemaId$1;
  const greaterThanOrEqualTo = (minimum, annotations2) => (self2) => self2.pipe(filter$1((a) => a >= minimum, {
    schemaId: GreaterThanOrEqualToSchemaId,
    title: `greaterThanOrEqualTo(${minimum})`,
    description: "a non-negative number",
    jsonSchema: {
      minimum
    },
    ...annotations2
  }));
  const IntSchemaId = IntSchemaId$1;
  const int = (annotations2) => (self2) => self2.pipe(filter$1((a) => Number.isSafeInteger(a), {
    schemaId: IntSchemaId,
    title: "int",
    description: "an integer",
    jsonSchema: {
      type: "integer"
    },
    ...annotations2
  }));
  const BetweenSchemaId = BetweenSchemaId$1;
  const between = (minimum, maximum, annotations2) => (self2) => self2.pipe(filter$1((a) => a >= minimum && a <= maximum, {
    schemaId: BetweenSchemaId,
    title: `between(${minimum}, ${maximum})`,
    description: `a number between ${minimum} and ${maximum}`,
    jsonSchema: {
      minimum,
      maximum
    },
    ...annotations2
  }));
  const nonNegative = (annotations2) => greaterThanOrEqualTo(0, {
    title: "nonNegative",
    ...annotations2
  });
  class Int extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ int({
    identifier: "Int"
  }))) {
  }
  class NonNegative extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ nonNegative({
    identifier: "NonNegative"
  }))) {
  }
  const toComposite = (eff, onSuccess, ast, actual) => mapBoth(eff, {
    onFailure: (e) => new Composite(ast, actual, e),
    onSuccess
  });
  class DurationFromSelf extends (/* @__PURE__ */ declare(isDuration, {
    identifier: "DurationFromSelf",
    pretty: () => String,
    arbitrary: () => (fc) => fc.oneof(fc.constant(infinity), fc.bigInt({
      min: 0n
    }).map((_) => nanos(_)), fc.maxSafeNat().map((_) => millis(_))),
    equivalence: () => Equivalence
  })) {
  }
  class DurationFromMillis extends (/* @__PURE__ */ transform(NonNegative.annotations({
    description: "a non-negative number to be decoded into a Duration"
  }), DurationFromSelf, {
    strict: true,
    decode: (i) => millis(i),
    encode: (a) => toMillis(a)
  }).annotations({
    identifier: "DurationFromMillis"
  })) {
  }
  class Uint8ArrayFromSelf extends (/* @__PURE__ */ declare(isUint8Array, {
    identifier: "Uint8ArrayFromSelf",
    pretty: () => (u8arr) => `new Uint8Array(${JSON.stringify(Array.from(u8arr))})`,
    arbitrary: () => (fc) => fc.uint8Array(),
    equivalence: () => getEquivalence$2(equals$1)
  })) {
  }
  class Uint8 extends (/* @__PURE__ */ Number$.pipe(/* @__PURE__ */ between(0, 255, {
    identifier: "Uint8",
    description: "a 8-bit unsigned integer"
  }))) {
  }
  class Uint8Array$ extends (/* @__PURE__ */ transform(Array$(Uint8).annotations({
    description: "an array of 8-bit unsigned integers to be decoded into a Uint8Array"
  }), Uint8ArrayFromSelf, {
    strict: true,
    decode: (i) => Uint8Array.from(i),
    encode: (a) => Array.from(a)
  }).annotations({
    identifier: "Uint8Array"
  })) {
  }
  const makeUint8ArrayTransformation = (id2, decode2, encode2) => transformOrFail(String$.annotations({
    description: "a string to be decoded into a Uint8Array"
  }), Uint8ArrayFromSelf, {
    strict: true,
    decode: (i, _, ast) => mapLeft(decode2(i), (decodeException) => new Type(ast, i, decodeException.message)),
    encode: (a) => succeed(encode2(a))
  }).annotations({
    identifier: id2
  });
  const Uint8ArrayFromBase64 = /* @__PURE__ */ makeUint8ArrayTransformation("Uint8ArrayFromBase64", decodeBase64, encodeBase64);
  const getNumberIndexedAccess = (self2) => make$d(getNumberIndexedAccess$1(self2.ast));
  function head$2(self2) {
    return transform(self2, OptionFromSelf(getNumberIndexedAccess(typeSchema(self2))), {
      strict: false,
      decode: (i) => head$4(i),
      encode: (a) => match$a(a, {
        onNone: () => [],
        onSome: of$3
      })
    });
  }
  const headOrElse = /* @__PURE__ */ dual((args2) => isSchema(args2[0]), (self2, fallback) => transformOrFail(self2, getNumberIndexedAccess(typeSchema(self2)), {
    strict: true,
    decode: (i, _, ast) => i.length > 0 ? succeed(i[0]) : fallback ? succeed(fallback()) : fail$1(new Type(ast, i, "Unable to retrieve the first element of an empty array")),
    encode: (a) => succeed(of$3(a))
  }));
  const ValidDateSchemaId = /* @__PURE__ */ Symbol.for("effect/SchemaId/ValidDate");
  const validDate = (annotations2) => (self2) => self2.pipe(filter$1((a) => !Number.isNaN(a.getTime()), {
    schemaId: ValidDateSchemaId,
    [ValidDateSchemaId]: {
      noInvalidDate: true
    },
    title: "validDate",
    description: "a valid Date",
    ...annotations2
  }));
  const DateFromSelfSchemaId = DateFromSelfSchemaId$1;
  class DateFromSelf extends (/* @__PURE__ */ declare(isDate, {
    identifier: "DateFromSelf",
    schemaId: DateFromSelfSchemaId,
    [DateFromSelfSchemaId]: {
      noInvalidDate: false
    },
    description: "a potentially invalid Date instance",
    pretty: () => (date) => `new Date(${JSON.stringify(date)})`,
    arbitrary: () => (fc) => fc.date({
      noInvalidDate: false
    }),
    equivalence: () => Date$1
  })) {
  }
  class DateFromString extends (/* @__PURE__ */ transform(String$.annotations({
    description: "a string to be decoded into a Date"
  }), DateFromSelf, {
    strict: true,
    decode: (i) => new Date(i),
    encode: (a) => formatDate(a)
  }).annotations({
    identifier: "DateFromString"
  })) {
  }
  class Date$ extends (/* @__PURE__ */ DateFromString.pipe(/* @__PURE__ */ validDate({
    identifier: "Date"
  }))) {
  }
  class DateFromNumber extends (/* @__PURE__ */ transform(Number$.annotations({
    description: "a number to be decoded into a Date"
  }), DateFromSelf, {
    strict: true,
    decode: (i) => new Date(i),
    encode: (a) => a.getTime()
  }).annotations({
    identifier: "DateFromNumber"
  })) {
  }
  const OptionNoneEncoded = /* @__PURE__ */ Struct({
    _tag: Literal("None")
  }).annotations({
    description: "NoneEncoded"
  });
  const optionSomeEncoded = (value2) => Struct({
    _tag: Literal("Some"),
    value: value2
  }).annotations({
    description: `SomeEncoded<${format(value2)}>`
  });
  const optionEncoded = (value2) => Union(OptionNoneEncoded, optionSomeEncoded(value2)).annotations({
    description: `OptionEncoded<${format(value2)}>`
  });
  const optionDecode = (input) => input._tag === "None" ? none$4() : some(input.value);
  const optionArbitrary = (value2, ctx) => (fc) => fc.oneof(ctx, fc.record({
    _tag: fc.constant("None")
  }), fc.record({
    _tag: fc.constant("Some"),
    value: value2(fc)
  })).map(optionDecode);
  const optionPretty = (value2) => match$a({
    onNone: () => "none()",
    onSome: (a) => `some(${value2(a)})`
  });
  const optionParse = (decodeUnknown2) => (u, options2, ast) => isOption(u) ? isNone(u) ? succeed(none$4()) : toComposite(decodeUnknown2(u.value, options2), some, ast, u) : fail$1(new Type(ast, u));
  const OptionFromSelf = (value2) => {
    return declare([value2], {
      decode: (value3) => optionParse(decodeUnknown$1(value3)),
      encode: (value3) => optionParse(encodeUnknown$1(value3))
    }, {
      description: `Option<${format(value2)}>`,
      pretty: optionPretty,
      arbitrary: optionArbitrary,
      equivalence: getEquivalence$3
    });
  };
  const makeNoneEncoded = {
    _tag: "None"
  };
  const makeSomeEncoded = (value2) => ({
    _tag: "Some",
    value: value2
  });
  function Option(value2) {
    const value_ = asSchema(value2);
    const out = transform(optionEncoded(value_), OptionFromSelf(typeSchema(value_)), {
      strict: true,
      decode: (i) => optionDecode(i),
      encode: (a) => match$a(a, {
        onNone: () => makeNoneEncoded,
        onSome: makeSomeEncoded
      })
    });
    return out;
  }
  const setArbitrary = (item, ctx) => (fc) => {
    const items = fc.array(item(fc));
    return (ctx.depthIdentifier !== void 0 ? fc.oneof(ctx, fc.constant([]), items) : items).map((as2) => new Set(as2));
  };
  const readonlySetPretty = (item) => (set2) => `new Set([${Array.from(set2.values()).map((a) => item(a)).join(", ")}])`;
  const readonlySetEquivalence = (item) => {
    const arrayEquivalence = getEquivalence$2(item);
    return make$11((a, b) => arrayEquivalence(Array.from(a.values()), Array.from(b.values())));
  };
  const readonlySetParse = (decodeUnknown2) => (u, options2, ast) => isSet(u) ? toComposite(decodeUnknown2(Array.from(u.values()), options2), (as2) => new Set(as2), ast, u) : fail$1(new Type(ast, u));
  const setFromSelf_ = (value2, description) => declare([value2], {
    decode: (item) => readonlySetParse(decodeUnknown$1(Array$(item))),
    encode: (item) => readonlySetParse(encodeUnknown$1(Array$(item)))
  }, {
    description,
    pretty: readonlySetPretty,
    arbitrary: setArbitrary,
    equivalence: readonlySetEquivalence
  });
  const ReadonlySetFromSelf = (value2) => setFromSelf_(value2, `ReadonlySet<${format(value2)}>`);
  function ReadonlySet(value2) {
    return transform(Array$(value2), ReadonlySetFromSelf(typeSchema(asSchema(value2))), {
      strict: true,
      decode: (i) => new Set(i),
      encode: (a) => Array.from(a)
    });
  }
  const isField = (u) => isSchema(u) || isPropertySignature(u);
  const isFields = (fields) => ownKeys(fields).every((key) => isField(fields[key]));
  const getFields = (hasFields) => "fields" in hasFields ? hasFields.fields : getFields(hasFields[RefineSchemaId]);
  const getSchemaFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? Struct(fieldsOr) : isSchema(fieldsOr) ? fieldsOr : Struct(getFields(fieldsOr));
  const getFieldsFromFieldsOr = (fieldsOr) => isFields(fieldsOr) ? fieldsOr : getFields(fieldsOr);
  const Class = (identifier2) => (fieldsOr, annotations2) => makeClass({
    kind: "Class",
    identifier: identifier2,
    schema: getSchemaFromFieldsOr(fieldsOr),
    fields: getFieldsFromFieldsOr(fieldsOr),
    Base: Class$2,
    annotations: annotations2
  });
  const getClassTag = (tag2) => withConstructorDefault(propertySignature(Literal(tag2)), () => tag2);
  const TaggedError = (identifier2) => (tag2, fieldsOr, annotations2) => {
    class Base2 extends Error$1 {
    }
    Base2.prototype.name = tag2;
    const fields = getFieldsFromFieldsOr(fieldsOr);
    const schema2 = getSchemaFromFieldsOr(fieldsOr);
    const newFields = {
      _tag: getClassTag(tag2)
    };
    const taggedFields = extendFields(newFields, fields);
    const hasMessageField = "message" in taggedFields;
    class TaggedErrorClass extends makeClass({
      kind: "TaggedError",
      identifier: tag2,
      schema: extend(schema2, Struct(newFields)),
      fields: taggedFields,
      Base: Base2,
      annotations: annotations2,
      disableToString: true
    }) {
    }
    __publicField(TaggedErrorClass, "_tag", tag2);
    if (!hasMessageField) {
      Object.defineProperty(TaggedErrorClass.prototype, "message", {
        get() {
          return `{ ${ownKeys(fields).map((p) => `${formatPropertyKey$1(p)}: ${formatUnknown(this[p])}`).join(", ")} }`;
        },
        enumerable: false,
        // mirrors the built-in Error.prototype.message, whose descriptor is also non-enumerable
        configurable: true
      });
    }
    return TaggedErrorClass;
  };
  const extendFields = (a, b) => {
    const out = {
      ...a
    };
    for (const key of ownKeys(b)) {
      if (key in a) {
        throw new Error(getASTDuplicatePropertySignatureErrorMessage(key));
      }
      out[key] = b[key];
    }
    return out;
  };
  function getDisableValidationMakeOption(options2) {
    return isBoolean(options2) ? options2 : (options2 == null ? void 0 : options2.disableValidation) ?? false;
  }
  const astCache = /* @__PURE__ */ globalValue("effect/Schema/astCache", () => /* @__PURE__ */ new WeakMap());
  const getClassAnnotations = (annotations2) => {
    if (annotations2 === void 0) {
      return [];
    } else if (Array.isArray(annotations2)) {
      return annotations2;
    } else {
      return [annotations2];
    }
  };
  const makeClass = ({
    Base: Base2,
    annotations: annotations2,
    disableToString,
    fields,
    identifier: identifier2,
    kind,
    schema: schema2
  }) => {
    var _a2, _b2;
    const classSymbol = Symbol.for(`effect/Schema/${kind}/${identifier2}`);
    const [typeAnnotations, transformationAnnotations, encodedAnnotations] = getClassAnnotations(annotations2);
    const typeSchema_ = typeSchema(schema2);
    const declarationSurrogate = typeSchema_.annotations({
      identifier: identifier2,
      ...typeAnnotations
    });
    const typeSide = typeSchema_.annotations({
      [AutoTitleAnnotationId]: `${identifier2} (Type side)`,
      ...typeAnnotations
    });
    const constructorSchema = schema2.annotations({
      [AutoTitleAnnotationId]: `${identifier2} (Constructor)`,
      ...typeAnnotations
    });
    const encodedSide = schema2.annotations({
      [AutoTitleAnnotationId]: `${identifier2} (Encoded side)`,
      ...encodedAnnotations
    });
    const transformationSurrogate = schema2.annotations({
      [JSONIdentifierAnnotationId]: identifier2,
      ...encodedAnnotations,
      ...typeAnnotations,
      ...transformationAnnotations
    });
    const fallbackInstanceOf = (u) => hasProperty(u, classSymbol) && is(typeSide)(u);
    const klass = (_b2 = class extends Base2 {
      constructor(props = {}, options2 = false) {
        props = {
          ...props
        };
        if (kind !== "Class") {
          delete props["_tag"];
        }
        props = lazilyMergeDefaults(fields, props);
        if (!getDisableValidationMakeOption(options2)) {
          props = validateSync(constructorSchema)(props);
        }
        super(props, true);
      }
      static get ast() {
        let out = astCache.get(this);
        if (out) {
          return out;
        }
        const declaration = declare([schema2], {
          decode: () => (input, _, ast) => input instanceof this || fallbackInstanceOf(input) ? succeed(input) : fail$1(new Type(ast, input)),
          encode: () => (input, options2) => input instanceof this ? succeed(input) : map$1(encodeUnknown$1(typeSide)(input, options2), (props) => new this(props, true))
        }, {
          identifier: identifier2,
          pretty: (pretty2) => (self2) => `${identifier2}(${pretty2(self2)})`,
          // @ts-expect-error
          arbitrary: (arb) => (fc) => arb(fc).map((props) => new this(props)),
          equivalence: identity,
          [SurrogateAnnotationId]: declarationSurrogate.ast,
          ...typeAnnotations
        });
        out = transform(encodedSide, declaration, {
          strict: true,
          decode: (i) => new this(i, true),
          encode: identity
        }).annotations({
          [SurrogateAnnotationId]: transformationSurrogate.ast,
          ...transformationAnnotations
        }).ast;
        astCache.set(this, out);
        return out;
      }
      static pipe() {
        return pipeArguments(this, arguments);
      }
      static annotations(annotations3) {
        return make$d(this.ast).annotations(annotations3);
      }
      static toString() {
        return `(${String(encodedSide)} <-> ${identifier2})`;
      }
      // ----------------
      // Class interface
      // ----------------
      static make(...args2) {
        return new this(...args2);
      }
      static extend(identifier3) {
        return (newFieldsOr, annotations3) => {
          const newFields = getFieldsFromFieldsOr(newFieldsOr);
          const newSchema = getSchemaFromFieldsOr(newFieldsOr);
          const extendedFields = extendFields(fields, newFields);
          return makeClass({
            kind,
            identifier: identifier3,
            schema: extend(schema2, newSchema),
            fields: extendedFields,
            Base: this,
            annotations: annotations3
          });
        };
      }
      static transformOrFail(identifier3) {
        return (newFieldsOr, options2, annotations3) => {
          const transformedFields = extendFields(fields, newFieldsOr);
          return makeClass({
            kind,
            identifier: identifier3,
            schema: transformOrFail(schema2, typeSchema(Struct(transformedFields)), options2),
            fields: transformedFields,
            Base: this,
            annotations: annotations3
          });
        };
      }
      static transformOrFailFrom(identifier3) {
        return (newFields, options2, annotations3) => {
          const transformedFields = extendFields(fields, newFields);
          return makeClass({
            kind,
            identifier: identifier3,
            schema: transformOrFail(encodedSchema(schema2), Struct(transformedFields), options2),
            fields: transformedFields,
            Base: this,
            annotations: annotations3
          });
        };
      }
      // ----------------
      // other
      // ----------------
      get [(_a2 = TypeId$a, classSymbol)]() {
        return classSymbol;
      }
    }, // ----------------
    // Schema interface
    // ----------------
    __publicField(_b2, _a2, variance), __publicField(_b2, "fields", {
      ...fields
    }), __publicField(_b2, "identifier", identifier2), _b2);
    if (disableToString !== true) {
      Object.defineProperty(klass.prototype, "toString", {
        value() {
          return `${identifier2}({ ${ownKeys(fields).map((p) => `${formatPropertyKey$1(p)}: ${formatUnknown(this[p])}`).join(", ")} })`;
        },
        configurable: true,
        writable: true
      });
    }
    return klass;
  };
  const FiberIdNoneEncoded = /* @__PURE__ */ Struct({
    _tag: Literal("None")
  }).annotations({
    identifier: "FiberIdNoneEncoded"
  });
  const FiberIdRuntimeEncoded = /* @__PURE__ */ Struct({
    _tag: Literal("Runtime"),
    id: Int,
    startTimeMillis: Int
  }).annotations({
    identifier: "FiberIdRuntimeEncoded"
  });
  const FiberIdCompositeEncoded = /* @__PURE__ */ Struct({
    _tag: Literal("Composite"),
    left: suspend$1(() => FiberIdEncoded),
    right: suspend$1(() => FiberIdEncoded)
  }).annotations({
    identifier: "FiberIdCompositeEncoded"
  });
  const FiberIdEncoded = /* @__PURE__ */ Union(FiberIdNoneEncoded, FiberIdRuntimeEncoded, FiberIdCompositeEncoded).annotations({
    identifier: "FiberIdEncoded"
  });
  const fiberIdArbitrary = (fc) => fc.letrec((tie) => ({
    None: fc.record({
      _tag: fc.constant("None")
    }),
    Runtime: fc.record({
      _tag: fc.constant("Runtime"),
      id: fc.integer(),
      startTimeMillis: fc.integer()
    }),
    Composite: fc.record({
      _tag: fc.constant("Composite"),
      left: tie("FiberId"),
      right: tie("FiberId")
    }),
    FiberId: fc.oneof(tie("None"), tie("Runtime"), tie("Composite"))
  })).FiberId.map(fiberIdDecode);
  const fiberIdPretty = (fiberId2) => {
    switch (fiberId2._tag) {
      case "None":
        return "FiberId.none";
      case "Runtime":
        return `FiberId.runtime(${fiberId2.id}, ${fiberId2.startTimeMillis})`;
      case "Composite":
        return `FiberId.composite(${fiberIdPretty(fiberId2.right)}, ${fiberIdPretty(fiberId2.left)})`;
    }
  };
  const fiberIdDecode = (input) => {
    switch (input._tag) {
      case "None":
        return none$2;
      case "Runtime":
        return runtime$2(input.id, input.startTimeMillis);
      case "Composite":
        return composite(fiberIdDecode(input.left), fiberIdDecode(input.right));
    }
  };
  const causeDieEncoded = (defect) => Struct({
    _tag: Literal("Die"),
    defect
  });
  const CauseEmptyEncoded = /* @__PURE__ */ Struct({
    _tag: /* @__PURE__ */ Literal("Empty")
  });
  const causeFailEncoded = (error) => Struct({
    _tag: Literal("Fail"),
    error
  });
  const CauseInterruptEncoded = /* @__PURE__ */ Struct({
    _tag: /* @__PURE__ */ Literal("Interrupt"),
    fiberId: FiberIdEncoded
  });
  let causeEncodedId = 0;
  const causeEncoded = (error, defect) => {
    const error_ = asSchema(error);
    const defect_ = asSchema(defect);
    const suspended2 = suspend$1(() => out);
    const out = Union(CauseEmptyEncoded, causeFailEncoded(error_), causeDieEncoded(defect_), CauseInterruptEncoded, Struct({
      _tag: Literal("Sequential"),
      left: suspended2,
      right: suspended2
    }), Struct({
      _tag: Literal("Parallel"),
      left: suspended2,
      right: suspended2
    })).annotations({
      title: `CauseEncoded<${format(error)}>`,
      [JSONIdentifierAnnotationId]: `CauseEncoded${causeEncodedId++}`
    });
    return out;
  };
  const causeArbitrary = (error, defect) => (fc) => fc.letrec((tie) => ({
    Empty: fc.record({
      _tag: fc.constant("Empty")
    }),
    Fail: fc.record({
      _tag: fc.constant("Fail"),
      error: error(fc)
    }),
    Die: fc.record({
      _tag: fc.constant("Die"),
      defect: defect(fc)
    }),
    Interrupt: fc.record({
      _tag: fc.constant("Interrupt"),
      fiberId: fiberIdArbitrary(fc)
    }),
    Sequential: fc.record({
      _tag: fc.constant("Sequential"),
      left: tie("Cause"),
      right: tie("Cause")
    }),
    Parallel: fc.record({
      _tag: fc.constant("Parallel"),
      left: tie("Cause"),
      right: tie("Cause")
    }),
    Cause: fc.oneof(tie("Empty"), tie("Fail"), tie("Die"), tie("Interrupt"), tie("Sequential"), tie("Parallel"))
  })).Cause.map(causeDecode);
  const causePretty = (error) => (cause) => {
    const f = (cause2) => {
      switch (cause2._tag) {
        case "Empty":
          return "Cause.empty";
        case "Fail":
          return `Cause.fail(${error(cause2.error)})`;
        case "Die":
          return `Cause.die(${pretty(cause2)})`;
        case "Interrupt":
          return `Cause.interrupt(${fiberIdPretty(cause2.fiberId)})`;
        case "Sequential":
          return `Cause.sequential(${f(cause2.left)}, ${f(cause2.right)})`;
        case "Parallel":
          return `Cause.parallel(${f(cause2.left)}, ${f(cause2.right)})`;
      }
    };
    return f(cause);
  };
  const causeParse = (decodeUnknown2) => (u, options2, ast) => isCause(u) ? toComposite(decodeUnknown2(causeEncode(u), options2), causeDecode, ast, u) : fail$1(new Type(ast, u));
  const CauseFromSelf = ({
    defect,
    error
  }) => {
    return declare([error, defect], {
      decode: (error2, defect2) => causeParse(decodeUnknown$1(causeEncoded(error2, defect2))),
      encode: (error2, defect2) => causeParse(encodeUnknown$1(causeEncoded(error2, defect2)))
    }, {
      title: `Cause<${error.ast}>`,
      pretty: causePretty,
      arbitrary: causeArbitrary
    });
  };
  function causeDecode(cause) {
    switch (cause._tag) {
      case "Empty":
        return empty$9;
      case "Fail":
        return fail$8(cause.error);
      case "Die":
        return die$4(cause.defect);
      case "Interrupt":
        return interrupt$3(fiberIdDecode(cause.fiberId));
      case "Sequential":
        return sequential(causeDecode(cause.left), causeDecode(cause.right));
      case "Parallel":
        return parallel(causeDecode(cause.left), causeDecode(cause.right));
    }
  }
  function causeEncode(cause) {
    switch (cause._tag) {
      case "Empty":
        return {
          _tag: "Empty"
        };
      case "Fail":
        return {
          _tag: "Fail",
          error: cause.error
        };
      case "Die":
        return {
          _tag: "Die",
          defect: cause.defect
        };
      case "Interrupt":
        return {
          _tag: "Interrupt",
          fiberId: cause.fiberId
        };
      case "Sequential":
        return {
          _tag: "Sequential",
          left: causeEncode(cause.left),
          right: causeEncode(cause.right)
        };
      case "Parallel":
        return {
          _tag: "Parallel",
          left: causeEncode(cause.left),
          right: causeEncode(cause.right)
        };
    }
  }
  const Cause = ({
    defect,
    error
  }) => {
    const error_ = asSchema(error);
    const defect_ = asSchema(defect);
    const out = transform(causeEncoded(error_, defect_), CauseFromSelf({
      error: typeSchema(error_),
      defect: typeSchema(defect_)
    }), {
      strict: false,
      decode: (i) => causeDecode(i),
      encode: (a) => causeEncode(a)
    });
    return out;
  };
  class Defect extends (/* @__PURE__ */ transform(Unknown, Unknown, {
    strict: true,
    decode: (i) => {
      if (isObject(i) && "message" in i && typeof i.message === "string") {
        const err = new Error(i.message, {
          cause: i
        });
        if ("name" in i && typeof i.name === "string") {
          err.name = i.name;
        }
        err.stack = "stack" in i && typeof i.stack === "string" ? i.stack : "";
        return err;
      }
      return String(i);
    },
    encode: (a) => {
      if (a instanceof Error) {
        return {
          name: a.name,
          message: a.message
          // no stack because of security reasons
        };
      }
      return prettyErrorMessage(a);
    }
  }).annotations({
    identifier: "Defect"
  })) {
  }
  const symbolSerializable = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbol");
  const symbolWithResult = /* @__PURE__ */ Symbol.for("effect/Schema/Serializable/symbolResult");
  const serializeFailure = /* @__PURE__ */ dual(2, (self2, value2) => encode(self2[symbolWithResult].failure)(value2));
  const serializeSuccess = /* @__PURE__ */ dual(2, (self2, value2) => encode(self2[symbolWithResult].success)(value2));
  const TaggedRequest = (identifier2) => (tag2, options2, annotations2) => {
    var _a2;
    const taggedFields = extendFields({
      _tag: getClassTag(tag2)
    }, options2.payload);
    return _a2 = class extends makeClass({
      kind: "TaggedRequest",
      identifier: tag2,
      schema: Struct(taggedFields),
      fields: taggedFields,
      Base: Class$1,
      annotations: annotations2
    }) {
      get [symbolSerializable]() {
        return this.constructor;
      }
      get [symbolWithResult]() {
        return {
          failure: options2.failure,
          success: options2.success
        };
      }
    }, __publicField(_a2, "_tag", tag2), __publicField(_a2, "success", options2.success), __publicField(_a2, "failure", options2.failure), _a2;
  };
  const asyncScoped = asyncScoped$1;
  const bufferChunks = bufferChunks$1;
  const ensuringWith = ensuringWith$1;
  const fail = fail$2;
  const filter = filter$2;
  const filterEffect = filterEffect$1;
  const filterMap = filterMap$1;
  const flatten = flatten$1;
  const flattenIterables = flattenIterables$1;
  const fromPubSub = fromPubSub$1;
  const fromQueue = fromQueue$1;
  const fromReadableStream = fromReadableStream$1;
  const make$c = make$m;
  const map = map$2;
  const mapChunksEffect = mapChunksEffect$1;
  const mapEffect = mapEffectOptions;
  const mapError = mapError$2;
  const never = never$1;
  const orDie = orDie$1;
  const provideContext = provideContext$1;
  const runCollect = runCollect$1;
  const runDrain = runDrain$1;
  const runForEachChunk = runForEachChunk$1;
  const suspend = suspend$2;
  const take = take$1;
  const tap = tap$1;
  const toReadableStreamEffect = toReadableStreamEffect$1;
  const unfoldChunk = unfoldChunk$1;
  const unwrap = unwrap$1;
  const unwrapScoped = unwrapScoped$1;
  const withSpan = withSpan$1;
  const zipLatest = zipLatest$1;
  const fromEventListener = fromEventListener$1;
  const TypeId$9 = /* @__PURE__ */ Symbol.for("effect/Subscribable");
  const SynchronizedRefTypeId = SynchronizedTypeId;
  const SubscriptionRefSymbolKey = "effect/SubscriptionRef";
  const SubscriptionRefTypeId = /* @__PURE__ */ Symbol.for(SubscriptionRefSymbolKey);
  const subscriptionRefVariance = {
    /* c8 ignore next */
    _A: (_) => _
  };
  class SubscriptionRefImpl extends (_Ja = Class$4, _Ia = TypeId$i, _Ha = TypeId$9, _Ga = RefTypeId, _Fa = SynchronizedRefTypeId, _Ea = SubscriptionRefTypeId, _Ja) {
    constructor(ref, pubsub, semaphore2) {
      super();
      __publicField(this, "ref");
      __publicField(this, "pubsub");
      __publicField(this, "semaphore");
      __publicField(this, _Ia, TypeId$i);
      __publicField(this, _Ha, TypeId$9);
      __publicField(this, _Ga, refVariance);
      __publicField(this, _Fa, synchronizedVariance);
      __publicField(this, _Ea, subscriptionRefVariance);
      __publicField(this, "get");
      this.ref = ref;
      this.pubsub = pubsub;
      this.semaphore = semaphore2;
      this.get = get$5(this.ref);
    }
    commit() {
      return this.get;
    }
    get changes() {
      return pipe(get$5(this.ref), flatMap$4((a) => map$5(fromPubSub$1(this.pubsub, {
        scoped: true
      }), (s) => concat(make$m(a), s))), this.semaphore.withPermits(1), unwrapScoped$1);
    }
    modify(f) {
      return this.modifyEffect((a) => succeed$5(f(a)));
    }
    modifyEffect(f) {
      return pipe(get$5(this.ref), flatMap$4(f), flatMap$4(([b, a]) => pipe(set$5(this.ref, a), as(b), zipLeft(publish(this.pubsub, a)))), this.semaphore.withPermits(1));
    }
  }
  const make$b = (value2) => pipe(all([unbounded$3(), make$G(value2), makeSemaphore(1)]), map$5(([pubsub, ref, semaphore2]) => new SubscriptionRefImpl(ref, pubsub, semaphore2)));
  const set$3 = /* @__PURE__ */ dual(2, (self2, value2) => pipe(set$5(self2.ref, value2), zipLeft(publish(self2.pubsub, value2)), self2.semaphore.withPermits(1)));
  const make$a = make$b;
  const set$2 = set$3;
  const get$2 = get$3;
  const make$9 = make$o;
  const set$1 = set$4;
  const update = update$1;
  const tapChunk = (f) => (self2) => mapChunksEffect(self2, (chunks) => pipe(f(chunks), map$5(() => chunks)));
  const make$8 = () => make$9([]);
  const offerAll = (self2, elements) => update(self2, (bucket) => appendAll$2(bucket, elements));
  const clear = (self2) => set$1(self2, []);
  const takeBetween = (bucket, min2, max2) => gen(function* () {
    const bucketValue = yield* get$2(bucket);
    if (bucketValue.length < min2) {
      return yield* retry;
    } else {
      const elements = bucketValue.splice(0, Math.min(max2, bucketValue.length));
      yield* set$1(bucket, bucketValue);
      return elements;
    }
  });
  const takeSplitWhere = (bucket, predicate) => gen(function* () {
    const bucketValue = yield* get$2(bucket);
    const [elements, rest] = splitWhere$1(bucketValue, predicate);
    yield* set$1(bucket, rest);
    return elements;
  });
  const size = (bucket) => get$2(bucket).pipe(map$5((_) => _.length));
  const waitUntil = dual(2, (sref, predicate) => pipe(sref.changes, filter(predicate), take(1), runCollect, map$5(unsafeHead)));
  const TypeId$8 = Symbol.for("effect/Subscribable");
  class SubscribableImpl extends (_Ma = Class$4, _La = TypeId$8, _Ka = TypeId$i, _Ma) {
    constructor(get2, changes) {
      super();
      __publicField(this, "get");
      __publicField(this, "changes");
      // @ts-expect-error type symbol
      __publicField(this, _La, TypeId$8);
      // @ts-expect-error type symbol
      __publicField(this, _Ka, TypeId$i);
      this.get = get2;
      this.changes = changes;
    }
    // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
    commit() {
      return this.get;
    }
  }
  const make$7 = (options2) => new SubscribableImpl(options2.get, options2.changes);
  dual(2, (self2, f) => make$7({
    get: map$5(self2.get, f),
    changes: map(self2.changes, f)
  }));
  dual(2, (self2, f) => make$7({
    get: flatMap$4(self2.get, f),
    changes: mapEffect(self2.changes, f)
  }));
  make$7({
    get: never$2,
    changes: never
  });
  const defaultDateFormat = (date) => `${date.getHours().toString().padStart(2, "0")}:${date.getMinutes().toString().padStart(2, "0")}:${date.getSeconds().toString().padStart(2, "0")}.${date.getMilliseconds().toString().padStart(3, "0")}`;
  const prettyWithThread = (threadName2) => replace(defaultLogger, prettyLogger({
    formatDate: (date) => `${defaultDateFormat(date)} ${threadName2}`
  }));
  const __vite_import_meta_env__$1 = {};
  var define_process_env_default$1 = {};
  const isDevEnv = () => {
    if (typeof process !== "undefined" && define_process_env_default$1 !== void 0) {
      return false;
    }
    if (__vite_import_meta_env__$1 !== void 0) {
      return false;
    }
    if (typeof globalThis !== "undefined" && globalThis.__DEV__) {
      return true;
    }
    return false;
  };
  const objectToString = (error) => {
    const str = error == null ? void 0 : error.toString();
    if (str !== "[object Object]")
      return str;
    try {
      return JSON.stringify(error, null, 2);
    } catch (e) {
      console.log(error);
      return "Error while printing error: " + e;
    }
  };
  const envTruish = (env2) => env2 !== void 0 && env2.toLowerCase() !== "false" && env2.toLowerCase() !== "0";
  const shouldNeverHappen = (msg, ...args2) => {
    console.error(msg, ...args2);
    if (isDevEnv()) {
      debugger;
    }
    throw new Error(`This should never happen: ${msg}`);
  };
  var _globalThis = typeof globalThis === "object" ? globalThis : typeof self === "object" ? self : typeof window === "object" ? window : typeof global === "object" ? global : {};
  var VERSION = "1.9.0";
  var re = /^(\d+)\.(\d+)\.(\d+)(-(.+))?$/;
  function _makeCompatibilityCheck(ownVersion) {
    var acceptedVersions = /* @__PURE__ */ new Set([ownVersion]);
    var rejectedVersions = /* @__PURE__ */ new Set();
    var myVersionMatch = ownVersion.match(re);
    if (!myVersionMatch) {
      return function() {
        return false;
      };
    }
    var ownVersionParsed = {
      major: +myVersionMatch[1],
      minor: +myVersionMatch[2],
      patch: +myVersionMatch[3],
      prerelease: myVersionMatch[4]
    };
    if (ownVersionParsed.prerelease != null) {
      return function isExactmatch(globalVersion) {
        return globalVersion === ownVersion;
      };
    }
    function _reject(v) {
      rejectedVersions.add(v);
      return false;
    }
    function _accept(v) {
      acceptedVersions.add(v);
      return true;
    }
    return function isCompatible2(globalVersion) {
      if (acceptedVersions.has(globalVersion)) {
        return true;
      }
      if (rejectedVersions.has(globalVersion)) {
        return false;
      }
      var globalVersionMatch = globalVersion.match(re);
      if (!globalVersionMatch) {
        return _reject(globalVersion);
      }
      var globalVersionParsed = {
        major: +globalVersionMatch[1],
        minor: +globalVersionMatch[2],
        patch: +globalVersionMatch[3],
        prerelease: globalVersionMatch[4]
      };
      if (globalVersionParsed.prerelease != null) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major !== globalVersionParsed.major) {
        return _reject(globalVersion);
      }
      if (ownVersionParsed.major === 0) {
        if (ownVersionParsed.minor === globalVersionParsed.minor && ownVersionParsed.patch <= globalVersionParsed.patch) {
          return _accept(globalVersion);
        }
        return _reject(globalVersion);
      }
      if (ownVersionParsed.minor <= globalVersionParsed.minor) {
        return _accept(globalVersion);
      }
      return _reject(globalVersion);
    };
  }
  var isCompatible = _makeCompatibilityCheck(VERSION);
  var major = VERSION.split(".")[0];
  var GLOBAL_OPENTELEMETRY_API_KEY = Symbol.for("opentelemetry.js.api." + major);
  var _global = _globalThis;
  function registerGlobal(type, instance, diag, allowOverride) {
    var _a2;
    if (allowOverride === void 0) {
      allowOverride = false;
    }
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY] = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) !== null && _a2 !== void 0 ? _a2 : {
      version: VERSION
    };
    if (!allowOverride && api[type]) {
      var err = new Error("@opentelemetry/api: Attempted duplicate registration of API: " + type);
      diag.error(err.stack || err.message);
      return false;
    }
    if (api.version !== VERSION) {
      var err = new Error("@opentelemetry/api: Registration of version v" + api.version + " for " + type + " does not match previously registered API v" + VERSION);
      diag.error(err.stack || err.message);
      return false;
    }
    api[type] = instance;
    diag.debug("@opentelemetry/api: Registered a global for " + type + " v" + VERSION + ".");
    return true;
  }
  function getGlobal(type) {
    var _a2, _b2;
    var globalVersion = (_a2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _a2 === void 0 ? void 0 : _a2.version;
    if (!globalVersion || !isCompatible(globalVersion)) {
      return;
    }
    return (_b2 = _global[GLOBAL_OPENTELEMETRY_API_KEY]) === null || _b2 === void 0 ? void 0 : _b2[type];
  }
  function unregisterGlobal(type, diag) {
    diag.debug("@opentelemetry/api: Unregistering a global for " + type + " v" + VERSION + ".");
    var api = _global[GLOBAL_OPENTELEMETRY_API_KEY];
    if (api) {
      delete api[type];
    }
  }
  var __read$3 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray$3 = function(to, from, pack2) {
    if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var DiagComponentLogger = (
    /** @class */
    function() {
      function DiagComponentLogger2(props) {
        this._namespace = props.namespace || "DiagComponentLogger";
      }
      DiagComponentLogger2.prototype.debug = function() {
        var args2 = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args2[_i2] = arguments[_i2];
        }
        return logProxy("debug", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.error = function() {
        var args2 = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args2[_i2] = arguments[_i2];
        }
        return logProxy("error", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.info = function() {
        var args2 = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args2[_i2] = arguments[_i2];
        }
        return logProxy("info", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.warn = function() {
        var args2 = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args2[_i2] = arguments[_i2];
        }
        return logProxy("warn", this._namespace, args2);
      };
      DiagComponentLogger2.prototype.verbose = function() {
        var args2 = [];
        for (var _i2 = 0; _i2 < arguments.length; _i2++) {
          args2[_i2] = arguments[_i2];
        }
        return logProxy("verbose", this._namespace, args2);
      };
      return DiagComponentLogger2;
    }()
  );
  function logProxy(funcName, namespace, args2) {
    var logger = getGlobal("diag");
    if (!logger) {
      return;
    }
    args2.unshift(namespace);
    return logger[funcName].apply(logger, __spreadArray$3([], __read$3(args2), false));
  }
  var DiagLogLevel;
  (function(DiagLogLevel2) {
    DiagLogLevel2[DiagLogLevel2["NONE"] = 0] = "NONE";
    DiagLogLevel2[DiagLogLevel2["ERROR"] = 30] = "ERROR";
    DiagLogLevel2[DiagLogLevel2["WARN"] = 50] = "WARN";
    DiagLogLevel2[DiagLogLevel2["INFO"] = 60] = "INFO";
    DiagLogLevel2[DiagLogLevel2["DEBUG"] = 70] = "DEBUG";
    DiagLogLevel2[DiagLogLevel2["VERBOSE"] = 80] = "VERBOSE";
    DiagLogLevel2[DiagLogLevel2["ALL"] = 9999] = "ALL";
  })(DiagLogLevel || (DiagLogLevel = {}));
  function createLogLevelDiagLogger(maxLevel, logger) {
    if (maxLevel < DiagLogLevel.NONE) {
      maxLevel = DiagLogLevel.NONE;
    } else if (maxLevel > DiagLogLevel.ALL) {
      maxLevel = DiagLogLevel.ALL;
    }
    logger = logger || {};
    function _filterFunc(funcName, theLevel) {
      var theFunc = logger[funcName];
      if (typeof theFunc === "function" && maxLevel >= theLevel) {
        return theFunc.bind(logger);
      }
      return function() {
      };
    }
    return {
      error: _filterFunc("error", DiagLogLevel.ERROR),
      warn: _filterFunc("warn", DiagLogLevel.WARN),
      info: _filterFunc("info", DiagLogLevel.INFO),
      debug: _filterFunc("debug", DiagLogLevel.DEBUG),
      verbose: _filterFunc("verbose", DiagLogLevel.VERBOSE)
    };
  }
  var __read$2 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray$2 = function(to, from, pack2) {
    if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var API_NAME$2 = "diag";
  var DiagAPI = (
    /** @class */
    function() {
      function DiagAPI2() {
        function _logProxy(funcName) {
          return function() {
            var args2 = [];
            for (var _i2 = 0; _i2 < arguments.length; _i2++) {
              args2[_i2] = arguments[_i2];
            }
            var logger = getGlobal("diag");
            if (!logger)
              return;
            return logger[funcName].apply(logger, __spreadArray$2([], __read$2(args2), false));
          };
        }
        var self2 = this;
        var setLogger = function(logger, optionsOrLogLevel) {
          var _a2, _b2, _c2;
          if (optionsOrLogLevel === void 0) {
            optionsOrLogLevel = { logLevel: DiagLogLevel.INFO };
          }
          if (logger === self2) {
            var err = new Error("Cannot use diag as the logger for itself. Please use a DiagLogger implementation like ConsoleDiagLogger or a custom implementation");
            self2.error((_a2 = err.stack) !== null && _a2 !== void 0 ? _a2 : err.message);
            return false;
          }
          if (typeof optionsOrLogLevel === "number") {
            optionsOrLogLevel = {
              logLevel: optionsOrLogLevel
            };
          }
          var oldLogger = getGlobal("diag");
          var newLogger = createLogLevelDiagLogger((_b2 = optionsOrLogLevel.logLevel) !== null && _b2 !== void 0 ? _b2 : DiagLogLevel.INFO, logger);
          if (oldLogger && !optionsOrLogLevel.suppressOverrideMessage) {
            var stack = (_c2 = new Error().stack) !== null && _c2 !== void 0 ? _c2 : "<failed to generate stacktrace>";
            oldLogger.warn("Current logger will be overwritten from " + stack);
            newLogger.warn("Current logger will overwrite one already registered from " + stack);
          }
          return registerGlobal("diag", newLogger, self2, true);
        };
        self2.setLogger = setLogger;
        self2.disable = function() {
          unregisterGlobal(API_NAME$2, self2);
        };
        self2.createComponentLogger = function(options2) {
          return new DiagComponentLogger(options2);
        };
        self2.verbose = _logProxy("verbose");
        self2.debug = _logProxy("debug");
        self2.info = _logProxy("info");
        self2.warn = _logProxy("warn");
        self2.error = _logProxy("error");
      }
      DiagAPI2.instance = function() {
        if (!this._instance) {
          this._instance = new DiagAPI2();
        }
        return this._instance;
      };
      return DiagAPI2;
    }()
  );
  function createContextKey(description) {
    return Symbol.for(description);
  }
  var BaseContext = (
    /** @class */
    /* @__PURE__ */ function() {
      function BaseContext2(parentContext) {
        var self2 = this;
        self2._currentContext = parentContext ? new Map(parentContext) : /* @__PURE__ */ new Map();
        self2.getValue = function(key) {
          return self2._currentContext.get(key);
        };
        self2.setValue = function(key, value2) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.set(key, value2);
          return context2;
        };
        self2.deleteValue = function(key) {
          var context2 = new BaseContext2(self2._currentContext);
          context2._currentContext.delete(key);
          return context2;
        };
      }
      return BaseContext2;
    }()
  );
  var ROOT_CONTEXT = new BaseContext();
  var __read$1 = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray$1 = function(to, from, pack2) {
    if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var NoopContextManager = (
    /** @class */
    function() {
      function NoopContextManager2() {
      }
      NoopContextManager2.prototype.active = function() {
        return ROOT_CONTEXT;
      };
      NoopContextManager2.prototype.with = function(_context, fn2, thisArg) {
        var args2 = [];
        for (var _i2 = 3; _i2 < arguments.length; _i2++) {
          args2[_i2 - 3] = arguments[_i2];
        }
        return fn2.call.apply(fn2, __spreadArray$1([thisArg], __read$1(args2), false));
      };
      NoopContextManager2.prototype.bind = function(_context, target) {
        return target;
      };
      NoopContextManager2.prototype.enable = function() {
        return this;
      };
      NoopContextManager2.prototype.disable = function() {
        return this;
      };
      return NoopContextManager2;
    }()
  );
  var __read = function(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    } catch (error) {
      e = { error };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }
    return ar;
  };
  var __spreadArray = function(to, from, pack2) {
    if (pack2 || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar) ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
  };
  var API_NAME$1 = "context";
  var NOOP_CONTEXT_MANAGER = new NoopContextManager();
  var ContextAPI = (
    /** @class */
    function() {
      function ContextAPI2() {
      }
      ContextAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new ContextAPI2();
        }
        return this._instance;
      };
      ContextAPI2.prototype.setGlobalContextManager = function(contextManager) {
        return registerGlobal(API_NAME$1, contextManager, DiagAPI.instance());
      };
      ContextAPI2.prototype.active = function() {
        return this._getContextManager().active();
      };
      ContextAPI2.prototype.with = function(context2, fn2, thisArg) {
        var _a2;
        var args2 = [];
        for (var _i2 = 3; _i2 < arguments.length; _i2++) {
          args2[_i2 - 3] = arguments[_i2];
        }
        return (_a2 = this._getContextManager()).with.apply(_a2, __spreadArray([context2, fn2, thisArg], __read(args2), false));
      };
      ContextAPI2.prototype.bind = function(context2, target) {
        return this._getContextManager().bind(context2, target);
      };
      ContextAPI2.prototype._getContextManager = function() {
        return getGlobal(API_NAME$1) || NOOP_CONTEXT_MANAGER;
      };
      ContextAPI2.prototype.disable = function() {
        this._getContextManager().disable();
        unregisterGlobal(API_NAME$1, DiagAPI.instance());
      };
      return ContextAPI2;
    }()
  );
  var TraceFlags;
  (function(TraceFlags2) {
    TraceFlags2[TraceFlags2["NONE"] = 0] = "NONE";
    TraceFlags2[TraceFlags2["SAMPLED"] = 1] = "SAMPLED";
  })(TraceFlags || (TraceFlags = {}));
  var INVALID_SPANID = "0000000000000000";
  var INVALID_TRACEID = "00000000000000000000000000000000";
  var INVALID_SPAN_CONTEXT = {
    traceId: INVALID_TRACEID,
    spanId: INVALID_SPANID,
    traceFlags: TraceFlags.NONE
  };
  var NonRecordingSpan = (
    /** @class */
    function() {
      function NonRecordingSpan2(_spanContext) {
        if (_spanContext === void 0) {
          _spanContext = INVALID_SPAN_CONTEXT;
        }
        this._spanContext = _spanContext;
      }
      NonRecordingSpan2.prototype.spanContext = function() {
        return this._spanContext;
      };
      NonRecordingSpan2.prototype.setAttribute = function(_key, _value2) {
        return this;
      };
      NonRecordingSpan2.prototype.setAttributes = function(_attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addEvent = function(_name, _attributes) {
        return this;
      };
      NonRecordingSpan2.prototype.addLink = function(_link) {
        return this;
      };
      NonRecordingSpan2.prototype.addLinks = function(_links) {
        return this;
      };
      NonRecordingSpan2.prototype.setStatus = function(_status) {
        return this;
      };
      NonRecordingSpan2.prototype.updateName = function(_name) {
        return this;
      };
      NonRecordingSpan2.prototype.end = function(_endTime) {
      };
      NonRecordingSpan2.prototype.isRecording = function() {
        return false;
      };
      NonRecordingSpan2.prototype.recordException = function(_exception, _time) {
      };
      return NonRecordingSpan2;
    }()
  );
  var SPAN_KEY = createContextKey("OpenTelemetry Context Key SPAN");
  function getSpan(context2) {
    return context2.getValue(SPAN_KEY) || void 0;
  }
  function getActiveSpan() {
    return getSpan(ContextAPI.getInstance().active());
  }
  function setSpan(context2, span2) {
    return context2.setValue(SPAN_KEY, span2);
  }
  function deleteSpan(context2) {
    return context2.deleteValue(SPAN_KEY);
  }
  function setSpanContext(context2, spanContext) {
    return setSpan(context2, new NonRecordingSpan(spanContext));
  }
  function getSpanContext(context2) {
    var _a2;
    return (_a2 = getSpan(context2)) === null || _a2 === void 0 ? void 0 : _a2.spanContext();
  }
  var VALID_TRACEID_REGEX = /^([0-9a-f]{32})$/i;
  var VALID_SPANID_REGEX = /^[0-9a-f]{16}$/i;
  function isValidTraceId(traceId) {
    return VALID_TRACEID_REGEX.test(traceId) && traceId !== INVALID_TRACEID;
  }
  function isValidSpanId(spanId) {
    return VALID_SPANID_REGEX.test(spanId) && spanId !== INVALID_SPANID;
  }
  function isSpanContextValid(spanContext) {
    return isValidTraceId(spanContext.traceId) && isValidSpanId(spanContext.spanId);
  }
  function wrapSpanContext(spanContext) {
    return new NonRecordingSpan(spanContext);
  }
  var contextApi = ContextAPI.getInstance();
  var NoopTracer = (
    /** @class */
    function() {
      function NoopTracer2() {
      }
      NoopTracer2.prototype.startSpan = function(name, options2, context2) {
        if (context2 === void 0) {
          context2 = contextApi.active();
        }
        var root = Boolean(options2 === null || options2 === void 0 ? void 0 : options2.root);
        if (root) {
          return new NonRecordingSpan();
        }
        var parentFromContext = context2 && getSpanContext(context2);
        if (isSpanContext(parentFromContext) && isSpanContextValid(parentFromContext)) {
          return new NonRecordingSpan(parentFromContext);
        } else {
          return new NonRecordingSpan();
        }
      };
      NoopTracer2.prototype.startActiveSpan = function(name, arg2, arg3, arg4) {
        var opts;
        var ctx;
        var fn2;
        if (arguments.length < 2) {
          return;
        } else if (arguments.length === 2) {
          fn2 = arg2;
        } else if (arguments.length === 3) {
          opts = arg2;
          fn2 = arg3;
        } else {
          opts = arg2;
          ctx = arg3;
          fn2 = arg4;
        }
        var parentContext = ctx !== null && ctx !== void 0 ? ctx : contextApi.active();
        var span2 = this.startSpan(name, opts, parentContext);
        var contextWithSpanSet = setSpan(parentContext, span2);
        return contextApi.with(contextWithSpanSet, fn2, void 0, span2);
      };
      return NoopTracer2;
    }()
  );
  function isSpanContext(spanContext) {
    return typeof spanContext === "object" && typeof spanContext["spanId"] === "string" && typeof spanContext["traceId"] === "string" && typeof spanContext["traceFlags"] === "number";
  }
  var NOOP_TRACER = new NoopTracer();
  var ProxyTracer = (
    /** @class */
    function() {
      function ProxyTracer2(_provider, name, version, options2) {
        this._provider = _provider;
        this.name = name;
        this.version = version;
        this.options = options2;
      }
      ProxyTracer2.prototype.startSpan = function(name, options2, context2) {
        return this._getTracer().startSpan(name, options2, context2);
      };
      ProxyTracer2.prototype.startActiveSpan = function(_name, _options, _context, _fn) {
        var tracer2 = this._getTracer();
        return Reflect.apply(tracer2.startActiveSpan, tracer2, arguments);
      };
      ProxyTracer2.prototype._getTracer = function() {
        if (this._delegate) {
          return this._delegate;
        }
        var tracer2 = this._provider.getDelegateTracer(this.name, this.version, this.options);
        if (!tracer2) {
          return NOOP_TRACER;
        }
        this._delegate = tracer2;
        return this._delegate;
      };
      return ProxyTracer2;
    }()
  );
  var NoopTracerProvider = (
    /** @class */
    function() {
      function NoopTracerProvider2() {
      }
      NoopTracerProvider2.prototype.getTracer = function(_name, _version2, _options) {
        return new NoopTracer();
      };
      return NoopTracerProvider2;
    }()
  );
  var NOOP_TRACER_PROVIDER = new NoopTracerProvider();
  var ProxyTracerProvider = (
    /** @class */
    function() {
      function ProxyTracerProvider2() {
      }
      ProxyTracerProvider2.prototype.getTracer = function(name, version, options2) {
        var _a2;
        return (_a2 = this.getDelegateTracer(name, version, options2)) !== null && _a2 !== void 0 ? _a2 : new ProxyTracer(this, name, version, options2);
      };
      ProxyTracerProvider2.prototype.getDelegate = function() {
        var _a2;
        return (_a2 = this._delegate) !== null && _a2 !== void 0 ? _a2 : NOOP_TRACER_PROVIDER;
      };
      ProxyTracerProvider2.prototype.setDelegate = function(delegate) {
        this._delegate = delegate;
      };
      ProxyTracerProvider2.prototype.getDelegateTracer = function(name, version, options2) {
        var _a2;
        return (_a2 = this._delegate) === null || _a2 === void 0 ? void 0 : _a2.getTracer(name, version, options2);
      };
      return ProxyTracerProvider2;
    }()
  );
  var SpanKind;
  (function(SpanKind2) {
    SpanKind2[SpanKind2["INTERNAL"] = 0] = "INTERNAL";
    SpanKind2[SpanKind2["SERVER"] = 1] = "SERVER";
    SpanKind2[SpanKind2["CLIENT"] = 2] = "CLIENT";
    SpanKind2[SpanKind2["PRODUCER"] = 3] = "PRODUCER";
    SpanKind2[SpanKind2["CONSUMER"] = 4] = "CONSUMER";
  })(SpanKind || (SpanKind = {}));
  var SpanStatusCode;
  (function(SpanStatusCode2) {
    SpanStatusCode2[SpanStatusCode2["UNSET"] = 0] = "UNSET";
    SpanStatusCode2[SpanStatusCode2["OK"] = 1] = "OK";
    SpanStatusCode2[SpanStatusCode2["ERROR"] = 2] = "ERROR";
  })(SpanStatusCode || (SpanStatusCode = {}));
  var context = ContextAPI.getInstance();
  var API_NAME = "trace";
  var TraceAPI = (
    /** @class */
    function() {
      function TraceAPI2() {
        this._proxyTracerProvider = new ProxyTracerProvider();
        this.wrapSpanContext = wrapSpanContext;
        this.isSpanContextValid = isSpanContextValid;
        this.deleteSpan = deleteSpan;
        this.getSpan = getSpan;
        this.getActiveSpan = getActiveSpan;
        this.getSpanContext = getSpanContext;
        this.setSpan = setSpan;
        this.setSpanContext = setSpanContext;
      }
      TraceAPI2.getInstance = function() {
        if (!this._instance) {
          this._instance = new TraceAPI2();
        }
        return this._instance;
      };
      TraceAPI2.prototype.setGlobalTracerProvider = function(provider) {
        var success = registerGlobal(API_NAME, this._proxyTracerProvider, DiagAPI.instance());
        if (success) {
          this._proxyTracerProvider.setDelegate(provider);
        }
        return success;
      };
      TraceAPI2.prototype.getTracerProvider = function() {
        return getGlobal(API_NAME) || this._proxyTracerProvider;
      };
      TraceAPI2.prototype.getTracer = function(name, version) {
        return this.getTracerProvider().getTracer(name, version);
      };
      TraceAPI2.prototype.disable = function() {
        unregisterGlobal(API_NAME, DiagAPI.instance());
        this._proxyTracerProvider = new ProxyTracerProvider();
      };
      return TraceAPI2;
    }()
  );
  var trace = TraceAPI.getInstance();
  const bigint1e9 = 1000000000n;
  const nanosToHrTime = (timestamp) => {
    return [Number(timestamp / bigint1e9), Number(timestamp % bigint1e9)];
  };
  const recordToAttributes = (value2) => Object.entries(value2).reduce((acc, [key, value3]) => {
    acc[key] = unknownToAttributeValue(value3);
    return acc;
  }, {});
  const unknownToAttributeValue = (value2) => {
    if (typeof value2 === "string" || typeof value2 === "number" || typeof value2 === "boolean") {
      return value2;
    } else if (typeof value2 === "bigint") {
      return Number(value2);
    }
    return toStringUnknown(value2);
  };
  const OtelSpanTypeId = /* @__PURE__ */ Symbol.for("@effect/opentelemetry/Tracer/OtelSpan");
  const kindMap = {
    "internal": SpanKind.INTERNAL,
    "client": SpanKind.CLIENT,
    "server": SpanKind.SERVER,
    "producer": SpanKind.PRODUCER,
    "consumer": SpanKind.CONSUMER
  };
  _Na = OtelSpanTypeId;
  class OtelSpan {
    constructor(contextApi2, tracer2, name, parent, context2, links, startTime, kind) {
      __publicField(this, "name");
      __publicField(this, "parent");
      __publicField(this, "context");
      __publicField(this, "links");
      __publicField(this, "kind");
      __publicField(this, _Na);
      __publicField(this, "_tag", "Span");
      __publicField(this, "span");
      __publicField(this, "spanId");
      __publicField(this, "traceId");
      __publicField(this, "attributes", /* @__PURE__ */ new Map());
      __publicField(this, "sampled");
      __publicField(this, "status");
      this.name = name;
      this.parent = parent;
      this.context = context2;
      this.links = links;
      this.kind = kind;
      this[OtelSpanTypeId] = OtelSpanTypeId;
      const active2 = contextApi2.active();
      this.span = tracer2.startSpan(name, {
        startTime: nanosToHrTime(startTime),
        links: links.length > 0 ? links.map((link) => ({
          context: makeSpanContext(link.span),
          attributes: recordToAttributes(link.attributes)
        })) : void 0,
        kind: kindMap[this.kind]
      }, parent._tag === "Some" ? populateContext(active2, parent.value, context2) : trace.deleteSpan(active2));
      const spanContext = this.span.spanContext();
      this.spanId = spanContext.spanId;
      this.traceId = spanContext.traceId;
      this.status = {
        _tag: "Started",
        startTime
      };
      this.sampled = (spanContext.traceFlags & TraceFlags.SAMPLED) === TraceFlags.SAMPLED;
    }
    attribute(key, value2) {
      this.span.setAttribute(key, unknownToAttributeValue(value2));
      this.attributes.set(key, value2);
    }
    addLinks(links) {
      this.links.push(...links);
      this.span.addLinks(links.map((link) => ({
        context: makeSpanContext(link.span),
        attributes: recordToAttributes(link.attributes)
      })));
    }
    end(endTime, exit2) {
      const hrTime = nanosToHrTime(endTime);
      this.status = {
        _tag: "Ended",
        endTime,
        exit: exit2,
        startTime: this.status.startTime
      };
      if (exit2._tag === "Success") {
        this.span.setStatus({
          code: SpanStatusCode.OK
        });
      } else {
        if (isInterruptedOnly(exit2.cause)) {
          this.span.setStatus({
            code: SpanStatusCode.OK,
            message: pretty(exit2.cause)
          });
          this.span.setAttribute("span.label", "⚠︎ Interrupted");
          this.span.setAttribute("status.interrupted", true);
        } else {
          const firstError = prettyErrors(exit2.cause)[0];
          if (firstError) {
            firstError.stack = pretty(exit2.cause, {
              renderErrorCause: true
            });
            this.span.recordException(firstError, hrTime);
            this.span.setStatus({
              code: SpanStatusCode.ERROR,
              message: firstError.message
            });
          } else {
            this.span.setStatus({
              code: SpanStatusCode.OK
            });
          }
        }
      }
      this.span.end(hrTime);
    }
    event(name, startTime, attributes) {
      this.span.addEvent(name, attributes ? recordToAttributes(attributes) : void 0, nanosToHrTime(startTime));
    }
  }
  const Tracer = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTracer");
  const make$6 = /* @__PURE__ */ map$5(Tracer, (tracer2) => make$F({
    span(name, parent, context$12, links, startTime, kind) {
      return new OtelSpan(context, tracer2, name, parent, context$12, links.slice(), startTime, kind);
    },
    context(execution, fiber) {
      const currentSpan2 = fiber.currentSpan;
      if (currentSpan2 === void 0) {
        return execution();
      }
      return context.with(populateContext(context.active(), currentSpan2), execution);
    }
  }));
  const traceFlagsTag = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTraceFlags");
  const traceStateTag = /* @__PURE__ */ GenericTag("@effect/opentelemetry/Tracer/OtelTraceState");
  const currentOtelSpan$1 = /* @__PURE__ */ flatMap$4(currentSpan, (span2) => {
    if (OtelSpanTypeId in span2) {
      return succeed$5(span2.span);
    }
    return fail$6(new NoSuchElementException());
  });
  const populateContext = (otelContext, span2, context2) => span2 instanceof OtelSpan ? trace.setSpan(otelContext, span2.span) : trace.setSpanContext(otelContext, makeSpanContext(span2, context2));
  const makeSpanContext = (span2, context2) => ({
    spanId: span2.spanId,
    traceId: span2.traceId,
    isRemote: span2._tag === "ExternalSpan",
    traceFlags: getOrElse(context2 ? extractTraceTag(span2, context2, traceFlagsTag) : getOption(span2.context, traceFlagsTag), () => TraceFlags.SAMPLED),
    traceState: getOrUndefined(context2 ? extractTraceTag(span2, context2, traceStateTag) : getOption(span2.context, traceStateTag))
  });
  const extractTraceTag = (parent, context2, tag2) => orElse$1(getOption(context2, tag2), () => getOption(parent.context, tag2));
  const make$5 = make$6;
  const currentOtelSpan = currentOtelSpan$1;
  const OtelTracer = Tracer;
  const indent = (str, n, char = " ") => str.split("\n").map((line) => char.repeat(n) + line).join("\n");
  const isNotUndefined = (_) => _ !== void 0;
  const isNil = (val) => val === null || val === void 0;
  const __vite_import_meta_env__ = { "BASE_URL": "/", "DEV": false, "MODE": "production", "PROD": true, "SSR": false };
  var define_process_env_default = {};
  const env = (name) => {
    if (typeof process !== "undefined" && define_process_env_default !== void 0) {
      return define_process_env_default[name];
    }
    if (__vite_import_meta_env__ !== void 0) {
      return __vite_import_meta_env__[name];
    }
    return void 0;
  };
  const TRACE_VERBOSE = env("LS_TRACE_VERBOSE") !== void 0 || env("VITE_LS_TRACE_VERBOSE") !== void 0;
  const LS_DEV = envTruish(env("LS_DEV")) || envTruish(env("VITE_LS_DEV"));
  envTruish(env("CI"));
  const BYTE_UNITS = [
    "B",
    "kB",
    "MB",
    "GB",
    "TB",
    "PB",
    "EB",
    "ZB",
    "YB"
  ];
  const BIBYTE_UNITS = [
    "B",
    "KiB",
    "MiB",
    "GiB",
    "TiB",
    "PiB",
    "EiB",
    "ZiB",
    "YiB"
  ];
  const BIT_UNITS = [
    "b",
    "kbit",
    "Mbit",
    "Gbit",
    "Tbit",
    "Pbit",
    "Ebit",
    "Zbit",
    "Ybit"
  ];
  const BIBIT_UNITS = [
    "b",
    "kibit",
    "Mibit",
    "Gibit",
    "Tibit",
    "Pibit",
    "Eibit",
    "Zibit",
    "Yibit"
  ];
  const toLocaleString = (number2, locale, options2) => {
    let result = number2;
    if (typeof locale === "string" || Array.isArray(locale)) {
      result = number2.toLocaleString(locale, options2);
    } else if (locale === true || options2 !== void 0) {
      result = number2.toLocaleString(void 0, options2);
    }
    return result;
  };
  function prettyBytes(number2, options2) {
    if (!Number.isFinite(number2)) {
      throw new TypeError(`Expected a finite number, got ${typeof number2}: ${number2}`);
    }
    options2 = {
      bits: false,
      binary: false,
      space: true,
      ...options2
    };
    const UNITS = options2.bits ? options2.binary ? BIBIT_UNITS : BIT_UNITS : options2.binary ? BIBYTE_UNITS : BYTE_UNITS;
    const separator = options2.space ? " " : "";
    if (options2.signed && number2 === 0) {
      return ` 0${separator}${UNITS[0]}`;
    }
    const isNegative = number2 < 0;
    const prefix = isNegative ? "-" : options2.signed ? "+" : "";
    if (isNegative) {
      number2 = -number2;
    }
    let localeOptions;
    if (options2.minimumFractionDigits !== void 0) {
      localeOptions = { minimumFractionDigits: options2.minimumFractionDigits };
    }
    if (options2.maximumFractionDigits !== void 0) {
      localeOptions = { maximumFractionDigits: options2.maximumFractionDigits, ...localeOptions };
    }
    if (number2 < 1) {
      const numberString2 = toLocaleString(number2, options2.locale, localeOptions);
      return prefix + numberString2 + separator + UNITS[0];
    }
    const exponent = Math.min(Math.floor(options2.binary ? Math.log(number2) / Math.log(1024) : Math.log10(number2) / 3), UNITS.length - 1);
    number2 /= (options2.binary ? 1024 : 1e3) ** exponent;
    if (!localeOptions) {
      number2 = number2.toPrecision(3);
    }
    const numberString = toLocaleString(Number(number2), options2.locale, localeOptions);
    const unit = UNITS[exponent];
    return prefix + numberString + separator + unit;
  }
  const isReadonlyArray = (value2) => Array.isArray(value2);
  function casesHandled(unexpectedCase) {
    debugger;
    throw new Error(`A case was not handled for value: ${truncate(objectToString(unexpectedCase), 1e3)}`);
  }
  const truncate = (str, length2) => {
    if (str.length > length2) {
      return str.slice(0, length2) + "...";
    } else {
      return str;
    }
  };
  const memoizeByStringifyArgs = (fn2) => {
    const cache = /* @__PURE__ */ new Map();
    return (...args2) => {
      const key = JSON.stringify(args2);
      if (cache.has(key)) {
        return cache.get(key);
      }
      const result = fn2(...args2);
      cache.set(key, result);
      return result;
    };
  };
  const memoizeByRef = (fn2) => {
    const cache = /* @__PURE__ */ new Map();
    return (arg) => {
      if (cache.has(arg)) {
        return cache.get(arg);
      }
      const result = fn2(arg);
      cache.set(arg, result);
      return result;
    };
  };
  const isPromise = (value2) => typeof (value2 == null ? void 0 : value2.then) === "function";
  const scopeWithCloseable = (fn2) => gen$2(function* () {
    const scope2 = yield* make$u();
    yield* addFinalizer((exit2) => close(scope2, exit2));
    return yield* fn2(scope2).pipe(extend$1(scope2));
  });
  const tryAll = (fn2) => try_(() => fn2()).pipe(andThen((fnRes) => isEffect(fnRes) ? fnRes : isPromise(fnRes) ? promise(() => fnRes) : succeed$5(fnRes)));
  const tapCauseLogPretty = (eff) => tapErrorCause(eff, (cause) => gen$2(function* () {
    if (isInterruptedOnly(cause)) {
      return;
    }
    const span2 = yield* currentOtelSpan.pipe(catchTag("NoSuchElementException", (_) => succeed$5(void 0)));
    const firstErrLine = cause.toString().split("\n")[0];
    yield* logError(firstErrLine, cause).pipe((_) => span2 === void 0 ? _ : annotateLogs({ spanId: span2.spanContext().spanId, traceId: span2.spanContext().traceId })(_));
  }));
  const spanEvent = (message, attributes) => locallyWith(log(message).pipe(annotateLogs(attributes ?? {})), currentLoggers, () => make$U(tracerLogger));
  const withPerformanceMeasure = (meaureLabel) => (eff) => acquireUseRelease$1(sync$3(() => performance.mark(`${meaureLabel}:start`)), () => eff, () => sync$3(() => {
    performance.mark(`${meaureLabel}:end`);
    performance.measure(meaureLabel, `${meaureLabel}:start`, `${meaureLabel}:end`);
  }));
  const getSpanTrace = () => {
    const fiberOption = getCurrentFiber();
    if (fiberOption._tag === "None" || fiberOption.value.currentSpan === void 0) {
      return "No current fiber";
    }
    return "";
  };
  const logSpanTrace = () => console.log(getSpanTrace());
  globalThis.getSpanTrace = getSpanTrace;
  globalThis.logSpanTrace = logSpanTrace;
  const TypeIdError = (typeId, tag2) => {
    class Base2 extends Error$1 {
      constructor() {
        super(...arguments);
        __publicField(this, "_tag", tag2);
      }
    }
    Base2.prototype[typeId] = typeId;
    Base2.prototype.name = tag2;
    return Base2;
  };
  const TypeId$7 = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies");
  const CookieTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Cookies/Cookie");
  const Proto$2 = {
    [TypeId$7]: TypeId$7,
    ...BaseProto,
    toJSON() {
      return {
        _id: "@effect/platform/Cookies",
        cookies: map$f(this.cookies, (cookie) => cookie.toJSON())
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  const fromReadonlyRecord = (cookies) => {
    const self2 = Object.create(Proto$2);
    self2.cookies = cookies;
    return self2;
  };
  const fromIterable = (cookies) => {
    const record2 = {};
    for (const cookie of cookies) {
      record2[cookie.name] = cookie;
    }
    return fromReadonlyRecord(record2);
  };
  const fromSetCookie = (headers) => {
    const arrayHeaders = typeof headers === "string" ? [headers] : headers;
    const cookies = [];
    for (const header of arrayHeaders) {
      const cookie = parseSetCookie(header.trim());
      if (isSome(cookie)) {
        cookies.push(cookie.value);
      }
    }
    return fromIterable(cookies);
  };
  function parseSetCookie(header) {
    const parts2 = header.split(";").map((_) => _.trim()).filter((_) => _ !== "");
    if (parts2.length === 0) {
      return none$4();
    }
    const firstEqual = parts2[0].indexOf("=");
    if (firstEqual === -1) {
      return none$4();
    }
    const name = parts2[0].slice(0, firstEqual);
    if (!fieldContentRegExp.test(name)) {
      return none$4();
    }
    const valueEncoded = parts2[0].slice(firstEqual + 1);
    const value2 = tryDecodeURIComponent(valueEncoded);
    if (parts2.length === 1) {
      return some(Object.assign(Object.create(CookieProto), {
        name,
        value: value2,
        valueEncoded
      }));
    }
    const options2 = {};
    for (let i = 1; i < parts2.length; i++) {
      const part = parts2[i];
      const equalIndex = part.indexOf("=");
      const key = equalIndex === -1 ? part : part.slice(0, equalIndex).trim();
      const value3 = equalIndex === -1 ? void 0 : part.slice(equalIndex + 1).trim();
      switch (key.toLowerCase()) {
        case "domain": {
          if (value3 === void 0) {
            break;
          }
          const domain = value3.trim().replace(/^\./, "");
          if (domain) {
            options2.domain = domain;
          }
          break;
        }
        case "expires": {
          if (value3 === void 0) {
            break;
          }
          const date = new Date(value3);
          if (!isNaN(date.getTime())) {
            options2.expires = date;
          }
          break;
        }
        case "max-age": {
          if (value3 === void 0) {
            break;
          }
          const maxAge = parseInt(value3, 10);
          if (!isNaN(maxAge)) {
            options2.maxAge = seconds(maxAge);
          }
          break;
        }
        case "path": {
          if (value3 === void 0) {
            break;
          }
          if (value3[0] === "/") {
            options2.path = value3;
          }
          break;
        }
        case "priority": {
          if (value3 === void 0) {
            break;
          }
          switch (value3.toLowerCase()) {
            case "low":
              options2.priority = "low";
              break;
            case "medium":
              options2.priority = "medium";
              break;
            case "high":
              options2.priority = "high";
              break;
          }
          break;
        }
        case "httponly": {
          options2.httpOnly = true;
          break;
        }
        case "secure": {
          options2.secure = true;
          break;
        }
        case "partitioned": {
          options2.partitioned = true;
          break;
        }
        case "samesite": {
          if (value3 === void 0) {
            break;
          }
          switch (value3.toLowerCase()) {
            case "lax":
              options2.sameSite = "lax";
              break;
            case "strict":
              options2.sameSite = "strict";
              break;
            case "none":
              options2.sameSite = "none";
              break;
          }
          break;
        }
      }
    }
    return some(Object.assign(Object.create(CookieProto), {
      name,
      value: value2,
      valueEncoded,
      options: Object.keys(options2).length > 0 ? options2 : void 0
    }));
  }
  const fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
  const CookieProto = {
    [CookieTypeId]: CookieTypeId,
    ...BaseProto,
    toJSON() {
      return {
        _id: "@effect/platform/Cookies/Cookie",
        name: this.name,
        value: this.value,
        options: this.options
      };
    }
  };
  const tryDecodeURIComponent = (str) => {
    try {
      return decodeURIComponent(str);
    } catch {
      return str;
    }
  };
  const HeadersTypeId = /* @__PURE__ */ Symbol.for("@effect/platform/Headers");
  const Proto$1 = /* @__PURE__ */ Object.assign(/* @__PURE__ */ Object.create(null), {
    [HeadersTypeId]: HeadersTypeId,
    [symbolRedactable](fiberRefs2) {
      return redact(this, getOrDefault(fiberRefs2, currentRedactedNames));
    }
  });
  const make$4 = (input) => Object.assign(Object.create(Proto$1), input);
  const empty$3 = /* @__PURE__ */ Object.create(Proto$1);
  const fromInput$1 = (input) => {
    if (input === void 0) {
      return empty$3;
    } else if (Symbol.iterator in input) {
      const out2 = Object.create(Proto$1);
      for (const [k, v] of input) {
        out2[k.toLowerCase()] = v;
      }
      return out2;
    }
    const out = Object.create(Proto$1);
    for (const [k, v] of Object.entries(input)) {
      if (Array.isArray(v)) {
        out[k.toLowerCase()] = v.join(", ");
      } else if (v !== void 0) {
        out[k.toLowerCase()] = v;
      }
    }
    return out;
  };
  const unsafeFromRecord = (input) => Object.setPrototypeOf(input, Proto$1);
  const set = /* @__PURE__ */ dual(3, (self2, key, value2) => {
    const out = make$4(self2);
    out[key.toLowerCase()] = value2;
    return out;
  });
  const setAll$1 = /* @__PURE__ */ dual(2, (self2, headers) => make$4({
    ...self2,
    ...fromInput$1(headers)
  }));
  const merge$1 = /* @__PURE__ */ dual(2, (self2, headers) => {
    const out = make$4(self2);
    Object.assign(out, headers);
    return out;
  });
  const remove = /* @__PURE__ */ dual(2, (self2, key) => {
    const out = make$4(self2);
    const modify2 = (key2) => {
      if (typeof key2 === "string") {
        const k = key2.toLowerCase();
        if (k in self2) {
          delete out[k];
        }
      } else {
        for (const name in self2) {
          if (key2.test(name)) {
            delete out[name];
          }
        }
      }
    };
    if (Array.isArray(key)) {
      for (let i = 0; i < key.length; i++) {
        modify2(key[i]);
      }
    } else {
      modify2(key);
    }
    return out;
  });
  const redact = /* @__PURE__ */ dual(2, (self2, key) => {
    const out = {
      ...self2
    };
    const modify2 = (key2) => {
      if (typeof key2 === "string") {
        const k = key2.toLowerCase();
        if (k in self2) {
          out[k] = make$e(self2[k]);
        }
      } else {
        for (const name in self2) {
          if (key2.test(name)) {
            out[name] = make$e(self2[name]);
          }
        }
      }
    };
    if (Array.isArray(key)) {
      for (let i = 0; i < key.length; i++) {
        modify2(key[i]);
      }
    } else {
      modify2(key);
    }
    return out;
  });
  const currentRedactedNames = /* @__PURE__ */ globalValue("@effect/platform/Headers/currentRedactedNames", () => unsafeMake$4(["authorization", "cookie", "set-cookie", "x-api-key"]));
  const TypeId$6 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientError");
  const TypeId$5 = TypeId$6;
  class RequestError extends (/* @__PURE__ */ TypeIdError(TypeId$5, "RequestError")) {
    get methodAndUrl() {
      return `${this.request.method} ${this.request.url}`;
    }
    get message() {
      return this.description ? `${this.reason}: ${this.description} (${this.methodAndUrl})` : `${this.reason} error (${this.methodAndUrl})`;
    }
  }
  class ResponseError extends (/* @__PURE__ */ TypeIdError(TypeId$5, "ResponseError")) {
    get methodAndUrl() {
      return `${this.request.method} ${this.request.url}`;
    }
    get message() {
      const info = `${this.response.status} ${this.methodAndUrl}`;
      return this.description ? `${this.reason}: ${this.description} (${info})` : `${this.reason} error (${info})`;
    }
  }
  const fromInput = (input) => {
    const parsed = fromInputNested(input);
    const out = [];
    for (let i = 0; i < parsed.length; i++) {
      if (Array.isArray(parsed[i][0])) {
        const [keys2, value2] = parsed[i];
        out.push([`${keys2[0]}[${keys2.slice(1).join("][")}]`, value2]);
      } else {
        out.push(parsed[i]);
      }
    }
    return out;
  };
  const fromInputNested = (input) => {
    const entries = Symbol.iterator in input ? fromIterable$8(input) : Object.entries(input);
    const out = [];
    for (const [key, value2] of entries) {
      if (Array.isArray(value2)) {
        for (let i = 0; i < value2.length; i++) {
          if (value2[i] !== void 0) {
            out.push([key, String(value2[i])]);
          }
        }
      } else if (typeof value2 === "object") {
        const nested = fromInputNested(value2);
        for (const [k, v] of nested) {
          out.push([[key, ...typeof k === "string" ? [k] : k], v]);
        }
      } else if (value2 !== void 0) {
        out.push([key, String(value2)]);
      }
    }
    return out;
  };
  const empty$2 = [];
  const setAll = /* @__PURE__ */ dual(2, (self2, input) => {
    const toSet2 = fromInput(input);
    const keys2 = toSet2.map(([k]) => k);
    return appendAll$2(filter$4(self2, ([k]) => keys2.includes(k)), toSet2);
  });
  const makeUrl = (url, params, hash2) => {
    try {
      const urlInstance = new URL(url, baseUrl());
      for (let i = 0; i < params.length; i++) {
        const [key, value2] = params[i];
        if (value2 !== void 0) {
          urlInstance.searchParams.append(key, value2);
        }
      }
      if (hash2._tag === "Some") {
        urlInstance.hash = hash2.value;
      }
      return right(urlInstance);
    } catch (e) {
      return left(e);
    }
  };
  const baseUrl = () => {
    if ("location" in globalThis && globalThis.location !== void 0 && globalThis.location.origin !== void 0 && globalThis.location.pathname !== void 0) {
      return location.origin + location.pathname;
    }
    return void 0;
  };
  const TypeId$4 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpIncomingMessage");
  const inspect = (self2, that) => {
    const contentType = self2.headers["content-type"] ?? "";
    let body;
    if (contentType.includes("application/json")) {
      try {
        body = runSync(self2.json);
      } catch {
      }
    } else if (contentType.includes("text/") || contentType.includes("urlencoded")) {
      try {
        body = runSync(self2.text);
      } catch {
      }
    }
    const obj = {
      ...that,
      headers: redact$1(self2.headers),
      remoteAddress: self2.remoteAddress.toJSON()
    };
    if (body !== void 0) {
      obj.body = body;
    }
    return obj;
  };
  const toHeaders = (span2) => unsafeFromRecord({
    b3: `${span2.traceId}-${span2.spanId}-${span2.sampled ? "1" : "0"}${span2.parent._tag === "Some" ? `-${span2.parent.value.spanId}` : ""}`,
    traceparent: `00-${span2.traceId}-${span2.spanId}-${span2.sampled ? "01" : "00"}`
  });
  const TypeId$3 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpBody");
  class BodyBase {
    constructor() {
      __publicField(this, _Oa);
      this[TypeId$3] = TypeId$3;
    }
    [(_Oa = TypeId$3, NodeInspectSymbol)]() {
      return this.toJSON();
    }
    toString() {
      return format$3(this);
    }
  }
  class EmptyImpl extends BodyBase {
    constructor() {
      super(...arguments);
      __publicField(this, "_tag", "Empty");
    }
    toJSON() {
      return {
        _id: "@effect/platform/HttpBody",
        _tag: "Empty"
      };
    }
  }
  const empty$1 = /* @__PURE__ */ new EmptyImpl();
  const TypeId$2 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientRequest");
  const Proto = {
    [TypeId$2]: TypeId$2,
    ...BaseProto,
    toJSON() {
      return {
        _id: "@effect/platform/HttpClientRequest",
        method: this.method,
        url: this.url,
        urlParams: this.urlParams,
        hash: this.hash,
        headers: redact$1(this.headers),
        body: this.body.toJSON()
      };
    },
    pipe() {
      return pipeArguments(this, arguments);
    }
  };
  function makeInternal(method, url, urlParams, hash2, headers, body) {
    const self2 = Object.create(Proto);
    self2.method = method;
    self2.url = url;
    self2.urlParams = urlParams;
    self2.hash = hash2;
    self2.headers = headers;
    self2.body = body;
    return self2;
  }
  const empty = /* @__PURE__ */ makeInternal("GET", "", empty$2, /* @__PURE__ */ none$4(), empty$3, empty$1);
  const make$3 = (method) => (url, options2) => modify(empty, {
    method,
    url,
    ...options2 ?? void 0
  });
  const get$1 = /* @__PURE__ */ make$3("GET");
  const post$1 = /* @__PURE__ */ make$3("POST");
  const put$1 = /* @__PURE__ */ make$3("PUT");
  const patch$1 = /* @__PURE__ */ make$3("PATCH");
  const del$1 = /* @__PURE__ */ make$3("DELETE");
  const head$1 = /* @__PURE__ */ make$3("HEAD");
  const options$1 = /* @__PURE__ */ make$3("OPTIONS");
  const modify = /* @__PURE__ */ dual(2, (self2, options2) => {
    let result = self2;
    if (options2.method) {
      result = setMethod(result, options2.method);
    }
    if (options2.url) {
      result = setUrl(result, options2.url);
    }
    if (options2.headers) {
      result = setHeaders(result, options2.headers);
    }
    if (options2.urlParams) {
      result = setUrlParams(result, options2.urlParams);
    }
    if (options2.hash) {
      result = setHash(result, options2.hash);
    }
    if (options2.body) {
      result = setBody(result, options2.body);
    }
    if (options2.accept) {
      result = accept(result, options2.accept);
    }
    if (options2.acceptJson) {
      result = acceptJson(result);
    }
    return result;
  });
  const setHeader = /* @__PURE__ */ dual(3, (self2, key, value2) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, set(self2.headers, key, value2), self2.body));
  const setHeaders = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, setAll$1(self2.headers, input), self2.body));
  const accept = /* @__PURE__ */ dual(2, (self2, mediaType) => setHeader(self2, "Accept", mediaType));
  const acceptJson = /* @__PURE__ */ accept("application/json");
  const setMethod = /* @__PURE__ */ dual(2, (self2, method) => makeInternal(method, self2.url, self2.urlParams, self2.hash, self2.headers, self2.body));
  const setUrl = /* @__PURE__ */ dual(2, (self2, url) => {
    if (typeof url === "string") {
      return makeInternal(self2.method, url, self2.urlParams, self2.hash, self2.headers, self2.body);
    }
    const clone = new URL(url.toString());
    const urlParams = fromInput(clone.searchParams);
    const hash2 = clone.hash ? some(clone.hash.slice(1)) : none$4();
    clone.search = "";
    clone.hash = "";
    return makeInternal(self2.method, clone.toString(), urlParams, hash2, self2.headers, self2.body);
  });
  const setUrlParams = /* @__PURE__ */ dual(2, (self2, input) => makeInternal(self2.method, self2.url, setAll(self2.urlParams, input), self2.hash, self2.headers, self2.body));
  const setHash = /* @__PURE__ */ dual(2, (self2, hash2) => makeInternal(self2.method, self2.url, self2.urlParams, some(hash2), self2.headers, self2.body));
  const setBody = /* @__PURE__ */ dual(2, (self2, body) => {
    let headers = self2.headers;
    if (body._tag === "Empty" || body._tag === "FormData") {
      headers = remove(headers, ["Content-type", "Content-length"]);
    } else {
      const contentType = body.contentType;
      if (contentType) {
        headers = set(headers, "content-type", contentType);
      }
      const contentLength = body.contentLength;
      if (contentLength) {
        headers = set(headers, "content-length", contentLength.toString());
      }
    }
    return makeInternal(self2.method, self2.url, self2.urlParams, self2.hash, headers, body);
  });
  const TypeId$1 = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClientResponse");
  const fromWeb = (request, source) => new ClientResponseImpl(request, source);
  class ClientResponseImpl extends (_Ra = Class$5, _Qa = TypeId$4, _Pa = TypeId$1, _Ra) {
    constructor(request, source) {
      super();
      __publicField(this, "request");
      __publicField(this, "source");
      __publicField(this, _Qa);
      __publicField(this, _Pa);
      __publicField(this, "cachedCookies");
      __publicField(this, "textBody");
      __publicField(this, "formDataBody");
      __publicField(this, "arrayBufferBody");
      this.request = request;
      this.source = source;
      this[TypeId$4] = TypeId$4;
      this[TypeId$1] = TypeId$1;
    }
    toJSON() {
      return inspect(this, {
        _id: "@effect/platform/HttpClientResponse",
        request: this.request.toJSON(),
        status: this.status
      });
    }
    get status() {
      return this.source.status;
    }
    get headers() {
      return fromInput$1(this.source.headers);
    }
    get cookies() {
      if (this.cachedCookies) {
        return this.cachedCookies;
      }
      return this.cachedCookies = fromSetCookie(this.source.headers.getSetCookie());
    }
    get remoteAddress() {
      return none$4();
    }
    get stream() {
      return this.source.body ? fromReadableStream(() => this.source.body, (cause) => new ResponseError({
        request: this.request,
        response: this,
        reason: "Decode",
        cause
      })) : fail(new ResponseError({
        request: this.request,
        response: this,
        reason: "EmptyBody",
        description: "can not create stream from empty body"
      }));
    }
    get json() {
      return tryMap(this.text, {
        try: (text2) => text2 === "" ? null : JSON.parse(text2),
        catch: (cause) => new ResponseError({
          request: this.request,
          response: this,
          reason: "Decode",
          cause
        })
      });
    }
    get text() {
      return this.textBody ?? (this.textBody = tryPromise({
        try: () => this.source.text(),
        catch: (cause) => new ResponseError({
          request: this.request,
          response: this,
          reason: "Decode",
          cause
        })
      }).pipe(cached, runSync));
    }
    get urlParamsBody() {
      return flatMap$4(this.text, (_) => try_({
        try: () => fromInput(new URLSearchParams(_)),
        catch: (cause) => new ResponseError({
          request: this.request,
          response: this,
          reason: "Decode",
          cause
        })
      }));
    }
    get formData() {
      return this.formDataBody ?? (this.formDataBody = tryPromise({
        try: () => this.source.formData(),
        catch: (cause) => new ResponseError({
          request: this.request,
          response: this,
          reason: "Decode",
          cause
        })
      }).pipe(cached, runSync));
    }
    get arrayBuffer() {
      return this.arrayBufferBody ?? (this.arrayBufferBody = tryPromise({
        try: () => this.source.arrayBuffer(),
        catch: (cause) => new ResponseError({
          request: this.request,
          response: this,
          reason: "Decode",
          cause
        })
      }).pipe(cached, runSync));
    }
  }
  const TypeId = /* @__PURE__ */ Symbol.for("@effect/platform/HttpClient");
  const tag = /* @__PURE__ */ GenericTag("@effect/platform/HttpClient");
  const currentTracerDisabledWhen = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpClient/tracerDisabledWhen"), () => unsafeMake$4(constFalse));
  const currentTracerPropagation = /* @__PURE__ */ globalValue(/* @__PURE__ */ Symbol.for("@effect/platform/HttpClient/currentTracerPropagation"), () => unsafeMake$4(true));
  const SpanNameGenerator = /* @__PURE__ */ Reference()("@effect/platform/HttpClient/SpanNameGenerator", {
    defaultValue: () => (request) => `http.client ${request.method}`
  });
  const ClientProto = {
    [TypeId]: TypeId,
    pipe() {
      return pipeArguments(this, arguments);
    },
    ...BaseProto,
    toJSON() {
      return {
        _id: "@effect/platform/HttpClient"
      };
    },
    get(url, options2) {
      return this.execute(get$1(url, options2));
    },
    head(url, options2) {
      return this.execute(head$1(url, options2));
    },
    post(url, options2) {
      return this.execute(post$1(url, options2));
    },
    put(url, options2) {
      return this.execute(put$1(url, options2));
    },
    patch(url, options2) {
      return this.execute(patch$1(url, options2));
    },
    del(url, options2) {
      return this.execute(del$1(url, options2));
    },
    options(url, options2) {
      return this.execute(options$1(url, options2));
    }
  };
  const makeWith = (postprocess, preprocess) => {
    const self2 = Object.create(ClientProto);
    self2.preprocess = preprocess;
    self2.postprocess = postprocess;
    self2.execute = function(request) {
      return postprocess(preprocess(request));
    };
    return self2;
  };
  const responseRegistry = /* @__PURE__ */ globalValue("@effect/platform/HttpClient/responseRegistry", () => {
    if ("FinalizationRegistry" in globalThis && globalThis.FinalizationRegistry) {
      const registry = new FinalizationRegistry((controller) => {
        controller.abort();
      });
      return {
        register(response, controller) {
          registry.register(response, controller, response);
        },
        unregister(response) {
          registry.unregister(response);
        }
      };
    }
    const timers = /* @__PURE__ */ new Map();
    return {
      register(response, controller) {
        timers.set(response, setTimeout(() => controller.abort(), 5e3));
      },
      unregister(response) {
        const timer = timers.get(response);
        if (timer === void 0) return;
        clearTimeout(timer);
        timers.delete(response);
      }
    };
  });
  const make$2 = (f) => makeWith((effect2) => flatMap$4(effect2, (request) => withFiberRuntime((fiber) => {
    const controller = new AbortController();
    const urlResult = makeUrl(request.url, request.urlParams, request.hash);
    if (urlResult._tag === "Left") {
      return fail$6(new RequestError({
        request,
        reason: "InvalidUrl",
        cause: urlResult.left
      }));
    }
    const url = urlResult.right;
    const tracerDisabled = !fiber.getFiberRef(currentTracerEnabled) || fiber.getFiberRef(currentTracerDisabledWhen)(request);
    if (tracerDisabled) {
      return uninterruptibleMask((restore) => matchCauseEffect(restore(f(request, url, controller.signal, fiber)), {
        onSuccess(response) {
          responseRegistry.register(response, controller);
          return succeed$5(new InterruptibleResponse(response, controller));
        },
        onFailure(cause) {
          if (isInterrupted(cause)) {
            controller.abort();
          }
          return failCause$3(cause);
        }
      }));
    }
    const nameGenerator = get$e(fiber.currentContext, SpanNameGenerator);
    return useSpan(nameGenerator(request), {
      kind: "client",
      captureStackTrace: false
    }, (span2) => {
      span2.attribute("http.request.method", request.method);
      span2.attribute("server.address", url.origin);
      if (url.port !== "") {
        span2.attribute("server.port", +url.port);
      }
      span2.attribute("url.full", url.toString());
      span2.attribute("url.path", url.pathname);
      span2.attribute("url.scheme", url.protocol.slice(0, -1));
      const query = url.search.slice(1);
      if (query !== "") {
        span2.attribute("url.query", query);
      }
      const redactedHeaderNames = fiber.getFiberRef(currentRedactedNames);
      const redactedHeaders = redact(request.headers, redactedHeaderNames);
      for (const name in redactedHeaders) {
        span2.attribute(`http.request.header.${name}`, String(redactedHeaders[name]));
      }
      request = fiber.getFiberRef(currentTracerPropagation) ? setHeaders(request, toHeaders(span2)) : request;
      return uninterruptibleMask((restore) => restore(f(request, url, controller.signal, fiber)).pipe(withParentSpan(span2), matchCauseEffect({
        onSuccess: (response) => {
          span2.attribute("http.response.status_code", response.status);
          const redactedHeaders2 = redact(response.headers, redactedHeaderNames);
          for (const name in redactedHeaders2) {
            span2.attribute(`http.response.header.${name}`, String(redactedHeaders2[name]));
          }
          responseRegistry.register(response, controller);
          return succeed$5(new InterruptibleResponse(response, controller));
        },
        onFailure(cause) {
          if (isInterrupted(cause)) {
            controller.abort();
          }
          return failCause$3(cause);
        }
      })));
    });
  })), succeed$5);
  class InterruptibleResponse {
    constructor(original, controller) {
      __publicField(this, "original");
      __publicField(this, "controller");
      __publicField(this, _Ta, TypeId$1);
      __publicField(this, _Sa, TypeId$4);
      this.original = original;
      this.controller = controller;
    }
    applyInterrupt(effect2) {
      return suspend$6(() => {
        responseRegistry.unregister(this.original);
        return onInterrupt(effect2, () => sync$3(() => {
          this.controller.abort();
        }));
      });
    }
    get request() {
      return this.original.request;
    }
    get status() {
      return this.original.status;
    }
    get headers() {
      return this.original.headers;
    }
    get cookies() {
      return this.original.cookies;
    }
    get remoteAddress() {
      return this.original.remoteAddress;
    }
    get formData() {
      return this.applyInterrupt(this.original.formData);
    }
    get text() {
      return this.applyInterrupt(this.original.text);
    }
    get json() {
      return this.applyInterrupt(this.original.json);
    }
    get urlParamsBody() {
      return this.applyInterrupt(this.original.urlParamsBody);
    }
    get arrayBuffer() {
      return this.applyInterrupt(this.original.arrayBuffer);
    }
    get stream() {
      return suspend(() => {
        responseRegistry.unregister(this.original);
        return ensuringWith(this.original.stream, (exit2) => {
          if (isInterrupted$1(exit2)) {
            this.controller.abort();
          }
          return _void;
        });
      });
    }
    toJSON() {
      return this.original.toJSON();
    }
    [(_Ta = TypeId$1, _Sa = TypeId$4, NodeInspectSymbol)]() {
      return this.original[NodeInspectSymbol]();
    }
  }
  const {
    /** @internal */
    del,
    /** @internal */
    execute,
    /** @internal */
    get,
    /** @internal */
    head,
    /** @internal */
    options,
    /** @internal */
    patch,
    /** @internal */
    post,
    /** @internal */
    put
  } = /* @__PURE__ */ serviceFunctions(tag);
  const transformResponse = /* @__PURE__ */ dual(2, (self2, f) => {
    const client = self2;
    return makeWith((request) => f(client.postprocess(request)), client.preprocess);
  });
  const layerMergedContext = (effect2) => effect$2(tag, flatMap$4(context$1(), (context2) => map$5(effect2, (client) => transformResponse(client, mapInputContext((input) => merge$4(context2, input))))));
  const fetchTagKey = "@effect/platform/FetchHttpClient/Fetch";
  const requestInitTagKey = "@effect/platform/FetchHttpClient/FetchOptions";
  const fetch$1 = /* @__PURE__ */ make$2((request, url, signal, fiber) => {
    const context2 = fiber.getFiberRef(currentContext);
    const fetch2 = context2.unsafeMap.get(fetchTagKey) ?? globalThis.fetch;
    const options2 = context2.unsafeMap.get(requestInitTagKey) ?? {};
    const headers = options2.headers ? merge$1(fromInput$1(options2.headers), request.headers) : request.headers;
    const send = (body) => map$5(tryPromise({
      try: () => fetch2(url, {
        ...options2,
        method: request.method,
        headers,
        body,
        duplex: request.body._tag === "Stream" ? "half" : void 0,
        signal
      }),
      catch: (cause) => new RequestError({
        request,
        reason: "Transport",
        cause
      })
    }), (response) => fromWeb(request, response));
    switch (request.body._tag) {
      case "Raw":
      case "Uint8Array":
        return send(request.body.body);
      case "FormData":
        return send(request.body.formData);
      case "Stream":
        return flatMap$4(toReadableStreamEffect(request.body.stream), send);
    }
    return send(void 0);
  });
  const layer$3 = /* @__PURE__ */ layerMergedContext(/* @__PURE__ */ succeed$5(fetch$1));
  const layer$2 = layer$3;
  class Collector extends (/* @__PURE__ */ Tag("@effect/platform/Transferable/Collector")()) {
  }
  const unsafeMakeCollector = () => {
    let tranferables = [];
    const unsafeAddAll = (transfers) => {
      tranferables.push(...transfers);
    };
    const unsafeRead = () => tranferables;
    const unsafeClear = () => {
      const prev = tranferables;
      tranferables = [];
      return prev;
    };
    return Collector.of({
      unsafeAddAll,
      addAll: (transferables) => sync$3(() => unsafeAddAll(transferables)),
      unsafeRead,
      read: sync$3(unsafeRead),
      unsafeClear,
      clear: sync$3(unsafeClear)
    });
  };
  const makeCollector = /* @__PURE__ */ sync$3(unsafeMakeCollector);
  const addAll = (tranferables) => flatMap$4(serviceOption(Collector), match$a({
    onNone: () => _void,
    onSome: (_) => _.addAll(tranferables)
  }));
  const schema$1 = /* @__PURE__ */ dual(2, (self2, f) => transformOrFail(encodedSchema(self2), self2, {
    strict: true,
    decode: succeed,
    encode: (i) => as(addAll(f(i)), i)
  }));
  const MessagePort = /* @__PURE__ */ schema$1(Any, (_) => [_]);
  const Uint8Array$1 = /* @__PURE__ */ schema$1(Uint8ArrayFromSelf, (_) => [_.buffer]);
  const WorkerErrorTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/platform/WorkerError");
  const WorkerErrorTypeId = WorkerErrorTypeId$1;
  const isWorkerError = (u) => hasProperty(u, WorkerErrorTypeId);
  const _WorkerError = class _WorkerError extends (_Va = /* @__PURE__ */ TaggedError()("WorkerError", {
    reason: /* @__PURE__ */ Literal("spawn", "decode", "send", "unknown", "encode"),
    cause: Defect
  }), _Ua = WorkerErrorTypeId, _Va) {
    constructor() {
      super(...arguments);
      /**
       * @since 1.0.0
       */
      __publicField(this, _Ua, WorkerErrorTypeId);
    }
    /**
     * @since 1.0.0
     */
    get message() {
      switch (this.reason) {
        case "send":
          return "An error occurred calling .postMessage";
        case "spawn":
          return "An error occurred while spawning a worker";
        case "decode":
          return "An error occurred during decoding";
        case "encode":
          return "An error occurred during encoding";
        case "unknown":
          return "An unexpected error occurred";
      }
    }
  };
  /**
   * @since 1.0.0
   */
  __publicField(_WorkerError, "Cause", /* @__PURE__ */ Cause({
    error: _WorkerError,
    defect: Defect
  }));
  /**
   * @since 1.0.0
   */
  __publicField(_WorkerError, "encodeCause", /* @__PURE__ */ encodeSync(_WorkerError.Cause));
  /**
   * @since 1.0.0
   */
  __publicField(_WorkerError, "decodeCause", /* @__PURE__ */ decodeSync(_WorkerError.Cause));
  let WorkerError = _WorkerError;
  const PlatformRunnerTypeId$1 = /* @__PURE__ */ Symbol.for("@effect/platform/Runner/PlatformRunner");
  const PlatformRunner$1 = /* @__PURE__ */ GenericTag("@effect/platform/Runner/PlatformRunner");
  const CloseLatch = /* @__PURE__ */ Reference()("@effect/platform/WorkerRunner/CloseLatch", {
    defaultValue: () => unsafeMake$9(none$2)
  });
  const layerCloseLatch = /* @__PURE__ */ effect$2(CloseLatch, /* @__PURE__ */ make$N());
  const make$1 = /* @__PURE__ */ fnUntraced(function* (process2, options2) {
    const fiber = yield* withFiberRuntime(succeed$5);
    const platform = yield* PlatformRunner$1;
    const closeLatch = yield* CloseLatch;
    const backing = yield* platform.start(closeLatch);
    const fiberMap = /* @__PURE__ */ new Map();
    yield* _await$2(closeLatch).pipe(onExit(() => {
      fiber.currentScheduler.scheduleTask(() => {
        fiber.unsafeInterruptAsFork(fiber.id());
      }, 0);
      return _void;
    }), forkScoped);
    yield* backing.run((portId, [id2, kind, data, span2]) => {
      if (kind === 1) {
        const fiber2 = fiberMap.get(id2);
        if (!fiber2) return _void;
        return interrupt$2(fiber2);
      }
      return withFiberRuntime((fiber2) => {
        fiberMap.set(id2, fiber2);
        return (options2 == null ? void 0 : options2.decode) ? options2.decode(data) : succeed$5(data);
      }).pipe(flatMap$4((input) => {
        const collector = unsafeMakeCollector();
        const stream = process2(input);
        let effect2 = isEffect(stream) ? flatMap$4(stream, (out) => pipe((options2 == null ? void 0 : options2.encodeOutput) ? provideService(options2.encodeOutput(input, out), Collector, collector) : succeed$5(out), flatMap$4((payload) => backing.send(portId, [id2, 0, [payload]], collector.unsafeRead())))) : pipe(stream, runForEachChunk((chunk2) => {
          if ((options2 == null ? void 0 : options2.encodeOutput) === void 0) {
            const payload = toReadonlyArray(chunk2);
            return backing.send(portId, [id2, 0, payload]);
          }
          collector.unsafeClear();
          return pipe(forEach(chunk2, (data2) => options2.encodeOutput(input, data2)), provideService(Collector, collector), flatMap$4((payload) => backing.send(portId, [id2, 0, payload], collector.unsafeRead())));
        }), andThen(backing.send(portId, [id2, 1])));
        if (span2) {
          effect2 = withParentSpan(effect2, {
            _tag: "ExternalSpan",
            traceId: span2[0],
            spanId: span2[1],
            sampled: span2[2],
            context: empty$s()
          });
        }
        return uninterruptibleMask((restore) => restore(effect2).pipe(catchIf(isWorkerError, (error) => backing.send(portId, [id2, 3, WorkerError.encodeCause(fail$8(error))])), catchAllCause$1((cause) => match$b(failureOrCause(cause), {
          onLeft: (error) => {
            collector.unsafeClear();
            return pipe((options2 == null ? void 0 : options2.encodeError) ? provideService(options2.encodeError(input, error), Collector, collector) : succeed$5(error), flatMap$4((payload) => backing.send(portId, [id2, 2, payload], collector.unsafeRead())), catchAllCause$1((cause2) => backing.send(portId, [id2, 3, WorkerError.encodeCause(cause2)])));
          },
          onRight: (cause2) => backing.send(portId, [id2, 3, WorkerError.encodeCause(cause2)])
        }))));
      }), ensuring$3(sync$3(() => fiberMap.delete(id2))));
    });
  });
  const makeSerialized = (schema2, handlers) => gen$2(function* () {
    const scope$12 = yield* scope;
    let context2 = empty$s();
    const parseRequest = decodeUnknown(schema2);
    return yield* make$1((request) => {
      const result = handlers[request._tag](request);
      if (isLayer(result)) {
        return flatMap$4(buildWithScope(result, scope$12), (_) => sync$3(() => {
          context2 = merge$4(context2, _);
        }));
      } else if (isEffect(result)) {
        return provide$1(result, context2);
      }
      return provideContext(result, context2);
    }, {
      decode(message) {
        return mapError$4(parseRequest(message), (cause) => new WorkerError({
          reason: "decode",
          cause
        }));
      },
      encodeError(request, message) {
        return mapError$4(serializeFailure(request, message), (cause) => new WorkerError({
          reason: "encode",
          cause
        }));
      },
      encodeOutput(request, message) {
        return catchAllCause$1(serializeSuccess(request, message), (cause) => new WorkerError({
          reason: "encode",
          cause
        }));
      }
    });
  });
  const layerSerialized$1 = (schema2, handlers) => scopedDiscard(makeSerialized(schema2, handlers)).pipe(provide(layerCloseLatch));
  const launch$1 = (layer2) => scopedWith$2(fnUntraced(function* (scope2) {
    const context2 = yield* buildWithScope(provideMerge(layer2, layerCloseLatch), scope2);
    const closeLatch = get$e(context2, CloseLatch);
    return yield* _await$2(closeLatch);
  }));
  const PlatformRunnerTypeId = PlatformRunnerTypeId$1;
  const PlatformRunner = PlatformRunner$1;
  const layerSerialized = layerSerialized$1;
  const launch = launch$1;
  const hash$1 = (schema2) => {
    try {
      return string(JSON.stringify(schema2.ast, null, 2));
    } catch {
      console.warn(`Schema hashing failed, falling back to hashing the shortend schema AST string. This is less reliable and may cause false positives.`);
      return hash$2(schema2.ast.toString());
    }
  };
  const encodeWithTransferables = (schema2, options2) => (a, overrideOptions) => gen$2(function* () {
    const collector = yield* makeCollector;
    const encoded = yield* encode(schema2, options2)(a, overrideOptions).pipe(provideService(Collector, collector));
    return [encoded, collector.unsafeRead()];
  });
  const encodeSyncDebug = (schema2, options2) => (input, overrideOptions) => {
    const res = encodeEither(schema2, options2)(input, overrideOptions);
    if (res._tag === "Left") {
      return shouldNeverHappen(`encodeSyncDebug failed:`, res.left);
    } else {
      return res.right;
    }
  };
  const swap = (schema2) => transformOrFail(typeSchema(schema2), encodedSchema(schema2), {
    decode: encode$1(schema2),
    encode: decode$1(schema2)
  });
  swap(Uint8ArrayFromBase64);
  const JsonValue = Union(String$, Number$, Boolean$, Null, Array$(suspend$1(() => JsonValue)), Record({ key: String$, value: suspend$1(() => JsonValue) })).annotations({ title: "JsonValue" });
  const WebChannelSymbol = Symbol("WebChannel");
  const DebugPingMessage = TaggedStruct("WebChannel.DebugPing", {
    message: String$,
    payload: optional(String$)
  });
  const WebChannelPing = TaggedStruct("WebChannel.Ping", {
    requestId: String$
  });
  const WebChannelPong = TaggedStruct("WebChannel.Pong", {
    requestId: String$
  });
  const WebChannelHeartbeat = Union(WebChannelPing, WebChannelPong);
  const schemaWithWebChannelMessages = (schema2) => ({
    send: Union(schema2.send, DebugPingMessage, WebChannelPing, WebChannelPong),
    listen: Union(schema2.listen, DebugPingMessage, WebChannelPing, WebChannelPong)
  });
  const mapSchema = (schema2) => hasProperty(schema2, "send") && hasProperty(schema2, "listen") ? schemaWithWebChannelMessages(schema2) : schemaWithWebChannelMessages({ send: schema2, listen: schema2 });
  const listenToDebugPing = (channelName) => (stream) => stream.pipe(filterEffect(fn(function* (msg) {
    if (msg._tag === "Right" && is(DebugPingMessage)(msg.right)) {
      yield* logDebug(`WebChannel:ping [${channelName}] ${msg.right.message}`, msg.right.payload);
      return false;
    }
    return true;
  })));
  const broadcastChannel = ({ channelName, schema: inputSchema }) => scopeWithCloseable((scope2) => gen$2(function* () {
    const schema2 = mapSchema(inputSchema);
    const channel = new BroadcastChannel(channelName);
    yield* addFinalizer(() => try_(() => channel.close()).pipe(ignoreLogged));
    const send = (message) => gen$2(function* () {
      const messageEncoded = yield* encode(schema2.send)(message);
      channel.postMessage(messageEncoded);
    });
    const listen = fromEventListener(channel, "message").pipe(map((_) => decodeEither(schema2.listen)(_.data)), listenToDebugPing(channelName));
    const closedDeferred = yield* make$N().pipe(acquireRelease(done$7(void_$3)));
    const supportsTransferables = false;
    return {
      [WebChannelSymbol]: WebChannelSymbol,
      send,
      listen,
      closedDeferred,
      shutdown: close(scope2, succeed$8("shutdown")),
      schema: schema2,
      supportsTransferables
    };
  }).pipe(withSpan$3(`WebChannel:broadcastChannel(${channelName})`)));
  const messagePortChannel = ({ port, schema: inputSchema, debugId }) => scopeWithCloseable((scope2) => gen$2(function* () {
    const schema2 = mapSchema(inputSchema);
    const label = debugId === void 0 ? "messagePort" : `messagePort:${debugId}`;
    const send = (message) => gen$2(function* () {
      const [messageEncoded, transferables] = yield* encodeWithTransferables(schema2.send)(message);
      port.postMessage(messageEncoded, transferables);
    });
    const listen = fromEventListener(port, "message").pipe(
      // Stream.tap((_) => Effect.log(`${label}:message`, _.data)),
      map((_) => decodeEither(schema2.listen)(_.data)),
      listenToDebugPing(label)
    );
    port.start();
    const closedDeferred = yield* make$N().pipe(acquireRelease(done$7(void_$3)));
    const supportsTransferables = true;
    yield* addFinalizer(() => try_(() => port.close()).pipe(ignoreLogged));
    return {
      [WebChannelSymbol]: WebChannelSymbol,
      send,
      listen,
      closedDeferred,
      shutdown: close(scope2, succeed$8("shutdown")),
      schema: schema2,
      supportsTransferables
    };
  }).pipe(withSpan$3(`WebChannel:messagePortChannel`)));
  globalValue("livestore:sameThreadChannels", () => /* @__PURE__ */ new Map());
  const messagePortChannelWithAck = ({ port, schema: inputSchema, debugId }) => scopeWithCloseable((scope2) => gen$2(function* () {
    const schema2 = mapSchema(inputSchema);
    const label = debugId === void 0 ? "messagePort" : `messagePort:${debugId}`;
    const requestAckMap = /* @__PURE__ */ new Map();
    const ChannelRequest = TaggedStruct("ChannelRequest", {
      id: String$,
      payload: Union(schema2.listen, schema2.send)
    }).annotations({ title: "webmesh.ChannelRequest" });
    const ChannelRequestAck = TaggedStruct("ChannelRequestAck", {
      reqId: String$
    }).annotations({ title: "webmesh.ChannelRequestAck" });
    const ChannelMessage = Union(ChannelRequest, ChannelRequestAck).annotations({
      title: "webmesh.ChannelMessage"
    });
    const debugInfo = {
      sendTotal: 0,
      sendPending: 0,
      listenTotal: 0,
      id: debugId
    };
    const send = (message) => gen$2(function* () {
      debugInfo.sendTotal++;
      debugInfo.sendPending++;
      const id2 = crypto.randomUUID();
      const [messageEncoded, transferables] = yield* encodeWithTransferables(ChannelMessage)({
        _tag: "ChannelRequest",
        id: id2,
        payload: message
      });
      const ack = yield* make$N();
      requestAckMap.set(id2, ack);
      port.postMessage(messageEncoded, transferables);
      yield* ack;
      requestAckMap.delete(id2);
      debugInfo.sendPending--;
    });
    const listen = fromEventListener(port, "message").pipe(
      // Stream.onStart(Effect.log(`${label}:listen:start`)),
      // Stream.tap((_) => Effect.log(`${label}:message`, _.data)),
      map((_) => decodeEither(ChannelMessage)(_.data)),
      tap((msg) => gen$2(function* () {
        if (msg._tag === "Right") {
          if (msg.right._tag === "ChannelRequestAck") {
            yield* succeed$9(requestAckMap.get(msg.right.reqId), void 0);
          } else if (msg.right._tag === "ChannelRequest") {
            debugInfo.listenTotal++;
            port.postMessage(encodeSync(ChannelMessage)({ _tag: "ChannelRequestAck", reqId: msg.right.id }));
          }
        }
      })),
      filterMap((msg) => msg._tag === "Left" ? some(msg) : msg.right._tag === "ChannelRequest" ? some(right(msg.right.payload)) : none$4()),
      (_) => _,
      listenToDebugPing(label)
    );
    port.start();
    const closedDeferred = yield* make$N().pipe(acquireRelease(done$7(void_$3)));
    const supportsTransferables = true;
    yield* addFinalizer(() => try_(() => port.close()).pipe(ignoreLogged));
    return {
      [WebChannelSymbol]: WebChannelSymbol,
      send,
      listen,
      closedDeferred,
      shutdown: close(scope2, succeed$8("shutdown")),
      schema: schema2,
      supportsTransferables,
      debugInfo
    };
  }).pipe(withSpan$3(`WebChannel:messagePortChannelWithAck`)));
  const toOpenChannel = (channel, options2) => gen$2(function* () {
    const queue = yield* unbounded$2().pipe(acquireRelease(shutdown));
    const pendingPingDeferredRef = {
      current: void 0
    };
    yield* channel.listen.pipe(
      // TODO implement this on the "chunk" level for better performance
      (options2 == null ? void 0 : options2.heartbeat) ? filterEffect(fn(function* (msg) {
        if (msg._tag === "Right" && is(WebChannelHeartbeat)(msg.right)) {
          if (msg.right._tag === "WebChannel.Ping") {
            yield* channel.send(WebChannelPong.make({ requestId: msg.right.requestId }));
          } else {
            const { deferred, requestId: requestId2 } = pendingPingDeferredRef.current ?? shouldNeverHappen("No pending ping");
            if (requestId2 !== msg.right.requestId) {
              shouldNeverHappen("Received pong for unexpected requestId", requestId2, msg.right.requestId);
            }
            yield* succeed$9(deferred, void 0);
          }
          return false;
        }
        return true;
      })) : identity,
      tapChunk((chunk2) => offerAll$1(queue, chunk2)),
      runDrain,
      forkScoped
    );
    if (options2 == null ? void 0 : options2.heartbeat) {
      const { interval, timeout: timeout$12 } = options2.heartbeat;
      yield* gen$2(function* () {
        while (true) {
          yield* sleep(interval);
          const requestId2 = crypto.randomUUID();
          yield* channel.send(WebChannelPing.make({ requestId: requestId2 }));
          const deferred = yield* make$N();
          pendingPingDeferredRef.current = { deferred, requestId: requestId2 };
          yield* deferred.pipe(timeout(timeout$12), catchTag("TimeoutException", () => channel.shutdown));
        }
      }).pipe(withSpan$3(`WebChannel:heartbeat`), forkScoped);
    }
    const listen = fromQueue(queue, { maxChunkSize: 1 });
    return {
      [WebChannelSymbol]: WebChannelSymbol,
      send: channel.send,
      listen,
      closedDeferred: channel.closedDeferred,
      shutdown: channel.shutdown,
      schema: channel.schema,
      supportsTransferables: channel.supportsTransferables,
      debugInfo: {
        innerDebugInfo: channel.debugInfo,
        listenQueueSize: queue
      }
    };
  });
  const withAsyncTaggingTracing = (makeTrace) => (eff) => {
    if (hasProperty(console, "createTask") === false) {
      return eff;
    }
    const makeTracer = gen$2(function* () {
      const oldTracer = yield* tracer;
      return make$F({
        span: (name, ...args2) => {
          const span2 = oldTracer.span(name, ...args2);
          const trace2 = makeTrace(name);
          span2.runInTask = (f) => trace2.run(f);
          return span2;
        },
        context: (f, fiber) => {
          const maybeParentSpan = getOption(ParentSpan)(fiber.currentContext);
          if (maybeParentSpan._tag === "None")
            return oldTracer.context(f, fiber);
          const parentSpan = maybeParentSpan.value;
          if (parentSpan._tag === "ExternalSpan")
            return oldTracer.context(f, fiber);
          const span2 = parentSpan;
          if ("runInTask" in span2 && typeof span2.runInTask === "function") {
            return span2.runInTask(() => oldTracer.context(f, fiber));
          }
          return oldTracer.context(f, fiber);
        }
      });
    });
    const withTracerLayer = pipe(makeTracer, map$5(setTracer), unwrapEffect);
    return provide$1(eff, withTracerLayer);
  };
  const cachedPorts = /* @__PURE__ */ globalValue("@effect/platform-browser/Worker/cachedPorts", () => /* @__PURE__ */ new Set());
  function globalHandleConnect(event) {
    cachedPorts.add(event.ports[0]);
  }
  if (typeof self !== "undefined" && "onconnect" in self) {
    self.onconnect = globalHandleConnect;
  }
  const make = (self2) => PlatformRunner.of({
    [PlatformRunnerTypeId]: PlatformRunnerTypeId,
    start: fnUntraced(function* (closeLatch) {
      const disconnects = yield* make$f();
      let currentPortId = 0;
      const ports = /* @__PURE__ */ new Map();
      const send = (portId, message, transfer) => sync$3(() => {
        var _a2;
        (((_a2 = ports.get(portId)) == null ? void 0 : _a2[0]) ?? self2).postMessage([1, message], {
          transfer
        });
      });
      const run2 = fnUntraced(function* (handler) {
        const scope$12 = yield* scope;
        const runtime$12 = (yield* interruptible(runtime())).pipe(updateContext(omit$1(Scope)));
        const fiberSet = yield* make$i();
        const runFork$22 = runFork(runtime$12);
        function onExit2(exit2) {
          if (exit2._tag === "Failure" && !isInterruptedOnly(exit2.cause)) {
            unsafeDone(closeLatch, die$5(squash(exit2.cause)));
          }
        }
        function onMessage(portId) {
          return function(event) {
            const message = event.data;
            if (message[0] === 0) {
              const result = handler(portId, message[1]);
              if (isEffect(result)) {
                const fiber = runFork$22(result);
                fiber.addObserver(onExit2);
                unsafeAdd(fiberSet, fiber);
              }
            } else {
              const port = ports.get(portId);
              if (!port) {
                return;
              } else if (ports.size === 1) {
                return unsafeDone(closeLatch, void_$3);
              }
              ports.delete(portId);
              runFork$1(close(port[1], void_$3));
            }
          };
        }
        function onMessageError(error) {
          unsafeDone(closeLatch, new WorkerError({
            reason: "decode",
            cause: error.data
          }));
        }
        function onError2(error) {
          unsafeDone(closeLatch, new WorkerError({
            reason: "unknown",
            cause: error.data
          }));
        }
        function handlePort(port) {
          const fiber = fork$1(scope$12, sequential$1).pipe(flatMap$4((scope2) => {
            const portId = currentPortId++;
            ports.set(portId, [port, scope2]);
            const onMsg = onMessage(portId);
            port.addEventListener("message", onMsg);
            port.addEventListener("messageerror", onMessageError);
            if ("start" in port) {
              port.start();
            }
            port.postMessage([0]);
            return addFinalizer$1(scope2, sync$3(() => {
              port.removeEventListener("message", onMsg);
              port.removeEventListener("messageerror", onError2);
              port.close();
            }));
          }), runFork$22);
          fiber.addObserver(onExit2);
          unsafeAdd(fiberSet, fiber);
        }
        self2.addEventListener("error", onError2);
        let prevOnConnect;
        if ("onconnect" in self2) {
          prevOnConnect = self2.onconnect;
          self2.onconnect = function(event) {
            const port = event.ports[0];
            handlePort(port);
          };
          for (const port of cachedPorts) {
            handlePort(port);
          }
          cachedPorts.clear();
          yield* addFinalizer$1(scope$12, sync$3(() => self2.close()));
        } else {
          handlePort(self2);
        }
        yield* addFinalizer$1(scope$12, sync$3(() => {
          self2.removeEventListener("error", onError2);
          if ("onconnect" in self2) {
            self2.onconnect = prevOnConnect;
          }
        }));
      });
      return identity({
        run: run2,
        send,
        disconnects
      });
    })
  });
  const layerMessagePort$1 = (port) => succeed$4(PlatformRunner, make(port));
  const layer$1 = /* @__PURE__ */ sync$2(PlatformRunner, () => make(self));
  const layer = layer$1;
  const layerMessagePort = layerMessagePort$1;
  const messageChannel = (shouldYield = defaultShouldYield) => makeBatched((task) => {
    const messageChannel2 = new MessageChannel();
    messageChannel2.port1.postMessage(void 0);
    messageChannel2.port2.onmessage = task;
  }, shouldYield);
  const localEventSequenceNumber = nominal();
  const ClientEventSequenceNumber = fromBrand(localEventSequenceNumber)(Int);
  const globalEventSequenceNumber = nominal();
  const GlobalEventSequenceNumber = fromBrand(globalEventSequenceNumber)(Int);
  const clientDefault = 0;
  const EventSequenceNumber = Struct({
    global: GlobalEventSequenceNumber,
    /** Only increments for clientOnly events */
    client: ClientEventSequenceNumber
    // TODO also provide a way to see "confirmation level" of event (e.g. confirmed by leader/sync backend)
    // TODO: actually add this field
    // Client only
    // generation: Schema.Number.pipe(Schema.optional),
  }).annotations({ title: "LiveStore.EventSequenceNumber" });
  const compare = (a, b) => {
    if (a.global !== b.global) {
      return a.global - b.global;
    }
    return a.client - b.client;
  };
  const toString = (seqNum) => seqNum.client === 0 ? `e${seqNum.global}` : `e${seqNum.global}+${seqNum.client}`;
  const isEqual = (a, b) => a.global === b.global && a.client === b.client;
  const ROOT = {
    global: 0,
    client: clientDefault
  };
  const isGreaterThan = (a, b) => {
    return a.global > b.global || a.global === b.global && a.client > b.client;
  };
  const isGreaterThanOrEqual = (a, b) => {
    return a.global > b.global || a.global === b.global && a.client >= b.client;
  };
  const max = (a, b) => {
    return a.global > b.global || a.global === b.global && a.client > b.client ? a : b;
  };
  const nextPair = (seqNum, isLocal) => {
    if (isLocal) {
      return {
        seqNum: { global: seqNum.global, client: seqNum.client + 1 },
        parentSeqNum: seqNum
      };
    }
    return {
      seqNum: { global: seqNum.global + 1, client: clientDefault },
      // NOTE we always point to `client: 0` for non-clientOnly events
      parentSeqNum: { global: seqNum.global, client: clientDefault }
    };
  };
  const isColumnDefinition = (value2) => {
    const validColumnTypes = ["text", "integer", "real", "blob"];
    return typeof value2 === "object" && value2 !== null && "columnType" in value2 && validColumnTypes.includes(value2["columnType"]);
  };
  const NoDefault = Symbol.for("NoDefault");
  const isSqlDefaultValue = (value2) => {
    return typeof value2 === "object" && value2 !== null && "sql" in value2 && typeof value2["sql"] === "string";
  };
  const makeColDef = (columnType) => (def) => {
    const nullable = (def == null ? void 0 : def.nullable) ?? false;
    const schemaWithoutNull = (def == null ? void 0 : def.schema) ?? defaultSchemaForColumnType(columnType);
    const schema2 = nullable === true ? NullOr(schemaWithoutNull) : schemaWithoutNull;
    const default_ = (def == null ? void 0 : def.default) === void 0 || def.default === NoDefault ? none$4() : some(def.default);
    return {
      columnType,
      schema: schema2,
      default: default_,
      nullable,
      primaryKey: (def == null ? void 0 : def.primaryKey) ?? false
    };
  };
  const column = (columnType) => makeColDef(columnType);
  const text$1 = makeColDef("text");
  const integer$1 = makeColDef("integer");
  const real = makeColDef("real");
  const blob = makeColDef("blob");
  const makeSpecializedColDef = (columnType, opts) => (def) => {
    const nullable = (def == null ? void 0 : def.nullable) ?? false;
    const schemaWithoutNull = opts._tag === "baseSchemaFn" ? opts.baseSchemaFn(def == null ? void 0 : def.schema) : opts.baseSchema;
    const schema2 = nullable === true ? NullOr(schemaWithoutNull) : schemaWithoutNull;
    const default_ = (def == null ? void 0 : def.default) === void 0 || def.default === NoDefault ? none$4() : some(def.default);
    return {
      columnType,
      schema: schema2,
      default: default_,
      nullable,
      primaryKey: (def == null ? void 0 : def.primaryKey) ?? false
    };
  };
  const json = makeSpecializedColDef("text", {
    _tag: "baseSchemaFn",
    baseSchemaFn: (customSchema) => parseJson(customSchema ?? Any)
  });
  const datetime = makeSpecializedColDef("text", {
    _tag: "baseSchema",
    baseSchema: Date$
  });
  const datetimeInteger = makeSpecializedColDef("integer", {
    _tag: "baseSchema",
    baseSchema: transform(Number$, DateFromSelf, {
      decode: (ms) => new Date(ms),
      encode: (date) => date.getTime()
    })
  });
  const boolean$1 = makeSpecializedColDef("integer", {
    _tag: "baseSchema",
    baseSchema: transform(Number$, Boolean$, {
      decode: (_) => _ === 1,
      encode: (_) => _ ? 1 : 0
    })
  });
  const defaultSchemaForColumnType = (columnType) => {
    switch (columnType) {
      case "text": {
        return String$;
      }
      case "integer": {
        return Number$;
      }
      case "real": {
        return Number$;
      }
      case "blob": {
        return Uint8ArrayFromSelf;
      }
      default: {
        return casesHandled(columnType);
      }
    }
  };
  const makeDbSchema = (schema2) => {
    return Array.isArray(schema2) ? Object.fromEntries(schema2.map((_) => [_.name, _])) : schema2;
  };
  const table$1 = (name, columns, indexes) => {
    const ast = {
      _tag: "table",
      name,
      columns: columsToAst(columns),
      indexes: indexesToAst(indexes ?? [])
    };
    return { name, columns, indexes, ast };
  };
  const structSchemaForTable = (tableDef) => Struct(Object.fromEntries(tableDef.ast.columns.map((column2) => [column2.name, column2.schema]))).annotations({
    title: tableDef.name
  });
  const insertStructSchemaForTable = (tableDef) => Struct(Object.fromEntries(tableDef.ast.columns.map((column2) => [
    column2.name,
    column2.nullable === true || column2.default._tag === "Some" ? optional(column2.schema) : column2.schema
  ]))).annotations({
    title: tableDef.name
  });
  const columsToAst = (columns) => {
    return Object.entries(columns).map(([name, column2]) => {
      return {
        _tag: "column",
        name,
        schema: column2.schema,
        default: column2.default,
        nullable: column2.nullable ?? false,
        primaryKey: column2.primaryKey ?? false,
        type: { _tag: column2.columnType }
      };
    });
  };
  const indexesToAst = (indexes) => {
    return indexes.map((_) => ({ _tag: "index", columns: _.columns, name: _.name, unique: _.isUnique ?? false }));
  };
  var SqliteDsl = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    NoDefault,
    blob,
    boolean: boolean$1,
    column,
    datetime,
    datetimeInteger,
    defaultSchemaForColumnType,
    insertStructSchemaForTable,
    integer: integer$1,
    isColumnDefinition,
    isSqlDefaultValue,
    json,
    makeDbSchema,
    real,
    structSchemaForTable,
    table: table$1,
    text: text$1
  });
  const hashCode = (str) => {
    let hash2 = 0, i, chr;
    if (str.length === 0)
      return hash2;
    for (i = 0; i < str.length; i++) {
      chr = str.charCodeAt(i);
      hash2 = (hash2 << 5) - hash2 + chr;
      hash2 = Math.trunc(hash2);
    }
    return hash2;
  };
  const hash = (obj) => hashCode(JSON.stringify(trimInfoForHasing(obj)));
  const trimInfoForHasing = (obj) => {
    switch (obj._tag) {
      case "table": {
        return {
          _tag: "table",
          name: obj.name,
          columns: obj.columns.map((column2) => trimInfoForHasing(column2)),
          indexes: obj.indexes.map((index) => trimInfoForHasing(index))
        };
      }
      case "column": {
        return {
          _tag: "column",
          name: obj.name,
          type: obj.type._tag,
          primaryKey: obj.primaryKey,
          nullable: obj.nullable,
          default: obj.default
        };
      }
      case "index": {
        return {
          _tag: "index",
          columns: obj.columns,
          name: obj.name,
          unique: obj.unique,
          primaryKey: obj.primaryKey
        };
      }
      case "foreignKey": {
        return {
          _tag: "foreignKey",
          references: obj.references,
          key: obj.key,
          columns: obj.columns
        };
      }
      case "dbSchema": {
        return {
          _tag: "dbSchema",
          tables: obj.tables.map(trimInfoForHasing)
        };
      }
      default: {
        throw new Error(`Unreachable: ${obj}`);
      }
    }
  };
  const QueryBuilderAstSymbol = Symbol.for("QueryBuilderAst");
  const QueryBuilderTypeId = Symbol.for("QueryBuilder");
  const isQueryBuilder = (value2) => hasProperty(value2, QueryBuilderTypeId);
  const LeaderPullCursor = Struct({
    mergeCounter: Number$,
    eventNum: EventSequenceNumber
  });
  Struct({
    fileName: String$
  }, { key: String$, value: Any }).annotations({ title: "LiveStore.PersistenceInfo" });
  const BootStateProgress = Struct({
    done: Number$,
    total: Number$
  });
  const BootStatus = Union(Struct({ stage: Literal("loading") }), Struct({ stage: Literal("migrating"), progress: BootStateProgress }), Struct({ stage: Literal("rehydrating"), progress: BootStateProgress }), Struct({ stage: Literal("syncing"), progress: BootStateProgress }), Struct({ stage: Literal("done") })).annotations({ title: "BootStatus" });
  const SessionIdSymbol = Symbol.for("@livestore/session-id");
  const _UnexpectedError = class _UnexpectedError extends TaggedError()("LiveStore.UnexpectedError", {
    cause: Defect,
    note: optional(String$),
    payload: optional(Any)
  }) {
  };
  __publicField(_UnexpectedError, "mapToUnexpectedError", (effect2) => effect2.pipe(mapError$4((cause) => is(_UnexpectedError)(cause) ? cause : new _UnexpectedError({ cause })), catchAllDefect((cause) => new _UnexpectedError({ cause }))));
  __publicField(_UnexpectedError, "mapToUnexpectedErrorStream", (stream) => stream.pipe(mapError((cause) => is(_UnexpectedError)(cause) ? cause : new _UnexpectedError({ cause }))));
  let UnexpectedError = _UnexpectedError;
  class IntentionalShutdownCause extends TaggedError()("LiveStore.IntentionalShutdownCause", {
    reason: Literal("devtools-reset", "devtools-import", "adapter-reset", "manual")
  }) {
  }
  class StoreInterrupted extends TaggedError()("LiveStore.StoreInterrupted", {
    reason: String$
  }) {
  }
  class SqliteError extends TaggedError()("LiveStore.SqliteError", {
    query: optional(Struct({
      sql: String$,
      bindValues: Union(Record({ key: String$, value: Any }), Array$(Any))
    })),
    /** The SQLite result code */
    // code: Schema.optional(Schema.Number),
    // Added string support for Expo SQLite (we should refactor this to have a unified error type)
    code: optional(Union(Number$, String$)),
    /** The original SQLite3 error */
    cause: Defect,
    note: optional(String$)
  }) {
  }
  const MigrationsReportEntry = Struct({
    tableName: String$,
    hashes: Struct({
      expected: Number$,
      actual: optional(Number$)
    })
  });
  const MigrationsReport = Struct({
    migrations: Array$(MigrationsReportEntry)
  });
  const formatWhereClause = (whereConditions, tableDef, bindValues) => {
    if (whereConditions.length === 0)
      return "";
    const whereClause = whereConditions.map(({ col, op, value: value2 }) => {
      if (value2 === null) {
        if (op !== "=" && op !== "!=") {
          throw new Error(`Unsupported operator for NULL value: ${op}`);
        }
        const opStmt = op === "=" ? "IS" : "IS NOT";
        return `${col} ${opStmt} NULL`;
      }
      const colDef = tableDef.sqliteDef.columns[col];
      if (colDef === void 0) {
        throw new Error(`Column ${col} not found`);
      }
      const isArray2 = op === "IN" || op === "NOT IN";
      if (isArray2) {
        if (!Array.isArray(value2)) {
          return shouldNeverHappen(`Expected array value for ${op} operator but got`, value2);
        }
        if (value2.length === 0) {
          return op === "IN" ? "0=1" : "1=1";
        }
        const encodedValues = value2.map((v) => encodeSync(colDef.schema)(v));
        bindValues.push(...encodedValues);
        const placeholders = encodedValues.map(() => "?").join(", ");
        return `${col} ${op} (${placeholders})`;
      } else {
        const encodedValue = encodeSync(colDef.schema)(value2);
        bindValues.push(encodedValue);
        return `${col} ${op} ?`;
      }
    }).join(" AND ");
    return `WHERE ${whereClause}`;
  };
  const formatReturningClause = (returning) => {
    if (!returning || returning.length === 0)
      return "";
    return ` RETURNING ${returning.join(", ")}`;
  };
  const astToSql = (ast) => {
    const bindValues = [];
    if (ast._tag === "InsertQuery") {
      const columns = Object.keys(ast.values);
      const placeholders = columns.map(() => "?").join(", ");
      const encodedValues = encodeSync(ast.tableDef.insertSchema)(ast.values);
      columns.forEach((col) => {
        bindValues.push(encodedValues[col]);
      });
      let insertVerb = "INSERT";
      let conflictClause = "";
      if (ast.onConflict) {
        if (ast.onConflict.action._tag === "replace") {
          insertVerb = "INSERT OR REPLACE";
        } else {
          conflictClause = ` ON CONFLICT (${ast.onConflict.targets.join(", ")}) `;
          if (ast.onConflict.action._tag === "ignore") {
            conflictClause += "DO NOTHING";
          } else {
            const updateValues = ast.onConflict.action.update;
            const updateCols = Object.keys(updateValues);
            if (updateCols.length === 0) {
              throw new Error("No update columns provided for ON CONFLICT DO UPDATE");
            }
            const updates = updateCols.map((col) => {
              const value2 = updateValues[col];
              return value2 === void 0 ? `${col} = excluded.${col}` : `${col} = ?`;
            }).join(", ");
            updateCols.forEach((col) => {
              const value2 = updateValues[col];
              if (value2 !== void 0) {
                const colDef = ast.tableDef.sqliteDef.columns[col];
                if (colDef === void 0) {
                  throw new Error(`Column ${col} not found`);
                }
                const encodedValue = encodeSync(colDef.schema)(value2);
                bindValues.push(encodedValue);
              }
            });
            conflictClause += `DO UPDATE SET ${updates}`;
          }
        }
      }
      let query2 = `${insertVerb} INTO '${ast.tableDef.sqliteDef.name}' (${columns.join(", ")}) VALUES (${placeholders})`;
      query2 += conflictClause;
      query2 += formatReturningClause(ast.returning);
      return { query: query2, bindValues };
    }
    if (ast._tag === "UpdateQuery") {
      const setColumns = Object.keys(ast.values);
      if (setColumns.length === 0) {
        console.warn(`UPDATE query requires at least one column to set (for table ${ast.tableDef.sqliteDef.name}). Running no-op query instead to skip this update query.`);
        return { query: "SELECT 1", bindValues: [] };
      }
      const encodedValues = encodeSync(partial(ast.tableDef.rowSchema))(ast.values);
      setColumns.forEach((col) => {
        bindValues.push(encodedValues[col]);
      });
      let query2 = `UPDATE '${ast.tableDef.sqliteDef.name}' SET ${setColumns.map((col) => `${col} = ?`).join(", ")}`;
      const whereClause = formatWhereClause(ast.where, ast.tableDef, bindValues);
      if (whereClause)
        query2 += ` ${whereClause}`;
      query2 += formatReturningClause(ast.returning);
      return { query: query2, bindValues };
    }
    if (ast._tag === "DeleteQuery") {
      let query2 = `DELETE FROM '${ast.tableDef.sqliteDef.name}'`;
      const whereClause = formatWhereClause(ast.where, ast.tableDef, bindValues);
      if (whereClause)
        query2 += ` ${whereClause}`;
      query2 += formatReturningClause(ast.returning);
      return { query: query2, bindValues };
    }
    if (ast._tag === "CountQuery") {
      const query2 = [
        `SELECT COUNT(*) as count FROM '${ast.tableDef.sqliteDef.name}'`,
        formatWhereClause(ast.where, ast.tableDef, bindValues)
      ].filter((clause) => clause.length > 0).join(" ");
      return { query: query2, bindValues };
    }
    if (ast._tag === "RowQuery") {
      const idColDef = ast.tableDef.sqliteDef.columns.id;
      if (idColDef === void 0) {
        throw new Error("Column id not found for ROW query");
      }
      const encodedId = ast.id === SessionIdSymbol ? ast.id : encodeSync(idColDef.schema)(ast.id);
      return {
        query: `SELECT * FROM '${ast.tableDef.sqliteDef.name}' WHERE id = ?`,
        bindValues: [encodedId]
      };
    }
    const columnsStmt = ast.select.columns.length === 0 ? "*" : ast.select.columns.join(", ");
    const selectStmt = `SELECT ${columnsStmt}`;
    const fromStmt = `FROM '${ast.tableDef.sqliteDef.name}'`;
    const whereStmt = formatWhereClause(ast.where, ast.tableDef, bindValues);
    const orderByStmt = ast.orderBy.length > 0 ? `ORDER BY ${ast.orderBy.map(({ col, direction }) => `${col} ${direction}`).join(", ")}` : "";
    const limitStmt = ast.limit._tag === "Some" ? `LIMIT ?` : "";
    const offsetStmt = ast.offset._tag === "Some" ? `OFFSET ?` : "";
    if (ast.offset._tag === "Some")
      bindValues.push(ast.offset.value);
    if (ast.limit._tag === "Some")
      bindValues.push(ast.limit.value);
    const query = [selectStmt, fromStmt, whereStmt, orderByStmt, offsetStmt, limitStmt].map((clause) => clause.trim()).filter((clause) => clause.length > 0).join(" ");
    return { query, bindValues };
  };
  const makeQueryBuilder = (tableDef, ast = emptyAst(tableDef)) => {
    const api = {
      // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
      select() {
        assertSelectQueryBuilderAst(ast);
        const params = [...arguments];
        if (params.length === 1) {
          const [col] = params;
          return makeQueryBuilder(tableDef, {
            ...ast,
            resultSchemaSingle: ast.resultSchemaSingle.pipe(pluck(col)),
            select: { columns: [col] }
          });
        }
        const columns = params;
        return makeQueryBuilder(tableDef, {
          ...ast,
          resultSchemaSingle: columns.length === 0 ? ast.resultSchemaSingle : ast.resultSchemaSingle.pipe(pick(...columns)),
          select: { columns }
        });
      },
      // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
      where: function() {
        if (ast._tag === "InsertQuery")
          return invalidQueryBuilder("Cannot use where with insert");
        if (ast._tag === "RowQuery")
          return invalidQueryBuilder("Cannot use where with row");
        if (arguments.length === 1) {
          const params = arguments[0];
          const newOps = Object.entries(params).filter(([, value3]) => value3 !== void 0).map(([col2, value3]) => hasProperty(value3, "op") && hasProperty(value3, "value") ? { col: col2, op: value3.op, value: value3.value } : { col: col2, op: "=", value: value3 });
          switch (ast._tag) {
            case "CountQuery":
            case "SelectQuery":
            case "UpdateQuery":
            case "DeleteQuery": {
              return makeQueryBuilder(tableDef, {
                ...ast,
                where: [...ast.where, ...newOps]
              });
            }
            default: {
              return casesHandled(ast);
            }
          }
        }
        const [col, opOrValue, valueOrUndefined] = arguments;
        const op = valueOrUndefined === void 0 ? "=" : opOrValue;
        const value2 = valueOrUndefined === void 0 ? opOrValue : valueOrUndefined;
        switch (ast._tag) {
          case "CountQuery":
          case "SelectQuery":
          case "UpdateQuery":
          case "DeleteQuery": {
            return makeQueryBuilder(tableDef, {
              ...ast,
              where: [...ast.where, { col, op, value: value2 }]
            });
          }
          default: {
            return casesHandled(ast);
          }
        }
      },
      // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
      orderBy() {
        assertSelectQueryBuilderAst(ast);
        if (arguments.length === 0 || arguments.length > 2)
          return invalidQueryBuilder();
        if (arguments.length === 1) {
          const params = arguments[0];
          return makeQueryBuilder(tableDef, {
            ...ast,
            orderBy: [...ast.orderBy, ...params]
          });
        }
        const [col, direction] = arguments;
        return makeQueryBuilder(tableDef, {
          ...ast,
          orderBy: [...ast.orderBy, { col, direction }]
        });
      },
      limit: (limit) => {
        assertSelectQueryBuilderAst(ast);
        return makeQueryBuilder(tableDef, { ...ast, limit: some(limit) });
      },
      offset: (offset) => {
        assertSelectQueryBuilderAst(ast);
        return makeQueryBuilder(tableDef, { ...ast, offset: some(offset) });
      },
      count: () => {
        if (isRowQuery(ast) || ast._tag === "InsertQuery" || ast._tag === "UpdateQuery" || ast._tag === "DeleteQuery")
          return invalidQueryBuilder();
        return makeQueryBuilder(tableDef, {
          _tag: "CountQuery",
          tableDef,
          where: ast.where,
          resultSchema: Struct({ count: Number$ }).pipe(pluck("count"), Array$, headOrElse())
        });
      },
      first: (options2) => {
        assertSelectQueryBuilderAst(ast);
        if (ast.limit._tag === "Some")
          return invalidQueryBuilder(`.first() can't be called after .limit()`);
        return makeQueryBuilder(tableDef, {
          ...ast,
          limit: some(1),
          pickFirst: (options2 == null ? void 0 : options2.fallback) !== void 0 && options2.fallback !== "throws" ? { fallback: options2.fallback } : "throws"
        });
      },
      // // eslint-disable-next-line prefer-arrow/prefer-arrow-functions
      // getOrCreate() {
      //   if (tableDef.options.isClientDocumentTable === false) {
      //     return invalidQueryBuilder(`getOrCreate() is not allowed when table is not a client document table`)
      //   }
      //   // eslint-disable-next-line prefer-rest-params
      //   const params = [...arguments]
      //   let id: string | number
      //   // TODO refactor to handle default id
      //   id = params[0] as string | number
      //   if (id === undefined) {
      //     invalidQueryBuilder(`Id missing for row query on non-singleton table ${tableDef.sqliteDef.name}`)
      //   }
      //   // TODO validate all required columns are present and values are matching the schema
      //   const insertValues: Record<string, unknown> = params[1]?.insertValues ?? {}
      //   return makeQueryBuilder(tableDef, {
      //     _tag: 'RowQuery',
      //     id,
      //     tableDef,
      //     insertValues,
      //   }) as any
      // },
      insert: (values) => {
        const filteredValues = Object.fromEntries(Object.entries(values).filter(([, value2]) => value2 !== void 0));
        return makeQueryBuilder(tableDef, {
          _tag: "InsertQuery",
          tableDef,
          values: filteredValues,
          onConflict: void 0,
          returning: void 0,
          resultSchema: Void
        });
      },
      onConflict: (targetOrTargets, action, updateValues) => {
        const targets = Array.isArray(targetOrTargets) ? targetOrTargets : [targetOrTargets];
        assertInsertQueryBuilderAst(ast);
        const onConflict = value(action).pipe(when("ignore", () => ({ targets, action: { _tag: "ignore" } })), when("replace", () => ({ targets, action: { _tag: "replace" } })), when("update", () => ({ targets, action: { _tag: "update", update: updateValues } })), exhaustive);
        return makeQueryBuilder(tableDef, {
          ...ast,
          onConflict
        });
      },
      returning: (...columns) => {
        assertWriteQueryBuilderAst(ast);
        return makeQueryBuilder(tableDef, {
          ...ast,
          returning: columns,
          resultSchema: tableDef.rowSchema.pipe(pick(...columns), Array$)
        });
      },
      update: (values) => {
        const filteredValues = Object.fromEntries(Object.entries(values).filter(([, value2]) => value2 !== void 0));
        return makeQueryBuilder(tableDef, {
          _tag: "UpdateQuery",
          tableDef,
          values: filteredValues,
          where: [],
          returning: void 0,
          resultSchema: Void
        });
      },
      delete: () => {
        return makeQueryBuilder(tableDef, {
          _tag: "DeleteQuery",
          tableDef,
          where: [],
          returning: void 0,
          resultSchema: Void
        });
      }
    };
    return {
      [QueryBuilderTypeId]: QueryBuilderTypeId,
      [QueryBuilderAstSymbol]: ast,
      ["ResultType"]: "only-for-type-inference",
      asSql: () => astToSql(ast),
      toString: () => {
        try {
          return astToSql(ast).query;
        } catch (cause) {
          console.debug(`QueryBuilder.toString(): Error converting query builder to string`, cause, ast);
          return `Error converting query builder to string`;
        }
      },
      ...api
    };
  };
  const emptyAst = (tableDef) => ({
    _tag: "SelectQuery",
    columns: [],
    pickFirst: false,
    select: { columns: [] },
    orderBy: [],
    offset: none$4(),
    limit: none$4(),
    tableDef,
    where: [],
    resultSchemaSingle: tableDef.rowSchema
  });
  function assertSelectQueryBuilderAst(ast) {
    if (ast._tag !== "SelectQuery") {
      return shouldNeverHappen("Expected SelectQuery but got " + ast._tag);
    }
  }
  function assertInsertQueryBuilderAst(ast) {
    if (ast._tag !== "InsertQuery") {
      return shouldNeverHappen("Expected InsertQuery but got " + ast._tag);
    }
  }
  function assertWriteQueryBuilderAst(ast) {
    if (ast._tag !== "InsertQuery" && ast._tag !== "UpdateQuery" && ast._tag !== "DeleteQuery") {
      return shouldNeverHappen("Expected WriteQuery but got " + ast._tag);
    }
  }
  const isRowQuery = (ast) => ast._tag === "RowQuery";
  const invalidQueryBuilder = (msg) => {
    return shouldNeverHappen("Invalid query builder" + (msg ? `: ${msg}` : ""));
  };
  const getResultSchema = (qb) => {
    const queryAst = qb[QueryBuilderAstSymbol];
    switch (queryAst._tag) {
      case "SelectQuery": {
        const arraySchema = Array$(queryAst.resultSchemaSingle);
        if (queryAst.pickFirst === false) {
          return arraySchema;
        } else if (queryAst.pickFirst === "throws") {
          return arraySchema.pipe(headOrElse());
        } else {
          const fallbackValue = queryAst.pickFirst.fallback();
          return Union(arraySchema, Tuple(Literal(fallbackValue))).pipe(headOrElse(() => fallbackValue));
        }
      }
      case "CountQuery": {
        return Struct({ count: Number$ }).pipe(pluck("count"), Array$, headOrElse());
      }
      case "InsertQuery":
      case "UpdateQuery":
      case "DeleteQuery": {
        if (queryAst.returning && queryAst.returning.length > 0) {
          return queryAst.tableDef.rowSchema.pipe(pick(...queryAst.returning), Array$);
        }
        return Number$;
      }
      case "RowQuery": {
        return queryAst.tableDef.rowSchema.pipe(pluck("value"), annotations({ title: `${queryAst.tableDef.sqliteDef.name}.value` }), Array$, headOrElse());
      }
      default: {
        casesHandled(queryAst);
      }
    }
  };
  const { boolean, integer, text } = SqliteDsl;
  const table = (args2) => {
    const { name, columns: columnOrColumns, ...options2 } = args2;
    const tablePath = name;
    const options_ = {
      isClientDocumentTable: false
    };
    const columns = isColumnDefinition(columnOrColumns) ? { value: columnOrColumns } : columnOrColumns;
    const sqliteDef = table$1(tablePath, columns, (options2 == null ? void 0 : options2.indexes) ?? []);
    const rowSchema = structSchemaForTable(sqliteDef);
    const insertSchema = insertStructSchemaForTable(sqliteDef);
    const tableDef = {
      sqliteDef,
      options: options_,
      rowSchema,
      insertSchema
    };
    const query = makeQueryBuilder(tableDef);
    for (const key of Object.keys(query)) {
      tableDef[key] = query[key];
    }
    tableDef[QueryBuilderAstSymbol] = query[QueryBuilderAstSymbol];
    tableDef[QueryBuilderTypeId] = query[QueryBuilderTypeId];
    return tableDef;
  };
  const SCHEMA_META_TABLE = "__livestore_schema";
  const schemaMetaTable = table({
    name: SCHEMA_META_TABLE,
    columns: {
      tableName: text$1({ primaryKey: true }),
      schemaHash: integer$1({ nullable: false }),
      /** ISO date format */
      updatedAt: text$1({ nullable: false })
    }
  });
  const SCHEMA_EVENT_DEFS_META_TABLE = "__livestore_schema_event_defs";
  const schemaEventDefsMetaTable = table({
    name: SCHEMA_EVENT_DEFS_META_TABLE,
    columns: {
      eventName: text$1({ primaryKey: true }),
      schemaHash: integer$1({ nullable: false }),
      /** ISO date format */
      updatedAt: text$1({ nullable: false })
    }
  });
  const SESSION_CHANGESET_META_TABLE = "__livestore_session_changeset";
  const sessionChangesetMetaTable = table({
    name: SESSION_CHANGESET_META_TABLE,
    columns: {
      // TODO bring back primary key
      seqNumGlobal: integer$1({ schema: GlobalEventSequenceNumber }),
      seqNumClient: integer$1({ schema: ClientEventSequenceNumber }),
      changeset: blob({ nullable: true }),
      debug: json({ nullable: true })
    },
    indexes: [{ columns: ["seqNumGlobal", "seqNumClient"], name: "idx_session_changeset_id" }]
  });
  const LEADER_MERGE_COUNTER_TABLE = "__livestore_leader_merge_counter";
  const leaderMergeCounterTable = table({
    name: LEADER_MERGE_COUNTER_TABLE,
    columns: {
      id: integer$1({ primaryKey: true, schema: Literal(0) }),
      mergeCounter: integer$1({ primaryKey: true })
    }
  });
  const stateSystemTables = [
    schemaMetaTable,
    schemaEventDefsMetaTable,
    sessionChangesetMetaTable,
    leaderMergeCounterTable
  ];
  const isStateSystemTable = (tableName) => stateSystemTables.some((_) => _.sqliteDef.name === tableName);
  const EVENTLOG_META_TABLE = "eventlog";
  const eventlogMetaTable = table({
    name: EVENTLOG_META_TABLE,
    columns: {
      // TODO Adjust modeling so a global event never needs a client id component
      seqNumGlobal: integer$1({ primaryKey: true, schema: GlobalEventSequenceNumber }),
      seqNumClient: integer$1({ primaryKey: true, schema: ClientEventSequenceNumber }),
      parentSeqNumGlobal: integer$1({ schema: GlobalEventSequenceNumber }),
      parentSeqNumClient: integer$1({ schema: ClientEventSequenceNumber }),
      name: text$1({}),
      argsJson: text$1({ schema: parseJson(Any) }),
      clientId: text$1({}),
      sessionId: text$1({}),
      schemaHash: integer$1({}),
      syncMetadataJson: text$1({ schema: parseJson(Option(JsonValue)) })
    },
    indexes: [
      { columns: ["seqNumGlobal"], name: "idx_eventlog_seqNumGlobal" },
      { columns: ["seqNumGlobal", "seqNumClient"], name: "idx_eventlog_seqNum" }
    ]
  });
  const SYNC_STATUS_TABLE = "__livestore_sync_status";
  const syncStatusTable = table({
    name: SYNC_STATUS_TABLE,
    columns: {
      head: integer$1({ primaryKey: true })
    }
  });
  const eventlogSystemTables = [eventlogMetaTable, syncStatusTable];
  const SqlValueSchema = Union(String$, Number$, Uint8Array$, Null);
  Union(Array$(SqlValueSchema), Record({ key: String$, value: SqlValueSchema })).pipe(brand("PreparedBindValues"));
  const sql = (template, ...args2) => {
    let str = "";
    for (const [i, arg] of args2.entries()) {
      str += template[i] + String(arg);
    }
    return str + template[template.length - 1];
  };
  const prepareBindValues = (values, statement) => {
    if (Array.isArray(values))
      return values;
    const result = {};
    for (const [key, value2] of Object.entries(values)) {
      if (statement.includes(key)) {
        result[`$${key}`] = value2;
      }
    }
    return result;
  };
  const dbExecute = (db, queryStr, bindValues) => {
    const stmt = db.prepare(queryStr);
    const preparedBindValues = bindValues ? prepareBindValues(bindValues, queryStr) : void 0;
    stmt.execute(preparedBindValues);
    stmt.finalize();
  };
  const dbSelect = (db, queryStr, bindValues) => {
    const stmt = db.prepare(queryStr);
    const res = stmt.select(void 0);
    stmt.finalize();
    return res;
  };
  const validateSchema = (schema2, schemaManager) => gen$2(function* () {
    const registeredEventDefInfos = schemaManager.getEventDefInfos();
    const missingEventDefs = registeredEventDefInfos.filter((registeredEventDefInfo) => !schema2.eventsDefsMap.has(registeredEventDefInfo.eventName));
    if (missingEventDefs.length > 0) {
      yield* new UnexpectedError({
        cause: `Missing mutation definitions: ${missingEventDefs.map((info) => info.eventName).join(", ")}`
      });
    }
    for (const [, eventDef] of schema2.eventsDefsMap) {
      const registeredEventDefInfo = registeredEventDefInfos.find((info) => info.eventName === eventDef.name);
      validateEventDef(eventDef, schemaManager, registeredEventDefInfo);
    }
  });
  const validateEventDef = (eventDef, schemaManager, registeredEventDefInfo) => {
    const schemaHash = hash$1(eventDef.schema);
    if (registeredEventDefInfo === void 0) {
      schemaManager.setEventDefInfo({
        schemaHash,
        eventName: eventDef.name
      });
      return;
    }
    if (schemaHash === registeredEventDefInfo.schemaHash)
      return;
    schemaManager.setEventDefInfo({
      schemaHash,
      eventName: eventDef.name
    });
  };
  const getMemoizedTimestamp = memoizeByStringifyArgs(() => (/* @__PURE__ */ new Date()).toISOString());
  const makeSchemaManager = (db) => gen$2(function* () {
    yield* migrateTable({
      db,
      tableAst: schemaEventDefsMetaTable.sqliteDef.ast,
      behaviour: "create-if-not-exists"
    });
    return {
      getEventDefInfos: () => dbSelect(db, sql`SELECT * FROM ${SCHEMA_EVENT_DEFS_META_TABLE}`),
      setEventDefInfo: (info) => {
        dbExecute(db, sql`INSERT OR REPLACE INTO ${SCHEMA_EVENT_DEFS_META_TABLE} (eventName, schemaHash, updatedAt) VALUES ($eventName, $schemaHash, $updatedAt)`, {
          eventName: info.eventName,
          schemaHash: info.schemaHash,
          updatedAt: (/* @__PURE__ */ new Date()).toISOString()
        });
      }
    };
  });
  const migrateDb = ({ db, schema: schema2, onProgress }) => gen$2(function* () {
    for (const tableDef of stateSystemTables) {
      yield* migrateTable({
        db,
        tableAst: tableDef.sqliteDef.ast,
        behaviour: "create-if-not-exists"
      });
    }
    const schemaManager = yield* makeSchemaManager(db);
    yield* validateSchema(schema2, schemaManager);
    const schemaMetaRows = dbSelect(db, sql`SELECT * FROM ${SCHEMA_META_TABLE}`);
    const dbSchemaHashByTable = Object.fromEntries(schemaMetaRows.map(({ tableName, schemaHash }) => [tableName, schemaHash]));
    const tableDefs = [
      // NOTE it's important the `SCHEMA_META_TABLE` comes first since we're writing to it below
      ...stateSystemTables,
      ...Array.from(schema2.state.sqlite.tables.values()).filter((_) => !isStateSystemTable(_.sqliteDef.name))
    ];
    const tablesToMigrate = /* @__PURE__ */ new Set();
    const migrationsReportEntries = [];
    for (const tableDef of tableDefs) {
      const tableAst = tableDef.sqliteDef.ast;
      const tableName = tableAst.name;
      const dbSchemaHash = dbSchemaHashByTable[tableName];
      const schemaHash = hash(tableAst);
      if (schemaHash !== dbSchemaHash) {
        tablesToMigrate.add({ tableAst, schemaHash });
        migrationsReportEntries.push({
          tableName,
          hashes: { expected: schemaHash, actual: dbSchemaHash }
        });
      }
    }
    let processedTables = 0;
    const tablesCount = tablesToMigrate.size;
    for (const { tableAst, schemaHash } of tablesToMigrate) {
      yield* migrateTable({ db, tableAst, schemaHash, behaviour: "create-if-not-exists" });
      if (onProgress !== void 0) {
        processedTables++;
        yield* onProgress({ done: processedTables, total: tablesCount });
      }
    }
    return { migrations: migrationsReportEntries };
  });
  const migrateTable = ({ db, tableAst, schemaHash = hash(tableAst), behaviour, skipMetaTable = false }) => gen$2(function* () {
    const tableName = tableAst.name;
    const columnSpec = makeColumnSpec(tableAst);
    {
      dbExecute(db, sql`create table if not exists '${tableName}' (${columnSpec}) strict`);
    }
    for (const index of tableAst.indexes) {
      dbExecute(db, createIndexFromDefinition(tableName, index));
    }
    if (skipMetaTable !== true) {
      const updatedAt = getMemoizedTimestamp();
      dbExecute(db, sql`
      INSERT INTO ${SCHEMA_META_TABLE} (tableName, schemaHash, updatedAt) VALUES ($tableName, $schemaHash, $updatedAt)
        ON CONFLICT (tableName) DO UPDATE SET schemaHash = $schemaHash, updatedAt = $updatedAt;
    `, { tableName, schemaHash, updatedAt });
    }
  }).pipe(withSpan$3("@livestore/common:migrateTable", {
    attributes: {
      "span.label": tableAst.name,
      tableName: tableAst.name
    }
  }));
  const createIndexFromDefinition = (tableName, index) => {
    const uniqueStr = index.unique ? "UNIQUE" : "";
    return sql`create ${uniqueStr} index if not exists '${index.name}' on '${tableName}' (${index.columns.join(", ")})`;
  };
  const makeColumnSpec = (tableAst) => {
    const primaryKeys = tableAst.columns.filter((_) => _.primaryKey).map((_) => `'${_.name}'`);
    const columnDefStrs = tableAst.columns.map(toSqliteColumnSpec);
    if (primaryKeys.length > 0) {
      columnDefStrs.push(`PRIMARY KEY (${primaryKeys.join(", ")})`);
    }
    return columnDefStrs.join(", ");
  };
  const toSqliteColumnSpec = (column2) => {
    const columnTypeStr = column2.type._tag;
    const nullableStr = column2.nullable === false ? "not null" : "";
    const defaultValueStr = (() => {
      if (column2.default._tag === "None")
        return "";
      if (column2.default.value === null)
        return "default null";
      if (isSqlDefaultValue(column2.default.value))
        return `default ${column2.default.value.sql}`;
      const encodeValue = encodeSync(column2.schema);
      const encodedDefaultValue = encodeValue(column2.default.value);
      if (columnTypeStr === "text")
        return `default '${encodedDefaultValue}'`;
      return `default ${encodedDefaultValue}`;
    })();
    return `'${column2.name}' ${columnTypeStr} ${nullableStr} ${defaultValueStr}`;
  };
  const defineEvent = (args2) => {
    const { name, schema: schema2, ...options2 } = args2;
    const makePartialEvent = (args3) => {
      const res = validateEither(schema2)(args3);
      if (res._tag === "Left") {
        shouldNeverHappen(`Invalid event args for event '${name}':`, res.left.message, "\n");
      }
      return { name, args: args3 };
    };
    Object.defineProperty(makePartialEvent, "name", { value: name });
    Object.defineProperty(makePartialEvent, "schema", { value: schema2 });
    Object.defineProperty(makePartialEvent, "encoded", {
      value: (args3) => ({ name, args: args3 })
    });
    Object.defineProperty(makePartialEvent, "options", {
      value: {
        clientOnly: (options2 == null ? void 0 : options2.clientOnly) ?? false,
        facts: (options2 == null ? void 0 : options2.facts) ? (args3, currentFacts) => {
          var _a2, _b2;
          const res = options2.facts(args3, currentFacts);
          return {
            modify: {
              set: ((_a2 = res.modify) == null ? void 0 : _a2.set) ? new Set(res.modify.set) : /* @__PURE__ */ new Set(),
              unset: ((_b2 = res.modify) == null ? void 0 : _b2.unset) ? new Set(res.modify.unset) : /* @__PURE__ */ new Set()
            },
            require: res.require ? new Set(res.require) : /* @__PURE__ */ new Set()
          };
        } : void 0,
        derived: (options2 == null ? void 0 : options2.derived) ?? false
      }
    });
    return makePartialEvent;
  };
  const synced = (args2) => defineEvent({ ...args2, clientOnly: false });
  const defineMaterializer = (eventDef, materializer) => {
    return materializer;
  };
  const materializers$1 = (eventDefRecord, handlers) => {
    return handlers;
  };
  const rawSqlEvent = defineEvent({
    name: "livestore.RawSql",
    schema: Struct({
      sql: String$,
      bindValues: optional(Record({ key: String$, value: Any })),
      writeTables: optional(ReadonlySet(String$))
    }),
    clientOnly: true,
    derived: true
  });
  const rawSqlMaterializer = defineMaterializer(rawSqlEvent, ({ sql: sql2, bindValues, writeTables }) => ({
    sql: sql2,
    bindValues: bindValues ?? {},
    writeTables
  }));
  const clientDocument = ({ name, schema: valueSchema, ...inputOptions }) => {
    const options2 = {
      partialSet: inputOptions.partialSet ?? true,
      default: {
        id: inputOptions.default.id,
        value: inputOptions.default.value
      }
    };
    const columns = {
      id: text$1({ primaryKey: true }),
      value: json({ schema: valueSchema })
    };
    const tableDef = table({ name, columns });
    tableDef.options.isClientDocumentTable = true;
    const { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer } = deriveEventAndMaterializer({
      name,
      valueSchema,
      defaultValue: options2.default.value,
      partialSet: options2.partialSet
    });
    const setEventDef = (...args2) => {
      const [value2, id2 = options2.default.id] = args2;
      return derivedSetEventDef({ id: id2, value: value2 });
    };
    Object.defineProperty(setEventDef, "name", { value: `${name}Set` });
    Object.defineProperty(setEventDef, "schema", {
      value: Struct({
        id: String$,
        value: options2.partialSet ? partial(valueSchema) : valueSchema
      }).annotations({ title: `${name}Set:Args` })
    });
    Object.defineProperty(setEventDef, "options", { value: { derived: true, clientOnly: true, facts: void 0 } });
    const clientDocumentTableDefTrait = {
      get: makeGetQueryBuilder(() => clientDocumentTableDef),
      set: setEventDef,
      Value: "only-for-type-inference",
      default: options2.default,
      valueSchema,
      [ClientDocumentTableDefSymbol]: {
        derived: {
          setEventDef: derivedSetEventDef,
          setMaterializer: derivedSetMaterializer
        },
        options: options2
      }
    };
    const clientDocumentTableDef = {
      ...tableDef,
      ...clientDocumentTableDefTrait
    };
    return clientDocumentTableDef;
  };
  const mergeDefaultValues = (defaultValues, explicitDefaultValues) => {
    if (typeof defaultValues !== "object" || typeof explicitDefaultValues !== "object" || defaultValues === null || explicitDefaultValues === null) {
      return explicitDefaultValues;
    }
    return Object.keys(defaultValues).reduce((acc, key) => {
      acc[key] = explicitDefaultValues[key] ?? defaultValues[key];
      return acc;
    }, {});
  };
  const deriveEventAndMaterializer = ({ name, valueSchema, defaultValue, partialSet }) => {
    const derivedSetEventDef = defineEvent({
      name: `${name}Set`,
      schema: Struct({
        id: Union(String$, UniqueSymbolFromSelf(SessionIdSymbol)),
        value: partialSet ? partial(valueSchema) : valueSchema
      }).annotations({ title: `${name}Set:Args` }),
      clientOnly: true,
      derived: true
    });
    const derivedSetMaterializer = defineMaterializer(derivedSetEventDef, ({ id: id2, value: value2 }) => {
      if (id2 === SessionIdSymbol) {
        return shouldNeverHappen(`SessionIdSymbol needs to be replaced before materializing the set event`);
      }
      const schemaProps = getPropertySignatures(valueSchema.ast);
      if (schemaProps.length === 0 || partialSet === false) {
        const valueColJsonSchema = parseJson(valueSchema);
        const encodedInsertValue = encodeSyncDebug(valueColJsonSchema)(value2 ?? defaultValue);
        const encodedUpdateValue = encodeSyncDebug(valueColJsonSchema)(value2);
        return {
          sql: `INSERT INTO '${name}' (id, value) VALUES (?, ?) ON CONFLICT (id) DO UPDATE SET value = ?`,
          bindValues: [id2, encodedInsertValue, encodedUpdateValue],
          writeTables: /* @__PURE__ */ new Set([name])
        };
      } else {
        const valueColJsonSchema = parseJson(partial(valueSchema));
        const encodedInsertValue = encodeSyncDebug(valueColJsonSchema)(mergeDefaultValues(defaultValue, value2));
        let jsonSetSql = "value";
        const setBindValues = [];
        const keys2 = Object.keys(value2);
        const partialUpdateSchema = valueSchema.pipe(pick(...keys2));
        const encodedPartialUpdate = encodeSyncDebug(partialUpdateSchema)(value2);
        for (const key in encodedPartialUpdate) {
          const encodedValueForKey = encodedPartialUpdate[key];
          if (encodedValueForKey === void 0) {
            continue;
          }
          jsonSetSql = `json_set(${jsonSetSql}, ?, json(?))`;
          setBindValues.push(`$.${key}`, JSON.stringify(encodedValueForKey));
        }
        const onConflictClause = setBindValues.length > 0 ? `ON CONFLICT (id) DO UPDATE SET value = ${jsonSetSql}` : "ON CONFLICT (id) DO NOTHING";
        const sqlQuery = `
      INSERT INTO '${name}' (id, value)
      VALUES (?, ?)
      ${onConflictClause}
    `;
        return {
          sql: sqlQuery,
          bindValues: [id2, encodedInsertValue, ...setBindValues],
          writeTables: /* @__PURE__ */ new Set([name])
        };
      }
    });
    return { eventDef: derivedSetEventDef, materializer: derivedSetMaterializer };
  };
  const tableIsClientDocumentTable = (tableDef) => tableDef.options.isClientDocumentTable === true;
  const makeGetQueryBuilder = (getTableDef) => {
    return (...args2) => {
      const tableDef = getTableDef();
      const [id2 = tableDef[ClientDocumentTableDefSymbol].options.default.id, options2 = {}] = args2;
      const explicitDefaultValues = options2.default ?? tableDef[ClientDocumentTableDefSymbol].options.default.value;
      const ast = {
        _tag: "RowQuery",
        tableDef,
        id: id2,
        explicitDefaultValues
      };
      const query = sql`SELECT * FROM '${tableDef.sqliteDef.name}' WHERE id = ?`;
      return {
        [QueryBuilderTypeId]: QueryBuilderTypeId,
        [QueryBuilderAstSymbol]: ast,
        ResultType: "only-for-type-inference",
        asSql: () => ({ query, bindValues: [id2] }),
        toString: () => query.toString(),
        ...{}
        // Needed for type cast
      };
    };
  };
  const ClientDocumentTableDefSymbol = Symbol("ClientDocumentTableDef");
  const LiveStoreSchemaSymbol = Symbol.for("livestore.LiveStoreSchema");
  const makeSchema = (inputSchema) => {
    var _a2;
    const state2 = inputSchema.state;
    const tables2 = inputSchema.state.sqlite.tables;
    for (const tableDef of stateSystemTables) {
      tables2.set(tableDef.sqliteDef.name, tableDef);
    }
    const eventsDefsMap = /* @__PURE__ */ new Map();
    if (isReadonlyArray(inputSchema.events)) {
      for (const eventDef of inputSchema.events) {
        eventsDefsMap.set(eventDef.name, eventDef);
      }
    } else {
      for (const eventDef of Object.values(inputSchema.events ?? {})) {
        if (eventsDefsMap.has(eventDef.name)) {
          shouldNeverHappen(`Duplicate event name: ${eventDef.name}. Please use unique names for events.`);
        }
        eventsDefsMap.set(eventDef.name, eventDef);
      }
    }
    eventsDefsMap.set(rawSqlEvent.name, rawSqlEvent);
    for (const tableDef of tables2.values()) {
      if (tableIsClientDocumentTable(tableDef) && eventsDefsMap.has(tableDef.set.name) === false) {
        eventsDefsMap.set(tableDef.set.name, tableDef.set);
      }
    }
    return {
      LiveStoreSchemaSymbol,
      _DbSchemaType: Symbol.for("livestore.DbSchemaType"),
      _EventDefMapType: Symbol.for("livestore.EventDefMapType"),
      state: state2,
      eventsDefsMap,
      devtools: {
        alias: ((_a2 = inputSchema.devtools) == null ? void 0 : _a2.alias) ?? "default"
      }
    };
  };
  const getEventDef = (schema2, eventName) => {
    const eventDef = schema2.eventsDefsMap.get(eventName);
    if (eventDef === void 0) {
      return shouldNeverHappen(`No mutation definition found for \`${eventName}\`.`);
    }
    const materializer = schema2.state.materializers.get(eventName);
    if (materializer === void 0) {
      return shouldNeverHappen(`No materializer found for \`${eventName}\`.`);
    }
    return { eventDef, materializer };
  };
  const getExecStatementsFromMaterializer = ({ eventDef, materializer, dbState, event }) => {
    var _a2;
    const eventArgsDecoded = event.decoded === void 0 ? decodeUnknownSync(eventDef.schema)(event.encoded.args) : event.decoded.args;
    const eventArgsEncoded = isNil((_a2 = event.decoded) == null ? void 0 : _a2.args) ? void 0 : encodeUnknownSync(eventDef.schema)(event.decoded.args);
    const query = (rawQueryOrQueryBuilder) => {
      if (isQueryBuilder(rawQueryOrQueryBuilder)) {
        const { query: query2, bindValues } = rawQueryOrQueryBuilder.asSql();
        const rawResults = dbState.select(query2, prepareBindValues(bindValues, query2));
        const resultSchema = getResultSchema(rawQueryOrQueryBuilder);
        return decodeSync(resultSchema)(rawResults);
      } else {
        const { query: query2, bindValues } = rawQueryOrQueryBuilder;
        return dbState.select(query2, prepareBindValues(bindValues, query2));
      }
    };
    const statementResults = fromMaterializerResult(materializer(eventArgsDecoded, {
      eventDef,
      query,
      // TODO properly implement this
      currentFacts: /* @__PURE__ */ new Map()
    }));
    return statementResults.map((statementRes) => {
      const statementSql = statementRes.sql;
      const bindValues = typeof statementRes === "string" ? eventArgsEncoded : statementRes.bindValues;
      const writeTables = typeof statementRes === "string" ? void 0 : statementRes.writeTables;
      return { statementSql, bindValues: prepareBindValues(bindValues ?? {}, statementSql), writeTables };
    });
  };
  const makeMaterializerHash = ({ schema: schema2, dbState }) => (event) => {
    if (isDevEnv()) {
      const { eventDef, materializer } = getEventDef(schema2, event.name);
      const materializerResults = getExecStatementsFromMaterializer({
        eventDef,
        materializer,
        dbState,
        event: { decoded: void 0, encoded: event }
      });
      return some(string(JSON.stringify(materializerResults)));
    }
    return none$4();
  };
  const hashMaterializerResults = (materializerResults) => string(JSON.stringify(materializerResults));
  const fromMaterializerResult = (materializerResult) => {
    if (isReadonlyArray(materializerResult)) {
      return materializerResult.flatMap(fromMaterializerResult);
    }
    if (isQueryBuilder(materializerResult)) {
      const { query, bindValues } = materializerResult.asSql();
      return [{ sql: query, bindValues, writeTables: void 0 }];
    } else if (typeof materializerResult === "string") {
      return [{ sql: materializerResult, bindValues: {}, writeTables: void 0 }];
    } else {
      return [
        {
          sql: materializerResult.sql,
          bindValues: materializerResult.bindValues,
          writeTables: materializerResult.writeTables
        }
      ];
    }
  };
  const makeState = (inputSchema) => {
    const inputTables = Array.isArray(inputSchema.tables) ? inputSchema.tables : Object.values(inputSchema.tables);
    const tables2 = /* @__PURE__ */ new Map();
    for (const tableDef of inputTables) {
      const sqliteDef = tableDef.sqliteDef;
      if (tables2.has(sqliteDef.ast.name)) {
        shouldNeverHappen(`Duplicate table name: ${sqliteDef.ast.name}. Please use unique names for tables.`);
      }
      tables2.set(sqliteDef.ast.name, tableDef);
    }
    for (const tableDef of stateSystemTables) {
      tables2.set(tableDef.sqliteDef.name, tableDef);
    }
    const materializers2 = /* @__PURE__ */ new Map();
    for (const [name, materializer] of Object.entries(inputSchema.materializers)) {
      materializers2.set(name, materializer);
    }
    materializers2.set(rawSqlEvent.name, rawSqlMaterializer);
    for (const tableDef of inputTables) {
      if (tableIsClientDocumentTable(tableDef)) {
        materializers2.set(tableDef[ClientDocumentTableDefSymbol].derived.setEventDef.name, tableDef[ClientDocumentTableDefSymbol].derived.setMaterializer);
      }
    }
    const hash$12 = hash({
      _tag: "dbSchema",
      tables: [...tables2.values()].map((_) => _.sqliteDef.ast)
    });
    return { sqlite: { tables: tables2, migrations: inputSchema.migrations ?? { strategy: "auto" }, hash: hash$12 }, materializers: materializers2 };
  };
  Struct({
    name: String$,
    args: Any,
    seqNum: EventSequenceNumber,
    parentSeqNum: EventSequenceNumber,
    clientId: String$,
    sessionId: String$
  }).annotations({ title: "LiveStoreEvent.AnyDecoded" });
  const AnyEncoded = Struct({
    name: String$,
    args: Any,
    seqNum: EventSequenceNumber,
    parentSeqNum: EventSequenceNumber,
    clientId: String$,
    sessionId: String$
  }).annotations({ title: "LiveStoreEvent.AnyEncoded" });
  const AnyEncodedGlobal = Struct({
    name: String$,
    args: Any,
    seqNum: GlobalEventSequenceNumber,
    parentSeqNum: GlobalEventSequenceNumber,
    clientId: String$,
    sessionId: String$
  }).annotations({ title: "LiveStoreEvent.AnyEncodedGlobal" });
  const PartialAnyEncoded = Struct({
    name: String$,
    args: Any
  });
  const makeEventDefSchema = (schema2) => Union(...[...schema2.eventsDefsMap.values()].map((def) => Struct({
    name: Literal(def.name),
    args: def.schema,
    seqNum: EventSequenceNumber,
    parentSeqNum: EventSequenceNumber,
    clientId: String$,
    sessionId: String$
  }))).annotations({ title: "EventDef" });
  const _EncodedWithMeta = class _EncodedWithMeta extends Class("LiveStoreEvent.EncodedWithMeta")({
    name: String$,
    args: Any,
    seqNum: EventSequenceNumber,
    parentSeqNum: EventSequenceNumber,
    clientId: String$,
    sessionId: String$,
    // TODO get rid of `meta` again by cleaning up the usage implementations
    meta: Struct({
      sessionChangeset: Union(TaggedStruct("sessionChangeset", {
        data: Uint8Array$,
        debug: Any.pipe(optional)
      }), TaggedStruct("no-op", {}), TaggedStruct("unset", {})),
      syncMetadata: Option(JsonValue),
      /** Used to detect if the materializer is side effecting (during dev) */
      materializerHashLeader: Option(Number$),
      materializerHashSession: Option(Number$)
    }).pipe(mutable, optional, withDefaults({
      constructor: () => ({
        sessionChangeset: { _tag: "unset" },
        syncMetadata: none$4(),
        materializerHashLeader: none$4(),
        materializerHashSession: none$4()
      }),
      decoding: () => ({
        sessionChangeset: { _tag: "unset" },
        syncMetadata: none$4(),
        materializerHashLeader: none$4(),
        materializerHashSession: none$4()
      })
    }))
  }) {
    constructor() {
      super(...arguments);
      __publicField(this, "toJSON", () => {
        return {
          seqNum: `${toString(this.seqNum)} → ${toString(this.parentSeqNum)} (${this.clientId}, ${this.sessionId})`,
          name: this.name,
          args: this.args
        };
      });
      /**
       * Example: (global event)
       * For event e2 → e1 which should be rebased on event e3 → e2
       * the resulting event num will be e4 → e3
       *
       * Example: (client event)
       * For event e2+1 → e2 which should be rebased on event e3 → e2
       * the resulting event num will be e3+1 → e3
       *
       * Syntax: e2+2 → e2+1
       *          ^ ^    ^ ^
       *          | |    | +- client parent number
       *          | |    +--- global parent number
       *          | +-- client number
       *          +---- global number
       * Client num is ommitted for global events
       */
      __publicField(this, "rebase", (parentSeqNum, isClient) => new _EncodedWithMeta({
        ...this,
        ...nextPair(parentSeqNum, isClient)
      }));
      __publicField(this, "toGlobal", () => ({
        ...this,
        seqNum: this.seqNum.global,
        parentSeqNum: this.parentSeqNum.global
      }));
    }
  };
  __publicField(_EncodedWithMeta, "fromGlobal", (event, meta) => new _EncodedWithMeta({
    ...event,
    seqNum: { global: event.seqNum, client: clientDefault },
    parentSeqNum: { global: event.parentSeqNum, client: clientDefault },
    meta: {
      sessionChangeset: { _tag: "unset" },
      syncMetadata: meta.syncMetadata,
      materializerHashLeader: meta.materializerHashLeader,
      materializerHashSession: meta.materializerHashSession
    }
  }));
  let EncodedWithMeta = _EncodedWithMeta;
  const isEqualEncoded = (a, b) => a.seqNum.global === b.seqNum.global && a.seqNum.client === b.seqNum.client && a.name === b.name && a.clientId === b.clientId && a.sessionId === b.sessionId && // TODO use schema equality here
  JSON.stringify(a.args) === JSON.stringify(b.args);
  const rematerializeFromEventlog = ({
    dbEventlog,
    // TODO re-use this db when bringing back the boot in-memory db implementation
    // db,
    schema: schema2,
    onProgress,
    materializeEvent
  }) => gen$2(function* () {
    const eventsCount = dbEventlog.select(`SELECT COUNT(*) AS count FROM ${EVENTLOG_META_TABLE}`)[0].count;
    const hashEventDef = memoizeByRef((event) => hash$1(event.schema));
    const processEvent = (row) => gen$2(function* () {
      const eventDef = getEventDef(schema2, row.name);
      if (hashEventDef(eventDef.eventDef) !== row.schemaHash) {
        yield* logWarning(`Schema hash mismatch for event definition ${row.name}. Trying to materialize event anyway.`);
      }
      const args2 = JSON.parse(row.argsJson);
      yield* decodeUnknown(eventDef.eventDef.schema)(args2).pipe(mapError$4((cause) => UnexpectedError.make({
        cause,
        note: `There was an error during rematerializing from the eventlog while decoding
the persisted event args for event definition "${row.name}".
This likely means the schema has changed in an incompatible way.
`
      })));
      const eventEncoded = EncodedWithMeta.make({
        seqNum: { global: row.seqNumGlobal, client: row.seqNumClient },
        parentSeqNum: { global: row.parentSeqNumGlobal, client: row.parentSeqNumClient },
        name: row.name,
        args: args2,
        clientId: row.clientId,
        sessionId: row.sessionId
      });
      yield* materializeEvent(eventEncoded, { skipEventlog: true });
    }).pipe(withSpan$3(`@livestore/common:rematerializeFromEventlog:processEvent`));
    const CHUNK_SIZE = 100;
    const stmt = dbEventlog.prepare(sql`\
SELECT * FROM ${EVENTLOG_META_TABLE} 
WHERE seqNumGlobal > $seqNumGlobal OR (seqNumGlobal = $seqNumGlobal AND seqNumClient > $seqNumClient)
ORDER BY seqNumGlobal ASC, seqNumClient ASC
LIMIT ${CHUNK_SIZE}
`);
    let processedEvents = 0;
    yield* unfoldChunk({ _tag: "Initial " }, (item) => {
      if (isChunk(item) && item.length === 0)
        return none$4();
      const lastId = isChunk(item) ? last(item).pipe(map$h((_) => ({ global: _.seqNumGlobal, client: _.seqNumClient })), getOrElse(() => ROOT)) : ROOT;
      const nextItem = fromIterable$7(stmt.select({
        $seqNumGlobal: lastId == null ? void 0 : lastId.global,
        $seqNumClient: lastId == null ? void 0 : lastId.client
      }));
      const prevItem = isChunk(item) ? item : empty$r();
      return some([prevItem, nextItem]);
    }).pipe(bufferChunks({ capacity: 2 }), tap((row) => gen$2(function* () {
      yield* processEvent(row);
      processedEvents++;
      yield* onProgress({ done: processedEvents, total: eventsCount });
    })), runDrain);
  }).pipe(withPerformanceMeasure("@livestore/common:rematerializeFromEventlog"), withSpan$3("@livestore/common:rematerializeFromEventlog"));
  class IsOfflineError extends TaggedError()("IsOfflineError", {}) {
  }
  class InvalidPushError extends TaggedError()("InvalidPushError", {
    reason: Union(TaggedStruct("Unexpected", {
      message: String$
    }), TaggedStruct("ServerAhead", {
      minimumExpectedNum: Number$,
      providedNum: Number$
    }))
  }) {
  }
  class InvalidPullError extends TaggedError()("InvalidPullError", {
    message: String$
  }) {
  }
  class LeaderAheadError extends TaggedError()("LeaderAheadError", {
    minimumExpectedNum: EventSequenceNumber,
    providedNum: EventSequenceNumber
    /** Generation number the client session should use for subsequent pushes */
    // nextGeneration: Schema.Number,
  }) {
  }
  class SyncState extends Class("SyncState")({
    pending: Array$(EncodedWithMeta),
    /** What this node expects the next upstream node to have as its own local head */
    upstreamHead: EventSequenceNumber,
    /** Equivalent to `pending.at(-1)?.id` if there are pending events */
    localHead: EventSequenceNumber
  }) {
    constructor() {
      super(...arguments);
      __publicField(this, "toJSON", () => ({
        pending: this.pending.map((e) => e.toJSON()),
        upstreamHead: toString(this.upstreamHead),
        localHead: toString(this.localHead)
      }));
    }
  }
  class PayloadUpstreamRebase extends TaggedStruct("upstream-rebase", {
    /** Events which need to be rolled back */
    rollbackEvents: Array$(EncodedWithMeta),
    /** Events which need to be applied after the rollback (already rebased by the upstream node) */
    newEvents: Array$(EncodedWithMeta)
  }) {
  }
  class PayloadUpstreamAdvance extends TaggedStruct("upstream-advance", {
    newEvents: Array$(EncodedWithMeta)
  }) {
  }
  class PayloadLocalPush extends TaggedStruct("local-push", {
    newEvents: Array$(EncodedWithMeta)
  }) {
  }
  class Payload extends Union(PayloadUpstreamRebase, PayloadUpstreamAdvance, PayloadLocalPush) {
  }
  class PayloadUpstream extends Union(PayloadUpstreamRebase, PayloadUpstreamAdvance) {
  }
  class MergeContext extends Class("MergeContext")({
    payload: Payload,
    syncState: SyncState
  }) {
    constructor() {
      super(...arguments);
      __publicField(this, "toJSON", () => {
        const payload = value(this.payload).pipe(tag$2("local-push", () => ({
          _tag: "local-push",
          newEvents: this.payload.newEvents.map((e) => e.toJSON())
        })), tag$2("upstream-advance", () => ({
          _tag: "upstream-advance",
          newEvents: this.payload.newEvents.map((e) => e.toJSON())
        })), tag$2("upstream-rebase", (payload2) => ({
          _tag: "upstream-rebase",
          newEvents: payload2.newEvents.map((e) => e.toJSON()),
          rollbackEvents: payload2.rollbackEvents.map((e) => e.toJSON())
        })), exhaustive);
        return {
          payload,
          syncState: this.syncState.toJSON()
        };
      });
    }
  }
  class MergeResultAdvance extends Class("MergeResultAdvance")({
    _tag: Literal("advance"),
    newSyncState: SyncState,
    newEvents: Array$(EncodedWithMeta),
    /** Events which were previously pending but are now confirmed */
    confirmedEvents: Array$(EncodedWithMeta),
    mergeContext: MergeContext
  }) {
    constructor() {
      super(...arguments);
      __publicField(this, "toJSON", () => {
        return {
          _tag: this._tag,
          newSyncState: this.newSyncState.toJSON(),
          newEvents: this.newEvents.map((e) => e.toJSON()),
          confirmedEvents: this.confirmedEvents.map((e) => e.toJSON()),
          mergeContext: this.mergeContext.toJSON()
        };
      });
    }
  }
  class MergeResultRebase extends Class("MergeResultRebase")({
    _tag: Literal("rebase"),
    newSyncState: SyncState,
    newEvents: Array$(EncodedWithMeta),
    /** Events which need to be rolled back */
    rollbackEvents: Array$(EncodedWithMeta),
    mergeContext: MergeContext
  }) {
    constructor() {
      super(...arguments);
      __publicField(this, "toJSON", () => {
        return {
          _tag: this._tag,
          newSyncState: this.newSyncState.toJSON(),
          newEvents: this.newEvents.map((e) => e.toJSON()),
          rollbackEvents: this.rollbackEvents.map((e) => e.toJSON()),
          mergeContext: this.mergeContext.toJSON()
        };
      });
    }
  }
  class MergeResultReject extends Class("MergeResultReject")({
    _tag: Literal("reject"),
    /** The minimum id that the new events must have */
    expectedMinimumId: EventSequenceNumber,
    mergeContext: MergeContext
  }) {
    constructor() {
      super(...arguments);
      __publicField(this, "toJSON", () => {
        return {
          _tag: this._tag,
          expectedMinimumId: toString(this.expectedMinimumId),
          mergeContext: this.mergeContext.toJSON()
        };
      });
    }
  }
  class MergeResultUnexpectedError extends Class("MergeResultUnexpectedError")({
    _tag: Literal("unexpected-error"),
    cause: UnexpectedError
  }) {
  }
  class MergeResult extends Union(MergeResultAdvance, MergeResultRebase, MergeResultReject, MergeResultUnexpectedError) {
  }
  const unexpectedError = (cause) => {
    if (LS_DEV) {
      debugger;
    }
    return MergeResultUnexpectedError.make({
      _tag: "unexpected-error",
      cause: new UnexpectedError({ cause })
    });
  };
  const merge = ({ syncState, payload, isClientEvent, isEqualEvent, ignoreClientEvents = false }) => {
    var _a2, _b2, _c2;
    validateSyncState(syncState);
    validatePayload(payload);
    const mergeContext = MergeContext.make({ payload, syncState });
    switch (payload._tag) {
      case "upstream-rebase": {
        const rollbackEvents = [...payload.rollbackEvents, ...syncState.pending];
        const newUpstreamHead = ((_a2 = payload.newEvents.at(-1)) == null ? void 0 : _a2.seqNum) ?? syncState.upstreamHead;
        const rebasedPending = rebaseEvents({
          events: syncState.pending,
          baseEventSequenceNumber: newUpstreamHead,
          isClientEvent
        });
        return validateMergeResult(MergeResultRebase.make({
          _tag: "rebase",
          newSyncState: new SyncState({
            pending: rebasedPending,
            upstreamHead: newUpstreamHead,
            localHead: ((_b2 = rebasedPending.at(-1)) == null ? void 0 : _b2.seqNum) ?? newUpstreamHead
          }),
          newEvents: [...payload.newEvents, ...rebasedPending],
          rollbackEvents,
          mergeContext
        }));
      }
      // #region upstream-advance
      case "upstream-advance": {
        if (payload.newEvents.length === 0) {
          return validateMergeResult(MergeResultAdvance.make({
            _tag: "advance",
            newSyncState: new SyncState({
              pending: syncState.pending,
              upstreamHead: syncState.upstreamHead,
              localHead: syncState.localHead
            }),
            newEvents: [],
            confirmedEvents: [],
            mergeContext
          }));
        }
        for (let i = 1; i < payload.newEvents.length; i++) {
          if (isGreaterThan(payload.newEvents[i - 1].seqNum, payload.newEvents[i].seqNum)) {
            return unexpectedError(`Events must be sorted in ascending order by event number. Received: [${payload.newEvents.map((e) => toString(e.seqNum)).join(", ")}]`);
          }
        }
        if (isGreaterThan(syncState.upstreamHead, payload.newEvents[0].seqNum) || isEqual(syncState.upstreamHead, payload.newEvents[0].seqNum)) {
          return unexpectedError(`Incoming events must be greater than upstream head. Expected greater than: ${toString(syncState.upstreamHead)}. Received: [${payload.newEvents.map((e) => toString(e.seqNum)).join(", ")}]`);
        }
        const newUpstreamHead = payload.newEvents.at(-1).seqNum;
        const divergentPendingIndex = findDivergencePoint({
          existingEvents: syncState.pending,
          incomingEvents: payload.newEvents,
          isEqualEvent,
          isClientEvent,
          ignoreClientEvents
        });
        if (divergentPendingIndex === -1) {
          const pendingEventSequenceNumbers = new Set(syncState.pending.map((e) => `${e.seqNum.global},${e.seqNum.client}`));
          const newEvents = payload.newEvents.filter((e) => !pendingEventSequenceNumbers.has(`${e.seqNum.global},${e.seqNum.client}`));
          let clientIndexOffset = 0;
          const [pendingMatching, pendingRemaining] = splitWhere$1(syncState.pending, (pendingEvent, index) => {
            if (ignoreClientEvents && isClientEvent(pendingEvent)) {
              clientIndexOffset++;
              return false;
            }
            const newEvent = payload.newEvents.at(index - clientIndexOffset);
            if (!newEvent) {
              return true;
            }
            return isEqualEvent(pendingEvent, newEvent) === false;
          });
          return validateMergeResult(MergeResultAdvance.make({
            _tag: "advance",
            newSyncState: new SyncState({
              pending: pendingRemaining,
              upstreamHead: newUpstreamHead,
              localHead: ((_c2 = pendingRemaining.at(-1)) == null ? void 0 : _c2.seqNum) ?? max(syncState.localHead, newUpstreamHead)
            }),
            newEvents,
            confirmedEvents: pendingMatching,
            mergeContext
          }));
        } else {
          const divergentPending = syncState.pending.slice(divergentPendingIndex);
          const rebasedPending = rebaseEvents({
            events: divergentPending,
            baseEventSequenceNumber: newUpstreamHead,
            isClientEvent
          });
          const divergentNewEventsIndex = findDivergencePoint({
            existingEvents: payload.newEvents,
            incomingEvents: syncState.pending,
            isEqualEvent,
            isClientEvent,
            ignoreClientEvents
          });
          return validateMergeResult(MergeResultRebase.make({
            _tag: "rebase",
            newSyncState: new SyncState({
              pending: rebasedPending,
              upstreamHead: newUpstreamHead,
              localHead: rebasedPending.at(-1).seqNum
            }),
            newEvents: [...payload.newEvents.slice(divergentNewEventsIndex), ...rebasedPending],
            rollbackEvents: divergentPending,
            mergeContext
          }));
        }
      }
      // #endregion
      // This is the same as what's running in the sync backend
      case "local-push": {
        if (payload.newEvents.length === 0) {
          return validateMergeResult(MergeResultAdvance.make({
            _tag: "advance",
            newSyncState: syncState,
            newEvents: [],
            confirmedEvents: [],
            mergeContext
          }));
        }
        const newEventsFirst = payload.newEvents.at(0);
        const invalidEventSequenceNumber = isGreaterThan(newEventsFirst.seqNum, syncState.localHead) === false;
        if (invalidEventSequenceNumber) {
          const expectedMinimumId = nextPair(syncState.localHead, true).seqNum;
          return validateMergeResult(MergeResultReject.make({
            _tag: "reject",
            expectedMinimumId,
            mergeContext
          }));
        } else {
          return validateMergeResult(MergeResultAdvance.make({
            _tag: "advance",
            newSyncState: new SyncState({
              pending: [...syncState.pending, ...payload.newEvents],
              upstreamHead: syncState.upstreamHead,
              localHead: payload.newEvents.at(-1).seqNum
            }),
            newEvents: payload.newEvents,
            confirmedEvents: [],
            mergeContext
          }));
        }
      }
      default: {
        casesHandled(payload);
      }
    }
  };
  const findDivergencePoint = ({ existingEvents, incomingEvents, isEqualEvent, isClientEvent, ignoreClientEvents }) => {
    if (ignoreClientEvents) {
      const filteredExistingEvents = existingEvents.filter((event) => !isClientEvent(event));
      const divergencePointWithoutClientEvents = findDivergencePoint({
        existingEvents: filteredExistingEvents,
        incomingEvents,
        isEqualEvent,
        isClientEvent,
        ignoreClientEvents: false
      });
      if (divergencePointWithoutClientEvents === -1)
        return -1;
      const divergencePointEventSequenceNumber = existingEvents[divergencePointWithoutClientEvents].seqNum;
      return existingEvents.findIndex((event) => isEqual(event.seqNum, divergencePointEventSequenceNumber));
    }
    return existingEvents.findIndex((existingEvent, index) => {
      const incomingEvent = incomingEvents[index];
      return incomingEvent && !isEqualEvent(existingEvent, incomingEvent);
    });
  };
  const rebaseEvents = ({ events: events2, baseEventSequenceNumber, isClientEvent }) => {
    let prevEventSequenceNumber = baseEventSequenceNumber;
    return events2.map((event) => {
      const isLocal = isClientEvent(event);
      const newEvent = event.rebase(prevEventSequenceNumber, isLocal);
      prevEventSequenceNumber = newEvent.seqNum;
      return newEvent;
    });
  };
  const validatePayload = (payload) => {
    for (let i = 1; i < payload.newEvents.length; i++) {
      if (isGreaterThanOrEqual(payload.newEvents[i - 1].seqNum, payload.newEvents[i].seqNum)) {
        return unexpectedError(`Events must be ordered in monotonically ascending order by eventNum. Received: [${payload.newEvents.map((e) => toString(e.seqNum)).join(", ")}]`);
      }
    }
  };
  const validateSyncState = (syncState) => {
    for (let i = 0; i < syncState.pending.length; i++) {
      const event = syncState.pending[i];
      const nextEvent = syncState.pending[i + 1];
      if (nextEvent === void 0)
        break;
      if (isGreaterThanOrEqual(event.seqNum, nextEvent.seqNum)) {
        shouldNeverHappen(`Events must be ordered in monotonically ascending order by eventNum. Received: [${syncState.pending.map((e) => toString(e.seqNum)).join(", ")}]`, {
          event,
          nextEvent
        });
      }
      const globalIdHasIncreased = nextEvent.seqNum.global > event.seqNum.global;
      if (globalIdHasIncreased) {
        if (nextEvent.seqNum.client !== 0) {
          shouldNeverHappen(`New global events must point to clientId 0 in the parentSeqNum. Received: (${toString(nextEvent.seqNum)})`, syncState.pending, {
            event,
            nextEvent
          });
        }
      } else {
        if (isEqual(nextEvent.parentSeqNum, event.seqNum) === false) {
          shouldNeverHappen("Events must be linked in a continuous chain via the parentSeqNum", syncState.pending, {
            event,
            nextEvent
          });
        }
      }
    }
  };
  const validateMergeResult = (mergeResult) => {
    if (mergeResult._tag === "unexpected-error" || mergeResult._tag === "reject")
      return mergeResult;
    validateSyncState(mergeResult.newSyncState);
    if (isGreaterThan(mergeResult.newSyncState.upstreamHead, mergeResult.newSyncState.localHead)) {
      shouldNeverHappen("Local head must be greater than or equal to upstream head", {
        localHead: mergeResult.newSyncState.localHead,
        upstreamHead: mergeResult.newSyncState.upstreamHead
      });
    }
    if (isGreaterThanOrEqual(mergeResult.newSyncState.localHead, mergeResult.mergeContext.syncState.localHead) === false) {
      shouldNeverHappen("New local head must be greater than or equal to the previous local head", {
        localHead: mergeResult.newSyncState.localHead,
        previousLocalHead: mergeResult.mergeContext.syncState.localHead
      });
    }
    if (isGreaterThanOrEqual(mergeResult.newSyncState.upstreamHead, mergeResult.mergeContext.syncState.upstreamHead) === false) {
      shouldNeverHappen("New upstream head must be greater than or equal to the previous upstream head", {
        upstreamHead: mergeResult.newSyncState.upstreamHead,
        previousUpstreamHead: mergeResult.mergeContext.syncState.upstreamHead
      });
    }
    return mergeResult;
  };
  const urlAlphabet = "useandom-26T198340PX75pxJACKVERYMINDBUSHWOLF_GQZbfghjklqvwyzrict";
  let nanoid = (size2 = 21) => {
    let id2 = "";
    let bytes = crypto.getRandomValues(new Uint8Array(size2 |= 0));
    while (size2--) {
      id2 += urlAlphabet[bytes[size2] & 63];
    }
    return id2;
  };
  const liveStoreVersion$1 = "0.3.1";
  const liveStoreStorageFormatVersion = 4;
  const NetworkStatus = Struct({
    isConnected: Boolean$,
    timestampMs: Number$,
    /** Whether the network status devtools latch is closed. Used to simulate network disconnection. */
    latchClosed: Boolean$
  });
  const requestId = String$;
  const clientId = String$;
  const liveStoreVersion = Literal(liveStoreVersion$1);
  const LSDMessage = (tag2, fields) => TaggedStruct(tag2, {
    liveStoreVersion,
    ...fields
  }).annotations({ identifier: tag2 });
  const LSDChannelMessage = (tag2, fields) => LSDMessage(tag2, {
    clientId,
    ...fields
  });
  const LSDReqResMessage = (tag2, fields) => LSDChannelMessage(tag2, {
    requestId,
    ...fields
  });
  const LeaderReqResMessage = (tag2, fields) => {
    const Success = TaggedStruct(`${tag2}.Response.Success`, {
      requestId,
      liveStoreVersion,
      ...fields.success
    }).annotations({ identifier: `${tag2}.Response.Success` });
    const Error2 = fields.error ? TaggedStruct(`${tag2}.Response.Error`, {
      requestId,
      liveStoreVersion,
      ...fields.error
    }).annotations({ identifier: `${tag2}.Response.Error` }) : Never;
    return {
      Request: TaggedStruct(`${tag2}.Request`, {
        requestId,
        liveStoreVersion,
        ...fields.payload
      }).annotations({ identifier: `${tag2}.Request` }),
      Response: Union(Success, Error2),
      Success,
      Error: Error2
    };
  };
  class ResetAllDataReq extends LSDReqResMessage("LSD.Leader.ResetAllDataReq", {
    mode: Literal("all-data", "only-app-db")
  }) {
  }
  class DatabaseFileInfoReq extends LSDReqResMessage("LSD.Leader.DatabaseFileInfoReq", {}) {
  }
  class DatabaseFileInfo extends Struct({
    fileSize: Number$,
    persistenceInfo: Struct({ fileName: String$ }, { key: String$, value: Any })
  }) {
  }
  class DatabaseFileInfoRes extends LSDReqResMessage("LSD.Leader.DatabaseFileInfoRes", {
    state: DatabaseFileInfo,
    eventlog: DatabaseFileInfo
  }) {
  }
  class NetworkStatusSubscribe extends LSDReqResMessage("LSD.Leader.NetworkStatusSubscribe", {
    subscriptionId: String$
  }) {
  }
  class NetworkStatusUnsubscribe extends LSDReqResMessage("LSD.Leader.NetworkStatusUnsubscribe", {
    subscriptionId: String$
  }) {
  }
  class NetworkStatusRes extends LSDReqResMessage("LSD.Leader.NetworkStatusRes", {
    networkStatus: NetworkStatus,
    subscriptionId: String$
  }) {
  }
  class SyncingInfoReq extends LSDReqResMessage("LSD.Leader.SyncingInfoReq", {}) {
  }
  class SyncingInfo extends Struct({
    enabled: Boolean$,
    metadata: Record({ key: String$, value: Any })
  }) {
  }
  class SyncingInfoRes extends LSDReqResMessage("LSD.Leader.SyncingInfoRes", {
    syncingInfo: SyncingInfo
  }) {
  }
  class SyncHistorySubscribe extends LSDReqResMessage("LSD.Leader.SyncHistorySubscribe", {
    subscriptionId: String$
  }) {
  }
  class SyncHistoryUnsubscribe extends LSDReqResMessage("LSD.Leader.SyncHistoryUnsubscribe", {
    subscriptionId: String$
  }) {
  }
  class SyncHistoryRes extends LSDReqResMessage("LSD.Leader.SyncHistoryRes", {
    eventEncoded: AnyEncodedGlobal,
    metadata: Option(JsonValue),
    subscriptionId: String$
  }) {
  }
  class SyncHeadSubscribe extends LSDReqResMessage("LSD.Leader.SyncHeadSubscribe", {
    subscriptionId: String$
  }) {
  }
  class SyncHeadUnsubscribe extends LSDReqResMessage("LSD.Leader.SyncHeadUnsubscribe", {
    subscriptionId: String$
  }) {
  }
  class SyncHeadRes extends LSDReqResMessage("LSD.Leader.SyncHeadRes", {
    local: EventSequenceNumber,
    upstream: EventSequenceNumber,
    subscriptionId: String$
  }) {
  }
  class SnapshotReq extends LSDReqResMessage("LSD.Leader.SnapshotReq", {}) {
  }
  class SnapshotRes extends LSDReqResMessage("LSD.Leader.SnapshotRes", {
    snapshot: Uint8Array$1
  }) {
  }
  const LoadDatabaseFile = LeaderReqResMessage("LSD.Leader.LoadDatabaseFile", {
    payload: {
      data: Uint8Array$1
    },
    success: {},
    error: {
      cause: Union(TaggedStruct("unsupported-file", {}), TaggedStruct("unsupported-database", {}), TaggedStruct("unexpected-error", { cause: Defect }))
    }
  });
  class SyncPull extends LSDMessage("LSD.Leader.SyncPull", {
    payload: PayloadUpstream
  }) {
  }
  class CommitEventReq extends LSDReqResMessage("LSD.Leader.CommitEventReq", {
    eventEncoded: PartialAnyEncoded
  }) {
  }
  class CommitEventRes extends LSDReqResMessage("LSD.Leader.CommitEventRes", {}) {
  }
  class EventlogReq extends LSDReqResMessage("LSD.Leader.EventlogReq", {}) {
  }
  class EventlogRes extends LSDReqResMessage("LSD.Leader.EventlogRes", {
    eventlog: Uint8Array$1
  }) {
  }
  class Ping extends LSDReqResMessage("LSD.Leader.Ping", {}) {
  }
  class Pong extends LSDReqResMessage("LSD.Leader.Pong", {}) {
  }
  class Disconnect extends LSDReqResMessage("LSD.Leader.Disconnect", {}) {
  }
  const SetSyncLatch = LeaderReqResMessage("LSD.Leader.SetSyncLatch", {
    payload: {
      closeLatch: Boolean$
    },
    success: {}
  });
  const ResetAllData = LeaderReqResMessage("LSD.Leader.ResetAllData", {
    payload: {
      mode: Literal("all-data", "only-app-db")
    },
    success: {}
  });
  const MessageToApp = Union(SnapshotReq, LoadDatabaseFile.Request, EventlogReq, ResetAllData.Request, NetworkStatusSubscribe, NetworkStatusUnsubscribe, Disconnect, CommitEventReq, Ping, DatabaseFileInfoReq, SyncHistorySubscribe, SyncHistoryUnsubscribe, SyncingInfoReq, SyncHeadSubscribe, SyncHeadUnsubscribe, SetSyncLatch.Request).annotations({ identifier: "LSD.Leader.MessageToApp" });
  const MessageFromApp = Union(SnapshotRes, LoadDatabaseFile.Response, EventlogRes, Disconnect, SyncPull, NetworkStatusRes, CommitEventRes, Pong, DatabaseFileInfoRes, SyncHistoryRes, SyncingInfoRes, SyncHeadRes, ResetAllData.Success, SetSyncLatch.Success).annotations({ identifier: "LSD.Leader.MessageFromApp" });
  const DevtoolsMode = Union(TaggedStruct("node", {
    /** WebSocket URL */
    url: String$
  }), TaggedStruct("web", {}), TaggedStruct("browser-extension", {}));
  DevtoolsMode.pipe(pluck("_tag"), typeSchema);
  const makeNodeName = {
    client: {
      session: ({ storeId, clientId: clientId2, sessionId }) => `client-session-${storeId}-${clientId2}-${sessionId}`,
      leader: ({ storeId, clientId: clientId2 }) => `client-leader-${storeId}-${clientId2}`
    }
  };
  const makeChannelName = {
    sessionInfo: () => `session-info`,
    devtoolsClientSession: ({ storeId, clientId: clientId2, sessionId }) => `devtools-channel(client-session-${storeId}-${clientId2}-${sessionId})`,
    devtoolsClientLeader: ({ storeId, clientId: clientId2, sessionId }) => `devtools-channel(client-leader-${storeId}-${clientId2}-${sessionId})`
  };
  const isChannelName = {
    devtoolsClientSession: (channelName, { storeId, clientId: clientId2, sessionId }) => channelName === makeChannelName.devtoolsClientSession({ storeId, clientId: clientId2, sessionId }),
    devtoolsClientLeader: (channelName, { storeId, clientId: clientId2 }) => channelName.startsWith(`devtools-channel(client-leader-${storeId}-${clientId2}`)
  };
  const id = String$.pipe(optional, withDefaults({ constructor: () => nanoid(10), decoding: () => nanoid(10) }));
  const defaultPacketFields = {
    id,
    target: String$,
    source: String$,
    channelName: String$,
    hops: Array$(String$)
  };
  const remainingHopsUndefined = Undefined.pipe(optional);
  class DirectChannelRequest extends TaggedStruct("DirectChannelRequest", {
    ...defaultPacketFields,
    remainingHops: Array$(String$).pipe(optional),
    channelVersion: Number$,
    /** Only set if the request is in response to an incoming request */
    reqId: UndefinedOr(String$),
    /**
     * Additionally to the `source` field, we use this field to track whether the instance of a
     * source has changed.
     */
    sourceId: String$
  }) {
  }
  class DirectChannelResponseSuccess extends TaggedStruct("DirectChannelResponseSuccess", {
    ...defaultPacketFields,
    reqId: String$,
    port: MessagePort,
    // Since we can't copy this message, we need to follow the exact route back to the sender
    remainingHops: Array$(String$),
    channelVersion: Number$
  }) {
  }
  class DirectChannelResponseNoTransferables extends TaggedStruct("DirectChannelResponseNoTransferables", {
    ...defaultPacketFields,
    reqId: String$,
    remainingHops: Array$(String$)
  }) {
  }
  class ProxyChannelRequest extends TaggedStruct("ProxyChannelRequest", {
    ...defaultPacketFields,
    remainingHops: remainingHopsUndefined,
    channelIdCandidate: String$
  }) {
  }
  class ProxyChannelResponseSuccess extends TaggedStruct("ProxyChannelResponseSuccess", {
    ...defaultPacketFields,
    reqId: String$,
    remainingHops: Array$(String$),
    combinedChannelId: String$,
    channelIdCandidate: String$
  }) {
  }
  class ProxyChannelPayload extends TaggedStruct("ProxyChannelPayload", {
    ...defaultPacketFields,
    remainingHops: remainingHopsUndefined,
    payload: Any,
    combinedChannelId: String$
  }) {
  }
  class ProxyChannelPayloadAck extends TaggedStruct("ProxyChannelPayloadAck", {
    ...defaultPacketFields,
    reqId: String$,
    remainingHops: Array$(String$),
    combinedChannelId: String$
  }) {
  }
  class NetworkEdgeAdded extends TaggedStruct("NetworkEdgeAdded", {
    id,
    source: String$,
    target: String$
  }) {
  }
  class NetworkTopologyRequest extends TaggedStruct("NetworkTopologyRequest", {
    id,
    hops: Array$(String$),
    /** Always fixed to who requested the topology */
    source: String$,
    target: Literal("-")
  }) {
  }
  class NetworkTopologyResponse extends TaggedStruct("NetworkTopologyResponse", {
    id,
    reqId: String$,
    remainingHops: Array$(String$),
    nodeName: String$,
    edges: Array$(String$),
    /** Always fixed to who requested the topology */
    source: String$,
    target: Literal("-")
  }) {
  }
  const BroadcastChannelPacket = TaggedStruct("BroadcastChannelPacket", {
    id,
    channelName: String$,
    /**
     * The payload is expected to be encoded/decoded by the send/listen schema.
     * Transferables are not supported.
     */
    payload: Any,
    hops: Array$(String$),
    source: String$,
    target: Literal("-")
  });
  class DirectChannelPacket extends Union(DirectChannelRequest, DirectChannelResponseSuccess, DirectChannelResponseNoTransferables) {
  }
  class ProxyChannelPacket extends Union(ProxyChannelRequest, ProxyChannelResponseSuccess, ProxyChannelPayload, ProxyChannelPayloadAck) {
  }
  class Packet extends Union(DirectChannelPacket, ProxyChannelPacket, NetworkEdgeAdded, NetworkTopologyRequest, NetworkTopologyResponse, BroadcastChannelPacket) {
  }
  class DirectChannelPing extends TaggedStruct("DirectChannelPing", {}) {
  }
  class DirectChannelPong extends TaggedStruct("DirectChannelPong", {}) {
  }
  class EdgeAlreadyExistsError extends TaggedError()("EdgeAlreadyExistsError", {
    target: String$
  }) {
  }
  const packetAsOtelAttributes = (packet) => ({
    packetId: packet.id,
    "span.label": packet.id + (hasProperty(packet, "reqId") && packet.reqId !== void 0 ? ` for ${packet.reqId}` : ""),
    ...packet._tag !== "DirectChannelResponseSuccess" && packet._tag !== "ProxyChannelPayload" ? { packet } : {}
  });
  Struct({
    channelName: String$,
    source: String$,
    mode: Union(Literal("proxy"), Literal("direct"))
  });
  const makeDeferredResult = make$N;
  const makeDirectChannelInternal = ({ nodeName, incomingPacketsQueue, target, checkTransferableEdges, channelName, schema: schema_, sendPacket, channelVersion, scope: scope2, sourceId }) => gen$2(function* () {
    const deferred = yield* makeDeferredResult();
    const span2 = yield* currentOtelSpan.pipe(catchAll$2(() => succeed$5(void 0)));
    const schema2 = {
      send: Union(schema_.send, DirectChannelPing, DirectChannelPong),
      listen: Union(schema_.listen, DirectChannelPing, DirectChannelPong)
    };
    const channelStateRef = {
      current: { _tag: "Initial" }
    };
    const processMessagePacket = ({ packet, respondToSender }) => gen$2(function* () {
      const channelState2 = channelStateRef.current;
      span2 == null ? void 0 : span2.addEvent(`process:${packet._tag}`, {
        channelState: channelState2._tag,
        packetId: packet.id,
        packetReqId: packet.reqId,
        packetChannelVersion: hasProperty("channelVersion")(packet) ? packet.channelVersion : void 0
      });
      if (channelState2._tag === "Initial")
        return shouldNeverHappen();
      if (packet._tag === "DirectChannelResponseNoTransferables") {
        yield* fail$a(deferred, packet);
        return "close";
      }
      if (packet.channelVersion > channelVersion) {
        span2 == null ? void 0 : span2.addEvent(`incoming packet has higher version (${packet.channelVersion}), closing channel`);
        yield* close(scope2, succeed$8("higher-version-expected"));
        return "close";
      }
      if (packet.channelVersion < channelVersion) {
        const newPacket = DirectChannelRequest.make({
          source: nodeName,
          sourceId,
          target,
          channelName,
          channelVersion,
          hops: [],
          remainingHops: packet.hops,
          reqId: void 0
        });
        span2 == null ? void 0 : span2.addEvent(`incoming packet has lower version (${packet.channelVersion}), sending request to reconnect (${newPacket.id})`);
        yield* sendPacket(newPacket);
        return;
      }
      if (channelState2._tag === "Established" && packet._tag === "DirectChannelRequest") {
        if (packet.sourceId === channelState2.otherSourceId) {
          return;
        } else {
          span2 == null ? void 0 : span2.addEvent(`force-new-channel`);
          yield* close(scope2, succeed$8("force-new-channel"));
          return "close";
        }
      }
      switch (packet._tag) {
        // Assumption: Each side has sent an initial request and another request as a response for an incoming request
        case "DirectChannelRequest": {
          if (channelState2._tag !== "RequestSent") {
            return;
          }
          if (packet.reqId === channelState2.reqPacketId) ;
          else {
            const newRequestPacket = DirectChannelRequest.make({
              source: nodeName,
              sourceId,
              target,
              channelName,
              channelVersion,
              hops: [],
              remainingHops: packet.hops,
              reqId: packet.id
            });
            span2 == null ? void 0 : span2.addEvent(`Re-sending new request (${newRequestPacket.id}) for incoming request (${packet.id})`);
            yield* sendPacket(newRequestPacket);
          }
          const isWinner = nodeName > target;
          if (isWinner) {
            span2 == null ? void 0 : span2.addEvent(`winner side: creating direct channel and sending response`);
            const mc = new MessageChannel();
            const channel2 = yield* messagePortChannelWithAck({
              port: mc.port1,
              schema: schema2,
              debugId: channelVersion
            }).pipe(andThen(toOpenChannel));
            yield* respondToSender(DirectChannelResponseSuccess.make({
              reqId: packet.id,
              target,
              source: nodeName,
              channelName: packet.channelName,
              hops: [],
              remainingHops: packet.hops.slice(0, -1),
              port: mc.port2,
              channelVersion
            }));
            channelStateRef.current = { _tag: "winner:ResponseSent", channel: channel2, otherSourceId: packet.sourceId };
            yield* channel2.listen.pipe(flatten(), filter(is(DirectChannelPing)), take(1), runDrain);
            yield* channel2.send(DirectChannelPong.make({}));
            span2 == null ? void 0 : span2.addEvent(`winner side: established`);
            channelStateRef.current = { _tag: "Established", otherSourceId: packet.sourceId };
            yield* succeed$9(deferred, channel2);
          } else {
            span2 == null ? void 0 : span2.addEvent(`loser side: waiting for response`);
            channelStateRef.current = { _tag: "loser:WaitingForResponse", otherSourceId: packet.sourceId };
          }
          break;
        }
        case "DirectChannelResponseSuccess": {
          if (channelState2._tag !== "loser:WaitingForResponse") {
            return shouldNeverHappen(`Expected to find direct channel response from ${target}, but was in ${channelState2._tag} state`);
          }
          const channel2 = yield* messagePortChannelWithAck({
            port: packet.port,
            schema: schema2,
            debugId: channelVersion
          }).pipe(andThen(toOpenChannel));
          const waitForPongFiber = yield* channel2.listen.pipe(flatten(), filter(is(DirectChannelPong)), take(1), runDrain, fork);
          yield* channel2.send(DirectChannelPing.make({})).pipe(timeout(10), retry$3({ times: 2 }));
          yield* waitForPongFiber;
          span2 == null ? void 0 : span2.addEvent(`loser side: established`);
          channelStateRef.current = { _tag: "Established", otherSourceId: channelState2.otherSourceId };
          yield* succeed$9(deferred, channel2);
          return;
        }
        default: {
          return casesHandled(packet);
        }
      }
    }).pipe(withSpan$3(`handleMessagePacket:${packet._tag}:${packet.source}→${packet.target}`, {
      attributes: packetAsOtelAttributes(packet)
    }));
    yield* gen$2(function* () {
      while (true) {
        const packet = yield* take$4(incomingPacketsQueue);
        const res = yield* processMessagePacket(packet);
        if (res === "close") {
          return;
        }
      }
    }).pipe(interruptible, tapCauseLogPretty, forkScoped);
    const channelState = channelStateRef.current;
    if (channelState._tag !== "Initial") {
      return shouldNeverHappen(`Expected channel to be in Initial state, but was in ${channelState._tag} state`);
    }
    const edgeRequest = gen$2(function* () {
      const packet = DirectChannelRequest.make({
        source: nodeName,
        sourceId,
        target,
        channelName,
        channelVersion,
        hops: [],
        reqId: void 0
      });
      channelStateRef.current = { _tag: "RequestSent", reqPacketId: packet.id };
      const noTransferableResponse = checkTransferableEdges(packet);
      if (noTransferableResponse !== void 0) {
        yield* spanEvent(`No transferable edges found for ${packet.source}→${packet.target}`);
        return yield* fail$6(noTransferableResponse);
      }
      yield* sendPacket(packet);
      span2 == null ? void 0 : span2.addEvent(`initial edge request sent (${packet.id})`);
    });
    yield* edgeRequest;
    const channel = yield* deferred;
    return channel;
  }).pipe(withSpanScoped(`makeDirectChannel:${channelVersion}`));
  const makeDirectChannel = ({ schema: schema2, newEdgeAvailablePubSub, channelName, checkTransferableEdges, nodeName, incomingPacketsQueue, target, sendPacket }) => scopeWithCloseable((scope2) => gen$2(function* () {
    const sourceId = nanoid();
    const listenQueue = yield* unbounded$2();
    const sendQueue = yield* unbounded();
    const initialEdgeDeferred = yield* make$N();
    const debugInfo = {
      pendingSends: 0,
      totalSends: 0,
      connectCounter: 0,
      isConnected: false,
      innerChannelRef: { current: void 0 }
    };
    yield* gen$2(function* () {
      const resultDeferred = yield* make$N();
      while (true) {
        debugInfo.connectCounter++;
        const channelVersion2 = debugInfo.connectCounter;
        yield* spanEvent(`Connecting#${channelVersion2}`);
        const makeDirectChannelScope2 = yield* make$u();
        yield* addFinalizer((ex) => close(makeDirectChannelScope2, ex));
        const waitForNewEdgeFiber = yield* fromPubSub(newEdgeAvailablePubSub).pipe(tap((edgeName) => spanEvent(`new-conn:${edgeName}`)), take(1), runDrain, as("new-edge"), fork);
        const makeChannel = makeDirectChannelInternal({
          nodeName,
          sourceId,
          incomingPacketsQueue,
          target,
          checkTransferableEdges,
          channelName,
          schema: schema2,
          channelVersion: channelVersion2,
          sendPacket,
          scope: makeDirectChannelScope2
        }).pipe(
          extend$1(makeDirectChannelScope2),
          forkIn(makeDirectChannelScope2),
          // Given we only call `Effect.exit` later when joining the fiber,
          // we don't want Effect to produce a "unhandled error" log message
          withUnhandledErrorLogLevel(none$4())
        );
        const raceResult = yield* raceFirst(makeChannel, waitForNewEdgeFiber.pipe(disconnect));
        if (raceResult === "new-edge") {
          yield* close(makeDirectChannelScope2, fail$9("new-edge"));
        } else {
          const channelExit = yield* raceResult.pipe(exit);
          if (channelExit._tag === "Failure") {
            yield* close(makeDirectChannelScope2, channelExit);
            if (isFailType(channelExit.cause) && is(DirectChannelResponseNoTransferables)(channelExit.cause.error)) {
              yield* waitForNewEdgeFiber.pipe(exit);
            }
          } else {
            const channel2 = channelExit.value;
            yield* succeed$9(resultDeferred, { channel: channel2, makeDirectChannelScope: makeDirectChannelScope2, channelVersion: channelVersion2 });
            break;
          }
        }
      }
      const { channel, makeDirectChannelScope, channelVersion } = yield* resultDeferred;
      yield* spanEvent(`Connected#${channelVersion}`);
      debugInfo.isConnected = true;
      debugInfo.innerChannelRef.current = channel;
      yield* succeed$9(initialEdgeDeferred, void 0);
      yield* channel.listen.pipe(
        flatten(),
        // Stream.tap((msg) => Effect.log(`${target}→${channelName}→${nodeName}:message:${msg.message}`)),
        tapChunk((chunk2) => offerAll$1(listenQueue, chunk2)),
        runDrain,
        tapCauseLogPretty,
        forkIn(makeDirectChannelScope)
      );
      yield* gen$2(function* () {
        while (true) {
          const [msg, deferred] = yield* peek(sendQueue);
          yield* channel.send(msg);
          yield* succeed$9(deferred, void 0);
          yield* take$2(sendQueue);
        }
      }).pipe(forkIn(makeDirectChannelScope));
      yield* channel.closedDeferred;
      yield* close(makeDirectChannelScope, succeed$8("channel-closed"));
      yield* spanEvent(`Disconnected#${channelVersion}`);
      debugInfo.isConnected = false;
      debugInfo.innerChannelRef.current = void 0;
    }).pipe(
      scoped$3,
      // Additionally scoping here to clean up finalizers after each loop run
      forever,
      tapCauseLogPretty,
      forkScoped
    );
    const parentSpan = yield* currentSpan.pipe(orDie$2);
    const send = (message) => gen$2(function* () {
      const sentDeferred = yield* make$N();
      debugInfo.pendingSends++;
      debugInfo.totalSends++;
      yield* offer(sendQueue, [message, sentDeferred]);
      yield* sentDeferred;
      debugInfo.pendingSends--;
    }).pipe(scoped$3, withParentSpan(parentSpan));
    const listen = fromQueue(listenQueue, { maxChunkSize: 1 }).pipe(map(right));
    const closedDeferred = yield* make$N().pipe(acquireRelease(done$7(void_$3)));
    const webChannel = {
      [WebChannelSymbol]: WebChannelSymbol,
      send,
      listen,
      closedDeferred,
      supportsTransferables: true,
      schema: schema2,
      debugInfo,
      shutdown: close(scope2, succeed$8("shutdown"))
    };
    return {
      webChannel,
      initialEdgeDeferred
    };
  }));
  const makeProxyChannel = ({ queue, nodeName, newEdgeAvailablePubSub, sendPacket, target, channelName, schema: schema2 }) => scopeWithCloseable((scope2) => gen$2(function* () {
    const channelStateRef = { current: { _tag: "Initial" } };
    const debugInfo = {
      kind: "proxy-channel",
      pendingSends: 0,
      totalSends: 0,
      connectCounter: 0,
      isConnected: false
    };
    const channelIdCandidate = nanoid(5);
    yield* annotateCurrentSpan({ channelIdCandidate });
    const channelSpan = yield* currentSpan.pipe(orDie$2);
    const connectedStateRef = yield* make$a(false);
    const waitForEstablished = gen$2(function* () {
      const state2 = yield* waitUntil(connectedStateRef, (state3) => state3 !== false);
      return state2;
    });
    const setStateToEstablished = (channelId) => gen$2(function* () {
      yield* spanEvent(`Connected (${channelId})`).pipe(withParentSpan(channelSpan));
      channelStateRef.current = {
        _tag: "Established",
        listenSchema: schema2.listen,
        listenQueue,
        ackMap,
        combinedChannelId: channelId
      };
      yield* set$2(connectedStateRef, channelStateRef.current);
      debugInfo.isConnected = true;
    });
    const edgeRequest = suspend$6(() => sendPacket(ProxyChannelRequest.make({ channelName, hops: [], source: nodeName, target, channelIdCandidate })));
    const getCombinedChannelId = (otherSideChannelIdCandidate) => [channelIdCandidate, otherSideChannelIdCandidate].sort().join("_");
    const earlyPayloadBuffer = yield* unbounded$2().pipe(acquireRelease(shutdown));
    const processProxyPacket = ({ packet, respondToSender }) => gen$2(function* () {
      const otherSideName = packet.source;
      const channelKey = `target:${otherSideName}, channelName:${packet.channelName}`;
      const channelState = channelStateRef.current;
      switch (packet._tag) {
        case "ProxyChannelRequest": {
          const combinedChannelId = getCombinedChannelId(packet.channelIdCandidate);
          if (channelState._tag === "Established") {
            if (channelState.combinedChannelId === combinedChannelId) ;
            else {
              yield* logWarning(`[${nodeName}] Received ProxyChannelRequest with different channel ID (${combinedChannelId}) while established with ${channelState.combinedChannelId}. Re-establishing.`);
              yield* set$2(connectedStateRef, false);
              channelStateRef.current = { _tag: "Pending", initiatedVia: "incoming-request" };
              yield* spanEvent(`Reconnecting (received conflicting ProxyChannelRequest)`).pipe(withParentSpan(channelSpan));
              debugInfo.isConnected = false;
              debugInfo.connectCounter++;
              yield* edgeRequest;
            }
          } else if (channelState._tag === "Initial") {
            yield* set$2(connectedStateRef, false);
            channelStateRef.current = { _tag: "Pending", initiatedVia: "incoming-request" };
            yield* spanEvent(`Connecting (received ProxyChannelRequest)`).pipe(withParentSpan(channelSpan));
            debugInfo.isConnected = false;
            debugInfo.connectCounter++;
          }
          yield* respondToSender(ProxyChannelResponseSuccess.make({
            reqId: packet.id,
            remainingHops: packet.hops,
            hops: [],
            target,
            source: nodeName,
            channelName,
            combinedChannelId,
            channelIdCandidate
          }));
          return;
        }
        case "ProxyChannelResponseSuccess": {
          if (channelState._tag !== "Pending") {
            if (channelState._tag === "Established" && channelState.combinedChannelId !== packet.combinedChannelId) {
              return shouldNeverHappen(`ProxyChannel[${channelKey}]: Expected proxy channel to have the same combinedChannelId as the packet:
${channelState.combinedChannelId} (channel) === ${packet.combinedChannelId} (packet)`);
            } else if (channelState._tag === "Established") {
              return;
            } else {
              yield* logWarning(`[${nodeName}] Ignoring ResponseSuccess ${packet.id} received in unexpected state ${channelState._tag}`);
              return;
            }
          }
          const combinedChannelId = getCombinedChannelId(packet.channelIdCandidate);
          if (combinedChannelId !== packet.combinedChannelId) {
            return yield* die$3(`ProxyChannel[${channelKey}]: Expected proxy channel to have the same combinedChannelId as the packet:
${combinedChannelId} (channel) === ${packet.combinedChannelId} (packet)`);
          }
          yield* setStateToEstablished(packet.combinedChannelId);
          const establishedState = channelStateRef.current;
          if (establishedState._tag === "Established") {
            const bufferedPackets = yield* takeAll(earlyPayloadBuffer);
            for (const bufferedPacket of bufferedPackets) {
              if (establishedState.combinedChannelId !== bufferedPacket.combinedChannelId) {
                yield* logWarning(`[${nodeName}] Discarding buffered payload ${bufferedPacket.id}: Combined channel ID mismatch during drain. Expected ${establishedState.combinedChannelId}, got ${bufferedPacket.combinedChannelId}`);
                continue;
              }
              const decodedMessage = yield* decodeUnknown(establishedState.listenSchema)(bufferedPacket.payload);
              yield* establishedState.listenQueue.pipe(offer$2(decodedMessage));
            }
          } else {
            yield* logError(`[${nodeName}] State is not Established immediately after setStateToEstablished was called. Cannot drain buffer. State: ${establishedState._tag}`);
          }
          return;
        }
        case "ProxyChannelPayload": {
          if (channelState._tag === "Established" && channelState.combinedChannelId !== packet.combinedChannelId) {
            return yield* die$3(`ProxyChannel[${channelKey}]: Expected proxy channel to have the same combinedChannelId as the packet:
${channelState.combinedChannelId} (channel) === ${packet.combinedChannelId} (packet)`);
          }
          yield* respondToSender(ProxyChannelPayloadAck.make({
            reqId: packet.id,
            remainingHops: packet.hops,
            hops: [],
            target,
            source: nodeName,
            channelName,
            combinedChannelId: channelState._tag === "Established" ? channelState.combinedChannelId : packet.combinedChannelId
          }));
          if (channelState._tag === "Established") {
            const decodedMessage = yield* decodeUnknown(channelState.listenSchema)(packet.payload);
            yield* channelState.listenQueue.pipe(offer$2(decodedMessage));
          } else {
            yield* offer$2(earlyPayloadBuffer, packet);
          }
          return;
        }
        case "ProxyChannelPayloadAck": {
          if (channelState._tag !== "Established") {
            yield* spanEvent(`Not yet connected to ${target}. dropping message`);
            yield* logWarning(`[${nodeName}] Received Ack but not established (State: ${channelState._tag}). Dropping Ack for ${packet.reqId}`);
            return;
          }
          const ack = channelState.ackMap.get(packet.reqId) ?? shouldNeverHappen(`[ProxyChannel[${channelKey}]] Expected ack for ${packet.reqId}`);
          yield* succeed$9(ack, void 0);
          channelState.ackMap.delete(packet.reqId);
          return;
        }
        default: {
          return casesHandled(packet);
        }
      }
    }).pipe(withSpan$3(`handleProxyPacket:${packet._tag}:${packet.source}->${packet.target}`, {
      attributes: packetAsOtelAttributes(packet)
    }));
    yield* fromQueue(queue).pipe(tap(processProxyPacket), runDrain, tapCauseLogPretty, forkScoped);
    const listenQueue = yield* unbounded$2();
    yield* spanEvent(`Connecting`);
    const ackMap = /* @__PURE__ */ new Map();
    {
      if (channelStateRef.current._tag !== "Initial") {
        return shouldNeverHappen("Expected proxy channel to be Initial");
      }
      channelStateRef.current = { _tag: "Pending", initiatedVia: "outgoing-request" };
      yield* edgeRequest;
      const retryOnNewEdgeFiber = yield* fromPubSub(newEdgeAvailablePubSub).pipe(tap(() => edgeRequest), runDrain, forkScoped);
      const { combinedChannelId: channelId } = yield* waitForEstablished;
      yield* interrupt$2(retryOnNewEdgeFiber);
      yield* setStateToEstablished(channelId);
    }
    const send = (message) => gen$2(function* () {
      const payload = yield* encodeUnknown(schema2.send)(message);
      const sendFiberHandle = yield* make$k();
      const sentDeferred = yield* make$N();
      debugInfo.pendingSends++;
      debugInfo.totalSends++;
      const trySend = gen$2(function* () {
        const { combinedChannelId } = yield* waitUntil(connectedStateRef, (channel) => channel !== false);
        const innerSend = gen$2(function* () {
          const ack = yield* make$N();
          const packet = ProxyChannelPayload.make({
            channelName,
            payload,
            hops: [],
            source: nodeName,
            target,
            combinedChannelId
          });
          ackMap.set(packet.id, ack);
          yield* sendPacket(packet);
          yield* ack;
          yield* succeed$9(sentDeferred, void 0);
          debugInfo.pendingSends--;
        });
        yield* innerSend.pipe(timeout(100), retry$3(exponential(10)), orDie$2);
      }).pipe(tapErrorCause(logError));
      const rerunOnNewChannelFiber = yield* connectedStateRef.changes.pipe(filter((_) => _ === false), tap(() => run$1(sendFiberHandle, trySend)), runDrain, fork);
      yield* run$1(sendFiberHandle, trySend);
      yield* sentDeferred;
      yield* interrupt$2(rerunOnNewChannelFiber);
    }).pipe(scoped$3, withSpan$3(`sendAckWithRetry:ProxyChannelPayload`), withParentSpan(channelSpan));
    const listen = fromQueue(listenQueue).pipe(map(right));
    const closedDeferred = yield* make$N().pipe(acquireRelease(done$7(void_$3)));
    const runtime$12 = yield* runtime();
    const webChannel = {
      [WebChannelSymbol]: WebChannelSymbol,
      send,
      listen,
      closedDeferred,
      supportsTransferables: false,
      schema: schema2,
      shutdown: close(scope2, void_$3),
      debugInfo,
      ...{
        debug: {
          ping: (message = "ping") => send(DebugPingMessage.make({ message })).pipe(provide$1(runtime$12), tapCauseLogPretty, runFork$1)
        }
      }
    };
    return webChannel;
  }).pipe(withSpanScoped("makeProxyChannel")));
  const _TimeoutSet = class _TimeoutSet {
    constructor({ timeout: timeout2 }) {
      __publicField(this, "values", /* @__PURE__ */ new Map());
      __publicField(this, "timeoutHandle");
      __publicField(this, "timeoutMs");
      __publicField(this, "onShutdown", () => clearTimeout(this.timeoutHandle));
      this.timeoutMs = toMillis(timeout2);
    }
    add(value2) {
      this.values.set(value2, Date.now());
      this.scheduleCleanup();
    }
    has(value2) {
      return this.values.has(value2);
    }
    delete(value2) {
      this.values.delete(value2);
    }
    scheduleCleanup() {
      if (this.timeoutHandle === void 0) {
        this.timeoutHandle = setTimeout(() => {
          this.cleanup();
          this.timeoutHandle = void 0;
        }, this.timeoutMs);
      }
    }
    cleanup() {
      const now = Date.now();
      for (const [value2, timestamp] of this.values.entries()) {
        if (now - timestamp >= this.timeoutMs) {
          this.values.delete(value2);
        }
      }
    }
  };
  __publicField(_TimeoutSet, "make", (timeout2) => gen$2(function* () {
    const timeoutSet = new _TimeoutSet({ timeout: timeout2 });
    yield* addFinalizer(() => sync$3(() => timeoutSet.onShutdown()));
    return timeoutSet;
  }));
  let TimeoutSet = _TimeoutSet;
  const makeMeshNode = (nodeName) => gen$2(function* () {
    const edgeChannels = /* @__PURE__ */ new Map();
    const handledPacketIds = yield* TimeoutSet.make(minutes(1));
    const newEdgeAvailablePubSub = yield* unbounded$3().pipe(acquireRelease(shutdown$1));
    const channelMap = /* @__PURE__ */ new Map();
    const channelRequestsQueue = yield* unbounded$2().pipe(acquireRelease(shutdown));
    const topologyRequestsMap = /* @__PURE__ */ new Map();
    const broadcastChannelListenQueueMap = /* @__PURE__ */ new Map();
    const checkTransferableEdges = (packet) => {
      var _a2;
      if (packet._tag === "DirectChannelRequest" && (edgeChannels.size === 0 || // Either if direct edge does not support transferables ...
      ((_a2 = edgeChannels.get(packet.target)) == null ? void 0 : _a2.channel.supportsTransferables) === false) || // ... or if no forward-edges support transferables
      ![...edgeChannels.values()].some((c) => c.channel.supportsTransferables === true)) {
        return DirectChannelResponseNoTransferables.make({
          reqId: packet.id,
          channelName: packet.channelName,
          // NOTE for now we're "pretending" that the message is coming from the target node
          // even though we're already handling it here.
          // TODO we should clean this up at some point
          source: packet.target,
          target: packet.source,
          remainingHops: packet.hops,
          hops: []
        });
      }
    };
    const sendPacket = (packet) => gen$2(function* () {
      var _a2, _b2;
      if (is(NetworkEdgeAdded)(packet)) {
        yield* spanEvent("NetworkEdgeAdded", { packet, nodeName });
        yield* publish(newEdgeAvailablePubSub, packet.target);
        const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => name !== packet.source).map(([_, con]) => con.channel);
        yield* forEach(edgesToForwardTo, (con) => con.send(packet), { concurrency: "unbounded" });
        return;
      }
      if (is(BroadcastChannelPacket)(packet)) {
        const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => !packet.hops.includes(name)).map(([_, con]) => con.channel);
        const adjustedPacket = {
          ...packet,
          hops: [...packet.hops, nodeName]
        };
        yield* forEach(edgesToForwardTo, (con) => con.send(adjustedPacket), { concurrency: "unbounded" });
        if (packet.source === nodeName) {
          return;
        }
        const queue = broadcastChannelListenQueueMap.get(packet.channelName);
        if (queue !== void 0) {
          yield* offer$2(queue, packet);
        }
        return;
      }
      if (is(NetworkTopologyRequest)(packet)) {
        if (packet.source !== nodeName) {
          const backEdgeName = packet.hops.at(-1) ?? shouldNeverHappen(`${nodeName}: Expected hops for packet`, packet);
          const backEdgeChannel = edgeChannels.get(backEdgeName).channel;
          const response = NetworkTopologyResponse.make({
            reqId: packet.id,
            source: packet.source,
            target: packet.target,
            remainingHops: packet.hops.slice(0, -1),
            nodeName,
            edges: Array.from(edgeChannels.keys())
          });
          yield* backEdgeChannel.send(response);
        }
        const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => !packet.hops.includes(name)).map(([_, con]) => con.channel);
        const adjustedPacket = {
          ...packet,
          hops: [...packet.hops, nodeName]
        };
        yield* forEach(edgesToForwardTo, (con) => con.send(adjustedPacket), { concurrency: "unbounded" });
        return;
      }
      if (is(NetworkTopologyResponse)(packet)) {
        if (packet.source === nodeName) {
          const topologyRequestItem = topologyRequestsMap.get(packet.reqId);
          topologyRequestItem.set(packet.nodeName, new Set(packet.edges));
        } else {
          const remainingHops = packet.remainingHops;
          const routeBack = remainingHops.at(-1) ?? shouldNeverHappen(`${nodeName}: Expected remaining hops for packet`, packet);
          const edgeChannel = ((_a2 = edgeChannels.get(routeBack)) == null ? void 0 : _a2.channel) ?? shouldNeverHappen(`${nodeName}: Expected edge channel (${routeBack}) for packet`, packet, "Available edges:", Array.from(edgeChannels.keys()));
          yield* edgeChannel.send({ ...packet, remainingHops: packet.remainingHops.slice(0, -1) });
        }
        return;
      }
      if (edgeChannels.has(packet.target)) {
        const edgeChannel = edgeChannels.get(packet.target).channel;
        const hops = packet.source === nodeName ? [] : [...packet.hops, nodeName];
        yield* annotateCurrentSpan({ hasDirectEdge: true });
        yield* edgeChannel.send({ ...packet, hops });
      } else if (packet.remainingHops !== void 0) {
        const hopTarget = packet.remainingHops.at(-1) ?? shouldNeverHappen(`${nodeName}: Expected remaining hops for packet`, packet);
        const edgeChannel = (_b2 = edgeChannels.get(hopTarget)) == null ? void 0 : _b2.channel;
        if (edgeChannel === void 0) {
          yield* logWarning(`${nodeName}: Expected to find hop target ${hopTarget} in edges. Dropping packet.`, packet);
          return;
        }
        yield* edgeChannel.send({
          ...packet,
          remainingHops: packet.remainingHops.slice(0, -1),
          hops: [...packet.hops, nodeName]
        });
      } else {
        const hops = packet.source === nodeName ? [] : [...packet.hops, nodeName];
        const edgesToForwardTo = Array.from(edgeChannels).filter(([name]) => name !== packet.source).map(([name, con]) => ({ name, channel: con.channel }));
        if (hops.length === 0 && edgesToForwardTo.length === 0 && LS_DEV) {
          yield* logWarning(nodeName, "no route found to", packet.target, packet._tag, "TODO handle better");
        }
        const packetToSend = { ...packet, hops };
        yield* annotateCurrentSpan({ edgesToForwardTo: edgesToForwardTo.map(({ name }) => name) });
        yield* forEach(edgesToForwardTo, ({ channel }) => channel.send(packetToSend), {
          concurrency: "unbounded"
        });
      }
    }).pipe(withSpan$3(`sendPacket:${packet._tag}:${packet.source}→${packet.target}`, {
      attributes: packetAsOtelAttributes(packet)
    }), orDie$2);
    const addEdge = ({ target: targetNodeName, edgeChannel, replaceIfExists = false }) => gen$2(function* () {
      if (edgeChannels.has(targetNodeName)) {
        if (replaceIfExists) {
          yield* removeEdge(targetNodeName).pipe(orDie$2);
        } else {
          return yield* new EdgeAlreadyExistsError({ target: targetNodeName });
        }
      }
      const listenFiber = yield* edgeChannel.listen.pipe(flatten(), tap((message) => gen$2(function* () {
        const packet = yield* decodeUnknown(Packet)(message);
        if (handledPacketIds.has(packet.id))
          return;
        handledPacketIds.add(packet.id);
        switch (packet._tag) {
          case "NetworkEdgeAdded":
          case "NetworkTopologyRequest":
          case "NetworkTopologyResponse": {
            yield* sendPacket(packet);
            break;
          }
          default: {
            if (packet.target === nodeName) {
              const channelKey = `target:${packet.source}, channelName:${packet.channelName}`;
              if (!channelMap.has(channelKey)) {
                const channelQueue2 = yield* unbounded$2().pipe(acquireRelease(shutdown));
                channelMap.set(channelKey, { queue: channelQueue2, debugInfo: void 0 });
              }
              const channelQueue = channelMap.get(channelKey).queue;
              const respondToSender = (outgoingPacket) => edgeChannel.send(outgoingPacket).pipe(withSpan$3(`respondToSender:${outgoingPacket._tag}:${outgoingPacket.source}→${outgoingPacket.target}`, { attributes: packetAsOtelAttributes(outgoingPacket) }), orDie$2);
              if (is(ProxyChannelPacket)(packet)) {
                yield* offer$2(channelQueue, { packet, respondToSender });
              } else if (is(DirectChannelPacket)(packet)) {
                yield* offer$2(channelQueue, { packet, respondToSender });
              }
              if (packet._tag === "ProxyChannelRequest" || packet._tag === "DirectChannelRequest") {
                yield* offer$2(channelRequestsQueue, {
                  channelName: packet.channelName,
                  source: packet.source,
                  mode: packet._tag === "ProxyChannelRequest" ? "proxy" : "direct"
                });
              }
            } else {
              if (is(DirectChannelPacket)(packet)) {
                const noTransferableResponse = checkTransferableEdges(packet);
                if (noTransferableResponse !== void 0) {
                  yield* spanEvent(`No transferable edges found for ${packet.source}→${packet.target}`);
                  return yield* edgeChannel.send(noTransferableResponse).pipe(withSpan$3(`sendNoTransferableResponse:${packet.source}→${packet.target}`, {
                    attributes: packetAsOtelAttributes(noTransferableResponse)
                  }));
                }
              }
              yield* sendPacket(packet);
            }
          }
        }
      })), runDrain, interruptible, orDie$2, tapCauseLogPretty, forkScoped);
      edgeChannels.set(targetNodeName, { channel: edgeChannel, listenFiber });
      const edgeAddedPacket = NetworkEdgeAdded.make({
        source: nodeName,
        target: targetNodeName
      });
      yield* sendPacket(edgeAddedPacket).pipe(orDie$2);
    }).pipe(annotateLogs({ "addEdge:target": targetNodeName, nodeName }), withSpan$3(`addEdge:${nodeName}→${targetNodeName}`, {
      attributes: { supportsTransferables: edgeChannel.supportsTransferables }
    }));
    const removeEdge = (targetNodeName) => gen$2(function* () {
      if (!edgeChannels.has(targetNodeName)) {
        yield* new NoSuchElementException(`No edge found for ${targetNodeName}`);
      }
      yield* interrupt$2(edgeChannels.get(targetNodeName).listenFiber);
      edgeChannels.delete(targetNodeName);
    });
    const hasChannel = ({ target, channelName }) => sync$3(() => channelMap.has(`target:${target}, channelName:${channelName}`));
    const makeChannel = ({
      target,
      channelName,
      schema: inputSchema,
      // TODO in the future we could have a mode that prefers directs and then falls back to proxies if needed
      mode,
      timeout: timeout2 = seconds(1),
      closeExisting = false
    }) => gen$2(function* () {
      var _a2;
      const schema2 = mapSchema(inputSchema);
      const channelKey = `target:${target}, channelName:${channelName}`;
      if (channelMap.has(channelKey)) {
        const existingChannel = (_a2 = channelMap.get(channelKey).debugInfo) == null ? void 0 : _a2.channel;
        if (existingChannel) {
          if (closeExisting) {
            yield* existingChannel.shutdown;
            channelMap.delete(channelKey);
          } else {
            shouldNeverHappen(`Channel ${channelKey} already exists`, existingChannel);
          }
        }
      }
      if (channelMap.has(channelKey) === false) {
        const channelQueue2 = yield* unbounded$2().pipe(acquireRelease(shutdown));
        channelMap.set(channelKey, { queue: channelQueue2, debugInfo: void 0 });
      }
      const channelQueue = channelMap.get(channelKey).queue;
      yield* addFinalizer(() => sync$3(() => channelMap.delete(channelKey)));
      if (mode === "direct") {
        const incomingPacketsQueue = yield* unbounded$2().pipe(acquireRelease(shutdown));
        yield* takeBetween$1(channelQueue, 1, 10).pipe(tap$2((_) => offerAll$1(incomingPacketsQueue, _)), forever, interruptible, tapCauseLogPretty, forkScoped);
        const { webChannel, initialEdgeDeferred } = yield* makeDirectChannel({
          nodeName,
          incomingPacketsQueue,
          newEdgeAvailablePubSub,
          target,
          channelName,
          schema: schema2,
          sendPacket,
          checkTransferableEdges
        });
        channelMap.set(channelKey, { queue: channelQueue, debugInfo: { channel: webChannel, target } });
        yield* initialEdgeDeferred;
        return webChannel;
      } else {
        const channel = yield* makeProxyChannel({
          nodeName,
          newEdgeAvailablePubSub,
          target,
          channelName,
          schema: schema2,
          queue: channelQueue,
          sendPacket
        });
        channelMap.set(channelKey, { queue: channelQueue, debugInfo: { channel, target } });
        return channel;
      }
    }).pipe(
      // Effect.timeout(timeout),
      withSpanScoped(`makeChannel:${nodeName}→${target}(${channelName})`, {
        attributes: { target, channelName, mode, timeout: timeout2 }
      }),
      annotateLogs({ nodeName, target, channelName })
    );
    let listenAlreadyStarted = false;
    const listenForChannel = suspend(() => {
      if (listenAlreadyStarted) {
        return shouldNeverHappen("listenForChannel already started");
      }
      listenAlreadyStarted = true;
      const hash2 = (res) => `${res.channelName}:${res.source}:${res.mode}`;
      const seen = /* @__PURE__ */ new Set();
      return fromQueue(channelRequestsQueue).pipe(filter((res) => {
        const hashed = hash2(res);
        if (seen.has(hashed)) {
          return false;
        }
        seen.add(hashed);
        return true;
      }));
    });
    const makeBroadcastChannel = ({ channelName, schema: schema2 }) => scopeWithCloseable((scope2) => gen$2(function* () {
      if (broadcastChannelListenQueueMap.has(channelName)) {
        return shouldNeverHappen(`Broadcast channel ${channelName} already exists`, broadcastChannelListenQueueMap.get(channelName));
      }
      const debugInfo = {};
      const queue = yield* unbounded$2().pipe(acquireRelease(shutdown));
      broadcastChannelListenQueueMap.set(channelName, queue);
      const send = (message) => gen$2(function* () {
        const payload = yield* encode(schema2)(message);
        const packet = BroadcastChannelPacket.make({
          channelName,
          payload,
          source: nodeName,
          target: "-",
          hops: []
        });
        yield* sendPacket(packet);
      });
      const listen = fromQueue(queue).pipe(filter(is(BroadcastChannelPacket)), map((_) => decodeEither(schema2)(_.payload)));
      const closedDeferred = yield* make$N().pipe(acquireRelease(done$7(void_$3)));
      return {
        [WebChannelSymbol]: WebChannelSymbol,
        send,
        listen,
        closedDeferred,
        supportsTransferables: false,
        schema: { listen: schema2, send: schema2 },
        shutdown: close(scope2, void_$3),
        debugInfo
      };
    }));
    const edgeKeys = sync$3(() => new Set(edgeChannels.keys()));
    const runtime$12 = yield* runtime();
    const debug = {
      print: () => {
        var _a2, _b2, _c2, _d2;
        console.log("Webmesh debug info for node:", nodeName);
        console.log("Edges:", edgeChannels.size);
        for (const [key, value2] of edgeChannels) {
          console.log(`  ${key}: supportsTransferables=${value2.channel.supportsTransferables}`);
        }
        console.log("Channels:", channelMap.size);
        for (const [key, value2] of channelMap) {
          console.log(indent(key, 2), "\n", Object.entries({
            target: (_a2 = value2.debugInfo) == null ? void 0 : _a2.target,
            supportsTransferables: (_b2 = value2.debugInfo) == null ? void 0 : _b2.channel.supportsTransferables,
            ...(_c2 = value2.debugInfo) == null ? void 0 : _c2.channel.debugInfo
          }).map(([key2, value3]) => indent(`${key2}=${value3}`, 4)).join("\n"), "    ", (_d2 = value2.debugInfo) == null ? void 0 : _d2.channel, "\n", indent(`Queue: ${value2.queue.unsafeSize().pipe(getOrUndefined)}`, 4), value2.queue);
        }
        console.log("Broadcast channels:", broadcastChannelListenQueueMap.size);
        for (const [key, _value2] of broadcastChannelListenQueueMap) {
          console.log(indent(key, 2));
        }
      },
      ping: (payload) => {
        gen$2(function* () {
          const msg = (via) => DebugPingMessage.make({ message: `ping from ${nodeName} via ${via}`, payload });
          for (const [channelName, con] of edgeChannels) {
            yield* logDebug(`sending ping via edge ${channelName}`);
            yield* con.channel.send(msg(`edge ${channelName}`));
          }
          for (const [channelKey, channel] of channelMap) {
            if (channel.debugInfo === void 0) {
              yield* logDebug(`channel ${channelKey} has no debug info`);
              continue;
            }
            yield* logDebug(`sending ping via channel ${channelKey}`);
            yield* channel.debugInfo.channel.send(msg(`channel ${channelKey}`));
          }
        }).pipe(provide$1(runtime$12), tapCauseLogPretty, runFork$1);
      },
      requestTopology: (timeoutMs = 1e3) => gen$2(function* () {
        const packet = NetworkTopologyRequest.make({
          source: nodeName,
          target: "-",
          hops: []
        });
        const item = /* @__PURE__ */ new Map();
        item.set(nodeName, new Set(edgeChannels.keys()));
        topologyRequestsMap.set(packet.id, item);
        yield* sendPacket(packet);
        yield* logDebug(`Waiting ${timeoutMs}ms for topology response`);
        yield* sleep(timeoutMs);
        yield* logDebug(`Topology response (from ${nodeName}):`);
        for (const [key, value2] of item) {
          yield* logDebug(`  node '${key}' has edge to: ${Array.from(value2.values()).join(", ")}`);
        }
      }).pipe(provide$1(runtime$12), tapCauseLogPretty, runPromise)
    };
    return {
      nodeName,
      addEdge,
      removeEdge,
      hasChannel,
      makeChannel,
      listenForChannel,
      makeBroadcastChannel,
      edgeKeys,
      debug
    };
  }).pipe(withSpan$3(`makeMeshNode:${nodeName}`), annotateLogs({ "makeMeshNode.nodeName": nodeName }));
  const makeExecute = (execute2) => {
    return (...args2) => {
      const [queryStrOrQueryBuilder, bindValuesOrOptions, maybeOptions] = args2;
      if (isQueryBuilder(queryStrOrQueryBuilder)) {
        const { query, bindValues } = queryStrOrQueryBuilder.asSql();
        return execute2(query, bindValues, bindValuesOrOptions);
      } else {
        return execute2(queryStrOrQueryBuilder, bindValuesOrOptions, maybeOptions);
      }
    };
  };
  const makeSelect = (select) => {
    return (...args2) => {
      const [queryStrOrQueryBuilder, maybeBindValues] = args2;
      if (isQueryBuilder(queryStrOrQueryBuilder)) {
        const { query, bindValues } = queryStrOrQueryBuilder.asSql();
        const resultSchema = getResultSchema(queryStrOrQueryBuilder);
        const results = select(query, bindValues);
        return decodeSync(resultSchema)(results);
      } else {
        return select(queryStrOrQueryBuilder, maybeBindValues);
      }
    };
  };
  const configureConnection = (sqliteDb, { foreignKeys, lockingMode }) => execSql(
    sqliteDb,
    // We use the WAL journal mode is significantly faster in most scenarios than the traditional rollback journal mode.
    // It specifically significantly improves write performance. However, when using the WAL journal mode, transactions
    // that involve changes against multiple ATTACHed databases are atomic for each database but are not atomic
    // across all databases as a set. Additionally, it is not possible to change the page size after entering WAL mode,
    // whether on an empty database or by using VACUUM or the backup API. To change the page size, we must switch to the
    // rollback journal mode.
    //
    // When connected to an in-memory database, the WAL journal mode option is ignored because an in-memory database can
    // only be in either the MEMORY or OFF options. By default, an in-memory database is in the MEMORY option, which
    // means that it stores the rollback journal in volatile RAM. This saves disk I/O but at the expense of safety and
    // integrity. If the thread using SQLite crashes in the middle of a transaction, then the database file will very
    // likely go corrupt.
    sql`
    -- disable WAL until we have it working properly
    -- PRAGMA journal_mode=WAL;
    PRAGMA page_size=8192;
    PRAGMA foreign_keys=${"ON"};
    ${lockingMode === void 0 ? "" : sql`PRAGMA locking_mode=${lockingMode};`}
  `,
    {}
  );
  const execSql = (sqliteDb, sql2, bind) => {
    const bindValues = prepareBindValues(bind, sql2);
    return try_({
      try: () => sqliteDb.execute(sql2, bindValues),
      catch: (cause) => new SqliteError({ cause, query: { bindValues, sql: sql2 }, code: cause.code })
    }).pipe(
      asVoid,
      // Effect.logDuration(`@livestore/common:execSql:${sql}`),
      withSpan$3(`@livestore/common:execSql`, {
        attributes: { "span.label": sql2, sql: sql2, bindValueKeys: Object.keys(bindValues) }
      })
    );
  };
  const execSqlPrepared = (sqliteDb, sql2, bindValues) => {
    return try_({
      try: () => sqliteDb.execute(sql2, bindValues),
      catch: (cause) => new SqliteError({ cause, query: { bindValues, sql: sql2 }, code: cause.code })
    }).pipe(
      asVoid,
      // Effect.logDuration(`@livestore/common:execSqlPrepared:${sql}`),
      withSpan$3(`@livestore/common:execSqlPrepared`, {
        attributes: {
          "span.label": sql2,
          sql: sql2,
          bindValueKeys: Object.keys(bindValues)
        }
      })
    );
  };
  const InitialSyncOptionsSkip = TaggedStruct("Skip", {});
  const InitialSyncOptionsBlocking = TaggedStruct("Blocking", {
    timeout: Union(DurationFromMillis, Number$)
  });
  Union(InitialSyncOptionsSkip, InitialSyncOptionsBlocking);
  class LeaderThreadCtx extends Tag("LeaderThreadCtx")() {
  }
  class All extends Union(IntentionalShutdownCause, UnexpectedError) {
  }
  const bootDevtools = (options2) => gen$2(function* () {
    if (options2.enabled === false) {
      return;
    }
    const { syncProcessor, extraIncomingMessagesQueue, clientId: clientId2, storeId } = yield* LeaderThreadCtx;
    yield* listenToDevtools({
      incomingMessages: fromQueue(extraIncomingMessagesQueue),
      sendMessage: () => _void
    }).pipe(tapCauseLogPretty, forkScoped);
    const { node, persistenceInfo, mode } = yield* options2.boot;
    yield* node.listenForChannel.pipe(filter((res) => isChannelName.devtoolsClientLeader(res.channelName, { storeId, clientId: clientId2 }) && res.mode === mode), tap(({ channelName, source }) => gen$2(function* () {
      const channel = yield* node.makeChannel({
        target: source,
        channelName,
        schema: { listen: MessageToApp, send: MessageFromApp },
        mode
      });
      const sendMessage = (message) => channel.send(message).pipe(withSpan$3("@livestore/common:leader-thread:devtools:sendToDevtools"), interruptible, ignoreLogged);
      const syncState = yield* syncProcessor.syncState;
      const mergeCounter = syncProcessor.getMergeCounter();
      yield* syncProcessor.pull({ cursor: { mergeCounter, eventNum: syncState.localHead } }).pipe(tap(({ payload }) => sendMessage(SyncPull.make({ payload, liveStoreVersion: liveStoreVersion$1 }))), runDrain, forkScoped);
      yield* listenToDevtools({
        incomingMessages: channel.listen.pipe(flatten(), orDie),
        sendMessage,
        persistenceInfo
      });
    }).pipe(tapCauseLogPretty, forkScoped)), runDrain);
  }).pipe(withSpan$3("@livestore/common:leader-thread:devtools:boot"));
  const listenToDevtools = ({ incomingMessages, sendMessage, persistenceInfo }) => gen$2(function* () {
    const { syncBackend, makeSqliteDb: makeSqliteDb2, dbState, dbEventlog, shutdownStateSubRef, shutdownChannel, syncProcessor, clientId: clientId2, devtools } = yield* LeaderThreadCtx;
    const subscriptionFiberMap = yield* make$j();
    const handledRequestIds = /* @__PURE__ */ new Set();
    yield* incomingMessages.pipe(tap((decodedEvent) => gen$2(function* () {
      const { requestId: requestId2 } = decodedEvent;
      const reqPayload = { requestId: requestId2, liveStoreVersion: liveStoreVersion$1, clientId: clientId2 };
      if (decodedEvent._tag === "LSD.Leader.Disconnect") {
        return;
      }
      if (handledRequestIds.has(requestId2)) {
        return;
      }
      handledRequestIds.add(requestId2);
      switch (decodedEvent._tag) {
        case "LSD.Leader.Ping": {
          yield* sendMessage(Pong.make({ ...reqPayload }));
          return;
        }
        case "LSD.Leader.SnapshotReq": {
          const snapshot = dbState.export();
          yield* sendMessage(SnapshotRes.make({ snapshot, ...reqPayload }));
          return;
        }
        case "LSD.Leader.LoadDatabaseFile.Request": {
          const { data } = decodedEvent;
          let tableNames;
          try {
            const tmpDb = yield* makeSqliteDb2({ _tag: "in-memory" });
            tmpDb.import(data);
            const tableNameResults = tmpDb.select(`select name from sqlite_master where type = 'table'`);
            tableNames = new Set(tableNameResults.map((_) => _.name));
            tmpDb.close();
          } catch (cause) {
            yield* logError(`Error importing database file`, cause);
            yield* sendMessage(LoadDatabaseFile.Error.make({
              ...reqPayload,
              cause: { _tag: "unexpected-error", cause }
            }));
            return;
          }
          try {
            if (tableNames.has(EVENTLOG_META_TABLE)) {
              yield* set$2(shutdownStateSubRef, "shutting-down");
              dbEventlog.import(data);
              dbState.destroy();
            } else if (tableNames.has(SCHEMA_META_TABLE) && tableNames.has(SCHEMA_EVENT_DEFS_META_TABLE)) {
              yield* set$2(shutdownStateSubRef, "shutting-down");
              dbState.import(data);
              dbEventlog.destroy();
            } else {
              yield* sendMessage(LoadDatabaseFile.Error.make({
                ...reqPayload,
                cause: { _tag: "unsupported-database" }
              }));
              return;
            }
            yield* sendMessage(LoadDatabaseFile.Success.make({ ...reqPayload }));
            yield* shutdownChannel.send(IntentionalShutdownCause.make({ reason: "devtools-import" })) ?? _void;
            return;
          } catch (cause) {
            yield* logError(`Error importing database file`, cause);
            yield* sendMessage(LoadDatabaseFile.Error.make({
              ...reqPayload,
              cause: { _tag: "unexpected-error", cause }
            }));
            return;
          }
        }
        case "LSD.Leader.ResetAllData.Request": {
          const { mode } = decodedEvent;
          yield* set$2(shutdownStateSubRef, "shutting-down");
          dbState.destroy();
          if (mode === "all-data") {
            dbEventlog.destroy();
          }
          yield* sendMessage(ResetAllData.Success.make({ ...reqPayload }));
          yield* shutdownChannel.send(IntentionalShutdownCause.make({ reason: "devtools-reset" })) ?? _void;
          return;
        }
        case "LSD.Leader.DatabaseFileInfoReq": {
          if (persistenceInfo === void 0) {
            console.log("[@livestore/common:leader-thread:devtools] persistenceInfo is required for this request");
            return;
          }
          const dbSizeQuery = `SELECT page_count * page_size as size FROM pragma_page_count(), pragma_page_size();`;
          const dbFileSize = dbState.select(dbSizeQuery, void 0)[0].size;
          const eventlogFileSize = dbEventlog.select(dbSizeQuery, void 0)[0].size;
          yield* sendMessage(DatabaseFileInfoRes.make({
            state: { fileSize: dbFileSize, persistenceInfo: persistenceInfo.state },
            eventlog: { fileSize: eventlogFileSize, persistenceInfo: persistenceInfo.eventlog },
            ...reqPayload
          }));
          return;
        }
        case "LSD.Leader.EventlogReq": {
          const eventlog = dbEventlog.export();
          yield* sendMessage(EventlogRes.make({ eventlog, ...reqPayload }));
          return;
        }
        case "LSD.Leader.CommitEventReq": {
          yield* syncProcessor.pushPartial({
            event: decodedEvent.eventEncoded,
            clientId: `devtools-${clientId2}`,
            sessionId: `devtools-${clientId2}`
          });
          yield* sendMessage(CommitEventRes.make({ ...reqPayload }));
          return;
        }
        case "LSD.Leader.SyncHistorySubscribe": {
          const { subscriptionId } = decodedEvent;
          if (syncBackend !== void 0) {
            yield* syncBackend.pull(none$4()).pipe(map((_) => _.batch), flattenIterables, tap(({ eventEncoded, metadata }) => sendMessage(SyncHistoryRes.make({
              eventEncoded,
              metadata,
              subscriptionId,
              ...reqPayload,
              requestId: nanoid(10)
            }))), runDrain, interruptible, tapCauseLogPretty, run(subscriptionFiberMap, subscriptionId));
          }
          return;
        }
        case "LSD.Leader.SyncHistoryUnsubscribe": {
          const { requestId: requestId3 } = decodedEvent;
          console.log("LSD.SyncHistoryUnsubscribe", requestId3);
          yield* remove$1(subscriptionFiberMap, requestId3);
          return;
        }
        case "LSD.Leader.SyncingInfoReq": {
          const syncingInfo = SyncingInfo.make({
            enabled: syncBackend !== void 0,
            metadata: (syncBackend == null ? void 0 : syncBackend.metadata) ?? {}
          });
          yield* sendMessage(SyncingInfoRes.make({ syncingInfo, ...reqPayload }));
          return;
        }
        case "LSD.Leader.NetworkStatusSubscribe": {
          if (syncBackend !== void 0) {
            const { subscriptionId } = decodedEvent;
            yield* sleep(1e3);
            yield* zipLatest(syncBackend.isConnected.changes, devtools.enabled ? devtools.syncBackendLatchState.changes : make$c({ latchClosed: false })).pipe(tap(([isConnected, { latchClosed }]) => sendMessage(NetworkStatusRes.make({
              networkStatus: { isConnected, timestampMs: Date.now(), latchClosed },
              subscriptionId,
              ...reqPayload,
              requestId: nanoid(10)
            }))), runDrain, interruptible, tapCauseLogPretty, run(subscriptionFiberMap, subscriptionId));
          }
          return;
        }
        case "LSD.Leader.NetworkStatusUnsubscribe": {
          const { requestId: requestId3 } = decodedEvent;
          yield* remove$1(subscriptionFiberMap, requestId3);
          return;
        }
        case "LSD.Leader.SyncHeadSubscribe": {
          const { subscriptionId } = decodedEvent;
          yield* syncProcessor.syncState.changes.pipe(tap((syncState) => sendMessage(SyncHeadRes.make({
            local: syncState.localHead,
            upstream: syncState.upstreamHead,
            subscriptionId,
            ...reqPayload,
            requestId: nanoid(10)
          }))), runDrain, interruptible, tapCauseLogPretty, run(subscriptionFiberMap, subscriptionId));
          return;
        }
        case "LSD.Leader.SyncHeadUnsubscribe": {
          const { subscriptionId } = decodedEvent;
          yield* remove$1(subscriptionFiberMap, subscriptionId);
          return;
        }
        case "LSD.Leader.SetSyncLatch.Request": {
          const { closeLatch } = decodedEvent;
          if (devtools.enabled === false)
            return;
          if (closeLatch === true) {
            yield* devtools.syncBackendLatch.close;
          } else {
            yield* devtools.syncBackendLatch.open;
          }
          yield* set$2(devtools.syncBackendLatchState, { latchClosed: closeLatch });
          yield* sendMessage(SetSyncLatch.Success.make({ ...reqPayload }));
          return;
        }
        default: {
          yield* logWarning(`TODO implement devtools message`, decodedEvent);
        }
      }
    }).pipe(withSpan$3(`@livestore/common:leader-thread:onDevtoolsMessage:${decodedEvent._tag}`))), UnexpectedError.mapToUnexpectedErrorStream, runDrain);
  });
  const objectEntries = (obj) => Object.entries(obj);
  const isValidWhereOp = (op) => {
    const validWhereOps = [">", "<", "="];
    return validWhereOps.includes(op);
  };
  const insertRow = ({ tableName, columns, values, options: options2 = { orReplace: false } }) => {
    const stmt = insertRowPrepared({
      tableName,
      columns,
      options: { orReplace: options2 == null ? void 0 : options2.orReplace, keys: Object.keys(values) }
    });
    return [stmt, makeBindValues({ columns, values })];
  };
  const insertRowPrepared = ({ tableName, columns, options: options2 = { orReplace: false } }) => {
    const keys2 = (options2 == null ? void 0 : options2.keys) ?? Object.keys(columns);
    const keysStr = keys2.join(", ");
    const valuesStr = keys2.map((key) => `$${key}`).join(", ");
    return sql`INSERT ${options2.orReplace ? "OR REPLACE " : ""}INTO ${tableName} (${keysStr}) VALUES (${valuesStr})`;
  };
  const updateRows = ({ columns, tableName, updateValues: updateValues_, where }) => {
    const updateValues = filterUndefinedFields(updateValues_);
    if (Object.keys(updateValues).length === 0) {
      return [sql`select 1`, {}];
    }
    const updateValueStr = Object.keys(updateValues).map((columnName) => `${columnName} = $update_${columnName}`).join(", ");
    const bindValues = {
      ...makeBindValues({ columns, values: updateValues, variablePrefix: "update_" }),
      ...makeBindValues({ columns, values: where, variablePrefix: "where_", skipNil: true })
    };
    const whereSql = buildWhereSql({ where });
    const whereModifier = whereSql === "" ? "" : `WHERE ${whereSql}`;
    return [sql`UPDATE ${tableName} SET ${updateValueStr} ${whereModifier}`, bindValues];
  };
  const makeBindValues = ({ columns, values, variablePrefix = "", skipNil }) => {
    const codecMap = pipe(columns, objectEntries, map$e(([columnName, columnDef]) => [
      columnName,
      (value2) => {
        if (columnDef.nullable === true && (value2 === null || value2 === void 0))
          return null;
        const res = encodeEither(columnDef.schema)(value2);
        if (res._tag === "Left") {
          const parseErrorStr = TreeFormatter.formatErrorSync(res.left);
          const expectedSchemaStr = String(columnDef.schema.ast);
          console.error(`Error making bind values for SQL query for column "${columnName}".

Expected schema: ${expectedSchemaStr}

Error: ${parseErrorStr}

Value:`, value2);
          debugger;
          throw res.left;
        } else {
          return res.right;
        }
      }
    ]), Object.fromEntries);
    return pipe(Object.entries(values).filter(([, value2]) => skipNil !== true || value2 !== null && value2 !== void 0).flatMap(([columnName, value2]) => {
      const codec = codecMap[columnName] ?? shouldNeverHappen(`No codec found for column "${columnName}"`);
      if (typeof value2 === "object" && value2 !== null && "op" in value2) {
        switch (value2.op) {
          case "in": {
            return value2.val.map((value3, i) => [`${variablePrefix}${columnName}_${i}`, codec(value3)]);
          }
          case "=":
          case ">":
          case "<": {
            return [[`${variablePrefix}${columnName}`, codec(value2.val)]];
          }
          default: {
            throw new Error(`Unknown op: ${value2.op}`);
          }
        }
      } else {
        return [[`${variablePrefix}${columnName}`, codec(value2)]];
      }
    }), Object.fromEntries);
  };
  const buildWhereSql = ({ where }) => {
    const getWhereOp = (columnName, value2) => {
      if (value2 === null) {
        return `IS NULL`;
      } else if (typeof value2 === "object" && typeof value2.op === "string" && isValidWhereOp(value2.op)) {
        return `${value2.op} $where_${columnName}`;
      } else if (typeof value2 === "object" && typeof value2.op === "string" && value2.op === "in") {
        return `in (${value2.val.map((_, i) => `$where_${columnName}_${i}`).join(", ")})`;
      } else {
        return `= $where_${columnName}`;
      }
    };
    return pipe(where, objectEntries, map$e(([columnName, value2]) => `${columnName} ${getWhereOp(columnName, value2)}`), join$2(" AND "));
  };
  const filterUndefinedFields = (obj) => {
    return Object.fromEntries(Object.entries(obj).filter(([, value2]) => value2 !== void 0));
  };
  const initEventlogDb = (dbEventlog) => gen$2(function* () {
    for (const tableDef of eventlogSystemTables) {
      yield* migrateTable({
        db: dbEventlog,
        behaviour: "create-if-not-exists",
        tableAst: tableDef.sqliteDef.ast,
        skipMetaTable: true
      });
    }
    yield* execSql(dbEventlog, sql`INSERT INTO ${SYNC_STATUS_TABLE} (head)
          SELECT ${ROOT.global}
          WHERE NOT EXISTS (SELECT 1 FROM ${SYNC_STATUS_TABLE})`, {});
  });
  const getEventsSince = (since) => gen$2(function* () {
    const { dbEventlog, dbState } = yield* LeaderThreadCtx;
    const query = eventlogMetaTable.where("seqNumGlobal", ">=", since.global).asSql();
    const pendingEventsRaw = dbEventlog.select(query.query, prepareBindValues(query.bindValues, query.query));
    const pendingEvents = decodeUnknownSync(eventlogMetaTable.rowSchema.pipe(Array$))(pendingEventsRaw);
    const sessionChangesetRows = sessionChangesetMetaTable.where("seqNumGlobal", ">=", since.global).asSql();
    const sessionChangesetRowsRaw = dbState.select(sessionChangesetRows.query, prepareBindValues(sessionChangesetRows.bindValues, sessionChangesetRows.query));
    const sessionChangesetRowsDecoded = decodeUnknownSync(sessionChangesetMetaTable.rowSchema.pipe(Array$))(sessionChangesetRowsRaw);
    return pendingEvents.map((eventlogEvent) => {
      const sessionChangeset = sessionChangesetRowsDecoded.find((readModelEvent) => readModelEvent.seqNumGlobal === eventlogEvent.seqNumGlobal && readModelEvent.seqNumClient === eventlogEvent.seqNumClient);
      return EncodedWithMeta.make({
        name: eventlogEvent.name,
        args: eventlogEvent.argsJson,
        seqNum: { global: eventlogEvent.seqNumGlobal, client: eventlogEvent.seqNumClient },
        parentSeqNum: { global: eventlogEvent.parentSeqNumGlobal, client: eventlogEvent.parentSeqNumClient },
        clientId: eventlogEvent.clientId,
        sessionId: eventlogEvent.sessionId,
        meta: {
          sessionChangeset: sessionChangeset && sessionChangeset.changeset !== null ? {
            _tag: "sessionChangeset",
            data: sessionChangeset.changeset,
            debug: sessionChangeset.debug
          } : { _tag: "unset" },
          syncMetadata: eventlogEvent.syncMetadataJson,
          materializerHashLeader: none$4(),
          materializerHashSession: none$4()
        }
      });
    }).filter((_) => compare(_.seqNum, since) > 0).sort((a, b) => compare(a.seqNum, b.seqNum));
  });
  const getClientHeadFromDb = (dbEventlog) => {
    const res = dbEventlog.select(sql`select seqNumGlobal, seqNumClient from ${EVENTLOG_META_TABLE} order by seqNumGlobal DESC, seqNumClient DESC limit 1`)[0];
    return res ? { global: res.seqNumGlobal, client: res.seqNumClient } : ROOT;
  };
  const getBackendHeadFromDb = (dbEventlog) => {
    var _a2;
    return ((_a2 = dbEventlog.select(sql`select head from ${SYNC_STATUS_TABLE}`)[0]) == null ? void 0 : _a2.head) ?? ROOT.global;
  };
  const updateBackendHead = (dbEventlog, head2) => dbEventlog.execute(sql`UPDATE ${SYNC_STATUS_TABLE} SET head = ${head2.global}`);
  const insertIntoEventlog = (eventEncoded, dbEventlog, eventDefSchemaHash, clientId2, sessionId) => gen$2(function* () {
    if (LS_DEV && eventEncoded.parentSeqNum.global !== ROOT.global) {
      const parentEventExists = dbEventlog.select(`SELECT COUNT(*) as count FROM ${EVENTLOG_META_TABLE} WHERE seqNumGlobal = ? AND seqNumClient = ?`, [eventEncoded.parentSeqNum.global, eventEncoded.parentSeqNum.client])[0].count === 1;
      if (parentEventExists === false) {
        shouldNeverHappen(`Parent mutation ${eventEncoded.parentSeqNum.global},${eventEncoded.parentSeqNum.client} does not exist`);
      }
    }
    yield* execSql(dbEventlog, ...insertRow({
      tableName: EVENTLOG_META_TABLE,
      columns: eventlogMetaTable.sqliteDef.columns,
      values: {
        seqNumGlobal: eventEncoded.seqNum.global,
        seqNumClient: eventEncoded.seqNum.client,
        parentSeqNumGlobal: eventEncoded.parentSeqNum.global,
        parentSeqNumClient: eventEncoded.parentSeqNum.client,
        name: eventEncoded.name,
        argsJson: eventEncoded.args ?? {},
        clientId: clientId2,
        sessionId,
        schemaHash: eventDefSchemaHash,
        syncMetadataJson: eventEncoded.meta.syncMetadata
      }
    }));
  });
  const updateSyncMetadata = (items) => gen$2(function* () {
    const { dbEventlog } = yield* LeaderThreadCtx;
    for (let i = 0; i < items.length; i++) {
      const event = items[i];
      yield* execSql(dbEventlog, ...updateRows({
        tableName: EVENTLOG_META_TABLE,
        columns: eventlogMetaTable.sqliteDef.columns,
        where: { seqNumGlobal: event.seqNum.global, seqNumClient: event.seqNum.client },
        updateValues: { syncMetadataJson: event.meta.syncMetadata }
      }));
    }
  });
  const getSyncBackendCursorInfo = (remoteHead) => gen$2(function* () {
    const { dbEventlog } = yield* LeaderThreadCtx;
    if (remoteHead === ROOT.global)
      return none$4();
    const EventlogQuerySchema = Struct({
      syncMetadataJson: parseJson(Option(JsonValue))
    }).pipe(pluck("syncMetadataJson"), Array$, head$2);
    const syncMetadataOption = yield* sync$3(() => dbEventlog.select(sql`SELECT syncMetadataJson FROM ${EVENTLOG_META_TABLE} WHERE seqNumGlobal = ${remoteHead} ORDER BY seqNumClient ASC LIMIT 1`)).pipe(andThen(decode(EventlogQuerySchema)), map$5(flatten$9), orDie$2);
    return some({
      cursor: { global: remoteHead, client: clientDefault },
      metadata: syncMetadataOption
    });
  }).pipe(withSpan$3("@livestore/common:eventlog:getSyncBackendCursorInfo", { attributes: { remoteHead } }));
  const makeMaterializeEvent = ({ schema: schema2, dbState, dbEventlog }) => gen$2(function* () {
    const eventDefSchemaHashMap = new Map(
      // TODO Running `Schema.hash` can be a bottleneck for larger schemas. There is an opportunity to run this
      // at build time and lookup the pre-computed hash at runtime.
      // Also see https://github.com/Effect-TS/effect/issues/2719
      [...schema2.eventsDefsMap.entries()].map(([k, v]) => [k, hash$1(v.schema)])
    );
    return (eventEncoded, options2) => gen$2(function* () {
      const skipEventlog = (options2 == null ? void 0 : options2.skipEventlog) ?? false;
      const eventName = eventEncoded.name;
      const { eventDef, materializer } = getEventDef(schema2, eventName);
      const execArgsArr = getExecStatementsFromMaterializer({
        eventDef,
        materializer,
        dbState,
        event: { decoded: void 0, encoded: eventEncoded }
      });
      const materializerHash = isDevEnv() ? some(hashMaterializerResults(execArgsArr)) : none$4();
      if (materializerHash._tag === "Some" && eventEncoded.meta.materializerHashSession._tag === "Some" && eventEncoded.meta.materializerHashSession.value !== materializerHash.value) {
        yield* UnexpectedError.make({
          cause: `Materializer hash mismatch detected for event "${eventEncoded.name}".`,
          note: `Please make sure your event materializer is a pure function without side effects.`
        });
      }
      const session = dbState.session();
      for (const { statementSql, bindValues } of execArgsArr) {
        yield* execSqlPrepared(dbState, statementSql, bindValues);
      }
      const changeset = session.changeset();
      session.finish();
      yield* execSql(dbState, ...insertRow({
        tableName: SESSION_CHANGESET_META_TABLE,
        columns: sessionChangesetMetaTable.sqliteDef.columns,
        values: {
          seqNumGlobal: eventEncoded.seqNum.global,
          seqNumClient: eventEncoded.seqNum.client,
          // NOTE the changeset will be empty (i.e. null) for no-op events
          changeset: changeset ?? null,
          debug: LS_DEV ? execArgsArr : null
        }
      }));
      if (skipEventlog === false) {
        const eventName2 = eventEncoded.name;
        const eventDefSchemaHash = eventDefSchemaHashMap.get(eventName2) ?? shouldNeverHappen(`Unknown event definition: ${eventName2}`);
        yield* insertIntoEventlog(eventEncoded, dbEventlog, eventDefSchemaHash, eventEncoded.clientId, eventEncoded.sessionId);
      }
      return {
        sessionChangeset: changeset ? {
          _tag: "sessionChangeset",
          data: changeset,
          debug: LS_DEV ? execArgsArr : null
        } : { _tag: "no-op" },
        hash: materializerHash
      };
    }).pipe(withSpan$3(`@livestore/common:leader-thread:materializeEvent`, {
      attributes: {
        eventName: eventEncoded.name,
        eventNum: eventEncoded.seqNum,
        "span.label": `${toString(eventEncoded.seqNum)} ${eventEncoded.name}`
      }
    }));
  });
  const rollback = ({ dbState, dbEventlog, eventNumsToRollback }) => gen$2(function* () {
    const rollbackEvents = dbState.select(sql`SELECT * FROM ${SESSION_CHANGESET_META_TABLE} WHERE (seqNumGlobal, seqNumClient) IN (${eventNumsToRollback.map((id2) => `(${id2.global}, ${id2.client})`).join(", ")})`).map((_) => ({
      seqNum: { global: _.seqNumGlobal, client: _.seqNumClient },
      changeset: _.changeset,
      debug: _.debug
    })).toSorted((a, b) => compare(a.seqNum, b.seqNum));
    for (let i = rollbackEvents.length - 1; i >= 0; i--) {
      const { changeset } = rollbackEvents[i];
      if (changeset !== null) {
        dbState.makeChangeset(changeset).invert().apply();
      }
    }
    const eventNumPairChunks = chunksOf(100)(eventNumsToRollback.map((seqNum) => `(${seqNum.global}, ${seqNum.client})`));
    for (const eventNumPairChunk of eventNumPairChunks) {
      dbState.execute(sql`DELETE FROM ${SESSION_CHANGESET_META_TABLE} WHERE (seqNumGlobal, seqNumClient) IN (${eventNumPairChunk.join(", ")})`);
    }
    for (const eventNumPairChunk of eventNumPairChunks) {
      dbEventlog.execute(sql`DELETE FROM ${EVENTLOG_META_TABLE} WHERE (seqNumGlobal, seqNumClient) IN (${eventNumPairChunk.join(", ")})`);
    }
  }).pipe(withSpan$3("@livestore/common:LeaderSyncProcessor:rollback", {
    attributes: { count: eventNumsToRollback.length }
  }));
  const makeLeaderSyncProcessor = ({ schema: schema2, dbEventlogMissing, dbEventlog, dbState, dbStateMissing, initialBlockingSyncContext, onError: onError2, params, testing }) => gen$2(function* () {
    const syncBackendPushQueue = yield* make$8();
    const localPushBatchSize = params.localPushBatchSize ?? 10;
    const backendPushBatchSize = params.backendPushBatchSize ?? 50;
    const syncStateSref = yield* make$a(void 0);
    const isClientEvent = (eventEncoded) => {
      const { eventDef } = getEventDef(schema2, eventEncoded.name);
      return eventDef.options.clientOnly;
    };
    const connectedClientSessionPullQueues = yield* makePullQueueSet;
    const currentLocalPushGenerationRef = { current: 0 };
    const mergeCounterRef = { current: dbStateMissing ? 0 : yield* getMergeCounterFromDb(dbState) };
    const mergePayloads = /* @__PURE__ */ new Map();
    const ctxRef = {
      current: void 0
    };
    const localPushesQueue = yield* make$8();
    const localPushesLatch = yield* makeLatch(true);
    const pullLatch = yield* makeLatch(true);
    const pushHeadRef = { current: ROOT };
    const advancePushHead = (eventNum) => {
      pushHeadRef.current = max(pushHeadRef.current, eventNum);
    };
    const push = (newEvents, options2) => {
      var _a2;
      return gen$2(function* () {
        if (newEvents.length === 0)
          return;
        yield* validatePushBatch(newEvents, pushHeadRef.current);
        advancePushHead(newEvents.at(-1).seqNum);
        const waitForProcessing = (options2 == null ? void 0 : options2.waitForProcessing) ?? false;
        const generation = currentLocalPushGenerationRef.current;
        if (waitForProcessing) {
          const deferreds = yield* forEach(newEvents, () => make$N());
          const items = newEvents.map((eventEncoded, i) => [eventEncoded, deferreds[i], generation]);
          yield* offerAll(localPushesQueue, items);
          yield* all(deferreds);
        } else {
          const items = newEvents.map((eventEncoded) => [eventEncoded, void 0, generation]);
          yield* offerAll(localPushesQueue, items);
        }
      }).pipe(withSpan$3("@livestore/common:LeaderSyncProcessor:push", {
        attributes: {
          batchSize: newEvents.length,
          batch: TRACE_VERBOSE ? newEvents : void 0
        },
        links: ((_a2 = ctxRef.current) == null ? void 0 : _a2.span) ? [{ _tag: "SpanLink", span: ctxRef.current.span, attributes: {} }] : void 0
      }));
    };
    const pushPartial = ({ event: { name, args: args2 }, clientId: clientId2, sessionId }) => gen$2(function* () {
      const syncState2 = yield* syncStateSref;
      if (syncState2 === void 0)
        return shouldNeverHappen("Not initialized");
      const { eventDef } = getEventDef(schema2, name);
      const eventEncoded = new EncodedWithMeta({
        name,
        args: args2,
        clientId: clientId2,
        sessionId,
        ...nextPair(syncState2.localHead, eventDef.options.clientOnly)
      });
      yield* push([eventEncoded]);
    }).pipe(catchTag("LeaderAheadError", orDie$2));
    const boot = gen$2(function* () {
      var _a2, _b2, _c2;
      const span2 = yield* currentSpan.pipe(orDie$2);
      const otelSpan = yield* currentOtelSpan.pipe(catchAll$2(() => succeed$5(void 0)));
      const { devtools, shutdownChannel } = yield* LeaderThreadCtx;
      const runtime$12 = yield* runtime();
      ctxRef.current = {
        otelSpan,
        span: span2,
        devtoolsLatch: devtools.enabled ? devtools.syncBackendLatch : void 0,
        runtime: runtime$12
      };
      const initialLocalHead = dbEventlogMissing ? ROOT : getClientHeadFromDb(dbEventlog);
      const initialBackendHead = dbEventlogMissing ? ROOT.global : getBackendHeadFromDb(dbEventlog);
      if (initialBackendHead > initialLocalHead.global) {
        return shouldNeverHappen(`During boot the backend head (${initialBackendHead}) should never be greater than the local head (${initialLocalHead.global})`);
      }
      const pendingEvents = dbEventlogMissing ? [] : yield* getEventsSince({ global: initialBackendHead, client: clientDefault });
      const initialSyncState = new SyncState({
        pending: pendingEvents,
        upstreamHead: { global: initialBackendHead, client: clientDefault },
        localHead: initialLocalHead
      });
      yield* set$2(syncStateSref, initialSyncState);
      if (pendingEvents.length > 0) {
        const globalPendingEvents = pendingEvents.filter((eventEncoded) => {
          const { eventDef } = getEventDef(schema2, eventEncoded.name);
          return eventDef.options.clientOnly === false;
        });
        if (globalPendingEvents.length > 0) {
          yield* offerAll(syncBackendPushQueue, globalPendingEvents);
        }
      }
      const shutdownOnError = (cause) => gen$2(function* () {
        if (onError2 === "shutdown") {
          yield* shutdownChannel.send(UnexpectedError.make({ cause }));
          yield* die$3(cause);
        }
      });
      yield* backgroundApplyLocalPushes({
        localPushesLatch,
        localPushesQueue,
        pullLatch,
        syncStateSref,
        syncBackendPushQueue,
        schema: schema2,
        isClientEvent,
        otelSpan,
        currentLocalPushGenerationRef,
        connectedClientSessionPullQueues,
        mergeCounterRef,
        mergePayloads,
        localPushBatchSize,
        testing: {
          delay: (_a2 = testing == null ? void 0 : testing.delays) == null ? void 0 : _a2.localPushProcessing
        }
      }).pipe(tapCauseLogPretty, catchAllCause$1(shutdownOnError), forkScoped);
      const backendPushingFiberHandle = yield* make$k();
      const backendPushingEffect = backgroundBackendPushing({
        syncBackendPushQueue,
        otelSpan,
        devtoolsLatch: (_b2 = ctxRef.current) == null ? void 0 : _b2.devtoolsLatch,
        backendPushBatchSize
      }).pipe(tapCauseLogPretty, catchAllCause$1(shutdownOnError));
      yield* run$1(backendPushingFiberHandle, backendPushingEffect);
      yield* backgroundBackendPulling({
        initialBackendHead,
        isClientEvent,
        restartBackendPushing: (filteredRebasedPending) => gen$2(function* () {
          yield* clear$1(backendPushingFiberHandle);
          yield* clear(syncBackendPushQueue);
          yield* offerAll(syncBackendPushQueue, filteredRebasedPending);
          yield* run$1(backendPushingFiberHandle, backendPushingEffect);
        }),
        syncStateSref,
        localPushesLatch,
        pullLatch,
        dbState,
        otelSpan,
        initialBlockingSyncContext,
        devtoolsLatch: (_c2 = ctxRef.current) == null ? void 0 : _c2.devtoolsLatch,
        connectedClientSessionPullQueues,
        mergeCounterRef,
        mergePayloads,
        advancePushHead
      }).pipe(tapCauseLogPretty, catchAllCause$1(shutdownOnError), forkScoped);
      return { initialLeaderHead: initialLocalHead };
    }).pipe(withSpanScoped("@livestore/common:LeaderSyncProcessor:boot"));
    const pull = ({ cursor }) => gen$2(function* () {
      const queue = yield* pullQueue({ cursor });
      return fromQueue(queue);
    }).pipe(unwrapScoped);
    const pullQueue = ({ cursor }) => {
      var _a2;
      const runtime2 = ((_a2 = ctxRef.current) == null ? void 0 : _a2.runtime) ?? shouldNeverHappen("Not initialized");
      return gen$2(function* () {
        const queue = yield* connectedClientSessionPullQueues.makeQueue;
        const payloadsSinceCursor = Array.from(mergePayloads.entries()).map(([mergeCounter, payload]) => ({ payload, mergeCounter })).filter(({ mergeCounter }) => mergeCounter > cursor.mergeCounter).toSorted((a, b) => a.mergeCounter - b.mergeCounter).map(({ payload, mergeCounter }) => {
          if (payload._tag === "upstream-advance") {
            return {
              payload: {
                _tag: "upstream-advance",
                newEvents: dropWhile(payload.newEvents, (eventEncoded) => isGreaterThanOrEqual(cursor.eventNum, eventEncoded.seqNum))
              },
              mergeCounter
            };
          } else {
            return { payload, mergeCounter };
          }
        });
        yield* queue.offerAll(payloadsSinceCursor);
        return queue;
      }).pipe(provide$1(runtime2));
    };
    const syncState = make$7({
      get: gen$2(function* () {
        const syncState2 = yield* syncStateSref;
        if (syncState2 === void 0)
          return shouldNeverHappen("Not initialized");
        return syncState2;
      }),
      changes: syncStateSref.changes.pipe(filter(isNotUndefined))
    });
    return {
      pull,
      pullQueue,
      push,
      pushPartial,
      boot,
      syncState,
      getMergeCounter: () => mergeCounterRef.current
    };
  });
  const backgroundApplyLocalPushes = ({ localPushesLatch, localPushesQueue, pullLatch, syncStateSref, syncBackendPushQueue, schema: schema2, isClientEvent, otelSpan, currentLocalPushGenerationRef, connectedClientSessionPullQueues, mergeCounterRef, mergePayloads, localPushBatchSize, testing }) => gen$2(function* () {
    while (true) {
      if (testing.delay !== void 0) {
        yield* testing.delay.pipe(withSpan$3("localPushProcessingDelay"));
      }
      const batchItems = yield* takeBetween(localPushesQueue, 1, localPushBatchSize);
      yield* localPushesLatch.await;
      yield* pullLatch.close;
      const filteredBatchItems = batchItems.filter(([_1, _2, generation]) => generation === currentLocalPushGenerationRef.current).map(([eventEncoded, deferred]) => [eventEncoded, deferred]);
      if (filteredBatchItems.length === 0) {
        yield* pullLatch.open;
        continue;
      }
      const [newEvents, deferreds] = unzip(filteredBatchItems);
      const syncState = yield* syncStateSref;
      if (syncState === void 0)
        return shouldNeverHappen("Not initialized");
      const mergeResult = merge({
        syncState,
        payload: { _tag: "local-push", newEvents },
        isClientEvent,
        isEqualEvent: isEqualEncoded
      });
      const mergeCounter = yield* incrementMergeCounter(mergeCounterRef);
      switch (mergeResult._tag) {
        case "unexpected-error": {
          otelSpan == null ? void 0 : otelSpan.addEvent(`[${mergeCounter}]:push:unexpected-error`, {
            batchSize: newEvents.length,
            newEvents: TRACE_VERBOSE ? JSON.stringify(newEvents) : void 0
          });
          return yield* fail$6(mergeResult.cause);
        }
        case "rebase": {
          return shouldNeverHappen("The leader thread should never have to rebase due to a local push");
        }
        case "reject": {
          otelSpan == null ? void 0 : otelSpan.addEvent(`[${mergeCounter}]:push:reject`, {
            batchSize: newEvents.length,
            mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
          });
          currentLocalPushGenerationRef.current++;
          const nextGeneration = currentLocalPushGenerationRef.current;
          const providedNum = newEvents.at(0).seqNum;
          const remainingEventsMatchingGeneration = yield* takeSplitWhere(localPushesQueue, (item) => item[2] >= nextGeneration);
          if (LS_DEV && (yield* size(localPushesQueue)) > 0) {
            console.log("localPushesQueue is not empty", yield* size(localPushesQueue));
            debugger;
          }
          const allDeferredsToReject = [
            ...deferreds,
            ...remainingEventsMatchingGeneration.map(([_, deferred]) => deferred)
          ].filter(isNotUndefined);
          yield* forEach(allDeferredsToReject, (deferred) => fail$a(deferred, LeaderAheadError.make({
            minimumExpectedNum: mergeResult.expectedMinimumId,
            providedNum
            // nextGeneration,
          })));
          yield* pullLatch.open;
          continue;
        }
        case "advance": {
          break;
        }
        default: {
          casesHandled(mergeResult);
        }
      }
      yield* set$2(syncStateSref, mergeResult.newSyncState);
      yield* connectedClientSessionPullQueues.offer({
        payload: PayloadUpstreamAdvance.make({ newEvents: mergeResult.newEvents }),
        mergeCounter
      });
      mergePayloads.set(mergeCounter, PayloadUpstreamAdvance.make({ newEvents: mergeResult.newEvents }));
      otelSpan == null ? void 0 : otelSpan.addEvent(`[${mergeCounter}]:push:advance`, {
        batchSize: newEvents.length,
        mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
      });
      const filteredBatch = mergeResult.newEvents.filter((eventEncoded) => {
        const { eventDef } = getEventDef(schema2, eventEncoded.name);
        return eventDef.options.clientOnly === false;
      });
      yield* offerAll(syncBackendPushQueue, filteredBatch);
      yield* materializeEventsBatch({ batchItems: mergeResult.newEvents, deferreds });
      yield* pullLatch.open;
    }
  });
  const materializeEventsBatch = ({ batchItems, deferreds }) => gen$2(function* () {
    const { dbState: db, dbEventlog, materializeEvent } = yield* LeaderThreadCtx;
    db.execute("BEGIN TRANSACTION", void 0);
    dbEventlog.execute("BEGIN TRANSACTION", void 0);
    yield* addFinalizer((exit2) => gen$2(function* () {
      if (isSuccess$1(exit2))
        return;
      db.execute("ROLLBACK", void 0);
      dbEventlog.execute("ROLLBACK", void 0);
    }));
    for (let i = 0; i < batchItems.length; i++) {
      const { sessionChangeset, hash: hash2 } = yield* materializeEvent(batchItems[i]);
      batchItems[i].meta.sessionChangeset = sessionChangeset;
      batchItems[i].meta.materializerHashLeader = hash2;
      if ((deferreds == null ? void 0 : deferreds[i]) !== void 0) {
        yield* succeed$9(deferreds[i], void 0);
      }
    }
    db.execute("COMMIT", void 0);
    dbEventlog.execute("COMMIT", void 0);
  }).pipe(uninterruptible, scoped$3, withSpan$3("@livestore/common:LeaderSyncProcessor:materializeEventItems", {
    attributes: { batchSize: batchItems.length }
  }), tapCauseLogPretty, UnexpectedError.mapToUnexpectedError);
  const backgroundBackendPulling = ({ initialBackendHead, isClientEvent, restartBackendPushing, otelSpan, dbState, syncStateSref, localPushesLatch, pullLatch, devtoolsLatch, initialBlockingSyncContext, connectedClientSessionPullQueues, mergeCounterRef, mergePayloads, advancePushHead }) => gen$2(function* () {
    const { syncBackend, dbState: db, dbEventlog, schema: schema2 } = yield* LeaderThreadCtx;
    if (syncBackend === void 0)
      return;
    const onNewPullChunk = (newEvents, remaining) => gen$2(function* () {
      if (newEvents.length === 0)
        return;
      if (devtoolsLatch !== void 0) {
        yield* devtoolsLatch.await;
      }
      yield* localPushesLatch.close;
      yield* pullLatch.await;
      const syncState = yield* syncStateSref;
      if (syncState === void 0)
        return shouldNeverHappen("Not initialized");
      const mergeResult = merge({
        syncState,
        payload: PayloadUpstreamAdvance.make({ newEvents }),
        isClientEvent,
        isEqualEvent: isEqualEncoded,
        ignoreClientEvents: true
      });
      const mergeCounter = yield* incrementMergeCounter(mergeCounterRef);
      if (mergeResult._tag === "reject") {
        return shouldNeverHappen("The leader thread should never reject upstream advances");
      } else if (mergeResult._tag === "unexpected-error") {
        otelSpan == null ? void 0 : otelSpan.addEvent(`[${mergeCounter}]:pull:unexpected-error`, {
          newEventsCount: newEvents.length,
          newEvents: TRACE_VERBOSE ? JSON.stringify(newEvents) : void 0
        });
        return yield* fail$6(mergeResult.cause);
      }
      const newBackendHead = newEvents.at(-1).seqNum;
      updateBackendHead(dbEventlog, newBackendHead);
      if (mergeResult._tag === "rebase") {
        otelSpan == null ? void 0 : otelSpan.addEvent(`[${mergeCounter}]:pull:rebase`, {
          newEventsCount: newEvents.length,
          newEvents: TRACE_VERBOSE ? JSON.stringify(newEvents) : void 0,
          rollbackCount: mergeResult.rollbackEvents.length,
          mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
        });
        const globalRebasedPendingEvents = mergeResult.newSyncState.pending.filter((event) => {
          const { eventDef } = getEventDef(schema2, event.name);
          return eventDef.options.clientOnly === false;
        });
        yield* restartBackendPushing(globalRebasedPendingEvents);
        if (mergeResult.rollbackEvents.length > 0) {
          yield* rollback({
            dbState: db,
            dbEventlog,
            eventNumsToRollback: mergeResult.rollbackEvents.map((_) => _.seqNum)
          });
        }
        yield* connectedClientSessionPullQueues.offer({
          payload: PayloadUpstreamRebase.make({
            newEvents: mergeResult.newEvents,
            rollbackEvents: mergeResult.rollbackEvents
          }),
          mergeCounter
        });
        mergePayloads.set(mergeCounter, PayloadUpstreamRebase.make({
          newEvents: mergeResult.newEvents,
          rollbackEvents: mergeResult.rollbackEvents
        }));
      } else {
        otelSpan == null ? void 0 : otelSpan.addEvent(`[${mergeCounter}]:pull:advance`, {
          newEventsCount: newEvents.length,
          mergeResult: TRACE_VERBOSE ? JSON.stringify(mergeResult) : void 0
        });
        yield* connectedClientSessionPullQueues.offer({
          payload: PayloadUpstreamAdvance.make({ newEvents: mergeResult.newEvents }),
          mergeCounter
        });
        mergePayloads.set(mergeCounter, PayloadUpstreamAdvance.make({ newEvents: mergeResult.newEvents }));
        if (mergeResult.confirmedEvents.length > 0) {
          const confirmedNewEvents = newEvents.filter((event) => mergeResult.confirmedEvents.some((confirmedEvent) => isEqual(event.seqNum, confirmedEvent.seqNum)));
          yield* updateSyncMetadata(confirmedNewEvents);
        }
      }
      trimChangesetRows(db, newBackendHead);
      advancePushHead(mergeResult.newSyncState.localHead);
      yield* materializeEventsBatch({ batchItems: mergeResult.newEvents, deferreds: void 0 });
      yield* set$2(syncStateSref, mergeResult.newSyncState);
      if (remaining === 0) {
        yield* localPushesLatch.open;
      }
    });
    const cursorInfo = yield* getSyncBackendCursorInfo(initialBackendHead);
    const hashMaterializerResult = makeMaterializerHash({ schema: schema2, dbState });
    yield* syncBackend.pull(cursorInfo).pipe(
      // TODO only take from queue while connected
      tap(({ batch, remaining }) => gen$2(function* () {
        yield* waitUntil(syncBackend.isConnected, (isConnected) => isConnected === true);
        yield* onNewPullChunk(batch.map((_) => EncodedWithMeta.fromGlobal(_.eventEncoded, {
          syncMetadata: _.metadata,
          materializerHashLeader: hashMaterializerResult(_.eventEncoded),
          materializerHashSession: none$4()
        })), remaining);
        yield* initialBlockingSyncContext.update({ processed: batch.length, remaining });
      })),
      runDrain,
      interruptible
    );
  }).pipe(withSpan$3("@livestore/common:LeaderSyncProcessor:backend-pulling"));
  const backgroundBackendPushing = ({ syncBackendPushQueue, otelSpan, devtoolsLatch, backendPushBatchSize }) => gen$2(function* () {
    const { syncBackend } = yield* LeaderThreadCtx;
    if (syncBackend === void 0)
      return;
    while (true) {
      yield* waitUntil(syncBackend.isConnected, (isConnected) => isConnected === true);
      const queueItems = yield* takeBetween(syncBackendPushQueue, 1, backendPushBatchSize);
      yield* waitUntil(syncBackend.isConnected, (isConnected) => isConnected === true);
      if (devtoolsLatch !== void 0) {
        yield* devtoolsLatch.await;
      }
      otelSpan == null ? void 0 : otelSpan.addEvent("backend-push", {
        batchSize: queueItems.length,
        batch: TRACE_VERBOSE ? JSON.stringify(queueItems) : void 0
      });
      const pushResult = yield* syncBackend.push(queueItems.map((_) => _.toGlobal())).pipe(either$1);
      if (pushResult._tag === "Left") {
        if (LS_DEV) {
          yield* logDebug("handled backend-push-error", { error: pushResult.left.toString() });
        }
        otelSpan == null ? void 0 : otelSpan.addEvent("backend-push-error", { error: pushResult.left.toString() });
        return yield* never$2;
      }
    }
  }).pipe(interruptible, withSpan$3("@livestore/common:LeaderSyncProcessor:backend-pushing"));
  const trimChangesetRows = (db, newHead) => {
    db.execute(sql`DELETE FROM ${SESSION_CHANGESET_META_TABLE} WHERE seqNumGlobal < ${newHead.global}`);
  };
  const makePullQueueSet = gen$2(function* () {
    const set2 = /* @__PURE__ */ new Set();
    yield* addFinalizer(() => gen$2(function* () {
      for (const queue of set2) {
        yield* shutdown(queue);
      }
      set2.clear();
    }));
    const makeQueue2 = gen$2(function* () {
      const queue = yield* unbounded$2().pipe(acquireRelease(shutdown));
      yield* addFinalizer(() => sync$3(() => set2.delete(queue)));
      set2.add(queue);
      return queue;
    });
    const offer2 = (item) => gen$2(function* () {
      if (item.payload._tag === "upstream-advance" && item.payload.newEvents.length === 0) {
        return;
      }
      for (const queue of set2) {
        yield* offer$2(queue, item);
      }
    });
    return {
      makeQueue: makeQueue2,
      offer: offer2
    };
  });
  const incrementMergeCounter = (mergeCounterRef) => gen$2(function* () {
    const { dbState } = yield* LeaderThreadCtx;
    mergeCounterRef.current++;
    dbState.execute(sql`INSERT OR REPLACE INTO ${LEADER_MERGE_COUNTER_TABLE} (id, mergeCounter) VALUES (0, ${mergeCounterRef.current})`);
    return mergeCounterRef.current;
  });
  const getMergeCounterFromDb = (dbState) => gen$2(function* () {
    var _a2;
    const result = dbState.select(sql`SELECT mergeCounter FROM ${LEADER_MERGE_COUNTER_TABLE} WHERE id = 0`);
    return ((_a2 = result[0]) == null ? void 0 : _a2.mergeCounter) ?? 0;
  });
  const validatePushBatch = (batch, pushHead) => gen$2(function* () {
    if (batch.length === 0) {
      return;
    }
    for (let i = 1; i < batch.length; i++) {
      if (isGreaterThanOrEqual(batch[i - 1].seqNum, batch[i].seqNum)) {
        shouldNeverHappen(`Events must be ordered in monotonically ascending order by eventNum. Received: [${batch.map((e) => toString(e.seqNum)).join(", ")}]`);
      }
    }
    if (isGreaterThanOrEqual(pushHead, batch[0].seqNum)) {
      return yield* LeaderAheadError.make({
        minimumExpectedNum: pushHead,
        providedNum: batch[0].seqNum
      });
    }
  });
  const recreateDb = gen$2(function* () {
    const { dbState, dbEventlog, schema: schema2, bootStatusQueue, materializeEvent } = yield* LeaderThreadCtx;
    const migrationOptions = schema2.state.sqlite.migrations;
    let migrationsReport;
    yield* addFinalizer(fn("recreateDb:finalizer")(function* (ex) {
      if (ex._tag === "Failure")
        dbState.destroy();
    }));
    const tmpDb = dbState;
    yield* configureConnection(tmpDb, { foreignKeys: true });
    const initDb = (hooks) => gen$2(function* () {
      yield* tryAll(() => {
        var _a2;
        return (_a2 = hooks == null ? void 0 : hooks.init) == null ? void 0 : _a2.call(hooks, tmpDb);
      }).pipe(UnexpectedError.mapToUnexpectedError);
      const migrationsReport2 = yield* migrateDb({
        db: tmpDb,
        schema: schema2,
        onProgress: ({ done: done2, total }) => offer$2(bootStatusQueue, { stage: "migrating", progress: { done: done2, total } })
      });
      yield* tryAll(() => {
        var _a2;
        return (_a2 = hooks == null ? void 0 : hooks.pre) == null ? void 0 : _a2.call(hooks, tmpDb);
      }).pipe(UnexpectedError.mapToUnexpectedError);
      return { migrationsReport: migrationsReport2, tmpDb };
    });
    switch (migrationOptions.strategy) {
      case "auto": {
        const hooks = migrationOptions.hooks;
        const initResult = yield* initDb(hooks);
        migrationsReport = initResult.migrationsReport;
        yield* rematerializeFromEventlog({
          // db: initResult.tmpDb,
          dbEventlog,
          schema: schema2,
          materializeEvent,
          onProgress: ({ done: done2, total }) => offer$2(bootStatusQueue, { stage: "rehydrating", progress: { done: done2, total } })
        });
        yield* tryAll(() => {
          var _a2;
          return (_a2 = hooks == null ? void 0 : hooks.post) == null ? void 0 : _a2.call(hooks, initResult.tmpDb);
        }).pipe(UnexpectedError.mapToUnexpectedError);
        break;
      }
      case "manual": {
        const oldDbData = dbState.export();
        migrationsReport = { migrations: [] };
        const newDbData = yield* tryAll(() => migrationOptions.migrate(oldDbData)).pipe(UnexpectedError.mapToUnexpectedError);
        tmpDb.import(newDbData);
        break;
      }
      default: {
        casesHandled(migrationOptions);
      }
    }
    return { migrationsReport };
  }).pipe(
    scoped$3,
    // NOTE we're closing the scope here so finalizers are called when the effect is done
    withSpan$3("@livestore/common:leader-thread:recreateDb"),
    withPerformanceMeasure("@livestore/common:leader-thread:recreateDb")
  );
  const makeLeaderThreadLayer = ({ schema: schema2, storeId, clientId: clientId2, syncPayload, makeSqliteDb: makeSqliteDb2, syncOptions, dbState, dbEventlog, devtoolsOptions, shutdownChannel, params, testing }) => gen$2(function* () {
    var _a2;
    const bootStatusQueue = yield* unbounded$2().pipe(acquireRelease(shutdown));
    const dbEventlogMissing = dbEventlog.select(sql`select count(*) as count from sqlite_master`)[0].count === 0;
    const dbStateMissing = dbState.select(sql`select count(*) as count from sqlite_master`)[0].count === 0;
    const syncBackend = (syncOptions == null ? void 0 : syncOptions.backend) === void 0 ? void 0 : yield* syncOptions.backend({ storeId, clientId: clientId2, payload: syncPayload });
    if (syncBackend !== void 0) {
      yield* syncBackend.connect.pipe(tapCauseLogPretty, forkScoped);
    }
    const initialBlockingSyncContext = yield* makeInitialBlockingSyncContext({
      initialSyncOptions: (syncOptions == null ? void 0 : syncOptions.initialSyncOptions) ?? { _tag: "Skip" },
      bootStatusQueue
    });
    const syncProcessor = yield* makeLeaderSyncProcessor({
      schema: schema2,
      dbEventlogMissing,
      dbEventlog,
      dbState,
      dbStateMissing,
      initialBlockingSyncContext,
      onError: (syncOptions == null ? void 0 : syncOptions.onSyncError) ?? "ignore",
      params: {
        localPushBatchSize: params == null ? void 0 : params.localPushBatchSize,
        backendPushBatchSize: params == null ? void 0 : params.backendPushBatchSize
      },
      testing: {
        delays: (_a2 = testing == null ? void 0 : testing.syncProcessor) == null ? void 0 : _a2.delays
      }
    });
    const extraIncomingMessagesQueue = yield* unbounded$2().pipe(acquireRelease(shutdown));
    const devtoolsContext = devtoolsOptions.enabled ? {
      enabled: true,
      syncBackendLatch: yield* makeLatch(true),
      syncBackendLatchState: yield* make$a({ latchClosed: false })
    } : { enabled: false };
    const materializeEvent = yield* makeMaterializeEvent({ schema: schema2, dbState, dbEventlog });
    const ctx = {
      schema: schema2,
      bootStatusQueue,
      storeId,
      clientId: clientId2,
      dbState,
      dbEventlog,
      makeSqliteDb: makeSqliteDb2,
      eventSchema: makeEventDefSchema(schema2),
      shutdownStateSubRef: yield* make$a("running"),
      shutdownChannel,
      syncBackend,
      syncProcessor,
      materializeEvent,
      extraIncomingMessagesQueue,
      devtools: devtoolsContext,
      // State will be set during `bootLeaderThread`
      initialState: {}
    };
    globalThis.__leaderThreadCtx = ctx;
    const layer2 = succeed$4(LeaderThreadCtx, ctx);
    ctx.initialState = yield* bootLeaderThread({
      dbStateMissing,
      initialBlockingSyncContext,
      devtoolsOptions
    }).pipe(provide$1(layer2));
    return layer2;
  }).pipe(withSpan$3("@livestore/common:leader-thread:boot"), withSpanScoped("@livestore/common:leader-thread"), UnexpectedError.mapToUnexpectedError, tapCauseLogPretty, unwrapScoped$3);
  const makeInitialBlockingSyncContext = ({ initialSyncOptions, bootStatusQueue }) => gen$2(function* () {
    const ctx = {
      isDone: false,
      processedEvents: 0,
      total: -1
    };
    const blockingDeferred = initialSyncOptions._tag === "Blocking" ? yield* make$N() : void 0;
    if (blockingDeferred !== void 0 && initialSyncOptions._tag === "Blocking") {
      yield* succeed$9(blockingDeferred, void 0).pipe(delay(initialSyncOptions.timeout), forkScoped);
    }
    return {
      blockingDeferred,
      update: ({ processed, remaining }) => gen$2(function* () {
        if (ctx.isDone === true)
          return;
        if (ctx.total === -1) {
          ctx.total = remaining + processed;
        }
        ctx.processedEvents += processed;
        yield* offer$2(bootStatusQueue, {
          stage: "syncing",
          progress: { done: ctx.processedEvents, total: ctx.total }
        });
        if (remaining === 0 && blockingDeferred !== void 0) {
          yield* succeed$9(blockingDeferred, void 0);
          ctx.isDone = true;
        }
      })
    };
  });
  const bootLeaderThread = ({ dbStateMissing, initialBlockingSyncContext, devtoolsOptions }) => gen$2(function* () {
    const { dbEventlog, bootStatusQueue, syncProcessor } = yield* LeaderThreadCtx;
    yield* initEventlogDb(dbEventlog);
    const { migrationsReport } = dbStateMissing ? yield* recreateDb : { migrationsReport: { migrations: [] } };
    const { initialLeaderHead } = yield* syncProcessor.boot;
    if (initialBlockingSyncContext.blockingDeferred !== void 0) {
      yield* offer$2(bootStatusQueue, {
        stage: "syncing",
        progress: { done: 0, total: -1 }
      });
      yield* initialBlockingSyncContext.blockingDeferred.pipe(withSpan$3("@livestore/common:leader-thread:initial-sync-blocking"));
    }
    yield* offer$2(bootStatusQueue, { stage: "done" });
    yield* bootDevtools(devtoolsOptions).pipe(tapCauseLogPretty, forkScoped);
    return { migrationsReport, leaderHead: initialLeaderHead };
  });
  let CreateConnection$1 = class CreateConnection extends TaggedRequest()("DevtoolsWebCommon.CreateConnection", {
    payload: {
      from: String$,
      port: MessagePort
    },
    success: Struct({}),
    failure: Never
  }) {
  };
  class Request extends Union(CreateConnection$1) {
  }
  const _CacheService = class _CacheService extends Tag("@livestore/devtools-web-common:CacheService")() {
  };
  __publicField(_CacheService, "layer", ({ nodeName }) => gen$2(function* () {
    const node = yield* makeMeshNode(nodeName);
    globalThis.__debugWebmeshNode = node;
    return { node };
  }).pipe(scoped$2(_CacheService)));
  let CacheService = _CacheService;
  const CreateConnection = ({ from, port }) => asyncScoped((emit) => gen$2(function* () {
    const { node } = yield* CacheService;
    const messagePortChannel$1 = yield* messagePortChannel({ port, schema: Packet });
    yield* node.addEdge({ target: from, edgeChannel: messagePortChannel$1, replaceIfExists: true });
    if (LS_DEV) {
      yield* logDebug(`@livestore/devtools-web-common: accepted edge: ${node.nodeName} ← ${from}`);
    }
    emit.single({});
    yield* spanEvent({ connectedTo: [...node.edgeKeys] });
  }).pipe(orDie$2)).pipe(withSpan(`@livestore/devtools-web-common:worker:create-connection:${from}`));
  const SQLITE_OK = 0;
  const SQLITE_ERROR = 1;
  const SQLITE_IOERR = 10;
  const SQLITE_NOTFOUND = 12;
  const SQLITE_CANTOPEN = 14;
  const SQLITE_MISUSE = 21;
  const SQLITE_RANGE = 25;
  const SQLITE_NOTICE = 27;
  const SQLITE_ROW = 100;
  const SQLITE_DONE = 101;
  const SQLITE_IOERR_SHORT_READ = 522;
  const SQLITE_IOERR_WRITE = 778;
  const SQLITE_OPEN_READWRITE = 2;
  const SQLITE_OPEN_CREATE = 4;
  const SQLITE_OPEN_DELETEONCLOSE = 8;
  const SQLITE_OPEN_URI = 64;
  const SQLITE_OPEN_MAIN_DB = 256;
  const SQLITE_OPEN_MAIN_JOURNAL = 2048;
  const SQLITE_OPEN_SUPER_JOURNAL = 16384;
  const SQLITE_OPEN_WAL = 524288;
  const SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN = 2048;
  const SQLITE_INTEGER = 1;
  const SQLITE_FLOAT = 2;
  const SQLITE_TEXT = 3;
  const SQLITE_BLOB = 4;
  const SQLITE_NULL = 5;
  const DEFAULT_SECTOR_SIZE = 512;
  class Base {
    /**
     * @param {string} name 
     * @param {object} module 
     */
    constructor(name, module) {
      __publicField(this, "name");
      __publicField(this, "mxPathname", 64);
      __publicField(this, "_module");
      this.name = name;
      this._module = module;
    }
    /**
     * @returns {void|Promise<void>} 
     */
    close() {
    }
    /**
     * @returns {boolean|Promise<boolean>}
     */
    isReady() {
      return true;
    }
    /**
     * Overload in subclasses to indicate which methods are asynchronous.
     * @param {string} methodName 
     * @returns {boolean}
     */
    hasAsyncMethod(methodName) {
      return false;
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} pFile 
     * @param {number} flags 
     * @param {number} pOutFlags 
     * @returns {number|Promise<number>}
     */
    xOpen(pVfs, zName, pFile, flags, pOutFlags) {
      return SQLITE_CANTOPEN;
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} syncDir 
     * @returns {number|Promise<number>}
     */
    xDelete(pVfs, zName, syncDir) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} flags 
     * @param {number} pResOut 
     * @returns {number|Promise<number>}
     */
    xAccess(pVfs, zName, flags, pResOut) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} nOut 
     * @param {number} zOut 
     * @returns {number|Promise<number>}
     */
    xFullPathname(pVfs, zName, nOut, zOut) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pVfs 
     * @param {number} nBuf 
     * @param {number} zBuf 
     * @returns {number|Promise<number>}
     */
    xGetLastError(pVfs, nBuf, zBuf) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    xClose(pFile) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} pData 
     * @param {number} iAmt 
     * @param {number} iOffsetLo 
     * @param {number} iOffsetHi 
     * @returns {number|Promise<number>}
     */
    xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} pData 
     * @param {number} iAmt 
     * @param {number} iOffsetLo 
     * @param {number} iOffsetHi 
     * @returns {number|Promise<number>}
     */
    xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} sizeLo 
     * @param {number} sizeHi 
     * @returns {number|Promise<number>}
     */
    xTruncate(pFile, sizeLo, sizeHi) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} flags 
     * @returns {number|Promise<number>}
     */
    xSync(pFile, flags) {
      return SQLITE_OK;
    }
    /**
     * 
     * @param {number} pFile 
     * @param {number} pSize 
     * @returns {number|Promise<number>}
     */
    xFileSize(pFile, pSize) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} lockType 
     * @returns {number|Promise<number>}
     */
    xLock(pFile, lockType) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} lockType 
     * @returns {number|Promise<number>}
     */
    xUnlock(pFile, lockType) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} pResOut 
     * @returns {number|Promise<number>}
     */
    xCheckReservedLock(pFile, pResOut) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} op 
     * @param {number} pArg 
     * @returns {number|Promise<number>}
     */
    xFileControl(pFile, op, pArg) {
      return SQLITE_NOTFOUND;
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    xSectorSize(pFile) {
      return DEFAULT_SECTOR_SIZE;
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    xDeviceCharacteristics(pFile) {
      return 0;
    }
  }
  const AsyncFunction$1 = Object.getPrototypeOf(async function() {
  }).constructor;
  let FacadeVFS$1 = (_Wa = class extends Base {
    /**
     * @param {string} name 
     * @param {object} module 
     */
    constructor(name, module) {
      super(name, module);
      __privateAdd(this, _FacadeVFS_instances);
    }
    /**
     * Override to indicate which methods are asynchronous.
     * @param {string} methodName 
     * @returns {boolean}
     */
    hasAsyncMethod(methodName) {
      const jMethodName = `j${methodName.slice(1)}`;
      return this[jMethodName] instanceof AsyncFunction$1;
    }
    /**
     * Return the filename for a file id for use by mixins.
     * @param {number} pFile 
     * @returns {string}
     */
    getFilename(pFile) {
      throw new Error("unimplemented");
    }
    /**
     * @param {string?} filename 
     * @param {number} pFile 
     * @param {number} flags 
     * @param {DataView} pOutFlags 
     * @returns {number|Promise<number>}
     */
    jOpen(filename, pFile, flags, pOutFlags) {
      return SQLITE_CANTOPEN;
    }
    /**
     * @param {string} filename 
     * @param {number} syncDir 
     * @returns {number|Promise<number>}
     */
    jDelete(filename, syncDir) {
      return SQLITE_OK;
    }
    /**
     * @param {string} filename 
     * @param {number} flags 
     * @param {DataView} pResOut 
     * @returns {number|Promise<number>}
     */
    jAccess(filename, flags, pResOut) {
      return SQLITE_OK;
    }
    /**
     * @param {string} filename 
     * @param {Uint8Array} zOut 
     * @returns {number|Promise<number>}
     */
    jFullPathname(filename, zOut) {
      const { read, written } = new TextEncoder().encodeInto(filename, zOut);
      if (read < filename.length) return SQLITE_IOERR;
      if (written >= zOut.length) return SQLITE_IOERR;
      zOut[written] = 0;
      return SQLITE_OK;
    }
    /**
     * @param {Uint8Array} zBuf 
     * @returns {number|Promise<number>}
     */
    jGetLastError(zBuf) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    jClose(pFile) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {Uint8Array} pData 
     * @param {number} iOffset 
     * @returns {number|Promise<number>}
     */
    jRead(pFile, pData, iOffset) {
      pData.fill(0);
      return SQLITE_IOERR_SHORT_READ;
    }
    /**
     * @param {number} pFile 
     * @param {Uint8Array} pData 
     * @param {number} iOffset 
     * @returns {number|Promise<number>}
     */
    jWrite(pFile, pData, iOffset) {
      return SQLITE_IOERR_WRITE;
    }
    /**
     * @param {number} pFile 
     * @param {number} size 
     * @returns {number|Promise<number>}
     */
    jTruncate(pFile, size2) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} flags 
     * @returns {number|Promise<number>}
     */
    jSync(pFile, flags) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {DataView} pSize
     * @returns {number|Promise<number>}
     */
    jFileSize(pFile, pSize) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} lockType 
     * @returns {number|Promise<number>}
     */
    jLock(pFile, lockType) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {number} lockType 
     * @returns {number|Promise<number>}
     */
    jUnlock(pFile, lockType) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile 
     * @param {DataView} pResOut 
     * @returns {number|Promise<number>}
     */
    jCheckReservedLock(pFile, pResOut) {
      pResOut.setInt32(0, 0, true);
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {number} op
     * @param {DataView} pArg
     * @returns {number|Promise<number>}
     */
    jFileControl(pFile, op, pArg) {
      return SQLITE_NOTFOUND;
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    jSectorSize(pFile) {
      return super.xSectorSize(pFile);
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    jDeviceCharacteristics(pFile) {
      return 0;
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} pFile 
     * @param {number} flags 
     * @param {number} pOutFlags 
     * @returns {number|Promise<number>}
     */
    xOpen(pVfs, zName, pFile, flags, pOutFlags) {
      var _a2;
      const filename = __privateMethod(this, _FacadeVFS_instances, decodeFilename_fn).call(this, zName, flags);
      const pOutFlagsView = __privateMethod(this, _FacadeVFS_instances, makeTypedDataView_fn).call(this, "Int32", pOutFlags);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jOpen", filename, pFile, "0x" + flags.toString(16));
      return this.jOpen(filename, pFile, flags, pOutFlagsView);
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} syncDir 
     * @returns {number|Promise<number>}
     */
    xDelete(pVfs, zName, syncDir) {
      var _a2;
      const filename = this._module.UTF8ToString(zName);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jDelete", filename, syncDir);
      return this.jDelete(filename, syncDir);
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} flags 
     * @param {number} pResOut 
     * @returns {number|Promise<number>}
     */
    xAccess(pVfs, zName, flags, pResOut) {
      var _a2;
      const filename = this._module.UTF8ToString(zName);
      const pResOutView = __privateMethod(this, _FacadeVFS_instances, makeTypedDataView_fn).call(this, "Int32", pResOut);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jAccess", filename, flags);
      return this.jAccess(filename, flags, pResOutView);
    }
    /**
     * @param {number} pVfs 
     * @param {number} zName 
     * @param {number} nOut 
     * @param {number} zOut 
     * @returns {number|Promise<number>}
     */
    xFullPathname(pVfs, zName, nOut, zOut) {
      var _a2;
      const filename = this._module.UTF8ToString(zName);
      const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jFullPathname", filename, nOut);
      return this.jFullPathname(filename, zOutArray);
    }
    /**
     * @param {number} pVfs 
     * @param {number} nBuf 
     * @param {number} zBuf 
     * @returns {number|Promise<number>}
     */
    xGetLastError(pVfs, nBuf, zBuf) {
      var _a2;
      const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jGetLastError", nBuf);
      return this.jGetLastError(zBufArray);
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    xClose(pFile) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jClose", pFile);
      return this.jClose(pFile);
    }
    /**
     * @param {number} pFile 
     * @param {number} pData 
     * @param {number} iAmt 
     * @param {number} iOffsetLo 
     * @param {number} iOffsetHi 
     * @returns {number|Promise<number>}
     */
    xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
      var _a2;
      const pDataArray = __privateMethod(this, _FacadeVFS_instances, makeDataArray_fn).call(this, pData, iAmt);
      const iOffset = delegalize$1(iOffsetLo, iOffsetHi);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jRead", pFile, iAmt, iOffset);
      return this.jRead(pFile, pDataArray, iOffset);
    }
    /**
     * @param {number} pFile 
     * @param {number} pData 
     * @param {number} iAmt 
     * @param {number} iOffsetLo 
     * @param {number} iOffsetHi 
     * @returns {number|Promise<number>}
     */
    xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
      var _a2;
      const pDataArray = __privateMethod(this, _FacadeVFS_instances, makeDataArray_fn).call(this, pData, iAmt);
      const iOffset = delegalize$1(iOffsetLo, iOffsetHi);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jWrite", pFile, pDataArray, iOffset);
      return this.jWrite(pFile, pDataArray, iOffset);
    }
    /**
     * @param {number} pFile 
     * @param {number} sizeLo 
     * @param {number} sizeHi 
     * @returns {number|Promise<number>}
     */
    xTruncate(pFile, sizeLo, sizeHi) {
      var _a2;
      const size2 = delegalize$1(sizeLo, sizeHi);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jTruncate", pFile, size2);
      return this.jTruncate(pFile, size2);
    }
    /**
     * @param {number} pFile 
     * @param {number} flags 
     * @returns {number|Promise<number>}
     */
    xSync(pFile, flags) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jSync", pFile, flags);
      return this.jSync(pFile, flags);
    }
    /**
     * 
     * @param {number} pFile 
     * @param {number} pSize 
     * @returns {number|Promise<number>}
     */
    xFileSize(pFile, pSize) {
      var _a2;
      const pSizeView = __privateMethod(this, _FacadeVFS_instances, makeTypedDataView_fn).call(this, "BigInt64", pSize);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jFileSize", pFile);
      return this.jFileSize(pFile, pSizeView);
    }
    /**
     * @param {number} pFile 
     * @param {number} lockType 
     * @returns {number|Promise<number>}
     */
    xLock(pFile, lockType) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jLock", pFile, lockType);
      return this.jLock(pFile, lockType);
    }
    /**
     * @param {number} pFile 
     * @param {number} lockType 
     * @returns {number|Promise<number>}
     */
    xUnlock(pFile, lockType) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jUnlock", pFile, lockType);
      return this.jUnlock(pFile, lockType);
    }
    /**
     * @param {number} pFile 
     * @param {number} pResOut 
     * @returns {number|Promise<number>}
     */
    xCheckReservedLock(pFile, pResOut) {
      var _a2;
      const pResOutView = __privateMethod(this, _FacadeVFS_instances, makeTypedDataView_fn).call(this, "Int32", pResOut);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jCheckReservedLock", pFile);
      return this.jCheckReservedLock(pFile, pResOutView);
    }
    /**
     * @param {number} pFile 
     * @param {number} op 
     * @param {number} pArg 
     * @returns {number|Promise<number>}
     */
    xFileControl(pFile, op, pArg) {
      var _a2;
      const pArgView = new DataView(
        this._module.HEAPU8.buffer,
        this._module.HEAPU8.byteOffset + pArg
      );
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jFileControl", pFile, op, pArgView);
      return this.jFileControl(pFile, op, pArgView);
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    xSectorSize(pFile) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jSectorSize", pFile);
      return this.jSectorSize(pFile);
    }
    /**
     * @param {number} pFile 
     * @returns {number|Promise<number>}
     */
    xDeviceCharacteristics(pFile) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jDeviceCharacteristics", pFile);
      return this.jDeviceCharacteristics(pFile);
    }
  }, _FacadeVFS_instances = new WeakSet(), /**
   * Wrapped DataView for pointer arguments.
   * Pointers to a single value are passed using DataView. A Proxy
   * wrapper prevents use of incorrect type or endianness.
   * @param {'Int32'|'BigInt64'} type 
   * @param {number} byteOffset 
   * @returns {DataView}
   */
  makeTypedDataView_fn = function(type, byteOffset) {
    const byteLength = type === "Int32" ? 4 : 8;
    const getter = `get${type}`;
    const setter = `set${type}`;
    const makeDataView = () => new DataView(
      this._module.HEAPU8.buffer,
      this._module.HEAPU8.byteOffset + byteOffset,
      byteLength
    );
    let dataView = makeDataView();
    return new Proxy(dataView, {
      get(_, prop) {
        if (dataView.buffer.byteLength === 0) {
          dataView = makeDataView();
        }
        if (prop === getter) {
          return function(byteOffset2, littleEndian) {
            if (!littleEndian) throw new Error("must be little endian");
            return dataView[prop](byteOffset2, littleEndian);
          };
        }
        if (prop === setter) {
          return function(byteOffset2, value2, littleEndian) {
            if (!littleEndian) throw new Error("must be little endian");
            return dataView[prop](byteOffset2, value2, littleEndian);
          };
        }
        if (typeof prop === "string" && prop.match(/^(get)|(set)/)) {
          throw new Error("invalid type");
        }
        const result = dataView[prop];
        return typeof result === "function" ? result.bind(dataView) : result;
      }
    });
  }, /**
   * @param {number} byteOffset 
   * @param {number} byteLength 
   */
  makeDataArray_fn = function(byteOffset, byteLength) {
    let target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);
    return new Proxy(target, {
      get: (_, prop, receiver) => {
        if (target.buffer.byteLength === 0) {
          target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);
        }
        const result = target[prop];
        return typeof result === "function" ? result.bind(target) : result;
      }
    });
  }, decodeFilename_fn = function(zName, flags) {
    if (flags & SQLITE_OPEN_URI) {
      let pName = zName;
      let state2 = 1;
      const charCodes = [];
      while (state2) {
        const charCode = this._module.HEAPU8[pName++];
        if (charCode) {
          charCodes.push(charCode);
        } else {
          if (!this._module.HEAPU8[pName]) state2 = null;
          switch (state2) {
            case 1:
              charCodes.push("?".charCodeAt(0));
              state2 = 2;
              break;
            case 2:
              charCodes.push("=".charCodeAt(0));
              state2 = 3;
              break;
            case 3:
              charCodes.push("&".charCodeAt(0));
              state2 = 2;
              break;
          }
        }
      }
      return new TextDecoder().decode(new Uint8Array(charCodes));
    }
    return zName ? this._module.UTF8ToString(zName) : null;
  }, _Wa);
  function delegalize$1(lo32, hi32) {
    return hi32 * 4294967296 + lo32 + (lo32 < 0 ? 2 ** 32 : 0);
  }
  class MemoryVFS extends FacadeVFS$1 {
    constructor(name, module) {
      super(name, module);
      // Map of existing files, keyed by filename.
      __publicField(this, "mapNameToFile", /* @__PURE__ */ new Map());
      // Map of open files, keyed by id (sqlite3_file pointer).
      __publicField(this, "mapIdToFile", /* @__PURE__ */ new Map());
    }
    static async create(name, module) {
      const vfs = new MemoryVFS(name, module);
      await vfs.isReady();
      return vfs;
    }
    close() {
      for (const fileId of this.mapIdToFile.keys()) {
        this.jClose(fileId);
      }
    }
    /**
     * @param {string?} filename 
     * @param {number} fileId 
     * @param {number} flags 
     * @param {DataView} pOutFlags 
     * @returns {number|Promise<number>}
     */
    jOpen(filename, fileId, flags, pOutFlags) {
      const url = new URL(filename || Math.random().toString(36).slice(2), "file://");
      const pathname = url.pathname;
      let file = this.mapNameToFile.get(pathname);
      if (!file) {
        if (flags & SQLITE_OPEN_CREATE) {
          file = {
            pathname,
            flags,
            size: 0,
            data: new ArrayBuffer(0)
          };
          this.mapNameToFile.set(pathname, file);
        } else {
          return SQLITE_CANTOPEN;
        }
      }
      this.mapIdToFile.set(fileId, file);
      pOutFlags.setInt32(0, flags, true);
      return SQLITE_OK;
    }
    /**
     * @param {number} fileId 
     * @returns {number|Promise<number>}
     */
    jClose(fileId) {
      const file = this.mapIdToFile.get(fileId);
      this.mapIdToFile.delete(fileId);
      if (file.flags & SQLITE_OPEN_DELETEONCLOSE) {
        this.mapNameToFile.delete(file.pathname);
      }
      return SQLITE_OK;
    }
    /**
     * @param {number} fileId 
     * @param {Uint8Array} pData 
     * @param {number} iOffset
     * @returns {number|Promise<number>}
     */
    jRead(fileId, pData, iOffset) {
      const file = this.mapIdToFile.get(fileId);
      const bgn = Math.min(iOffset, file.size);
      const end2 = Math.min(iOffset + pData.byteLength, file.size);
      const nBytes = end2 - bgn;
      if (nBytes) {
        pData.set(new Uint8Array(file.data, bgn, nBytes));
      }
      if (nBytes < pData.byteLength) {
        pData.fill(0, nBytes);
        return SQLITE_IOERR_SHORT_READ;
      }
      return SQLITE_OK;
    }
    /**
     * @param {number} fileId 
     * @param {Uint8Array} pData 
     * @param {number} iOffset
     * @returns {number|Promise<number>}
     */
    jWrite(fileId, pData, iOffset) {
      const file = this.mapIdToFile.get(fileId);
      if (iOffset + pData.byteLength > file.data.byteLength) {
        const newSize = Math.max(iOffset + pData.byteLength, 2 * file.data.byteLength);
        const data = new ArrayBuffer(newSize);
        new Uint8Array(data).set(new Uint8Array(file.data, 0, file.size));
        file.data = data;
      }
      new Uint8Array(file.data, iOffset, pData.byteLength).set(pData);
      file.size = Math.max(file.size, iOffset + pData.byteLength);
      return SQLITE_OK;
    }
    /**
     * @param {number} fileId 
     * @param {number} iSize 
     * @returns {number|Promise<number>}
     */
    jTruncate(fileId, iSize) {
      const file = this.mapIdToFile.get(fileId);
      file.size = Math.min(file.size, iSize);
      return SQLITE_OK;
    }
    /**
     * @param {number} fileId 
     * @param {DataView} pSize64 
     * @returns {number|Promise<number>}
     */
    jFileSize(fileId, pSize64) {
      const file = this.mapIdToFile.get(fileId);
      pSize64.setBigInt64(0, BigInt(file.size), true);
      return SQLITE_OK;
    }
    /**
     * @param {string} name 
     * @param {number} syncDir 
     * @returns {number|Promise<number>}
     */
    jDelete(name, syncDir) {
      const url = new URL(name, "file://");
      const pathname = url.pathname;
      this.mapNameToFile.delete(pathname);
      return SQLITE_OK;
    }
    /**
     * @param {string} name 
     * @param {number} flags 
     * @param {DataView} pResOut 
     * @returns {number|Promise<number>}
     */
    jAccess(name, flags, pResOut) {
      const url = new URL(name, "file://");
      const pathname = url.pathname;
      const file = this.mapNameToFile.get(pathname);
      pResOut.setInt32(0, file ? 1 : 0, true);
      return SQLITE_OK;
    }
  }
  let cachedMemoryVfs;
  const makeInMemoryDb = (sqlite3) => {
    if (sqlite3.vfs_registered.has("memory-vfs") === false) {
      const vfs2 = new MemoryVFS("memory-vfs", sqlite3.module);
      sqlite3.vfs_register(vfs2, false);
      cachedMemoryVfs = vfs2;
    }
    const dbPointer = sqlite3.open_v2Sync(":memory:", void 0, "memory-vfs");
    const vfs = cachedMemoryVfs;
    return { dbPointer, vfs };
  };
  const makeSqliteDb = ({ sqlite3, metadata }) => {
    const preparedStmts = [];
    const { dbPointer } = metadata;
    let isClosed = false;
    const sqliteDb = {
      _tag: "SqliteDb",
      metadata,
      prepare: (queryStr) => {
        try {
          const stmts = sqlite3.statements(dbPointer, queryStr.trim(), { unscoped: true });
          let isFinalized = false;
          const preparedStmt = {
            execute: (bindValues, options2) => {
              for (const stmt of stmts) {
                if (bindValues !== void 0 && Object.keys(bindValues).length > 0) {
                  sqlite3.bind_collection(stmt, bindValues);
                }
                try {
                  sqlite3.step(stmt);
                } finally {
                  if (options2 == null ? void 0 : options2.onRowsChanged) {
                    options2.onRowsChanged(sqlite3.changes(dbPointer));
                  }
                  sqlite3.reset(stmt);
                }
              }
            },
            select: (bindValues) => {
              if (stmts.length !== 1) {
                throw new SqliteError({
                  query: { bindValues, sql: queryStr },
                  code: -1,
                  cause: "Expected only one statement when using `select`"
                });
              }
              const stmt = stmts[0];
              if (bindValues !== void 0 && Object.keys(bindValues).length > 0) {
                sqlite3.bind_collection(stmt, bindValues);
              }
              const results = [];
              try {
                let columns = void 0;
                try {
                  columns = sqlite3.column_names(stmt);
                } catch (_e2) {
                }
                while (sqlite3.step(stmt) === SQLITE_ROW) {
                  if (columns !== void 0) {
                    const obj = {};
                    for (let i = 0; i < columns.length; i++) {
                      obj[columns[i]] = sqlite3.column(stmt, i);
                    }
                    results.push(obj);
                  }
                }
              } catch (e) {
                throw new SqliteError({
                  query: { bindValues, sql: queryStr },
                  code: e.code,
                  cause: e
                });
              } finally {
                sqlite3.reset(stmt);
              }
              return results;
            },
            finalize: () => {
              if (isFinalized) {
                return;
              }
              isFinalized = true;
              for (const stmt of stmts) {
                sqlite3.finalize(stmt);
              }
            },
            sql: queryStr
          };
          preparedStmts.push(preparedStmt);
          return preparedStmt;
        } catch (e) {
          throw new SqliteError({
            query: { sql: queryStr, bindValues: {} },
            code: e.code,
            cause: e
          });
        }
      },
      export: () => sqlite3.serialize(dbPointer, "main"),
      execute: makeExecute((queryStr, bindValues, options2) => {
        const stmt = sqliteDb.prepare(queryStr);
        stmt.execute(bindValues, options2);
        stmt.finalize();
      }),
      select: makeSelect((queryStr, bindValues) => {
        const stmt = sqliteDb.prepare(queryStr);
        const results = stmt.select(bindValues);
        stmt.finalize();
        return results;
      }),
      destroy: () => {
        sqliteDb.close();
        metadata.deleteDb();
      },
      close: () => {
        if (isClosed) {
          return;
        }
        for (const stmt of preparedStmts) {
          stmt.finalize();
        }
        sqlite3.close(dbPointer);
        isClosed = true;
      },
      import: (source) => {
        const FREE_ON_CLOSE = 1;
        const RESIZEABLE = 2;
        if (source instanceof Uint8Array) {
          const tmpDb = makeInMemoryDb(sqlite3);
          sqlite3.deserialize(tmpDb.dbPointer, "main", source, source.length, source.length, FREE_ON_CLOSE | RESIZEABLE);
          sqlite3.backup(dbPointer, "main", tmpDb.dbPointer, "main");
          sqlite3.close(tmpDb.dbPointer);
        } else {
          sqlite3.backup(dbPointer, "main", source.metadata.dbPointer, "main");
        }
        metadata.configureDb(sqliteDb);
      },
      session: () => {
        const sessionPointer = sqlite3.session_create(dbPointer, "main");
        sqlite3.session_attach(sessionPointer, null);
        return {
          changeset: () => {
            const res = sqlite3.session_changeset(sessionPointer);
            return res.changeset ?? void 0;
          },
          finish: () => {
            sqlite3.session_delete(sessionPointer);
          }
        };
      },
      makeChangeset: (data) => {
        const changeset = {
          invert: () => {
            const inverted = sqlite3.changeset_invert(data);
            return sqliteDb.makeChangeset(inverted);
          },
          apply: () => {
            try {
              sqlite3.changeset_apply(dbPointer, data);
              data = void 0;
            } catch (cause) {
              throw new SqliteError({
                code: cause.code ?? -1,
                cause,
                note: `Failed calling makeChangeset.apply`
              });
            }
          }
        };
        return changeset;
      }
    };
    metadata.configureDb(sqliteDb);
    return sqliteDb;
  };
  const AsyncFunction = Object.getPrototypeOf(async () => {
  }).constructor;
  class FacadeVFS extends Base {
    /**
     * @param {string} name
     * @param {object} module
     */
    constructor(name, module) {
      super(name, module);
      __privateAdd(this, _FacadeVFS_instances2);
    }
    /**
     * Override to indicate which methods are asynchronous.
     * @param {string} methodName
     * @returns {boolean}
     */
    hasAsyncMethod(methodName) {
      const jMethodName = `j${methodName.slice(1)}`;
      return this[jMethodName] instanceof AsyncFunction;
    }
    /**
     * Return the filename for a file id for use by mixins.
     * @param {number} pFile
     * @returns {string}
     */
    getFilename(pFile) {
      throw new Error("unimplemented");
    }
    /**
     * @param {string?} filename
     * @param {number} pFile
     * @param {number} flags
     * @param {DataView} pOutFlags
     * @returns {number|Promise<number>}
     */
    jOpen(filename, pFile, flags, pOutFlags) {
      return SQLITE_CANTOPEN;
    }
    /**
     * @param {string} filename
     * @param {number} syncDir
     * @returns {number|Promise<number>}
     */
    jDelete(filename, syncDir) {
      return SQLITE_OK;
    }
    /**
     * @param {string} filename
     * @param {number} flags
     * @param {DataView} pResOut
     * @returns {number|Promise<number>}
     */
    jAccess(filename, flags, pResOut) {
      return SQLITE_OK;
    }
    /**
     * @param {string} filename
     * @param {Uint8Array} zOut
     * @returns {number|Promise<number>}
     */
    jFullPathname(filename, zOut) {
      const { read, written } = new TextEncoder().encodeInto(filename, zOut);
      if (read < filename.length)
        return SQLITE_IOERR;
      if (written >= zOut.length)
        return SQLITE_IOERR;
      zOut[written] = 0;
      return SQLITE_OK;
    }
    /**
     * @param {Uint8Array} zBuf
     * @returns {number|Promise<number>}
     */
    jGetLastError(zBuf) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    jClose(pFile) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {Uint8Array} pData
     * @param {number} iOffset
     * @returns {number|Promise<number>}
     */
    jRead(pFile, pData, iOffset) {
      pData.fill(0);
      return SQLITE_IOERR_SHORT_READ;
    }
    /**
     * @param {number} pFile
     * @param {Uint8Array} pData
     * @param {number} iOffset
     * @returns {number|Promise<number>}
     */
    jWrite(pFile, pData, iOffset) {
      return SQLITE_IOERR_WRITE;
    }
    /**
     * @param {number} pFile
     * @param {number} size
     * @returns {number|Promise<number>}
     */
    jTruncate(pFile, size2) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {number} flags
     * @returns {number|Promise<number>}
     */
    jSync(pFile, flags) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {DataView} pSize
     * @returns {number|Promise<number>}
     */
    jFileSize(pFile, pSize) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {number} lockType
     * @returns {number|Promise<number>}
     */
    jLock(pFile, lockType) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {number} lockType
     * @returns {number|Promise<number>}
     */
    jUnlock(pFile, lockType) {
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {DataView} pResOut
     * @returns {number|Promise<number>}
     */
    jCheckReservedLock(pFile, pResOut) {
      pResOut.setInt32(0, 0, true);
      return SQLITE_OK;
    }
    /**
     * @param {number} pFile
     * @param {number} op
     * @param {DataView} pArg
     * @returns {number|Promise<number>}
     */
    jFileControl(pFile, op, pArg) {
      return SQLITE_NOTFOUND;
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    jSectorSize(pFile) {
      return super.xSectorSize(pFile);
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    jDeviceCharacteristics(pFile) {
      return 0;
    }
    /**
     * @param {number} pVfs
     * @param {number} zName
     * @param {number} pFile
     * @param {number} flags
     * @param {number} pOutFlags
     * @returns {number|Promise<number>}
     */
    xOpen(pVfs, zName, pFile, flags, pOutFlags) {
      var _a2;
      const filename = __privateMethod(this, _FacadeVFS_instances2, decodeFilename_fn2).call(this, zName, flags);
      const pOutFlagsView = __privateMethod(this, _FacadeVFS_instances2, makeTypedDataView_fn2).call(this, "Int32", pOutFlags);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jOpen", filename, pFile, "0x" + flags.toString(16));
      return this.jOpen(filename, pFile, flags, pOutFlagsView);
    }
    /**
     * @param {number} pVfs
     * @param {number} zName
     * @param {number} syncDir
     * @returns {number|Promise<number>}
     */
    xDelete(pVfs, zName, syncDir) {
      var _a2;
      const filename = this._module.UTF8ToString(zName);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jDelete", filename, syncDir);
      return this.jDelete(filename, syncDir);
    }
    /**
     * @param {number} pVfs
     * @param {number} zName
     * @param {number} flags
     * @param {number} pResOut
     * @returns {number|Promise<number>}
     */
    xAccess(pVfs, zName, flags, pResOut) {
      var _a2;
      const filename = this._module.UTF8ToString(zName);
      const pResOutView = __privateMethod(this, _FacadeVFS_instances2, makeTypedDataView_fn2).call(this, "Int32", pResOut);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jAccess", filename, flags);
      return this.jAccess(filename, flags, pResOutView);
    }
    /**
     * @param {number} pVfs
     * @param {number} zName
     * @param {number} nOut
     * @param {number} zOut
     * @returns {number|Promise<number>}
     */
    xFullPathname(pVfs, zName, nOut, zOut) {
      var _a2;
      const filename = this._module.UTF8ToString(zName);
      const zOutArray = this._module.HEAPU8.subarray(zOut, zOut + nOut);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jFullPathname", filename, nOut);
      return this.jFullPathname(filename, zOutArray);
    }
    /**
     * @param {number} pVfs
     * @param {number} nBuf
     * @param {number} zBuf
     * @returns {number|Promise<number>}
     */
    xGetLastError(pVfs, nBuf, zBuf) {
      var _a2;
      const zBufArray = this._module.HEAPU8.subarray(zBuf, zBuf + nBuf);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jGetLastError", nBuf);
      return this.jGetLastError(zBufArray);
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    xClose(pFile) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jClose", pFile);
      return this.jClose(pFile);
    }
    /**
     * @param {number} pFile
     * @param {number} pData
     * @param {number} iAmt
     * @param {number} iOffsetLo
     * @param {number} iOffsetHi
     * @returns {number|Promise<number>}
     */
    xRead(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
      var _a2;
      const pDataArray = __privateMethod(this, _FacadeVFS_instances2, makeDataArray_fn2).call(this, pData, iAmt);
      const iOffset = delegalize(iOffsetLo, iOffsetHi);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jRead", pFile, iAmt, iOffset);
      return this.jRead(pFile, pDataArray, iOffset);
    }
    /**
     * @param {number} pFile
     * @param {number} pData
     * @param {number} iAmt
     * @param {number} iOffsetLo
     * @param {number} iOffsetHi
     * @returns {number|Promise<number>}
     */
    xWrite(pFile, pData, iAmt, iOffsetLo, iOffsetHi) {
      var _a2;
      const pDataArray = __privateMethod(this, _FacadeVFS_instances2, makeDataArray_fn2).call(this, pData, iAmt);
      const iOffset = delegalize(iOffsetLo, iOffsetHi);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jWrite", pFile, pDataArray, iOffset);
      return this.jWrite(pFile, pDataArray, iOffset);
    }
    /**
     * @param {number} pFile
     * @param {number} sizeLo
     * @param {number} sizeHi
     * @returns {number|Promise<number>}
     */
    xTruncate(pFile, sizeLo, sizeHi) {
      var _a2;
      const size2 = delegalize(sizeLo, sizeHi);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jTruncate", pFile, size2);
      return this.jTruncate(pFile, size2);
    }
    /**
     * @param {number} pFile
     * @param {number} flags
     * @returns {number|Promise<number>}
     */
    xSync(pFile, flags) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jSync", pFile, flags);
      return this.jSync(pFile, flags);
    }
    /**
     *
     * @param {number} pFile
     * @param {number} pSize
     * @returns {number|Promise<number>}
     */
    xFileSize(pFile, pSize) {
      var _a2;
      const pSizeView = __privateMethod(this, _FacadeVFS_instances2, makeTypedDataView_fn2).call(this, "BigInt64", pSize);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jFileSize", pFile);
      return this.jFileSize(pFile, pSizeView);
    }
    /**
     * @param {number} pFile
     * @param {number} lockType
     * @returns {number|Promise<number>}
     */
    xLock(pFile, lockType) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jLock", pFile, lockType);
      return this.jLock(pFile, lockType);
    }
    /**
     * @param {number} pFile
     * @param {number} lockType
     * @returns {number|Promise<number>}
     */
    xUnlock(pFile, lockType) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jUnlock", pFile, lockType);
      return this.jUnlock(pFile, lockType);
    }
    /**
     * @param {number} pFile
     * @param {number} pResOut
     * @returns {number|Promise<number>}
     */
    xCheckReservedLock(pFile, pResOut) {
      var _a2;
      const pResOutView = __privateMethod(this, _FacadeVFS_instances2, makeTypedDataView_fn2).call(this, "Int32", pResOut);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jCheckReservedLock", pFile);
      return this.jCheckReservedLock(pFile, pResOutView);
    }
    /**
     * @param {number} pFile
     * @param {number} op
     * @param {number} pArg
     * @returns {number|Promise<number>}
     */
    xFileControl(pFile, op, pArg) {
      var _a2;
      const pArgView = new DataView(this._module.HEAPU8.buffer, this._module.HEAPU8.byteOffset + pArg);
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jFileControl", pFile, op, pArgView);
      return this.jFileControl(pFile, op, pArgView);
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    xSectorSize(pFile) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jSectorSize", pFile);
      return this.jSectorSize(pFile);
    }
    /**
     * @param {number} pFile
     * @returns {number|Promise<number>}
     */
    xDeviceCharacteristics(pFile) {
      var _a2;
      (_a2 = this["log"]) == null ? void 0 : _a2.call(this, "jDeviceCharacteristics", pFile);
      return this.jDeviceCharacteristics(pFile);
    }
  }
  _FacadeVFS_instances2 = new WeakSet();
  /**
   * Wrapped DataView for pointer arguments.
   * Pointers to a single value are passed using DataView. A Proxy
   * wrapper prevents use of incorrect type or endianness.
   * @param {'Int32'|'BigInt64'} type
   * @param {number} byteOffset
   * @returns {DataView}
   */
  makeTypedDataView_fn2 = function(type, byteOffset) {
    const byteLength = type === "Int32" ? 4 : 8;
    const getter = `get${type}`;
    const setter = `set${type}`;
    const makeDataView = () => new DataView(this._module.HEAPU8.buffer, this._module.HEAPU8.byteOffset + byteOffset, byteLength);
    let dataView = makeDataView();
    return new Proxy(dataView, {
      get(_, prop) {
        if (dataView.buffer.byteLength === 0) {
          dataView = makeDataView();
        }
        if (prop === getter) {
          return function(byteOffset2, littleEndian) {
            if (!littleEndian)
              throw new Error("must be little endian");
            return dataView[prop](byteOffset2, littleEndian);
          };
        }
        if (prop === setter) {
          return function(byteOffset2, value2, littleEndian) {
            if (!littleEndian)
              throw new Error("must be little endian");
            return dataView[prop](byteOffset2, value2, littleEndian);
          };
        }
        if (typeof prop === "string" && /^(get)|(set)/.test(prop)) {
          throw new Error("invalid type");
        }
        const result = dataView[prop];
        return typeof result === "function" ? result.bind(dataView) : result;
      }
    });
  };
  /**
   * @param {number} byteOffset
   * @param {number} byteLength
   */
  makeDataArray_fn2 = function(byteOffset, byteLength) {
    let target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);
    return new Proxy(target, {
      get: (_, prop, receiver) => {
        if (target.buffer.byteLength === 0) {
          target = this._module.HEAPU8.subarray(byteOffset, byteOffset + byteLength);
        }
        const result = target[prop];
        return typeof result === "function" ? result.bind(target) : result;
      }
    });
  };
  decodeFilename_fn2 = function(zName, flags) {
    if (flags & SQLITE_OPEN_URI) {
      let pName = zName;
      let state2 = 1;
      const charCodes = [];
      while (state2) {
        const charCode = this._module.HEAPU8[pName++];
        if (charCode) {
          charCodes.push(charCode);
        } else {
          if (!this._module.HEAPU8[pName])
            state2 = null;
          switch (state2) {
            case 1: {
              charCodes.push("?".charCodeAt(0));
              state2 = 2;
              break;
            }
            case 2: {
              charCodes.push("=".charCodeAt(0));
              state2 = 3;
              break;
            }
            case 3: {
              charCodes.push("&".charCodeAt(0));
              state2 = 2;
              break;
            }
          }
        }
      }
      return new TextDecoder().decode(new Uint8Array(charCodes));
    }
    return zName ? this._module.UTF8ToString(zName) : null;
  };
  function delegalize(lo32, hi32) {
    return hi32 * 4294967296 + lo32 + (lo32 < 0 ? 2 ** 32 : 0);
  }
  const SECTOR_SIZE = 4096;
  const HEADER_MAX_PATH_SIZE = 512;
  const HEADER_FLAGS_SIZE = 4;
  const HEADER_DIGEST_SIZE = 8;
  const HEADER_CORPUS_SIZE = HEADER_MAX_PATH_SIZE + HEADER_FLAGS_SIZE;
  const HEADER_OFFSET_FLAGS = HEADER_MAX_PATH_SIZE;
  const HEADER_OFFSET_DIGEST = HEADER_CORPUS_SIZE;
  const HEADER_OFFSET_DATA = SECTOR_SIZE;
  const PERSISTENT_FILE_TYPES = SQLITE_OPEN_MAIN_DB | SQLITE_OPEN_MAIN_JOURNAL | SQLITE_OPEN_SUPER_JOURNAL | SQLITE_OPEN_WAL;
  const DEFAULT_CAPACITY = 6;
  const _AccessHandlePoolVFS = class _AccessHandlePoolVFS extends FacadeVFS {
    constructor(name, directoryPath, module) {
      super(name, module);
      __privateAdd(this, _AccessHandlePoolVFS_instances);
      __publicField(this, "log", null);
      //function(...args) { console.log(`[${contextName}]`, ...args) };
      // All the OPFS files the VFS uses are contained in one flat directory
      // specified in the constructor. No other files should be written here.
      __privateAdd(this, _directoryPath);
      __privateAdd(this, _directoryHandle);
      // The OPFS files all have randomly-generated names that do not match
      // the SQLite files whose data they contain. This map links those names
      // with their respective OPFS access handles.
      __privateAdd(this, _mapAccessHandleToName, /* @__PURE__ */ new Map());
      // When a SQLite file is associated with an OPFS file, that association
      // is kept in #mapPathToAccessHandle. Each access handle is in exactly
      // one of #mapPathToAccessHandle or #availableAccessHandles.
      __privateAdd(this, _mapPathToAccessHandle, /* @__PURE__ */ new Map());
      __privateAdd(this, _availableAccessHandles, /* @__PURE__ */ new Set());
      __privateAdd(this, _mapIdToFile, /* @__PURE__ */ new Map());
      __privateSet(this, _directoryPath, directoryPath);
    }
    static async create(name, directoryPath, module) {
      const vfs = new _AccessHandlePoolVFS(name, directoryPath, module);
      await vfs.isReady();
      return vfs;
    }
    getOpfsFileName(zName) {
      const path = __privateMethod(this, _AccessHandlePoolVFS_instances, getPath_fn).call(this, zName);
      const accessHandle = __privateGet(this, _mapPathToAccessHandle).get(path);
      return __privateGet(this, _mapAccessHandleToName).get(accessHandle);
    }
    resetAccessHandle(zName) {
      const path = __privateMethod(this, _AccessHandlePoolVFS_instances, getPath_fn).call(this, zName);
      const accessHandle = __privateGet(this, _mapPathToAccessHandle).get(path);
      accessHandle.truncate(HEADER_OFFSET_DATA);
    }
    jOpen(zName, fileId, flags, pOutFlags) {
      try {
        const path = zName ? __privateMethod(this, _AccessHandlePoolVFS_instances, getPath_fn).call(this, zName) : Math.random().toString(36);
        let accessHandle = __privateGet(this, _mapPathToAccessHandle).get(path);
        if (!accessHandle && flags & SQLITE_OPEN_CREATE) {
          if (this.getSize() < this.getCapacity()) {
            ;
            [accessHandle] = __privateGet(this, _availableAccessHandles).keys();
            __privateMethod(this, _AccessHandlePoolVFS_instances, setAssociatedPath_fn).call(this, accessHandle, path, flags);
          } else {
            throw new Error("cannot create file");
          }
        }
        if (!accessHandle) {
          throw new Error("file not found");
        }
        const file = { path, flags, accessHandle };
        __privateGet(this, _mapIdToFile).set(fileId, file);
        pOutFlags.setInt32(0, flags, true);
        return SQLITE_OK;
      } catch (e) {
        console.error(e.message);
        return SQLITE_CANTOPEN;
      }
    }
    jClose(fileId) {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      if (file) {
        file.accessHandle.flush();
        __privateGet(this, _mapIdToFile).delete(fileId);
        if (file.flags & SQLITE_OPEN_DELETEONCLOSE) {
          __privateMethod(this, _AccessHandlePoolVFS_instances, deletePath_fn).call(this, file.path);
        }
      }
      return SQLITE_OK;
    }
    jRead(fileId, pData, iOffset) {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      const nBytes = file.accessHandle.read(pData.subarray(), { at: HEADER_OFFSET_DATA + iOffset });
      if (nBytes < pData.byteLength) {
        pData.fill(0, nBytes, pData.byteLength);
        return SQLITE_IOERR_SHORT_READ;
      }
      return SQLITE_OK;
    }
    jWrite(fileId, pData, iOffset) {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      const nBytes = file.accessHandle.write(pData.subarray(), { at: HEADER_OFFSET_DATA + iOffset });
      return nBytes === pData.byteLength ? SQLITE_OK : SQLITE_IOERR;
    }
    jTruncate(fileId, iSize) {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      file.accessHandle.truncate(HEADER_OFFSET_DATA + iSize);
      return SQLITE_OK;
    }
    jSync(fileId, _flags) {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      file.accessHandle.flush();
      return SQLITE_OK;
    }
    jFileSize(fileId, pSize64) {
      const file = __privateGet(this, _mapIdToFile).get(fileId);
      const size2 = file.accessHandle.getSize() - HEADER_OFFSET_DATA;
      pSize64.setBigInt64(0, BigInt(size2), true);
      return SQLITE_OK;
    }
    jSectorSize(_fileId) {
      return SECTOR_SIZE;
    }
    jDeviceCharacteristics(_fileId) {
      return SQLITE_IOCAP_UNDELETABLE_WHEN_OPEN;
    }
    jAccess(zName, flags, pResOut) {
      const path = __privateMethod(this, _AccessHandlePoolVFS_instances, getPath_fn).call(this, zName);
      pResOut.setInt32(0, __privateGet(this, _mapPathToAccessHandle).has(path) ? 1 : 0, true);
      return SQLITE_OK;
    }
    jDelete(zName, _syncDir) {
      const path = __privateMethod(this, _AccessHandlePoolVFS_instances, getPath_fn).call(this, zName);
      __privateMethod(this, _AccessHandlePoolVFS_instances, deletePath_fn).call(this, path);
      return SQLITE_OK;
    }
    async close() {
      __privateMethod(this, _AccessHandlePoolVFS_instances, releaseAccessHandles_fn).call(this);
    }
    async isReady() {
      if (!__privateGet(this, _directoryHandle)) {
        let handle = await navigator.storage.getDirectory();
        for (const d of __privateGet(this, _directoryPath).split("/")) {
          if (d) {
            handle = await handle.getDirectoryHandle(d, { create: true });
          }
        }
        __privateSet(this, _directoryHandle, handle);
        await __privateMethod(this, _AccessHandlePoolVFS_instances, acquireAccessHandles_fn).call(this);
        if (this.getCapacity() === 0) {
          await this.addCapacity(DEFAULT_CAPACITY);
        }
      }
      return true;
    }
    /**
     * Returns the number of SQLite files in the file system.
     */
    getSize() {
      return __privateGet(this, _mapPathToAccessHandle).size;
    }
    /**
     * Returns the maximum number of SQLite files the file system can hold.
     */
    getCapacity() {
      return __privateGet(this, _mapAccessHandleToName).size;
    }
    /**
     * Increase the capacity of the file system by n.
     */
    async addCapacity(n) {
      for (let i = 0; i < n; ++i) {
        const name = Math.random().toString(36).replace("0.", "");
        const handle = await __privateGet(this, _directoryHandle).getFileHandle(name, { create: true });
        const accessHandle = await handle.createSyncAccessHandle();
        __privateGet(this, _mapAccessHandleToName).set(accessHandle, name);
        __privateMethod(this, _AccessHandlePoolVFS_instances, setAssociatedPath_fn).call(this, accessHandle, "", 0);
      }
      return n;
    }
    /**
     * Decrease the capacity of the file system by n. The capacity cannot be
     * decreased to fewer than the current number of SQLite files in the
     * file system.
     */
    async removeCapacity(n) {
      let nRemoved = 0;
      for (const accessHandle of Array.from(__privateGet(this, _availableAccessHandles))) {
        if (nRemoved == n || this.getSize() === this.getCapacity())
          return nRemoved;
        const name = __privateGet(this, _mapAccessHandleToName).get(accessHandle);
        accessHandle.close();
        await __privateGet(this, _directoryHandle).removeEntry(name);
        __privateGet(this, _mapAccessHandleToName).delete(accessHandle);
        __privateGet(this, _availableAccessHandles).delete(accessHandle);
        ++nRemoved;
      }
      return nRemoved;
    }
  };
  _directoryPath = new WeakMap();
  _directoryHandle = new WeakMap();
  _mapAccessHandleToName = new WeakMap();
  _mapPathToAccessHandle = new WeakMap();
  _availableAccessHandles = new WeakMap();
  _mapIdToFile = new WeakMap();
  _AccessHandlePoolVFS_instances = new WeakSet();
  acquireAccessHandles_fn = async function() {
    const files = [];
    for await (const [name, handle] of __privateGet(this, _directoryHandle)) {
      if (handle.kind === "file") {
        files.push([name, handle]);
      }
    }
    await Promise.all(files.map(async ([name, handle]) => {
      const accessHandle = await handle.createSyncAccessHandle();
      __privateGet(this, _mapAccessHandleToName).set(accessHandle, name);
      const path = __privateMethod(this, _AccessHandlePoolVFS_instances, getAssociatedPath_fn).call(this, accessHandle);
      if (path) {
        __privateGet(this, _mapPathToAccessHandle).set(path, accessHandle);
      } else {
        __privateGet(this, _availableAccessHandles).add(accessHandle);
      }
    }));
  };
  releaseAccessHandles_fn = function() {
    for (const accessHandle of __privateGet(this, _mapAccessHandleToName).keys()) {
      accessHandle.close();
    }
    __privateGet(this, _mapAccessHandleToName).clear();
    __privateGet(this, _mapPathToAccessHandle).clear();
    __privateGet(this, _availableAccessHandles).clear();
  };
  /**
   * Read and return the associated path from an OPFS file header.
   * Empty string is returned for an unassociated OPFS file.
   * @returns {string} path or empty string
   */
  getAssociatedPath_fn = function(accessHandle) {
    const corpus = new Uint8Array(HEADER_CORPUS_SIZE);
    accessHandle.read(corpus, { at: 0 });
    const dataView = new DataView(corpus.buffer, corpus.byteOffset);
    const flags = dataView.getUint32(HEADER_OFFSET_FLAGS);
    if (corpus[0] && (flags & SQLITE_OPEN_DELETEONCLOSE || (flags & PERSISTENT_FILE_TYPES) === 0)) {
      console.warn(`Remove file with unexpected flags ${flags.toString(16)}`);
      __privateMethod(this, _AccessHandlePoolVFS_instances, setAssociatedPath_fn).call(this, accessHandle, "", 0);
      return "";
    }
    const fileDigest = new Uint32Array(HEADER_DIGEST_SIZE / 4);
    accessHandle.read(fileDigest, { at: HEADER_OFFSET_DIGEST });
    const computedDigest = __privateMethod(this, _AccessHandlePoolVFS_instances, computeDigest_fn).call(this, corpus);
    if (fileDigest.every((value2, i) => value2 === computedDigest[i])) {
      const pathBytes = corpus.indexOf(0);
      if (pathBytes === 0) {
        accessHandle.truncate(HEADER_OFFSET_DATA);
      }
      return new TextDecoder().decode(corpus.subarray(0, pathBytes));
    } else {
      console.warn("Disassociating file with bad digest.");
      __privateMethod(this, _AccessHandlePoolVFS_instances, setAssociatedPath_fn).call(this, accessHandle, "", 0);
      return "";
    }
  };
  /**
   * Set the path on an OPFS file header.
   */
  setAssociatedPath_fn = function(accessHandle, path, flags) {
    const corpus = new Uint8Array(HEADER_CORPUS_SIZE);
    const encodedResult = new TextEncoder().encodeInto(path, corpus);
    if (encodedResult.written >= HEADER_MAX_PATH_SIZE) {
      throw new Error("path too long");
    }
    const dataView = new DataView(corpus.buffer, corpus.byteOffset);
    dataView.setUint32(HEADER_OFFSET_FLAGS, flags);
    const digest = __privateMethod(this, _AccessHandlePoolVFS_instances, computeDigest_fn).call(this, corpus);
    accessHandle.write(corpus, { at: 0 });
    accessHandle.write(digest, { at: HEADER_OFFSET_DIGEST });
    accessHandle.flush();
    if (path) {
      __privateGet(this, _mapPathToAccessHandle).set(path, accessHandle);
      __privateGet(this, _availableAccessHandles).delete(accessHandle);
    } else {
      accessHandle.truncate(HEADER_OFFSET_DATA);
      __privateGet(this, _availableAccessHandles).add(accessHandle);
    }
  };
  /**
   * We need a synchronous digest function so can't use WebCrypto.
   * Adapted from https://github.com/bryc/code/blob/master/jshash/experimental/cyrb53.js
   * @returns {ArrayBuffer} 64-bit digest
   */
  computeDigest_fn = function(corpus) {
    if (!corpus[0]) {
      return new Uint32Array([4274806656, 2899230775]);
    }
    let h1 = 3735928559;
    let h2 = 1103547991;
    for (const value2 of corpus) {
      h1 = Math.imul(h1 ^ value2, 2654435761);
      h2 = Math.imul(h2 ^ value2, 1597334677);
    }
    h1 = Math.imul(h1 ^ h1 >>> 16, 2246822507) ^ Math.imul(h2 ^ h2 >>> 13, 3266489909);
    h2 = Math.imul(h2 ^ h2 >>> 16, 2246822507) ^ Math.imul(h1 ^ h1 >>> 13, 3266489909);
    return new Uint32Array([h1 >>> 0, h2 >>> 0]);
  };
  /**
   * Convert a bare filename, path, or URL to a UNIX-style path.
   */
  getPath_fn = function(nameOrURL) {
    const url = typeof nameOrURL === "string" ? new URL(nameOrURL, "file://localhost/") : nameOrURL;
    return url.pathname;
  };
  /**
   * Remove the association between a path and an OPFS file.
   * @param {string} path
   */
  deletePath_fn = function(path) {
    const accessHandle = __privateGet(this, _mapPathToAccessHandle).get(path);
    if (accessHandle) {
      __privateGet(this, _mapPathToAccessHandle).delete(path);
      __privateMethod(this, _AccessHandlePoolVFS_instances, setAssociatedPath_fn).call(this, accessHandle, "", 0);
    }
  };
  let AccessHandlePoolVFS = _AccessHandlePoolVFS;
  const semaphore = makeSemaphore(1).pipe(runSync);
  const opfsVfsMap = /* @__PURE__ */ new Map();
  const makeOpfsDb = ({ sqlite3, directory, fileName }) => gen$2(function* () {
    const safePath = directory.replaceAll(/["*/:<>?\\|]/g, "_");
    const pathSegment = safePath.length === 0 ? "" : `-${safePath}`;
    const vfsName = `opfs${pathSegment}`;
    if (sqlite3.vfs_registered.has(vfsName) === false) {
      const vfs2 = yield* promise(() => AccessHandlePoolVFS.create(vfsName, directory, sqlite3.module));
      sqlite3.vfs_register(vfs2, false);
      opfsVfsMap.set(vfsName, vfs2);
    }
    const dbPointer = sqlite3.open_v2Sync(fileName, void 0, vfsName);
    const vfs = opfsVfsMap.get(vfsName);
    return { dbPointer, vfs };
  }).pipe(semaphore.withPermits(1));
  new TextDecoder();
  const sqliteDbFactory = ({ sqlite3 }) => (input) => gen$2(function* () {
    if (input._tag === "in-memory") {
      const { dbPointer: dbPointer2, vfs: vfs2 } = makeInMemoryDb(sqlite3);
      return makeSqliteDb({
        sqlite3,
        metadata: {
          _tag: "in-memory",
          vfs: vfs2,
          dbPointer: dbPointer2,
          deleteDb: () => {
          },
          configureDb: input.configureDb ?? (() => {
          }),
          persistenceInfo: {
            fileName: ":memory:"
          }
        }
      });
    }
    const MAX_DB_FILENAME_LENGTH = 60;
    let dbFilename = input.fileName;
    if (input.fileName.length > MAX_DB_FILENAME_LENGTH) {
      yield* logWarning(`dbFilename too long: '${input.fileName}'. Max ${MAX_DB_FILENAME_LENGTH} chars, got ${input.fileName.length}. Hashing...`);
      dbFilename = `hash-${string(input.fileName)}.db`;
    }
    const { dbPointer, vfs } = yield* makeOpfsDb({
      sqlite3,
      directory: input.opfsDirectory,
      fileName: dbFilename
    });
    return makeSqliteDb({
      sqlite3,
      metadata: {
        _tag: "opfs",
        vfs,
        dbPointer,
        deleteDb: () => vfs.resetAccessHandle(input.fileName),
        configureDb: input.configureDb ?? (() => {
        }),
        persistenceInfo: {
          fileName: dbFilename,
          opfsDirectory: input.opfsDirectory,
          opfsFileName: vfs.getOpfsFileName(dbFilename)
        }
      }
    });
  });
  const MAX_INT64 = 0x7fffffffffffffffn;
  const MIN_INT64 = -0x8000000000000000n;
  class SQLiteError extends Error {
    constructor(message, code) {
      super(message);
      this.code = code;
    }
  }
  const async = false;
  function Factory(Module2) {
    const sqlite3 = {};
    Module2.retryOps = [];
    const sqliteFreeAddress = Module2._getSqliteFree();
    const tmp = Module2._malloc(8);
    const tmpPtr = [tmp, tmp + 4];
    function createUTF8(s) {
      if (typeof s !== "string") return 0;
      const utf8 = new TextEncoder().encode(s);
      const zts = Module2._sqlite3_malloc(utf8.byteLength + 1);
      Module2.HEAPU8.set(utf8, zts);
      Module2.HEAPU8[zts + utf8.byteLength] = 0;
      return zts;
    }
    function cvt32x2ToBigInt(lo32, hi32) {
      return BigInt(hi32) << 32n | BigInt(lo32) & 0xffffffffn;
    }
    const cvt32x2AsSafe = function() {
      const hiMax = BigInt(Number.MAX_SAFE_INTEGER) >> 32n;
      const hiMin = BigInt(Number.MIN_SAFE_INTEGER) >> 32n;
      return function(lo32, hi32) {
        if (hi32 > hiMax || hi32 < hiMin) {
          return cvt32x2ToBigInt(lo32, hi32);
        } else {
          return hi32 * 4294967296 + (lo32 & 2147483647) - (lo32 & 2147483648);
        }
      };
    }();
    const databases = /* @__PURE__ */ new Set();
    function verifyDatabase(db) {
      if (!databases.has(db)) {
        throw new SQLiteError("not a database", SQLITE_MISUSE);
      }
    }
    const mapStmtToDB = /* @__PURE__ */ new Map();
    function verifyStatement(stmt) {
      if (!mapStmtToDB.has(stmt)) {
        throw new SQLiteError("not a statement", SQLITE_MISUSE);
      }
    }
    sqlite3.bind_collection = function(stmt, bindings) {
      verifyStatement(stmt);
      const isArray2 = Array.isArray(bindings);
      const nBindings = sqlite3.bind_parameter_count(stmt);
      for (let i = 1; i <= nBindings; ++i) {
        const key = isArray2 ? i - 1 : sqlite3.bind_parameter_name(stmt, i);
        const value2 = bindings[key];
        if (value2 !== void 0) {
          sqlite3.bind(stmt, i, value2);
        }
      }
      return SQLITE_OK;
    };
    sqlite3.bind = function(stmt, i, value2) {
      verifyStatement(stmt);
      switch (typeof value2) {
        case "number":
          if (value2 === (value2 | 0)) {
            return sqlite3.bind_int(stmt, i, value2);
          } else {
            return sqlite3.bind_double(stmt, i, value2);
          }
        case "string":
          return sqlite3.bind_text(stmt, i, value2);
        default:
          if (value2 instanceof Uint8Array || Array.isArray(value2)) {
            return sqlite3.bind_blob(stmt, i, value2);
          } else if (value2 === null) {
            return sqlite3.bind_null(stmt, i);
          } else if (typeof value2 === "bigint") {
            return sqlite3.bind_int64(stmt, i, value2);
          } else if (value2 === void 0) {
            return SQLITE_NOTICE;
          } else {
            console.warn("unknown binding converted to null", value2);
            return sqlite3.bind_null(stmt, i);
          }
      }
    };
    sqlite3.bind_blob = function() {
      const fname = "sqlite3_bind_blob";
      const f = Module2.cwrap(fname, ...decl("nnnnn:n"));
      return function(stmt, i, value2) {
        verifyStatement(stmt);
        const byteLength = value2.byteLength ?? value2.length;
        const ptr = Module2._sqlite3_malloc(byteLength);
        Module2.HEAPU8.subarray(ptr).set(value2);
        const result = f(stmt, i, ptr, byteLength, sqliteFreeAddress);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.bind_parameter_count = function() {
      const fname = "sqlite3_bind_parameter_count";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(stmt) {
        verifyStatement(stmt);
        const result = f(stmt);
        return result;
      };
    }();
    sqlite3.bind_double = function() {
      const fname = "sqlite3_bind_double";
      const f = Module2.cwrap(fname, ...decl("nnn:n"));
      return function(stmt, i, value2) {
        verifyStatement(stmt);
        const result = f(stmt, i, value2);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.bind_int = function() {
      const fname = "sqlite3_bind_int";
      const f = Module2.cwrap(fname, ...decl("nnn:n"));
      return function(stmt, i, value2) {
        verifyStatement(stmt);
        if (value2 > 2147483647 || value2 < -2147483648) return SQLITE_RANGE;
        const result = f(stmt, i, value2);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.bind_int64 = function() {
      const fname = "sqlite3_bind_int64";
      const f = Module2.cwrap(fname, ...decl("nnnn:n"));
      return function(stmt, i, value2) {
        verifyStatement(stmt);
        if (value2 > MAX_INT64 || value2 < MIN_INT64) return SQLITE_RANGE;
        const lo32 = value2 & 0xffffffffn;
        const hi32 = value2 >> 32n;
        const result = f(stmt, i, Number(lo32), Number(hi32));
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.bind_null = function() {
      const fname = "sqlite3_bind_null";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, i) {
        verifyStatement(stmt);
        const result = f(stmt, i);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.bind_parameter_name = function() {
      const fname = "sqlite3_bind_parameter_name";
      const f = Module2.cwrap(fname, ...decl("n:s"));
      return function(stmt, i) {
        verifyStatement(stmt);
        const result = f(stmt, i);
        return result;
      };
    }();
    sqlite3.bind_text = function() {
      const fname = "sqlite3_bind_text";
      const f = Module2.cwrap(fname, ...decl("nnnnn:n"));
      return function(stmt, i, value2) {
        verifyStatement(stmt);
        const ptr = createUTF8(value2);
        const result = f(stmt, i, ptr, -1, sqliteFreeAddress);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.changes = function() {
      const fname = "sqlite3_changes";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(db) {
        verifyDatabase(db);
        const result = f(db);
        return result;
      };
    }();
    sqlite3.deserialize = function() {
      const fname = "sqlite3_deserialize";
      const f = Module2.cwrap(fname, ...decl("nnnnnn:n"));
      return function(db, schema2, data, szDb, szBuf, flags) {
        verifyDatabase(db);
        const ptr = Module2._sqlite3_malloc(szDb);
        Module2.HEAPU8.subarray(ptr).set(data);
        const result = f(db, schema2, ptr, szDb, szBuf, flags);
        return result;
      };
    }();
    const SQLITE_SERIALIZE_NOCOPY = 1;
    sqlite3.serialize = function() {
      const fname = "sqlite3_serialize";
      const f = Module2.cwrap(fname, ...decl("nsnn:n"));
      return function(db, schema2) {
        verifyDatabase(db);
        const piSize = tmpPtr[0];
        let address = f(db, schema2, piSize, 0);
        if (address === 0) {
          address = f(db, schema2, piSize, SQLITE_SERIALIZE_NOCOPY);
          const size2 = Module2.getValue(piSize, "*");
          const result = Module2.HEAPU8.subarray(address, address + size2);
          return new Uint8Array(result.slice());
        } else {
          const size2 = Module2.getValue(piSize, "*");
          const result = Module2.HEAPU8.subarray(address, address + size2);
          return new Uint8Array(result);
        }
      };
    }();
    sqlite3.backup = function() {
      const fInit = Module2.cwrap("sqlite3_backup_init", ...decl("nsns:n"));
      const fStep = Module2.cwrap("sqlite3_backup_step", ...decl("nn:n"));
      const fFinish = Module2.cwrap("sqlite3_backup_finish", ...decl("n:n"));
      return function(dest, destName, source, sourceName) {
        verifyDatabase(dest);
        verifyDatabase(source);
        const backup = fInit(dest, destName, source, sourceName);
        if (backup === 0) {
          const errMsg = Module2.ccall("sqlite3_errmsg", "string", ["number"], [dest]);
          throw new SQLiteError(`backup failed: ${errMsg}`, SQLITE_ERROR);
        }
        fStep(backup, -1);
        return fFinish(backup);
      };
    }();
    sqlite3.clear_bindings = function() {
      const fname = "sqlite3_clear_bindings";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(stmt) {
        verifyStatement(stmt);
        const result = f(stmt);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.close = function() {
      const fname = "sqlite3_close";
      const f = Module2.cwrap(fname, ...decl("n:n"), { async });
      return function(db) {
        verifyDatabase(db);
        const result = f(db);
        databases.delete(db);
        return check2(fname, result, db);
      };
    }();
    sqlite3.column = function(stmt, iCol) {
      verifyStatement(stmt);
      const type = sqlite3.column_type(stmt, iCol);
      switch (type) {
        case SQLITE_BLOB:
          return sqlite3.column_blob(stmt, iCol);
        case SQLITE_FLOAT:
          return sqlite3.column_double(stmt, iCol);
        case SQLITE_INTEGER:
          const lo32 = sqlite3.column_int(stmt, iCol);
          const hi32 = Module2.getTempRet0();
          return cvt32x2AsSafe(lo32, hi32);
        case SQLITE_NULL:
          return null;
        case SQLITE_TEXT:
          return sqlite3.column_text(stmt, iCol);
        default:
          throw new SQLiteError("unknown type", type);
      }
    };
    sqlite3.column_blob = function() {
      const fname = "sqlite3_column_blob";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const nBytes = sqlite3.column_bytes(stmt, iCol);
        const address = f(stmt, iCol);
        if (address === 0) {
          return null;
        }
        const result = Module2.HEAPU8.subarray(address, address + nBytes);
        return new Uint8Array(result);
      };
    }();
    sqlite3.column_bytes = function() {
      const fname = "sqlite3_column_bytes";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const result = f(stmt, iCol);
        return result;
      };
    }();
    sqlite3.column_count = function() {
      const fname = "sqlite3_column_count";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(stmt) {
        verifyStatement(stmt);
        const result = f(stmt);
        return result;
      };
    }();
    sqlite3.column_double = function() {
      const fname = "sqlite3_column_double";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const result = f(stmt, iCol);
        return result;
      };
    }();
    sqlite3.column_int = function() {
      const fname = "sqlite3_column_int64";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const result = f(stmt, iCol);
        return result;
      };
    }();
    sqlite3.column_int64 = function() {
      const fname = "sqlite3_column_int64";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const lo32 = f(stmt, iCol);
        const hi32 = Module2.getTempRet0();
        const result = cvt32x2ToBigInt(lo32, hi32);
        return result;
      };
    }();
    sqlite3.column_name = function() {
      const fname = "sqlite3_column_name";
      const f = Module2.cwrap(fname, ...decl("nn:s"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const result = f(stmt, iCol);
        return result;
      };
    }();
    sqlite3.column_names = function(stmt) {
      const columns = [];
      const nColumns = sqlite3.column_count(stmt);
      for (let i = 0; i < nColumns; ++i) {
        columns.push(sqlite3.column_name(stmt, i));
      }
      return columns;
    };
    sqlite3.column_text = function() {
      const fname = "sqlite3_column_text";
      const f = Module2.cwrap(fname, ...decl("nn:s"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const result = f(stmt, iCol);
        return result;
      };
    }();
    sqlite3.column_type = function() {
      const fname = "sqlite3_column_type";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(stmt, iCol) {
        verifyStatement(stmt);
        const result = f(stmt, iCol);
        return result;
      };
    }();
    sqlite3.create_function = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
      verifyDatabase(db);
      function adapt(f) {
        return (ctx, n, values) => f(ctx, Module2.HEAP32.subarray(values / 4, values / 4 + n));
      }
      const result = Module2.create_function(
        db,
        zFunctionName,
        nArg,
        eTextRep,
        pApp,
        xFunc && adapt(xFunc),
        xStep && adapt(xStep),
        xFinal
      );
      return check2("sqlite3_create_function", result, db);
    };
    sqlite3.data_count = function() {
      const fname = "sqlite3_data_count";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(stmt) {
        verifyStatement(stmt);
        const result = f(stmt);
        return result;
      };
    }();
    sqlite3.exec = function(db, sql2, callback) {
      const stmts = sqlite3.statements(db, sql2, { unscoped: true });
      for (const stmt of stmts) {
        let columns;
        while (sqlite3.step(stmt) === SQLITE_ROW) {
          if (callback) {
            columns = columns ?? sqlite3.column_names(stmt);
            const row = sqlite3.row(stmt);
            callback(row, columns);
            callback(row, columns);
          }
        }
      }
      for (const stmt of stmts) {
        sqlite3.finalize(stmt);
      }
      return SQLITE_OK;
    };
    sqlite3.finalize = function() {
      const fname = "sqlite3_finalize";
      const f = Module2.cwrap(fname, ...decl("n:n"), { async });
      return function(stmt) {
        const result = f(stmt);
        mapStmtToDB.delete(stmt);
        return result;
      };
    }();
    sqlite3.get_autocommit = function() {
      const fname = "sqlite3_get_autocommit";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(db) {
        const result = f(db);
        return result;
      };
    }();
    sqlite3.libversion = function() {
      const fname = "sqlite3_libversion";
      const f = Module2.cwrap(fname, ...decl(":s"));
      return function() {
        const result = f();
        return result;
      };
    }();
    sqlite3.libversion_number = function() {
      const fname = "sqlite3_libversion_number";
      const f = Module2.cwrap(fname, ...decl(":n"));
      return function() {
        const result = f();
        return result;
      };
    }();
    sqlite3.limit = function() {
      const fname = "sqlite3_limit";
      const f = Module2.cwrap(fname, ...decl("nnn:n"));
      return function(db, id2, newVal) {
        const result = f(db, id2, newVal);
        return result;
      };
    }();
    sqlite3.open_v2 = function() {
      const fname = "sqlite3_open_v2";
      const f = Module2.cwrap(fname, ...decl("snnn:n"), { async });
      return async function(zFilename, flags, zVfs) {
        flags = flags || SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
        zVfs = createUTF8(zVfs);
        try {
          const rc = await retry2(() => f(zFilename, tmpPtr[0], flags, zVfs));
          const db = Module2.getValue(tmpPtr[0], "*");
          databases.add(db);
          Module2.ccall("RegisterExtensionFunctions", "void", ["number"], [db]);
          check2(fname, rc, db);
          return db;
        } finally {
          Module2._sqlite3_free(zVfs);
        }
      };
    }();
    sqlite3.open_v2Sync = function() {
      const fname = "sqlite3_open_v2";
      const f = Module2.cwrap(fname, ...decl("snnn:n"), { async });
      return function(zFilename, flags, zVfs) {
        flags = flags || SQLITE_OPEN_CREATE | SQLITE_OPEN_READWRITE;
        zVfs = createUTF8(zVfs);
        try {
          const rc = f(zFilename, tmpPtr[0], flags, zVfs);
          const db = Module2.getValue(tmpPtr[0], "*");
          databases.add(db);
          Module2.ccall("RegisterExtensionFunctions", "void", ["number"], [db]);
          check2(fname, rc, db);
          return db;
        } finally {
          Module2._sqlite3_free(zVfs);
        }
      };
    }();
    sqlite3.progress_handler = function(db, nProgressOps, handler, userData) {
      verifyDatabase(db);
      Module2.progress_handler(db, nProgressOps, handler, userData);
    };
    sqlite3.reset = function() {
      const fname = "sqlite3_reset";
      const f = Module2.cwrap(fname, ...decl("n:n"), { async });
      return function(stmt) {
        verifyStatement(stmt);
        const result = f(stmt);
        return check2(fname, result, mapStmtToDB.get(stmt));
      };
    }();
    sqlite3.result = function(context2, value2) {
      switch (typeof value2) {
        case "number":
          if (value2 === (value2 | 0)) {
            sqlite3.result_int(context2, value2);
          } else {
            sqlite3.result_double(context2, value2);
          }
          break;
        case "string":
          sqlite3.result_text(context2, value2);
          break;
        default:
          if (value2 instanceof Uint8Array || Array.isArray(value2)) {
            sqlite3.result_blob(context2, value2);
          } else if (value2 === null) {
            sqlite3.result_null(context2);
          } else if (typeof value2 === "bigint") {
            return sqlite3.result_int64(context2, value2);
          } else {
            console.warn("unknown result converted to null", value2);
            sqlite3.result_null(context2);
          }
          break;
      }
    };
    sqlite3.result_blob = function() {
      const fname = "sqlite3_result_blob";
      const f = Module2.cwrap(fname, ...decl("nnnn:n"));
      return function(context2, value2) {
        const byteLength = value2.byteLength ?? value2.length;
        const ptr = Module2._sqlite3_malloc(byteLength);
        Module2.HEAPU8.subarray(ptr).set(value2);
        f(context2, ptr, byteLength, sqliteFreeAddress);
      };
    }();
    sqlite3.result_double = function() {
      const fname = "sqlite3_result_double";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(context2, value2) {
        f(context2, value2);
      };
    }();
    sqlite3.result_int = function() {
      const fname = "sqlite3_result_int";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(context2, value2) {
        f(context2, value2);
      };
    }();
    sqlite3.result_int64 = function() {
      const fname = "sqlite3_result_int64";
      const f = Module2.cwrap(fname, ...decl("nnn:n"));
      return function(context2, value2) {
        if (value2 > MAX_INT64 || value2 < MIN_INT64) return SQLITE_RANGE;
        const lo32 = value2 & 0xffffffffn;
        const hi32 = value2 >> 32n;
        f(context2, Number(lo32), Number(hi32));
      };
    }();
    sqlite3.result_null = function() {
      const fname = "sqlite3_result_null";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(context2) {
        f(context2);
      };
    }();
    sqlite3.result_text = function() {
      const fname = "sqlite3_result_text";
      const f = Module2.cwrap(fname, ...decl("nnnn:n"));
      return function(context2, value2) {
        const ptr = createUTF8(value2);
        f(context2, ptr, -1, sqliteFreeAddress);
      };
    }();
    sqlite3.row = function(stmt) {
      const row = [];
      const nColumns = sqlite3.data_count(stmt);
      for (let i = 0; i < nColumns; ++i) {
        const value2 = sqlite3.column(stmt, i);
        row.push((value2 == null ? void 0 : value2.buffer) === Module2.HEAPU8.buffer ? value2.slice() : value2);
      }
      return row;
    };
    sqlite3.set_authorizer = function(db, xAuth, pApp) {
      verifyDatabase(db);
      function cvtArgs(_, iAction, p3, p4, p5, p6) {
        return [
          _,
          iAction,
          Module2.UTF8ToString(p3),
          Module2.UTF8ToString(p4),
          Module2.UTF8ToString(p5),
          Module2.UTF8ToString(p6)
        ];
      }
      function adapt(f) {
        return (_, iAction, p3, p4, p5, p6) => f(...cvtArgs(_, iAction, p3, p4, p5, p6));
      }
      const result = Module2.set_authorizer(db, adapt(xAuth), pApp);
      return check2("sqlite3_set_authorizer", result, db);
    };
    sqlite3.sql = function() {
      const fname = "sqlite3_sql";
      const f = Module2.cwrap(fname, ...decl("n:s"));
      return function(stmt) {
        verifyStatement(stmt);
        const result = f(stmt);
        return result;
      };
    }();
    sqlite3.statements = function(db, sql2, options2 = {}) {
      const prepare = Module2.cwrap(
        "sqlite3_prepare_v3",
        "number",
        ["number", "number", "number", "number", "number", "number"],
        // { async: true });
        { async: false }
      );
      const stmts = [];
      const utf8 = new TextEncoder().encode(sql2);
      const allocSize = utf8.byteLength - utf8.byteLength % 4 + 12;
      const pzHead = Module2._sqlite3_malloc(allocSize);
      const pzEnd = pzHead + utf8.byteLength + 1;
      Module2.HEAPU8.set(utf8, pzHead);
      Module2.HEAPU8[pzEnd - 1] = 0;
      const pStmt = pzHead + allocSize - 8;
      const pzTail = pzHead + allocSize - 4;
      let stmt;
      function maybeFinalize() {
        if (stmt && !options2.unscoped) {
          sqlite3.finalize(stmt);
        }
        stmt = 0;
      }
      Module2.setValue(pzTail, pzHead, "*");
      do {
        maybeFinalize();
        const zTail = Module2.getValue(pzTail, "*");
        const rc = prepare(
          db,
          zTail,
          pzEnd - pzTail,
          options2.flags || 0,
          pStmt,
          pzTail
        );
        if (rc !== SQLITE_OK) {
          check2("sqlite3_prepare_v3", rc, db);
        }
        stmt = Module2.getValue(pStmt, "*");
        if (stmt) {
          mapStmtToDB.set(stmt, db);
          stmts.push(stmt);
        }
      } while (stmt);
      return stmts;
    };
    sqlite3.step = function() {
      const fname = "sqlite3_step";
      const f = Module2.cwrap(fname, ...decl("n:n"), { async });
      return function(stmt) {
        verifyStatement(stmt);
        const rc = f(stmt);
        return check2(fname, rc, mapStmtToDB.get(stmt), [SQLITE_ROW, SQLITE_DONE]);
      };
    }();
    sqlite3.commit_hook = function(db, xCommitHook) {
      verifyDatabase(db);
      Module2.commit_hook(db, xCommitHook);
    };
    sqlite3.update_hook = function(db, xUpdateHook) {
      verifyDatabase(db);
      function cvtArgs(iUpdateType, dbName, tblName, lo32, hi32) {
        return [
          iUpdateType,
          Module2.UTF8ToString(dbName),
          Module2.UTF8ToString(tblName),
          cvt32x2ToBigInt(lo32, hi32)
        ];
      }
      function adapt(f) {
        return (iUpdateType, dbName, tblName, lo32, hi32) => f(...cvtArgs(iUpdateType, dbName, tblName, lo32, hi32));
      }
      Module2.update_hook(db, adapt(xUpdateHook));
    };
    sqlite3.session_create = function() {
      const fname = "sqlite3session_create";
      const f = Module2.cwrap(fname, ...decl("nsn:n"));
      return function(db, zDb) {
        verifyDatabase(db);
        const ppSession = Module2._malloc(4);
        const result = f(db, zDb, ppSession);
        if (result !== SQLITE_OK) {
          check2(fname, result, db);
        }
        const pSession = Module2.getValue(ppSession, "i32");
        return pSession;
      };
    }();
    sqlite3.session_attach = function() {
      const fname = "sqlite3session_attach";
      const f = Module2.cwrap(fname, ...decl("ns:n"));
      return function(pSession, zTab) {
        if (typeof pSession !== "number") {
          throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
        }
        const result = f(pSession, zTab);
        return check2(fname, result);
      };
    }();
    sqlite3.session_enable = function() {
      const fname = "sqlite3session_enable";
      const f = Module2.cwrap(fname, ...decl("nn:n"));
      return function(pSession, enableBool) {
        const enable2 = enableBool ? 1 : 0;
        if (typeof pSession !== "number") {
          throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
        }
        const result = f(pSession, enable2);
        if (result !== enable2) {
          throw new SQLiteError("Failed to enable session", SQLITE_MISUSE);
        }
      };
    }();
    sqlite3.session_changeset = function() {
      const fname = "sqlite3session_changeset";
      const f = Module2.cwrap(fname, ...decl("nnn:n"));
      return function(pSession) {
        if (typeof pSession !== "number") {
          throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
        }
        const sizePtr = Module2._malloc(4);
        const changesetPtrPtr = Module2._malloc(4);
        try {
          const result = f(pSession, sizePtr, changesetPtrPtr);
          if (result === SQLITE_OK) {
            const size2 = Module2.getValue(sizePtr, "i32");
            const changesetPtr = Module2.getValue(changesetPtrPtr, "i32");
            if (changesetPtr === 0) {
              return {
                result,
                size: 0,
                changeset: null
              };
            }
            const changeset = new Uint8Array(Module2.HEAPU8.subarray(changesetPtr, changesetPtr + size2));
            Module2._sqlite3_free(changesetPtr);
            return {
              result,
              size: size2,
              changeset
            };
          }
          return check2(fname, result);
        } finally {
          Module2._free(sizePtr);
          Module2._free(changesetPtrPtr);
        }
      };
    }();
    sqlite3.session_delete = function() {
      const fname = "sqlite3session_delete";
      const f = Module2.cwrap(fname, ...decl("n:v"));
      return function(pSession) {
        if (typeof pSession !== "number") {
          throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
        }
        const result = f(pSession);
        return result;
      };
    }();
    sqlite3.changeset_start = function() {
      const fname = "sqlite3changeset_start";
      const f = Module2.cwrap(fname, ...decl("nnn:n"));
      return function(changesetData) {
        const inPtr = Module2._sqlite3_malloc(changesetData.length);
        Module2.HEAPU8.subarray(inPtr).set(changesetData);
        const ppIter = Module2._malloc(4);
        try {
          const result = f(ppIter, changesetData.length, inPtr);
          if (result !== SQLITE_OK) {
            check2(fname, result);
          }
          const pIter = Module2.getValue(ppIter, "i32");
          return pIter;
        } finally {
          Module2._sqlite3_free(inPtr);
          Module2._free(ppIter);
        }
      };
    }();
    sqlite3.changeset_finalize = function() {
      const fname = "sqlite3changeset_finalize";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pIter) {
        const result = f(pIter);
        return result;
      };
    }();
    sqlite3.changeset_invert = function() {
      const fname = "sqlite3changeset_invert";
      const f = Module2.cwrap(fname, ...decl("nn:nn"));
      return function(changesetData) {
        const inPtr = Module2._sqlite3_malloc(changesetData.length);
        Module2.HEAPU8.subarray(inPtr).set(changesetData);
        const outLengthPtr = Module2._malloc(4);
        const outPtrPtr = Module2._malloc(4);
        const result = f(changesetData.length, inPtr, outLengthPtr, outPtrPtr);
        if (result !== SQLITE_OK) {
          check2(fname, result);
        }
        const outLength = Module2.getValue(outLengthPtr, "i32");
        const changesetOutPtr = Module2.getValue(outPtrPtr, "i32");
        const changesetOut = new Uint8Array(Module2.HEAPU8.buffer, changesetOutPtr, outLength).slice();
        Module2._sqlite3_free(inPtr);
        Module2._sqlite3_free(changesetOutPtr);
        return changesetOut;
      };
    }();
    sqlite3.session_changeset_inverted = function() {
      const fnameChangeset = "sqlite3session_changeset";
      const fChangeset = Module2.cwrap(fnameChangeset, ...decl("nnn:n"));
      const fnameInvert = "sqlite3changeset_invert";
      const fInvert = Module2.cwrap(fnameInvert, ...decl("nn:nn"));
      return function(pSession) {
        if (typeof pSession !== "number") {
          throw new SQLiteError("Invalid session object", SQLITE_MISUSE);
        }
        const sizePtr = Module2._malloc(4);
        const changesetPtrPtr = Module2._malloc(4);
        const sizePtrInvert = Module2._malloc(4);
        const changesetPtrPtrInvert = Module2._malloc(4);
        try {
          const changesetResult = fChangeset(pSession, sizePtr, changesetPtrPtr);
          if (changesetResult !== SQLITE_OK) {
            return check2(fnameChangeset, changesetResult);
          }
          const size2 = Module2.getValue(sizePtr, "i32");
          const changesetPtr = Module2.getValue(changesetPtrPtr, "i32");
          const invertedResult = fInvert(size2, changesetPtr, sizePtrInvert, changesetPtrPtrInvert);
          if (invertedResult !== SQLITE_OK) {
            return check2(fnameInvert, invertedResult);
          }
          const sizeInvert = Module2.getValue(sizePtrInvert, "i32");
          const changesetPtrInvert = Module2.getValue(changesetPtrPtrInvert, "i32");
          const changesetInvert = new Uint8Array(Module2.HEAPU8.buffer, changesetPtrInvert, sizeInvert);
          Module2._sqlite3_free(changesetPtr);
          Module2._sqlite3_free(changesetPtrInvert);
          return {
            result: changesetResult,
            size: size2,
            changeset: new Uint8Array(changesetInvert)
          };
        } finally {
          Module2._free(sizePtr);
          Module2._free(changesetPtrPtr);
          Module2._free(sizePtrInvert);
          Module2._free(changesetPtrPtrInvert);
        }
      };
    }();
    sqlite3.changeset_apply = function() {
      const fname = "sqlite3changeset_apply";
      const f = Module2.cwrap(fname, ...decl("nnnnnn:n"));
      return function(db, changesetData, options2) {
        const inPtr = Module2._sqlite3_malloc(changesetData.length);
        Module2.HEAPU8.subarray(inPtr).set(changesetData);
        const SQLITE_CHANGESET_REPLACE = 1;
        const onConflict = () => {
          return SQLITE_CHANGESET_REPLACE;
        };
        const result = f(db, changesetData.length, inPtr, null, onConflict, null);
        Module2._sqlite3_free(inPtr);
        if (result !== SQLITE_OK) {
          check2(fname, result);
        }
        return result;
      };
    }();
    sqlite3.value = function(pValue) {
      const type = sqlite3.value_type(pValue);
      switch (type) {
        case SQLITE_BLOB:
          return sqlite3.value_blob(pValue);
        case SQLITE_FLOAT:
          return sqlite3.value_double(pValue);
        case SQLITE_INTEGER:
          const lo32 = sqlite3.value_int(pValue);
          const hi32 = Module2.getTempRet0();
          return cvt32x2AsSafe(lo32, hi32);
        case SQLITE_NULL:
          return null;
        case SQLITE_TEXT:
          return sqlite3.value_text(pValue);
        default:
          throw new SQLiteError("unknown type", type);
      }
    };
    sqlite3.value_blob = function() {
      const fname = "sqlite3_value_blob";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pValue) {
        const nBytes = sqlite3.value_bytes(pValue);
        const address = f(pValue);
        const result = Module2.HEAPU8.subarray(address, address + nBytes);
        return result;
      };
    }();
    sqlite3.value_bytes = function() {
      const fname = "sqlite3_value_bytes";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pValue) {
        const result = f(pValue);
        return result;
      };
    }();
    sqlite3.value_double = function() {
      const fname = "sqlite3_value_double";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pValue) {
        const result = f(pValue);
        return result;
      };
    }();
    sqlite3.value_int = function() {
      const fname = "sqlite3_value_int64";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pValue) {
        const result = f(pValue);
        return result;
      };
    }();
    sqlite3.value_int64 = function() {
      const fname = "sqlite3_value_int64";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pValue) {
        const lo32 = f(pValue);
        const hi32 = Module2.getTempRet0();
        const result = cvt32x2ToBigInt(lo32, hi32);
        return result;
      };
    }();
    sqlite3.value_text = function() {
      const fname = "sqlite3_value_text";
      const f = Module2.cwrap(fname, ...decl("n:s"));
      return function(pValue) {
        const result = f(pValue);
        return result;
      };
    }();
    sqlite3.value_type = function() {
      const fname = "sqlite3_value_type";
      const f = Module2.cwrap(fname, ...decl("n:n"));
      return function(pValue) {
        const result = f(pValue);
        return result;
      };
    }();
    const registeredVfs = /* @__PURE__ */ new Set();
    sqlite3.vfs_register = function(vfs, makeDefault) {
      if (registeredVfs.has(vfs.name)) return;
      const result = Module2.vfs_register(vfs, makeDefault);
      const res = check2("sqlite3_vfs_register", result);
      registeredVfs.add(vfs.name);
      return res;
    };
    sqlite3.vfs_registered = registeredVfs;
    function check2(fname, result, db = null, allowed = [SQLITE_OK]) {
      if (allowed.includes(result)) return result;
      const message = db ? Module2.ccall("sqlite3_errmsg", "string", ["number"], [db]) : fname;
      throw new SQLiteError(message, result);
    }
    async function retry2(f) {
      let rc;
      do {
        if (Module2.retryOps.length) {
          await Promise.all(Module2.retryOps);
          Module2.retryOps = [];
        }
        rc = await f();
      } while (rc && Module2.retryOps.length);
      return rc;
    }
    return sqlite3;
  }
  function decl(s) {
    const result = [];
    const m = s.match(/([ns@]*):([nsv@])/);
    switch (m[2]) {
      case "n":
        result.push("number");
        break;
      case "s":
        result.push("string");
        break;
      case "v":
        result.push(null);
        break;
    }
    const args2 = [];
    for (let c of m[1]) {
      switch (c) {
        case "n":
          args2.push("number");
          break;
        case "s":
          args2.push("string");
          break;
      }
    }
    result.push(args2);
    return result;
  }
  var Module = (() => {
    var _scriptName = self.location.href;
    return function(moduleArg = {}) {
      var moduleRtn;
      var Module2 = moduleArg;
      var readyPromiseResolve, readyPromiseReject;
      var readyPromise = new Promise((resolve, reject) => {
        readyPromiseResolve = resolve;
        readyPromiseReject = reject;
      });
      var ENVIRONMENT_IS_WEB = typeof window == "object";
      var ENVIRONMENT_IS_WORKER = typeof WorkerGlobalScope != "undefined";
      typeof process == "object" && typeof process.versions == "object" && typeof process.versions.node == "string" && process.type != "renderer";
      var moduleOverrides = Object.assign({}, Module2);
      var thisProgram = "./this.program";
      var quit_ = (status, toThrow) => {
        throw toThrow;
      };
      var scriptDirectory = "";
      function locateFile(path) {
        if (Module2["locateFile"]) {
          return Module2["locateFile"](path, scriptDirectory);
        }
        return scriptDirectory + path;
      }
      var readAsync, readBinary;
      if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
        if (ENVIRONMENT_IS_WORKER) {
          scriptDirectory = self.location.href;
        } else if (typeof document != "undefined" && document.currentScript) {
          scriptDirectory = document.currentScript.src;
        }
        if (_scriptName) {
          scriptDirectory = _scriptName;
        }
        if (scriptDirectory.startsWith("blob:")) {
          scriptDirectory = "";
        } else {
          scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, "").lastIndexOf("/") + 1);
        }
        {
          if (ENVIRONMENT_IS_WORKER) {
            readBinary = (url) => {
              var xhr = new XMLHttpRequest();
              xhr.open("GET", url, false);
              xhr.responseType = "arraybuffer";
              xhr.send(null);
              return new Uint8Array(xhr.response);
            };
          }
          readAsync = (url) => fetch(url, { credentials: "same-origin" }).then((response) => {
            if (response.ok) {
              return response.arrayBuffer();
            }
            return Promise.reject(new Error(response.status + " : " + response.url));
          });
        }
      }
      var out = Module2["print"] || console.log.bind(console);
      var err = Module2["printErr"] || console.error.bind(console);
      Object.assign(Module2, moduleOverrides);
      moduleOverrides = null;
      if (Module2["arguments"]) Module2["arguments"];
      if (Module2["thisProgram"]) thisProgram = Module2["thisProgram"];
      var wasmBinary = Module2["wasmBinary"];
      var wasmMemory;
      var ABORT = false;
      var EXITSTATUS;
      var HEAP8, HEAPU8, HEAP16, HEAPU16, HEAP32, HEAPU32, HEAPF32, HEAPF64;
      function updateMemoryViews() {
        var b = wasmMemory.buffer;
        Module2["HEAP8"] = HEAP8 = new Int8Array(b);
        Module2["HEAP16"] = HEAP16 = new Int16Array(b);
        Module2["HEAPU8"] = HEAPU8 = new Uint8Array(b);
        Module2["HEAPU16"] = HEAPU16 = new Uint16Array(b);
        Module2["HEAP32"] = HEAP32 = new Int32Array(b);
        Module2["HEAPU32"] = HEAPU32 = new Uint32Array(b);
        Module2["HEAPF32"] = HEAPF32 = new Float32Array(b);
        Module2["HEAPF64"] = HEAPF64 = new Float64Array(b);
      }
      var __ATPRERUN__ = [];
      var __ATINIT__ = [];
      var __ATMAIN__ = [];
      var __ATPOSTRUN__ = [];
      function preRun() {
        if (Module2["preRun"]) {
          if (typeof Module2["preRun"] == "function") Module2["preRun"] = [Module2["preRun"]];
          while (Module2["preRun"].length) {
            addOnPreRun(Module2["preRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPRERUN__);
      }
      function initRuntime() {
        if (!Module2["noFSInit"] && !FS.initialized) FS.init();
        FS.ignorePermissions = false;
        callRuntimeCallbacks(__ATINIT__);
      }
      function preMain() {
        callRuntimeCallbacks(__ATMAIN__);
      }
      function postRun() {
        if (Module2["postRun"]) {
          if (typeof Module2["postRun"] == "function") Module2["postRun"] = [Module2["postRun"]];
          while (Module2["postRun"].length) {
            addOnPostRun(Module2["postRun"].shift());
          }
        }
        callRuntimeCallbacks(__ATPOSTRUN__);
      }
      function addOnPreRun(cb) {
        __ATPRERUN__.unshift(cb);
      }
      function addOnInit(cb) {
        __ATINIT__.unshift(cb);
      }
      function addOnPostRun(cb) {
        __ATPOSTRUN__.unshift(cb);
      }
      var runDependencies = 0;
      var dependenciesFulfilled = null;
      function getUniqueRunDependency(id2) {
        return id2;
      }
      function addRunDependency(id2) {
        var _a2;
        runDependencies++;
        (_a2 = Module2["monitorRunDependencies"]) == null ? void 0 : _a2.call(Module2, runDependencies);
      }
      function removeRunDependency(id2) {
        var _a2;
        runDependencies--;
        (_a2 = Module2["monitorRunDependencies"]) == null ? void 0 : _a2.call(Module2, runDependencies);
        if (runDependencies == 0) {
          if (dependenciesFulfilled) {
            var callback = dependenciesFulfilled;
            dependenciesFulfilled = null;
            callback();
          }
        }
      }
      function abort(what) {
        var _a2;
        (_a2 = Module2["onAbort"]) == null ? void 0 : _a2.call(Module2, what);
        what = "Aborted(" + what + ")";
        err(what);
        ABORT = true;
        what += ". Build with -sASSERTIONS for more info.";
        var e = new WebAssembly.RuntimeError(what);
        readyPromiseReject(e);
        throw e;
      }
      var dataURIPrefix = "data:application/octet-stream;base64,";
      var isDataURI = (filename) => filename.startsWith(dataURIPrefix);
      function findWasmBinary() {
        if (Module2["locateFile"]) {
          var f = "wa-sqlite.wasm";
          if (!isDataURI(f)) {
            return locateFile(f);
          }
          return f;
        }
        return new URL("data:application/wasm;base64,AGFzbQEAAAABgwRCYAJ/fwF/YAF/AX9gA39/fwBgA39/fwF/YAF/AGACf38AYAR/f39/AX9gBX9/f39/AX9gBH9/f38AYAR/f39+AX9gBn9/f39/fwF/YAAAYAV/f39/fwBgAn9+AX9gB39/f39/f38Bf2AAAX9gBn9/f39/fwBgCH9/f39/f39/AX9gAn9+AGABfAF8YAF/AX5gAn9/AX5gA39+fwF/YAd/f39/f39/AGABfgF/YAN/f34Bf2ACf3wAYAl/f39/f39/f38Bf2AJf39/f39/f39/AGAEf35/fwF/YAV/f39/fgBgBn9/f39/fgF/YAV/f35/fwF/YAp/f39/f39/f39/AX9gA39+fwBgAAF8YAF/AXxgCH9/f39/f39/AGAGf39/fn9/AX9gC39/f39/f39/f39/AX9gC39/f39/f39/f39/AGACfHwBfGADfHx/AXxgAXwBf2AHf39/f39+fgBgBH9/fn8AYAR/fn9/AGABfgF+YAN/fn4Bf2ADf3x8AGAFf39+f38AYAh/fn5/f39/fwF/YAJ+fAF/YAJ8fwF8YAJ/fwF8YAh/f39/f35/fwBgAnx/AX9gA39/fAF/YA1/f39/f39/f39/f39/AGADf39/AX5gBX9/f39+AX9gB39/f39/fHwAYAV/fn9/fwF/YAJ/fgF+YAR/f39+AGACfH4BfwKSA0EBYQFhAAgBYQFiAAMBYQFjAAYBYQFkAAYBYQFlAAYBYQFmAAYBYQFnAAcBYQFoAAcBYQFpAAMBYQFqAAMBYQFrAAIBYQFsAAIBYQFtACMBYQFuACMBYQFvAAEBYQFwAAoBYQFxAAoBYQFyABcBYQFzAAABYQF0AAABYQF1ABEBYQF2AA4BYQF3AAIBYQF4AAcBYQF5AAMBYQF6AAcBYQFBAAcBYQFCAA4BYQFDAA4BYQFEAAEBYQFFAAABYQFGAAYBYQFHAAMBYQFIAAYBYQFJAAEBYQFKAAYBYQFLAAYBYQFMAAYBYQFNAAgBYQFOAAMBYQFPAAABYQFQAAABYQFRAAABYQFSAAEBYQFTAAYBYQFUAAwBYQFVAAABYQFWAAABYQFXAAABYQFYAAMBYQFZAAABYQFaAAABYQFfAAwBYQEkAAYBYQJhYQAHAWECYmEABwFhAmNhAAoBYQJkYQAKAWECZWEADgFhAmZhAA4BYQJn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AgICAgICAgICAgICAgICAgICAgICAgICAgQEAgICAgICBAEFCAIDAQUDBAEPBw8BAA8DAQMDAAEABwYKCgcHCgEBAQYGBgYBAQEDAAEAAQEBAAABBwcAAAABAQAAAQEEAQUIBQgCBAEBAQEBAQEBJAEBAQYBAQQBAQoKCgMDAgAADwAAAAEAAAAFAAAAAAYEAgIAAAAEAgICAAMBBwEAAAoEBwFwAcUDxQMFBwEBigKAgAIGDQJ/AUGgkiQLfwFBAAsH9gyWAgJsYQIAAm1hAKIHAm5hAKQJAm9hAKsLAnBhAPgHAnFhAPcLAnJhAIoHAnNhAJIFAnRhAKoPAnVhAL4KAnZhAPYLAndhAPULAnhhAPQLAnlhAPILAnphANEBAkFhAPELAkJhAEUCQ2EA+AYCRGEA8AsCRWEAyAICRmEAZAJHYQDvAgJIYQDPAQJJYQBVAkphAJ0PAkthAJwPAkxhAJoPAk1hAJcPAk5hAJsCAk9hAI8PAlBhAOcGAlFhAHsCUmEAkgoCU2EAuwECVGEAjwECVWEA4AECVmEAdQJXYQBhAlhhAIgKAllhALYGAlphANMLAl9hANoBAiRhALoBAmFiAO8LAmJiANkBAmNiALMBAmRiALEDAmViAJcBAmZiAO4LAmdiAJkPAmhiAJgPAmliAKIKAmpiAKEKAmtiAJYPAmxiAJUPAm1iAJkKAm5iAKsBAm9iAEoCcGIAXgJxYgDpBgJyYgCUDwJzYgCTDwJ0YgDtCwJ1YgCSDwJ2YgCYCgJ3YgCiAwJ4YgCRDwJ5YgCiAwJ6YgCQDwJBYgCODwJCYgCNDwJDYgCMDwJEYgC5AwJFYgCLDwJGYgCxAgJHYgDsCwJIYgBtAkliAHECSmIAig8CS2IAigECTGIA6wsCTWIAbAJOYgCJDwJPYgCIDwJQYgBcAlFiAOoLAlJiAJUKAlNiAIcPAlRiAJUKAlViAP4BAlZiANgCAldiAIYPAlhiAOkLAlliALMCAlpiAG8CX2IAhQ8CJGIAgw8CYWMAgg8CYmMAgQ8CY2MAgA8CZGMAYgJlYwCMBQJmYwCTCgJnYwD/DgJoYwD+DgJpYwCLBQJqYwCLAgJrYwD9DgJsYwCKBQJtYwD1AgJuYwCDCwJvYwD8DgJwYwD0AgJxYwCYCQJyYwD7DgJzYwDlBgJ0YwDnCwJ1YwDkBgJ2YwDjBgJ3YwDmCwJ4YwCRCgJ5YwD6DgJ6YwCQCgJBYwDlCwJCYwD5DgJDYwCPCgJEYwDiBgJFYwDkCwJGYwD4DgJHYwD3DgJIYwD2DgJJYwD1DgJKYwD0DgJLYwDzDgJMYwDyDgJNYwDxDgJOYwDwDgJPYwDvDgJQYwDuDgJRYwDtDgJSYwD8AgJTYwDjCwJUYwDsDgJVYwDrDgJWYwDoDgJXYwDnDgJYYwDiCwJZYwCKCgJaYwCaBQJfYwD/CgIkYwDzAgJhZADmDgJiZADlDgJjZACJCgJkZAC9BwJlZADkDgJmZADjDgJnZADiDgJoZADhDgJpZADgDgJqZACJBQJrZACIBQJsZADeDgJtZADdDgJuZACmBQJvZADcDgJwZACHCgJxZADbDgJyZADaDgJzZADZDgJ0ZADYDgJ1ZADXDgJ2ZADWDgJ3ZADVDgJ4ZACFCgJ5ZADUDgJ6ZADTDgJBZADRDgJCZAC2BgJDZACECgJEZADMDQJFZADeBgJGZADLDQJHZADABwJIZADKDQJJZADJDQJKZADhCwJLZADgCwJMZADfCwJNZADIDQJOZADeCwJPZADGDQJQZADFDQJRZADbCQJSZADEDQJTZADDDQJUZADCDQJVZADBDQJWZADADQJXZAC+DQJYZADJBgJZZADHBgJaZAC9DQJfZAC8DQIkZADYCQJhZQC6DQJiZQC5DQJjZQC3DQJkZQC2DQJlZQC1DQJmZQC0DQJnZQCzDQJoZQDrCgJpZQDsCgJqZQCyDQJrZQCxDQJsZQD3BAJtZQCwDQJuZQCvDQJvZQCuDQJwZQDBBwJxZQCtDQJyZQCUDQJzZQCTDQJ0ZQCSDQJ1ZQDQCQJ2ZQCRDQJ3ZQCQDQJ4ZQCODQJ5ZQCNDQJ6ZQCMDQJBZQCLDQJCZQDPCQJDZQCKDQJEZQCJDQJFZQC1BgJGZQCIDQJHZQCHDQJIZQCcBQJJZQCGBQJKZQCGDQJLZQCRBAJMZQDcCwJNZQCFDQJOZQDNCQJPZQCEDQJQZQCDDQJRZQCCDQJSZQCBDQJTZQD7CQJUZQCADQJVZQD/DAJWZQDzDAJXZQDMCQJYZQDyDAJZZQDwDAJaZQDvDAJfZQDxBAIkZQDtDAJhZgDsDAJiZgDrDAJjZgD5AQJkZgD4AQJlZgDpDAJmZgCzDAJnZgD4CwJoZgCyDAJqZgCwDAJrZgCrDAJsZgCqDAJtZgCoDAJuZgCnDAJvZgEAAnBmAI4IAnFmAKYPAnJmAIQPAnNmAMcOAnRmAIUOCYsHAQBBAQvEA0XUBLALrwu9CNEL0gvNC8wLywvKC8kLyAvHC+sEmw+zD+ADog+hD6APnw+eD/IKtA+pCOsCrgutC6wLlgupC6gLqguZC5gLlwtamguzA6YLpQukC6MLogtIoQugC58LnguAAZ0LnAubC6cLuQ/5CpULswOUC5MLkguoD6cPtw/OCq8PpQ+TAbAHkQupD7IPsQ+wD0/yAZALjwuOC4wLjQu6D7gP8wOuD60Pqw+sD6QPow/qDukO3w7+DdwN2w3YDdcN0w27DawNqw3+DPwM+wz6DPkM+Az3DPYM9QzABsEJ5AzjDOEM3AyxDK8MrQysDLEJqQyxCaYMpQykDKMMogyhDKAMnwyeDJ0MnAybDJoMmQyYDJcMlgyVDJQMkwySDJAMjwyODI0M0g6EDv0N/A30DfAN5w3dDdoN0Q3HDdQL2wu/DdgLng2PDf0M9AzxDNcLownWC+AMyQy4DNULrgzrBJEMgQz5C/MLiwyMDIUM/AuHDIYMiAz/C/oLigz7C+gLgwz9C4kMtgaCDIAM3Qv+C4QM2guzA7MD2Qu4De4M1wnqDLsLugu5C7gLswO3C7YLtQu0C7MLsguxC4UJ0AvPC5oGswPOC8YLxQvEC8MLwgvBC8ALvwu+C70LvAvFD8QPhQvDD8IPwQ+EC8APvw++D7UPtg+7D7wPvQ/FDsQOww7CDsEOwA6/Dr4OvQ68DrsOug65DrgOtw62DrUOtA6zDrIOsQ6wDq8Org6tDqwOqw6qDqkOqA6nDqYOpQ6kDqMOog6hDqAOnw6eDp0OnA6bDpoOmQ6YDpcOlg6VDt4N2Q3WDdUN1A3zDfIN8Q3vDe4N7Q3hCewN4AnhCesN4AnqDekN6A3mDeUN5A3jDeIN4Q3rBOAN3w37DfoN6AnnCeUJ+Q34DfcN9g31DZQOkw6SDpEOkA6PDo4OjQ6MDosOig6JDogOhw6GDoMOgg6BDoAO/w3SDdANzw3ODc0NvgrrBNAOzw7ODs0OzA7LDsoOyQ7IDv8Jxg6qDakNqA2fDZ0NnA3UCZoNmQ2YDZcNlg2VDZsNpw2mDYULpQ2kDaMN1QmiDaENoA3bDNoM2QzYDNcM1gzVDNQM0wzSDNEM0AzPDM4MzQzM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CANAIAIEQCACKAIAIAAgByACKAIMEKEHIAZwQQN0aiACEIILIQIMAQsLIAUgARChByAAKAIAcDYCDAtBACEDIAAgACgCDCIAIAUoAgxBA3RqQQAgABsgBBCCCwsgBUEQaiQAIAMLOAEBfyMAQRBrIgIkACACIAE3AwggAEHIAEEBIAJBCGpBcxCWByAAQdQAQQFBARBBGiACQRBqJAALawEBfwJAAkBB2NIDKAIAIgNFDQBBrAIgAxEBAEUNACAAKAIAEGUMAQsgACgCAEIMELgBIgNFDQAgAyAAKAKIATYCACAAIAM2AogBIAMgATYCCCADIAI2AgQgAg8LIAAoAgAgAiABEQUAQQALoQMBA38CQCABRQ0AIAAoApAERQRAIAEgASgCGEEBayICNgIYIAINAQsgACECIAEiAygCCCEAA0AgAARAIAAoAhQCQCACKAKQBA0AIAMtACtBAUYNACAAKAIYQRhqIAAoAgBBABC+ARoLIAIgABCkBCEADAELCwJAAkACQAJAIAMtACsOAgABAgsgAygCMCEAA0AgAEUNAwJAIAIoApAEDQAgACgCDCEBAkAgACgCECIEBEAgBCABNgIMDAELIAMoAjxBOGogASAAIAEbKAIIIAEQvgEaIAAoAgwhAQsgAUUNACABIAAoAhA2AhALIAIgACgCHBDDAyACIAAoAiAQwwMgACgCBCACIAAQTSEADAALAAsgAigCkARFBEBBACADELgHGgsgAygCMEUNAUEAIQADQCADKAIsIABKBEAgAEEBRwRAIAIgAygCMCAAQQJ0aigCABBICyAAQQFqIQAMAQsLIAIgAygCMBBIDAELIAIgAygCLBCAAQsgAiADELAFIAIgAygCABBIIAIgAygCDBBIIAIgAygCEBBaIAIgAxBNCws0AQF/IAAoAnwiAyAAIAMbIgAgAhDFByAAIAAoAlxBASACdHI2AlwgACAALQAUIAFyOgAUCxUBAX8gACgCfCICIAAgAhsgARDFBwufAQIDfwF+IwBBEGsiAyQAIAAsAAEiBEH/AXEhAgJAIARBAE4EQCAALQAAQf8AcUEHdCACciEAQQIhAgwBCyAALAACIgRBAE4EQCACQQd0QYD/AHEgAC0AAEH/AHFBDnRyIARyIQBBAyECDAELIAAgA0EIahCmAyECQX8gAykDCCIFpyAFQoCAgIAQ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bCEAIARBAWohBAwBCwsgAEUEQCAFIANBEmxqLAAAQThrIQALIABBAEgNAQsgASALNwMAQQJBAyAGIAcbIAAbIQYLIAYLHwAgAUHkACACQQEgACACQQR0aigCDCgCAEEBahBCGguZAQEEfyAAKAIAIQIDQCAAKAKIASIBBEAgACABKAIANgKIASACIAEoAgQgASgCCBEFACACIAEQcgwBCwsgACgCRCIBBEAgAiABEHILIAAoAkgiAQRAIAIgARCyAgsgAiACKAKwAiIDIAAtABgiBGs2ArACQQAhASACIAMgBEYEfyACLwG2AgVBAAs7AbQCIAIgACgCwAE2AoACC/QCAQJ/AkACQAJAAkAgACwARCICQQBOBEAgACgCdCEBIAJFDQEgASgCSBCOASAAQfgAaiECA0AgACAALQBEQQFrIgE6AEQgAUH/AXFFDQMgAiABwEECdGooAgAoAkgQjgEMAAsACyAAKAJAIgFFDQMgAC0AACICQQNPBEAgAkEERgRAIAAoAgQPCyAAENYEIAAoAkAhAQsgACgCFCABIABB9ABqIAAtAAIQlQQiAQRAIABBAToAACABDwsgAEEAOgBEIAAgACgCdCIBLQABOgBFCyABLQAABEAgAS0AASAAKAJwRUYNAgtBqNMEEEdBCw8LIAAgACgCeCIBNgJ0CyAAQQA7ATIgAEEAOwFGIAAgAC0AAUHxAXE6AAEgAS8BGARAIABBADoAAEEADwsgAS0ACEUEQCABKAIEQQFHBEBBtNMEEEdBCw8LIAEoAjggAS0ACWpBCGoQUCEBIABBADoAACAAIAEQ4gIPCwsgAEEBOgAAQRALWwACQAJAAkAgAEHkAGsOAgABAgtBhZMBDwtBm5MBDwsCf0GjvgEgAEGEBEYNABpBh+kAIABB/wFxIgBBHEtBhICECiAAdkEBcXINABogAEECdEGArgNqKAIACwtgAQF/AkACQCAALQASIgJBBUcgASACTHENACAALQANBH8gAgUgACgCQCICIAEgAigCACgCHBEAACICDQIgAC0AEgtB/wFxQQVGIAFBBEdxDQAgACABOgASC0EAIQILIAILDAAgABDsAiAAKAIsC50DAQJ/An8gA0UEQEEADAELIAMoAgQhBSADKAIACyEDIAEgAmohBgJAIABFBEADQCADIAVqIAEoAgAiAEEYdCAAQYD+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IgNBoL4Cai8BAEHmAEcNACADQeDjAmoMAgsgBUGghgNqDAELIANB4OMCagsvAQAhBQsgBUH//wNxIgdB6QlPBEACQCAHQYeoAmotAAANACAOKAI0IA4oAjxJDQAgDkE0aiIDEK4IRQ0AIAMQrQgMAwsgDiAOKQP4CTcDGEEAIQVBACEDQQAhCEEAIRQjAEGgBmsiBiQAIA4oAjQhAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgB0HpCWsiHQ7YAgABAgMEBQUFBgYHCAkKCwwNDgwPEBESExQVkgKRApACjwKOAo0CjAKLAooCiQKIAocChgKFAoQCgwKCAoECgAL/Af4BDP0B/AH7AfoB+QH4AfcB9gH1AfQB8wHyAfEB8AEM7wHuAZIC7QGMAuwB6wHqAekBDOgB5wHoAfAB5gHlAeQB7wEM4wHiAeEB4AHfAd4B3QHcAdsB3AHaAdkB2AHXAdYB1gHVAdQBDNMB0gHR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EKYEC0EAIQYgBygCACgCQCIAKAIAIgFFDQIgAEEeIAdBBGogASgCKBEDABoMAgsgBygCACIARQ0AIABBABCTCQsgBxBFIAwQRSADQQA2AgALIApB8ABqJAAgBgunAQMBfwF+AXxBASECAkAgAUQAAAAAAADgw2MNACABvSIDQoCAgICAgID4/wCDQoCAgICAgID4/wBRIANC/////////weDQgBScQ0AQX8hAiABRAAAAAAAAOBDZg0AAn4gAZlEAAAAAAAA4ENjBEAgAbAMAQtCgICAgICAgICAfwsiAyAAVQ0AQQEhAiAAIANVDQBBfyAAuSIEIAFkIAEgBGQbIQILIAILDQAgACABIAJBABCaAws9AQF/IAAoAgwgADMBBkIofkLIAHwQuAEiAQRAIAEgADYCACABIAFBIGo2AgQgASAALwEGQQFqOwEUCyABC1oBAn8gACgCDCIDKAI4IQQCQCADKAJIEG4iAw0AIAQgAUECdGogAkEYdCACQYD+A3FBCHRyIAJBCHZBgP4DcSACQRh2cnI2ACQgAUEHRw0AIAAgAjoAEgsgAwuBAgMBfAV/AX4jAEEQayIEJAAgACgCCCIDIARBCGogACgCDCIFIAAtABIiBhDJASIHQQBKBEAgBCsDCCECAkACQCAHQQFHDQACQCACAn4CQCACRP///////9/DYw0AQv///////////wAgAkT////////fQ2QNARogAplEAAAAAAAA4ENjRQ0AIAKwDAELQoCAgICAgICAgH8LIggQhwsEQCAAIAg3AwAMAQsgAyAAIAUgBhC/Ag0BCyAALwEQQQRyIQMMAQsgACACOQMAIAAgAC8BEEEIciIDOwEQIAFFDQAgABCICyAALwEQIQMLIAAgA0H9/wNxOwEQCyAEQRBqJAALggEBAn8jAEEgayIEJAACQCADKAIADQAgACACIARBCGogACgCUBECACAELwEYIgUgBCgCFE8NACABKAI8IgEgAk0gAiAFaiABTXJFBEBBprQEEEcgA0ELNgIADAELIAAoAjQgAiAELwEaakEEaxBQQQMgACgCBCADEM4BCyAEQSBqJAALUAAgACABIAIgAxDFASIARQRAIAIoAgAiACgCSCIBKAIgQQJOBEAgARCOASACQQA2AgBBirsEEEdBCw8LIABBADoAAEEADwsgAkEANgIAIAAL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EEQaIAcgDDsBECAJQX5xIAkgE0EBSxsiAiABKAIIakEAOgAAIAEoAgggAmpBADoAASABIBM6ABIgASACNgIMIAEgAS8BEEGABHI7ARAMowELIAogAygCDEEobGohAiAKIAMoAgRBKGxqIgUvARAiCSAKIAMoAghBKGxqIgcvARAiDXFBBHENmQEgCSANckEBcQ2bASAFENIIIAcQ0ghxQQRxRQ2aASADLQAAIQEMmQELIAMoAgQiAUUNoQEgCiABQShsakIAEIcBDKEBCyAKIAMoAgxBKGxqIQEgCiADKAIIQShsaiICLwEQIAogAygCBEEobGoiBS8BEHJBAXEEQCABEHMMoQELIAIQWSEmIAUQWSEnAkACQAJAAkAgAy0AACICQecAaw4CAAECCyAmICeDISYMAgsgJiAnhCEmDAELICdQDQBBUyACayACICdCAFMiBRshAkLAAEIAICd9ICdCQFcbICcgBRsiKELAAFkEQEIAIAJB/wFxQekARyAmQgBTca19ISYMAQsgAkH/AXFB6QBGBEAgJiAohiEmDAELICYgKIghJyAmQgBZBEAgJyEmDAELQn9CwAAgKH2GICeEISYLIAEgJjcDACABIAEvARBBwOQDcUEEcjsBEAygAQsgCiADKAIEQShsaiIBEKEDIAEgASkDACADNAIIfDcDAAyfAQsCQCAKIAMoAgRBKGxqIgEvARAiAkEEcQ0AIAFBwwAgExDpASABLwEQIgJBBHENACADKAIIDZwBQRQhBAykAQsgASACQcDkA3FBBHI7ARAMngELIAogAygCBEEobGoiAS0AEEEkcUUNnQEgARCCBgydAQsgCiADKAIEQShsaiIBLQARQQRxBEAgARDfASIEDaIBCyABIAMtAAggExDRCCEEDHkLIAogAygCDCIOQShsaiIFLwEQIgIgCiADKAIEIg9BKGxqIgcvARAiDHEiEUEEcQRAIAUpAwAiJiAHKQMAIidVBEAgAUGn/wFqLQAADZoBDJMBCyAmICdTBEAgAUGb/wFqLQAADZoBQX8hFQydAQsgAUGh/wFqLQAADZkBDJEBCyADLwECIQkCfwJAAkACQCACIAxyIg1BAXEEQCAJQYABcQRAQQEhFSARQQFxRSACQYACcXJFBEBBACEVQaH/AQwGCyACQQFxRQ0EQX8hFQwCCyAJQRBxDZ0BDJYB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QQEQZAsgAEHlwQFBARBkIARBAWohBAwBCwsgAkECTgRAIABB2eUBQQEQZAsLegIBfgJ/Qv///////////wAhASAAQeEETAR+IABBCm0iAsEhAyACQXZsIABqIgKtwyIBQgJ9IAFCAX1CACACQf//A3EiAhsgAkEESxtCCHwhASAAQR5OBEAgASADQQNrrYYPCyABQQMgA2utiAVC////////////AAsL4wIBBH8jAEGwAWsiAyQAIAAoAgghBiACLQA0IQQgACgCACEFIANBgAI7AawBIANBADYCqAEgA0LkgICAgMCyzTs3AqABIAMgBTYCmAEgAyABIARBMGxqIgRBCGo2AiAgAyADQTBqNgKcASADQZgBaiIFQdvlASADQSBqEFUCQAJAIAIoAkgiAS0AKUEBcQRAIAQoAhAiAS4BICICQQBIDQEgAyABKAIEIAJBDGxqKAIANgIQIAVBuMEBIANBEGoQVQwCCyABLwEuIQIDQCACIAEvARhPDQIgASgCICACEIMHIQQgAS8BLiACSQRAIANBmAFqQdX6AUEFEGQLIAMgBDYCACADQZgBakG4wQEgAxBVIAJBAWohAgwACwALIANBmAFqQb3BAUEAEFULIANBmAFqIgFB2eUBQQEQZCABENgBIQEgBkG8ASAGKAJsIAAoAuQBQQAgAUF6EE4aIANBsAFqJAALHAAgAiAEIAEgAyABIANIGxB6IgAgASADayAAGwvwAQIFfwF+IAAvAQAiBiEFIABBCGoiCCEEAkACQANAIAVB//8DcQRAIAIgBC4BCCIHTARAIAQpAwAgAYMgAVENAwsgAiAHTgRAIAQpAwAiCSABgyAJUQ0ECyAEQRBqIQQgBUEBayEFDAELCyAGQQJLBEBBASEFIAghBANAIAQuAQghByAFIAZGRQRAIAggBUEEdGoiACAEIAcgAC4BCEobIQQgBUEBaiEFDAELCyACIAdODQIMAQsgACAGQQFqOwEAIAggBkEEdGoiBCADOwEKCyAEIAI7AQggBCABNwMAIAQuAQogA0wNACAEIAM7AQoLC8sBAQV/AkAgAUHAAHENACACKAIAKAIAIQQDQCADLQAAQSxGBEAgACABIAIgAygCDBDQCkUNAiADKAIQIQMMAQsLQQAgBCAEKAIALQAiQYABcRshByABQSBxIQggAigCGCEBQQAhBANA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ASECA0AgAiAFRgRAIABB+AVqIQdBACECA0AgAiAIRkUEQCAHIAJB2ABsaiIFIAMoAhggAkECdGooAgAiBDYCSCAFIAQtABAiBDoANCAFIAAoAgQgBEEwbGooAhg2AgQgAkEBaiECDAELCwJAIAFFIAAvAShBgANxQYACR3INACAALQAvDQAgACAAKAIMIANBgAEgCEEBayIBQf//A3EgAygCGCABQQJ0aigCACAJQQhqEJMFIAAoAgwoAgBHDQAgAEECOgAvCyAAIAAtADAiBUH7AXE6ADACQCAAKAIIIgJFDQAgACADLAAWIgE6AC0CQCAALwEoIgRBgAFxBEAgAigCACABRw0BIABBAjoALwwBCyAAIAMpAwg3A0ggAUEATARAIABBADoALSAIRQ0BIAMoAhggCEEBayIBQQJ0aigCACIFKAIoIgdBgCBxIAdBhAJxQYQCRnINASAJQgA3AwggACACIANBgBAgAUH//wNxIAUgCUEIahCTBSAAKAIIIgIoAgBGBEAgACAALQAwQQRyOgAwIAAgCSkDCDcDSAsgAC8BKCEEDAELIARBA3FFIAhFIAFBAUdycg0AIAAgBUEEcjoAMAsgBEGABHFFIAhFcg0AIAIoAgAgACwALUcNACAJQgA3AwggACACIANBACAIQQFrIgFB//8DcSADKAIYIAFBAnRqKAIAIAlBCGoQkwUgACgCCCgCAEcNACAAIAAtADBBCHI6ADAgACAJKQMINwNICyAAIAAvATIgAy8BEGo7ATQMAwUgByACQQV0aiIEIAMgAy4BEiAELgESShshAyACQQFqIQIMAQsACwALIBdBm/IAQQAQQwsgCUEQaiQACz8BAn8gASgCNCICIAFBPGoiA0cEQCAAIAIQTSABQQM7ATAgASADNgI0CyAAIAEQ0wogAUEANgIoIAFBADsBLAusBgETfyMAQeAEayIDJAAgACgCACEEIAAoAgghBiAAKAIEIgsoAhghCSALKAIMIQcgA0HwAGpBAEE4EEYaAkAgBCgCBCAGLQAQQTBsaiIOLQAUQRBxDQAgCSAHQTBsaiEQIA4oAhghESADQQhqIRIgA0FAayEPIANB+ABqIQwDQCAFIAkgEE9yDQFBACEFAkAgCS0ADUECcUUNACAGKQMIIAkoAhgiBCkDoAODUA0AIAQoAhghByAEKAIMIQQgAyAA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mwULIAIoAkgiAwRAIAAgAxCTBwsDQCACKAJEIgMEQCADEJcHDAELCyAEQQAhBA0BIAAgAhByDAELCwsVACAAEF0iAARAIABBlgEgARBJGgsLiwEBAn8CfwJAIAFFDQAgASgCACIEBH8gASgCBAVBAAshAyABIAI2AgQgASAEQQFqNgIAIANFDQAgAiADNgIAIAIgAygCBCIBNgIEIAEgAEEIaiABGyACNgIAIANBBGoMAQsgAiAAKAIIIgE2AgAgAQRAIAEgAjYCBAsgAkEANgIEIABBCGoLIAI2AgALMgEBfyAAIAEQhQIiAS8BECICQYDAAHEEQCABIAJB/78CcUGAgAFyOwEQCyAAEIQCIAELOAEBfyAAIAApAwhCAXw3AwggACgCBBC6AUHkAEcEQCAAKAIEEJcBIQEgAEEANgIEIAAQoAcLIAELCAAgABBFQQALmQEBAn8CQCACRQRADAELIAEQTCIGQRlqrRBWIgVFBEAgABBlQQAPCyAFQRhqIAEgBkEBahBEIQEgBUEANgIUIAUgBDYCECAFIAM2AgwgBSACNgIAIAUgATYCBCAFQQE2AggLIABBhANqIAEgBRC+ASIBBEAgASAFRgRAIAAQZSAAIAEQTUEADwsgACABEK4GIAAgARC/BQsgBQs8AAJ/QQEgAEQAAAAAAAAAAGENABpBACAAvSABub1SIAFCgICAgICAgHxTcg0AGiABQoCAgICAgIAEUwsLnAEDAXwBfgF/AkAgAC8BECIDQSBxRQRAAn4CQCAAKwMAIgFE////////38NjDQBC////////////ACABRP///////99DZA0BGiABmUQAAAAAAADgQ2NFDQAgAbAMAQtCgICAgICAgICAfwsiAkL///////////8AfEJ9ViABIAK5YnINASAAIAI3AwALIAAgA0HA5ANxQQRyOwEQCwuiAQECfwJAIAAvARAiAUGCxAFxQQJHDQAgAC0AEkEBRw0AIAAoAggiAkUNAAJAAn8gAUGAIHEEQCAAKAIkIgFBAUYEfyACQYTRAygCABEBACAAKAIMIgFBAWpPBEAgACgCCCABagwDCyAAKAIkBSABC0EbRg0CDAMLIAAoAgwiASAAKAIYTg0CIAEgAmoLQQA6AAALIAAgAC8BEEGABHI7ARALC4QBAQN/IAAgAkECbUEBaq0QZiIABEAg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IAAoAgQtAAANASABKAIMEIkBQcIARg0AIAAgASgCEEEAEIAHGgsgACABIAAoAhAQgAchAgsgAgstAQF/AkAgAS0AAEGpAUcNACABLQACIgIgACgCEEgNACABIAJBAWo6AAILQQALDwAgACAAKAIQQQFrNgIQCxEAIAAgACgCEEEBajYCEEEAC0IBAX8jAEEQayICJAACQCABLQAAQakBRw0AIAEoAiQNACAAKAIAIAIgASgCCDYCAEG03wEgAhBDCyACQRBqJABBAAvFAQEDfwJAIAEvAAVBwAJxDQAgASgCJCICRQ0AIAEuAR4hAyAAKAIAIgAoAgAhBCABLQAAQakBRwRAIAIoAhggA0wNASACKAIUIANBBHRqKAIEIAFHDQEgBCABQQAQVCIBRQ0BIAAgARCDAw0BIAIoAhQgA0EEdGogATYCBAwBCyACKAIkIANMDQAgAigCICADQRhsaigCACABRw0AIAQgAUEAEFQiAUUNACAAIAEQgwMNACACKAIgIANBGGxqIAE2AgALQQALKgAgACgCACIAQQAgARC2ASABLQAHQQNxRQRAIABBACABQShqELYBC0EACyoAAkAgAS0AAEGsAUcNACABLQAHQQFxRQ0AIAAoAhggASgCKBCuBwtBAAsKACAAKAIYIAFHCzIAAkAgACgCACIAKAKQAkUNACABKAI0DQAgARDOBSgCQCIBRQ0AIAAgASgCCDYCkAILC0wBAX8jAEEQayIEJAAgBEIANwMIIARCADcDACAAIARBCGogBCADEKQJIgBFBEAgASAEKQMIPgIAIAIgBCkDAD4CAAsgBEEQaiQAIAALAgAL/QICDH8BfiMAQRBrIgYkACAAKAIYIgUoAgAoAgAiByAFKAIoEOwBIQsCQCABKAIgIghFBEAMAQsgBUEEaiEMIAhBCGoiDSECAkADQCAIKAIAIANKBEACQCAFLQAkDQAgAi8ADSIJQQRxDQACQCACLQAPIgpBAXENACACKAIsIgRFDQAgByAEEOwBIAtHBEAgBSgCACAFKQIsIQ4gBiAENgIIIAYgDjcDAEHa2QAgBhBDDAULIAcgBBBNIAIgAi8ADUGACHIiCTsADSACIAItAA9BAnIiCjoADwsgBSgCICEEIAIgCkEBcjoADyACIAlBgAJyOwANIAIgBDYCLAsgDSADQTBsaiIELQAOQQhxRQRAIAwgBCgCKBBnDQMLIAJBMGohAiADQQFqIQMMAQsLQQAhAiABKAJARQ0BQQAhAwNAIAMgASgCQCIFKAIATg0CIANBGGwhBCADQQFqIQMgACAEIAVqKAIUEIMBRQ0ACwtBAiECCyAGQRBqJAAgAgt6AQN/IwBBEGsiAiQAIAAoAhgiAy0AJEUEQCABIAEoAgRBgICAgARyNgIEC0EAIQACQCABLQAAQZ0BRw0AIAMoAgAiBCgCAC0AsQEEQCABQfoAOgAADAELIAIgAygCLDYCACAEQa/RACACEENBAiEACyACQRBqJAAgAAscAQF/IAAgACgCACIBKALUATYCBCABIAA2AtQBCwYAIAAQRQsWACAAKAIEIgAgACgCIEEBazYCIEEAC0UAIAMCf0EAIAAoAgQiACkDACACrCABfFMNABpBACAALQAkQQJxDQAaIAAgACgCIEEBajYCICAAKAIYIAGnags2AgBBAAsFAEGBLAuVAQIBfwJ+IwBBEGsiAyQAIAAoAgQhAAJ/AkAgAUEkRwRAQQwgAUEMRw0CGiAAKAIYIQEgAyAAKQMANwMIIAMgATYCACACQYXZASADEHs2AgAMAQsCQCACKQMAIgUgACkDACIEWQRAIAUhBAwBCyAFQgBZDQAgACkDECEECyAAIAQ3AxAgAiAENwMAC0EACyADQRBqJAALZAECfyABIAAoAggiA0gEQCAAKAIEIQICQCABQQFGBEAgA0ECSA0BIAIgAigCLEEBazYCLAwBCyADQQJOBEAgAiACKAIsQQFrNgIsCyACIAIoAihBAWs2AigLIAAgATYCCAtBAAuhAQECfwJAIAEgACgCCCIDSgRAIAAoAgQhAgJAIAFBAkgNACACLQAkQQRxRQ0AQQgPCwJAAkACQAJAIAFBAWsOAwABAQILIAIoAixBAEoNBCACIAIoAihBAWo2AigMAgsgA0EBRw0BIAIoAixBAEoNAyACQQE2AiwMAQsgAigCKEEBSg0CIANBAUcNACACQQE2AiwLIAAgATYCCAtBAA8LQQULEQAgASAAKAIEKQMANwMAQQALJAEBf0ELIQIgASAAKAIEIgApAwBXBH8gACABNwMAQQAFQQsLC9ABAgN+An8gACgCBCIAKAIkIghBBHEEQEGKBg8LAkAgAqwgA3wiBSAAKQMAIgRVBEAgACkDCCAFUwRAQQ0hByAIQQJxRQ0CIAAoAiBBAEoNAiAAKQMQIgQgBVMNAiAAKAIYIAVCAYYiBiAEIAQgBlUbIgQQpwEiB0UEQEGKGA8LIAAgBDcDCCAAIAc2AhggACkDACEECyADIARVBEAgACgCGCAEp2pBACADIAR9pxBGGgsgACAFNwMACyAAKAIYIAOnaiABIAIQRBpBACEHCyAHC1sBAX4CfyAAKAIEIgApAwAgAqwgA3xTBEAgAUEAIAIQRkGKBCAAKQMAIgQgA1cNARogACgCGCADp2ogBCADfacQRBpBigQPCyABIAAoAhggA6dqIAIQRBpBAAsLwwEBBX8CQCAAKAIEIgEoAjRFDQBBACEAQfSOBCgCACIEQQAgBEEAShshBUH4jgQoAgAhAgNAIAAgBUYNASAAQQJ0IQMgAEEBaiEAIAIgA2oiAygCACABRw0ACyABKAIwQQFHDQBB9I4EIARBAWsiADYCACADIAIgAEECdGooAgA2AgAgAA0AIAIQRUH4jgRBADYCAAsgASABKAIwIgBBAWs2AjAgAEEBTARAIAEtACRBAXEEQCABKAIYEEULIAEQRQtBAAsTACAAKAIUIgAgASAAKAJIEQAACxUAIAAoAhQiACABIAIgACgCRBEDAAsTACAAKAIUIgAgASAAKAI8EQAACxUAIAAoAhQiACABIAIgACgCOBEDAAsTACAAKAIUIgAgASAAKAI0EQUACxUAIAAoAhQiACABIAIgACgCMBEDAAsVACAAKAIUIgAgASACIAAoAiwRAgALEwAgACgCFCIAIAEgACgCKBEAAAspACMAQRBrIgAkACAAIAE2AgAgAiADQYvoACAAELsBGiAAQRBqJABBAAsLACADQQA2AgBBAAuAAwIEfwF+IAJCADcCACACQQA2AggCfwJAAkAgARBMIgdBAkkNACABLQAAIgBB3ABHIABBL0dxDQBB9I4EKAIAIgBBACAAQQBKGyEGQfiOBCgCACEIAkADQCAFIAZGDQEgBUECdCAFQQFqIQUgCGooAgAiACgCNCABELABDQALIAAgACgCMEEBajYCMAwCC0EHIAdBO2qtEFYiAEUNAhpB+I4EKAIAQfSOBCgCAEECdEEEaq0QpwEiBUUEQCAAEEVBBw8LQfSOBEH0jgQoAgAiBkEBajYCACAFIAZBAnRqIAA2AgBB+I4EIAU2AgAgAEEAQTgQRiIFQQM2AiRB0NIDKQMAIQkgBSAFQThqIgY2AjQgBSAJNwMQIAYgASAHQQFqEEQaIAVBATYCMCAFQQg2AhwMAQtCOBBWIgBFBEBBBw8LIABBAEE4EEYiAUEDNgIkIAFB0NIDKQMANwMQCyACIAA2AgQgBARAIAQgA0GAAXI2AgALIAJBqJACNgIAQQALCzQBAn9BBCEAA0ACQCAAQQFqIQIgAEELSw0AIAAgAWogAiEALAAAQQBIDQELCyACQf//A3ELKgAgAUEEaiACEKYDIQAgAkEAOwEQIAJCADcDCCACIABBBGpB/wFxOwESC6wBAQR/IAEsAAQiAkH/AXEhA0EEIQQCQCACQQBODQAgA0H/AHEhA0EEIQIDQCABIAJBAWoiBGosAAAiBUH/AHEgA0EHdHIhAyACQQpLDQEgBCECIAVBAEgNAAsLIAEgBGpBAWohAiAALwEOIgQgA08EfyADIAFrIAJqBSACIAFrIAAvARAiASABIAMgAWsgACgCNCgCKEEEa3BqIgAgACAESxtqQQRqC0H//wNxC7wBAQV/IAEsAAAiAkH/AXEhAwJAIAJBAE4EQCABIQQMAQsgA0H/AHEhA0EAIQIDQCABIAJBAWoiBWoiBCwAACIGQf8AcSADQQd0ciEDIAJBBksNASAFIQIgBkEASA0ACwsgBEEBaiECAn8gAC8BDiIEIANPBEBBBCADIAFrIAJqIgAgAEEETRsMAQsgAiABayAALwEQIgEgASADIAFrIAAoAjQoAihBBGtwaiIAIAAgBEsbakEEagtB//8DcQu4AQEGfyABIAAtAApqIgUsAAAiBEH/AXEhAwJAIARBAE4EQCAFIQYMAQsgA0H/AHEhA0EAIQQDQCAFIARBAWoiB2oiBiwAACIIQf8AcSADQQd0ciEDIARBBksNASAHIQQgCEEASA0ACwsgAiADNgIMIAIgA603AwAgAiAGQQFqIgQ2AgggAC8BDiADTwRAIAIgAzsBECACIAQgAWsgA2oiAEEEIABB/P8DcRs7ARIPCyAAIAEgAhDhCAu2AgEFfyABLAAAIgJB/wFxIQMCQCACQQBOBEAgASECDAELIANB/wBxIQMDQCABIARBAWoiBWoiAiwAACIGQf8AcSADQQd0ciEDIARBBksNASAFIQQgBkEASA0ACwsCfyACQQJqIAIsAAFBAE4NABogAkEDaiACLAACQQBODQAaIAJBBGogAiwAA0EATg0AGiACQQVqIAIsAARBAE4NABogAkEGaiACLAAFQQBODQAaIAJBB2ogAiwABkEATg0AGiACQQhqIAIsAAdBAE4NABogAkEKQQkgAiwACEEASBtqCyEEAn8gAC8BDiICIANPBEBBBCADIAFrIARqIgAgAEEETRsMAQsgBCABayAALwEQIgEgASADIAFrIAAoAjQoAihBBGtwaiIAIAAgAksbakEEagtB//8DcQv9AwIFfwF+IAEsAAAiA0H/AXEhBQJAIANBAE4EQCABIQMMAQsgBUH/AHEhBQNAIAEgBEEBaiIGaiIDLAAAIgdB/wBxIAVBB3RyIQUgBEEGSw0BIAYhBCAHQQBIDQALCyADLAABIgStQv8BgyEIAn8gA0EBaiAEQQBODQAaIAMsAAIiBK1C/wGDIAhCB4aFIQggBEEASARAIAMsAAMiBK1C/wGDIAhCB4aFIQggBEEASARAIAMsAAQiBK1C/wGDIAhCB4aFQoCAgYEBhSEIIANBBGogBEEATg0CGiADLAAFIgStQv8BgyAIQgeGhUKAgAGFIQggA0EFaiAEQQBODQIaIAMsAAYiBK1C/wGDIAhCB4aFQoCAAYUhCCADQQZqIARBAE4NAhogAywAByIErUL/AYMgCEIHhoVCgIABhSEIIANBB2ogBEEATg0CGiADLAAIIgStQv8BgyAIQgeGhUKAgAGFIQggA0EIaiAEQQBODQIaIAMxAAkgCEIIhoRCgIAChSEIIANBCWoMAgsgCEKAgIEBhSEIIANBA2oMAQsgCEL//wCDIQggA0ECagshBCACIAU2AgwgAiAINwMAIAIgBEEBaiIDNgIIIAAvAQ4gBU8EQCACIAU7ARAgAiADIAFrIAVqIgBBBCAAQfz/A3EbOwESDwsgACABIAIQ4QgLDgAgASAAKQMQNwMAQQALnwIBBX8CQCAAKAIIIgRBAEwgBK0gAqwgA3xZckUEQCAAEPgIIgYNASAAIAEgAiADIAAoAgAoAgwRCQAPCwJAIANCAFUEQCAAKQMQIANRDQEgACADEJoGGgwBCyADQgBSDQAgACgCDCIERQ0AIARBBGogASACEEQaDAELIABBDGohCANAIAJBAEwNASAAKAIYIQQCQCAAKQMQIAAoAgQiB6yBIgNQRQRAIAQhBQwBCyAHQQRqENEBIgVFBEBBihgPCyAFQQA2AgAgBCAIIAQbIAU2AgAgACAFNgIYCyAFIAOnIgRqQQRqIAEgAiAHIARrIgQgAiAESBsiBBBEGiAAIAApAxAgBKx8NwMQIAIgBGshAiABIARqIQEMAAsACyAGC9kBAgN/An5BigQhBCACrCADfCIIIAApAxBXBH8CQAJAIANQRQRAIAApAyAgA1ENAQsgAEEMaiEEA0AgBCgCACIERQRAQQAhBAwDCyAHIAA0AgR8IgcgA1cNAAsMAQsgACgCKCEECyADIAA0AgSBpyEFA0ACQCABIAQgBWpBBGogAiAAKAIEIAVrIgEgASACShsiBRBEIQYgAiABayICQQBIDQAgBCgCACEEIAJFDQAgBSAGaiEBQQAhBSAEDQELCyAAIAQ2AiggACAIQgAgBBs3AyBBAAVBigQLCw4AIAJBADYCACAAKAIsC68EAQN/IAFFBEBB/ukDEEdBCw8LAkAgACgC5AEiBCgCNCABIAQtAClBA3FB2NEDKAIAEQMAIgRFBEBBByEGIAAoAuQBIgUtAClBAkYNAQJAIAUoAjRB1NEDKAIAEQEAIAUoAhxMDQAgBUEIaiEEAkACQANAIAQoAgAiBARAIAQpAyBQBEAgBC0AHEEIcUUNAwsgBEEsaiEEDAELCyAFQQA2AgggBUEEaiEEA0AgBCgCACIERQ0DIAQpAyBQDQIgBEEsaiEEDAALAAsgBSAENgIICyAFKAIwIAQgBSgCLBEAACIGQQVGDQAgBg0CC0EHIQYgBSgCNCABQQJB2NEDKAIAEQMAIgRFDQELIAIgACgC5AEgASAEEJ0GIgQ2AgACQAJAAkAgA0EBcSIDDQAgBCgCFEUNACAAIAAoAsgBQQFqNgLIAQwBCyABIAAoAqQBRgRAQZ7qAxBHQQshBgwCCyAEIAA2AhQCQCAAKAJAKAIARSADckUEQCAAKAIcIAFPDQELIAEgACgCoAFLBEBBDSEGIAAoAhwgAUkNAyAEEN8EDAQLAkAgA0UNAEHgjwQoAgAiAgRAIAIRCwALIAEgACgCIE0EQCAAKAI8IAEQnwIaCyAAIAEQnAYaQeSPBCgCACIBRQ0AIAERCwALIAQoAgRBACAAKAKoARBGGkEADwsgACAAKALMAUEBajYCzAEgBBD2CCIGDQELQQAPCyAEENsECyAAEPUIIAJBADYCACAGC/gDAgZ/An4jAEEQayIFJAAgBUEANgIMIAFFBEAgACgCECgCACEBCyAAIAEQnwkhBCAAIAEQ7AEhByACBEAgAkJ/NwMACwJAIAdBAEgNACAEBEAgBCgCBCEAIAIEQCACIAApAwA3AwALIANBAXEEQCAAKAIYIQYMAgsgACkDABBWIgFFDQEgASAAKAIYIAAoAgAQRCEGDAELIAAoAhAgB0EEdGooAgQiCEUNACAIKAIEKAIkIQcgBSABNgIAQf03IAUQeyIBRQ0AIAAgAUF/IAVBDGpBABDaASABEEUNAAJAIAUoAgwiBBC6AUHkAEcNAAJAIARBABCyAyAHrCILfiIKQgBSDQAgBBDZARogAEH3wQFBAEEAQQAQswEaQgAhCiAEELoBQeQARw0AIARBABCyAyALfiEKCyACBEAgAiAKNwMACyADQQFxDQAgChBWIgBFDQAgBEEAELEDIgFBACABQQBKG0EBaiEJIAgoAgQoAgAhAkEBIQEDfyABIAlGBH8gAAUgBUEANgIIIAAgAUEBayAHbGohAwJAIAIgASAFQQhqQQAgAigC3AERBgBFBEAgAyAFKAIIIgYoAgQgBxBEGgwBCyADQQAgBxBGGiAFKAIIIQYLIAYQ0AEgAUEBaiEBDAELCyEGCyAEEJcBGgsgBUEQaiQAIAYLBgBBxI4CC9UIAgp/An4jAEHwAGsiCiQAQbDYAygCABEPACELAkACQCAAKAIkIgUEQCAFKAIAIQUMAQtCEBBWIghFBEBBByEHDAILIAhCADcCACAIQgA3AggCQCAAKAIIIgwoAigiBQ0AIAAoAiAhCQJAIAAoAgwgCkEQakHA1gMoAgARAAAEQEGKDiEHDAELIAkQdiINQcoAaiIGrRBWIgVFBEBBByEHDAELIAVBACAGEEYiBiAGQcQAaiIONgIIIAogCTYCACANQQZqIA5BvvwAIAoQuwEhCSAGQX82AgwgACgCCCINIAY2AiggBiANNgIAQdzQAy0AAARAIAZBCDYCBAsgDC0AHQ0BAkAgACgCIEGx/ABBABCRBEUEQCAGIAlBwoAIIAooAhRB/wNxELYDIgc2AgwMAQsgBigCDCEHCyAHQQBIBEAgBiAJQYCACCAKKAIUQf8DcRC2AyIHNgIMIAdBAEgEQEHG0QIQ7gFBDiEHQQ5B7/oAIAlBxtECENwBDAILIAZBAToAFgsgCigCICEJIAooAhwhDEGA2AMoAgARDwBFBEAgByAMIAlB9NcDKAIAEQMAGgsgACAGEKEJIgdBiApGIAdFcg0BCyAAEK8JIAgQRQwCCyAIIAU2AgAgBSAFKAIcQQFqNgIcIAAgCDYCJCAIIAUoAiA2AgQgBSAINgIgIAcNAQsCQCAFLQAXBEAgACAFEKEJIgYNASAFQQA6ABcLQQAhBkEBIAtBD3YgC0GAgAJIGyIIIAFqIgAgACAIb2siCSAFLwEUTA0AIAUgAjYCEAJAAkAgBSgCDCIAQQBIDQAgACAKQRBqQcDWAygCABEAAARAQYomIQYMAwsgCikDKCIPIAIgCWwiAKxZDQAgA0UEQAwDCyAAQYAgbSIAIA9CgCB/Ig+nIgMgACADShusIRAgD8QhDwNAIA8gEFENASAFKAIMIA9CDIZC/x+EQfz7AUEBIApBDGoQqQlBAUcNAiAPQgF8IQ8MAAsACyAFKAIYIAlBAnQQ+AYiAEUEQEGKGCEGDAILIAUgADYCGCAIQQAgCEEAShshCyACIAhsIgOsIQ8gBS8BFCEAIAKsIRADQCAJIABB//8DcUwNAgJAIAUoAgwiB0EATgRAQQAgA0EBQQMgBS0AFhtBASAHIACtQv//A4MgEH5BjNgDKAIAER8AIgdBf0cNAUGKKiEGQYoqQafwACAFKAIIQfHSAhDcAQwECyAPEFYiB0UEQEEHIQYMBAsgB0EAIAMQRhoLQQAhAANAIAAgC0ZFBEAgBSgCGCAAQQJ0aiAFLwEUQQJ0aiAHIAAgAmxqNgIAIABBAWohAAwBCwsgBSAFLwEUIAhqIgA7ARQMAAsAC0GKJiEGQYomQYiIASAFKAIIQdbSAhDcAQtBACEAIAQgASAFLwEUSAR/IAUoAhggAUECdGooAgAFQQALNgIAIAZBCCAGIAUtABYbIAYbIQcLIApB8ABqJAAgBwuYAQEDfyMAQTBrIgIkAAJ/An9BASAAKAIIIgMtABxBAUsNABpBACADLQAdDQAaIAJCATcDICACQQE2AhAgAkHw1QMoAgBBAWqsNwMYIAAoAgwgAiACQRBqNgIAQQwgAkHY1gMoAgARAwAEQCAAQZCIBCgCADYCFEGKHAwCCyACLwEQQQJHCyEEQQALIAEgBDYCACACQTBqJAAL6wQCBX8BfiMAQSBrIgMkAAJAIAAtABAiBSABTg0AAkACQAJAAn8CQAJAAkACQAJAAkACQCAAKAIIIgQtABwiBiAFRwRAQQUhAiABQQFLDQwgBkECTQ0BDAwLIAFBAUcNAQsgBkEBa0H/AXFBAU0EQCAAQQE6ABAgBCAEKAIUQQFqNgIUIAQgBCgCGEEBajYCGAwKC0EAIQIgA0EAOwECIANCATcDEAwBCyADQQA7AQIgA0IBNwMQIAFBBEcNBEEBIQIgBUECRw0BCyADIAI7AQAgA0Hw1QM0AgA3AwggACADEPYCBEBBBSECQZCIBCgCACIEEPAEIgFBBUYNCSAAIAQ2AhQgASECDAkLIAFBBEcNASAAQQM6ABAgBEEDOgAcIAJFDQILQQUhAiAEKAIUQQFKDQcgA0EBOwEAQv4DIQdBAgwDCyACDQELIANC/gM3AxAgA0Hw1QMoAgBBAmqsNwMIQQAhAkEAIQUgACADEPYCBEBBkIgEKAIAIgUQ8AQhAgsgA0IBNwMQIANBAjsBACADQfDVAzQCADcDCAJAIAAgAxD2AkUgAnJFBEBBkIgEKAIAIQVBihAhAgwBCyACRQ0DIAJBBUYNBgsgACAFNgIUDAULQgFC/gMgAUECRiICGyEHIANBATsBAEEBQQIgAhsLIQIgAyAHNwMQIANB8NUDKAIAIAJqrDcDCCAAIAMQ9gJFDQFBBSECQZCIBCgCACIEEPAEIgFBBUYNAyAAIAQ2AhQgASECDAMLIARBATYCFCAEIAQoAhhBAWo2AhgLIAAgAToAECAEIAE6ABwLQQAhAgsgA0EgaiQAIAILogEBA38gACgCCCEBIAAQ9gkgAEEAEKMJGiAAKAIIIQICQAJAIAEoAhgEQCAAKAIcIgEgAigCIDYCCCACIAE2AiAgAEEANgIcIABBfzYCDAwBCyACRQ0BCyACIAIoAiRBAWsiATYCJCABDQAgABCiCSACKAIwIgFBLGpB7I4EIAEbIAIoAiwiAzYCACADBEAgAyABNgIwCyACEEULIAAQxQZBAAsLACABQQA2AgBBAAsJACAAEMUGQQALBgBBkI8CC08BAX4gAq0gA61CIIaEIQQjAEEQayICJAAgACABEIYFIgAEQCAAIAJBCGoQ/wEhACAEIAIpAwggABshBAsgAkEQaiQAIARCIIinJAEgBKcLBgBBgIAECxQBAX4gACkDcCIBQiCIpyQBIAGnCxQBAX4gACkDaCIBQiCIpyQBIAGnCxEAIAAgAa0gAq1CIIaENwMoCxQBAX4gACkDKCIBQiCIpyQBIAGnC5QBAgF/AX4gAa0gAq1CIIaEIQQjAEEQayIBJAACfyAARQRAQbelBhCIAUEVDAELIAAoAhQhAgJAIAAoAhAiA0UEQEEEIQAMAQsgA0EANgIkIAAgBCABQQxqEIwKIgBFDQAgASABKAIMIgM2AgAgAiAAQYvoAEEAIAMbIAEQsgEgAiADEEgLIAIgABCWAQsgAUEQaiQAC7EIAgp/AX4gBK0gBa1CIIaEIRIjAEHQAmsiCCQAIAhBADYCzAIgB0EANgIAIAZBAEchESAAIgRCIBBXIQoCQAJAAkACQAJAA0AgCEE0aiIAIAQQnQQgCkUNASAEIAgoAswCEEggCEEANgLMAgJAIABBACACIAEQjgIiCwRAAn9BzOQAIAstACsiBUEBRg0AGkGa5gAgCygCHCIAQYABcQ0AGkHm3wAgAEHgAHENABogBUECRw0CQbvfAAshACAIIAI2AhAgCEE0aiAAIAhBEGoQQwtBASEOIAgoAjgiAEUNBCAIQQA2AjggCCAANgLMAgwECyAKIAs2AhwgCiAEKAIQIAQgCygCPBBjQQR0aigCADYCGEEAIQUgCy4BIiIMQQAgDEEAShshAANAAkACQCAAIAVHBEAgCygCBCAFQQxsaigCACADEEsNASAFIQALAkACQCAAIAxGBEAgCCADNgIgIAggBEGx9AEgCEEgahBYNgLMAgwBCyAGRQ0BQQAhDwJAIAQtACFBwABxRQ0AIAtBMGohBQNAIAUoAgAiCUUNAUEAIQUgCSgCFCIMQQAgDEEAShshDSAJQSRqIQwDQCAFIA1HBEBB+i0gDyAMIAVBA3RqKAIAIABGGyEPIAVBAWohBQwBCwsgCUEEaiEFDAALAAsgC0EIaiEFA0AgBSgCACIJBEAgCS8BMiENQQAhBQNAIAUgDUcEQEHSmgFB0poBIA8gACAJKAIEIAVBAXRqLgEAIgxGGyAMQX5GGyEPIAVBAWohBQwBCwsgCUEUaiEFDAELCyAPRQ0BIAggDzYCMCAIIARBtoMBIAhBMGoQWDYCzAILQQEhDgwGCyAKIAhBNGoQ9wciCTYCECAJBEAgCUECIAQgCygCPCIFEGMiDCARIAUoAgAgBSgCBBBRGiAJKAJsIgVBAEoEQCAJKAJoIAVBFGxqQRJrQQE7AQALIAlBBkGwgAIQ4QIhDSAJIAkoApwBQQEgDHRyNgKcASAELQBXBEAgCiAENgIUIAogADsBCAwDCyANQbsBOgAAIAYEQCANQfEAOgAUCyALKAIUIQUgDSAMNgIgIA0gBTYCHCANQf0BOgAVIA0gCy4BIkEBajYCJCANIAsuASI2AkQgCEEAOwGIAiAIQoGAgIAQNwJgIAkgCEE0ahCmCAsgBC0AVyAKIAQ2AhQgCiAAOwEIDQEgCiASIAhBzAJqEIwKIg5BEUcgEEEwS3INASAQQQFqIRAgCEE0ahDBAkERIQ4MAwsgBUEBaiEFDAELCwsgDg0CC0EAIQ4gBC0AVw0AIAcgCjYCAAwDCyAKRQ0BCyAKKAIQIgBFDQAgABCmAhoLIAQgChBICyAIIAgoAswCIgA2AgAgBCAOQYvoAEEAIAAbIAgQsgEgBCAAEEggCEE0ahDBAiAEIA4QlgEgCEHQAmokAAs9AgJ/AX5BEiEEIAKtIAOtQiCGhCIGIAAoAgAiBTQCeFgEfyAAIAEgBqcQ4gYhBCAAKAIABSAFCyAEEJYBCzABAX4gACABIAIgA60gBK1CIIaEIgcgB0J+gyAGQQFGGyAFQQIgBiAGQQRGGxC4AwsTACAAIAEgAq0gA61CIIaEEJMECxkAIAAgASACIAOtIAStQiCGhCAFQQAQuAMLswEBA38jAEGgBGsiAyQAIAMgADYCAEGABCADQRBqQYvoACADELsBIgIQdiEAAkADQCAAQQBKBEAgACACaiEEIABBAWshACAELQAAQS9HDQEMAgsLIAItAABBL0cEQCACQS46AAALIAJBAWohBAtBACEAIARBADoAACABIAJBAEEAELYDIgE2AgAgAUEASARAQdLJAhDuAUEOQc4rIAJB0skCENwBQQ4hAAsgA0GgBGokACAACxEAIAAgAa0gAq1CIIaEEOYGCxcAIAAgASACrSADrUIghoQgBCAFEK8CCxEAIAAgAa0gAq1CIIaEEIUBCxUAIAAgASACrSADrUIghoQgBBCXCgsTAQF+IAAQWSIBQiCIpyQBIAGnC78CAgJ+An8gA60gBK1CIIaEIQggBa0gBq1CIIaEIQlBACEGIwBBEGsiBSQAIAVBADYCDEEBIQMgAUUEQCAAKAIQKAIAIQELAkAgACABEOwBIgpBAUxBACAKGw0AIAUgATYCAEGHugEgBRB7IgtFBEBBByEDDAELIAAgC0F/IAVBDGpBABDaASEEIAsQRSAFKAIMIQYgBARAIAQhAwwBCyAAIAo6ALABIAAgAC0AsgFBBHI6ALIBIAYQugEgACAALQCyAUH7AXE6ALIBQeUARw0AIAAgARCfCSIARQ0AIAAoAgQiACAJNwMIIAAgCDcDACAAIAI2AhhBACEDQdDSAykDACEIIAAgBzYCJCAAIAggCSAIIAlVGzcDEEEAIQILIAYQlwEaIAdBAXFFIAJFckUEQCACEEULIAVBEGokACADCxYBAX4gACABELIDIgJCIIinJAEgAqcLEQAgACABrSACrUIghoQQpwELDgAgAK0gAa1CIIaEEFYLKwEBfkGsjAQ1AgAhASAABEBBrIwEQYSMBCgCADYCAAsgAUIgiKckASABpwtyAQF/IwBBEGsiAyQAIAMgAjYCACMAQRBrIgIkACACAn4gAUHAAHFFBEBCACABQYCAhAJxQYCAhAJHDQEaCyACIANBBGo2AgwgAzUCAAs3AwBBnH8gACABQYCAAnIgAhAlEJEBIAJBEGokACADQRBqJAALHAEBfiAArSABrUIghoQQswoiAkIgiKckASACpwsWAQF+QYSMBDUCACIAQiCIpyQBIACnCxwBAX4gAK0gAa1CIIaEELgKIgJCIIinJAEgAqcLJAEBfiAABH4gAEGE0QMoAgARAQCsBUIACyIBQiCIpyQBIAGnCwgAEIQKGkEACwQAQQALRQEBfyMAQRBrIgMkACADIAI2AgwgAyABNgIIIAAgA0EIakEBIANBBGoQIRD9AyEAIAMoAgQhASADQRBqJABBfyABIAAbCw4AQZx/IABBABAgEJEBCw4AQZx/IAAgAUEAELgGCwkAIAAQIhCRAQtGAQJ/IwBBEGsiAyQAQZx/IAAgASADQQ9qIgQgAhsiAUEBIAIgAkEBTRsQIyIAQR91IABxIAAgASAERhsQkQEgA0EQaiQAC0UBAX8jAEEQayIDJAAgAyACNgIMIAMgATYCCCAAIANBCGpBASADQQRqECQQ/QMhACADKAIEIQEgA0EQaiQAQX8gASAAGwvkAQIEfwF+IwBBEGsiBCQAIARBADYCDEFkIQMCQCABRQJ/QZSSBCgCACICBEAgBEEMaiEFA0AgAiAAIAIoAgBGDQIaIAUEQCAFIAI2AgALIAIoAiQiAg0ACwtBAAsiAkVyDQAgAigCBCABRw0AIAQoAgwiA0EkakGUkgQgAxsgAigCJDYCACACKAIQIgNBIHFFBEAgACABIAIoAiAgAyACKAIMIAIpAxgiBqcgBkIgiKcQFRoLIAIoAggEQCACKAIAEPgBC0EAIQMgAi0AEEEgcQ0AIAIQ+AELIARBEGokACADEJEBCwsAIANBADYCAEEAC6UCAQJ/IAVC/5+AgICAfINQRQRAQZCIBEEcNgIAQX8PCyABQf////8HTwRAQZCIBEEwNgIAQX8PCwJ/QWQgAA0AGiAFQoBggyEFAkACQCADQSBxBEBBgIAEIAFBD2pBcHEiBkEoahCOCCIEDQFBUAwDCyABIAIgAyAEIAWnIAVCIIinQSgQ+QEiBkEIaiAGEBQiB0EATgRAIAYgBDYCDAwCCyAGEPgBIAcMAgsgBEEAIAYQRhogBCAGaiIGIAQ2AgAgBkKBgICAcDcDCAsgBiACNgIgIAYgBTcDGCAGIAM2AhAgBiABNgIEIAZBlJIEKAIANgIkQZSSBCAGNgIAIAYoAgALIgEgAUFBQVAgA0EQcRtBQSADQSBxGyABQUFHGyAAGxCRAQsOAEGcfyAAIAEQJxCRAQsPAEGcfyAAIAFBgAIQuAYLjgEBBH8jACICQYAgIQMgAkEQQYAgIAAbayIEJAAgBCECAkACQCAARQ0AIAAhAiABIgMNAEGQiARBHDYCAEEAIQAMAQtBACEAIAIgAxAqEJEBIgFBAEgNAAJAIAEEQCACLQAAQS9GDQELQZCIBEEsNgIADAELIAIgBEcEQCACIQAMAQsgAhCwCSEACyQAIAALEgAgACABpyABQiCIpxAYEJEBCx4AIABBAEgEQEF4EJEBDwsgAEH8+wEgAUGAIBC4BguMAwICfwF+IwBBgAFrIgMkAAJAAkACQCABQQFrDgMCAQIACyABQQlGDQELIAMgAkEEajYCeCACKAIAIQQLAn8CQCABQRBLDQBBASABdEGA4AZxRQRAIAFBCUcEQCABQQ5HDQIgAyAErTcDECAAQQ4gA0EQahABEJEBDAMLIAMgA0H4AGqtNwMwIABBECADQTBqEAEiAUFkRgRAIAMgBK03AyAgAEEJIANBIGoQASEBCyABBEAgARCRAQwDC0EAIAMoAnwiAGsgACADKAJ4QQJGGwwCCyADIAStNwNwIAAgASADQfAAahABEJEBDAELIAFBhghHBEAgAyAEQYCAAnIgBCABQQRGG603AwAgACABIAMQARCRAQwBCyADIAStIgU3A2AgAEGGCCADQeAAahABIgFBZEcEQCABEJEBDAELIANCADcDUCAAQYYIIANB0ABqEAEiAUFkRwRAIAFBAE4EQCABEA4aC0FkEJEBDAELIAMgBTcDQCAAQQAgA0FAaxABEJEBCyADQYABaiQACw0AIAAgASACEDEQkQELgwIBBH8jAEEgayIEJAACfyAAIAEQMyIDQXhHBEAgAxCRAQwBCyMAQSBrIgMkACAAIANBCGoQHiICBH9BkIgEIAI2AgBBAAVBAQsgA0EgaiQARQRAQXgQkQEMAQtBACECA0AgAiAEaiIDIAJB6NMBai0AADoAACACQQ5HIAJBAWohAg0ACwJAIAAEQEEOIQIgACEDA0AgAkEBaiECIANBCUsgA0EKbiEDDQALIAIgBGpBADoAAANAIAQgAkEBayICaiAAQQpuIgNB9gFsIABqQTByOgAAIABBCUsgAyEADQALDAELIANBMDoAACAEQQA6AA8LIAQgARAyEJEBCyAEQSBqJAALEwAgABAOIgBBACAAQRtHGxD9AwsQAEGcfyAAIAFBABA1EJEBCykBAX8gACgCBCIBLQBdQQJxBEAgAUHgiwEgABAJDwsgAUHgiwEgABAICzcBAX8gACgCBCIELQBdQQRxBEAgBEHzogEgACABIAIgAxCqCQ8LIARB86IBIAAgASACIAMQqAkLNwEBfyAAKAIEIgQtAF1BCHEEQCAEQY6IASAAIAEgAiADEKoJDwsgBEGOiAEgACABIAIgAxCoCQs7AQF/IAAoAgQiAi0AXUEQcQRAIAJBlYkBIAAgAacgAUIgiKcQGg8LIAJBlYkBIAAgAacgAUIgiKcQGQuGAQEFfwJAIAAoAiQiAkUNACACKAIAIgNBIGohBANAIAQiBSgCACIGQQRqIQQgAiAGRw0ACyAFIAIoAgQ2AgAgAhBFIABBADYCJCADIAMoAhxBAWsiBDYCHCAEDQACQCABRQ0AIAMoAgxBAEgNACADKAIIQcTXAygCABEBABoLIAAQrwkLQQALLQEBfyAAKAIEIgItAF1BIHEEQCACQeaqASAAIAEQAw8LIAJB5qoBIAAgARACCy4BAX8gACgCBCICLQBdQcAAcQRAIAJBlIYBIAAgARAFDwsgAkGUhgEgACABEAQLLgEBfyAAKAIEIgItAF1BgAFxBEAgAkHz/wAgACABEAMPCyACQfP/ACAAIAEQAgstAQF/IAAoAgQiAi0AXkEBcQRAIAJB1v8AIAAgARADDwsgAkHW/wAgACABEAILLQEBfyAAKAIEIgItAF5BAnEEQCACQZeAASAAIAEQBQ8LIAJBl4ABIAAgARAECzEBAX8gACgCBCIDLQBeQQRxBEAgA0GR/QAgACABIAIQBw8LIANBkf0AIAAgASACEAYLKQEBfyAAKAIEIgEtAF5BCHEEQCABQYiGASAAEAkPCyABQYiGASAAEAgLKQEBfyAAKAIEIgEtAF5BEHEEQCABQbHTACAAEAkPCyABQbHTACAAEAgLOQEBfyAAKAIEIgUtAF5BIHEEQCAFQbPwACAAIAEgAiADIAQQOw8LIAVBs/AAIAAgASACIAMgBBA6CzYBAX8gACgCBCIELQBeQcAAcQRAIARBhIABIAAgASACIAMQOQ8LIARBhIABIAAgASACIAMQOAsqAQF/IAAoAgQiAS0AXkGAAXEEQCABQbfrACAAEAsPCyABQbfrACAAEAoLLQEBfyAAKAIEIgItAF9BAXEEQCACQZ3wACAAIAEQAw8LIAJBnfAAIAAgARACCyYAIAAtAF1BAXEEQCAAQb7JASAAIAEQBQ8LIABBvskBIAAgARAECysAIAAtAFxBgAFxBEAgAEHO6QAgACABIAIQBw8LIABBzukAIAAgASACEAYLJwAgAC0AXEHAAHEEQCAAQbSPASAAIAEQBQ8LIABBtI8BIAAgARAECyYAIAAtAFxBIHEEQCAAQY/wACAAIAEQAw8LIABBj/AAIAAgARACCyoAIAAtAFxBEHEEQCAAQePGACAAIAEgAhAHDwsgAEHjxgAgACABIAIQBgsuACAALQBcQQhxBEAgAEHBjwEgACABIAIgAxAQDwsgAEHBjwEgACABIAIgAxAPCy4AIAAtAFxBBHEEQCAAQfbGACAAIAEgAiADEBAPCyAAQfbGACAAIAEgAiADEA8LKgAgAC0AXEECcQRAIABBuYgBIAAgASACEDcPCyAAQbmIASAAIAEgAhA2C+UCAAJ/IAAtAFxBAXEEQCAAQfT6ACAAIAEgAiADIAQQPgwBCyAAQfT6ACAAIAEgAiADIAQQPQtCzAAQViIDQQI2AgAgAyAAKAJYIgRBB3RBH3VBhwFxNgJAIAMgBEEIdEEfdUGIAXE2AjwgAyAEQQl0QR91QYkBcTYCOCADIARBCnRBH3VBigFxNgI0IAMgBEELdEEfdUGLAXE2AjAgAyAEQQx0QR91QYwBcTYCLCADIARBDXRBH3VBjQFxNgIoIAMgBEEOdEEfdUGOAXE2AiQgAyAEQQ90QR91QY8BcTYCICADIARBEHRBH3VBkAFxNgIcIAMgBEERdEEfdUGRAXE2AhggAyAEQRJ0QR91QZIBcTYCFCADIARBE3RBH3VBkwFxNgIQIAMgBEEUdEEfdUGUAXE2AgwgAyAEQRV0QR91QZUBcTYCCCADIARBFnRBH3VBlgFxNgIEIAIgADYCBCACIAM2AgAL2wIBAn9B1IwEKAIAIQdC4AAQViIGRQRAQQcPCyAGQQxqQQBB1AAQRhogBiABNgIIIAZCgoCAgIABNwIAIAYgABCwCTYCEEH+ACEBIAYgAkEBcQR/Qf4ABSAHKAIYCzYCGEH/ACEBIAYgAkECcQR/Qf8ABSAHKAIcCzYCHEGAASEBIAYgAkEEcQR/QYABBSAHKAIgCzYCIEGBASEBIAYgAkEIcQR/QYEBBSAHKAIkCzYCJEGCASEBIAYgAkEQcQR/QYIBBSAHKAI4CzYCOEGDASEBIAYgAkEgcQR/QYMBBSAHKAI8CzYCPEGEASEBIAYgAkHAAHEEf0GEAQUgBygCQAs2AkBBhQEhASAGIAJBgAFxBH9BhQEFIAcoAkQLNgJEQYYBIQEgAkGAAnFFBEAgBygCSCEBCyAGIAM2AlwgBiACNgJYIAYgATYCSCAFIAY2AgAgBiAEEJIFGkEACzQAIAAgAUEAIAFBAEoiARs2AvwCIABB/QBBACACG0EAIAEbNgL0AiAAIANBACABGzYC+AILQgECfyAEQiCIpyEFIASnIQYCQCAARQ0AIAAoAgBFDQAgACAAIAEgAiADIAYgBRARDwsgACAAIAEgAiADIAYgBRA/CxgAIAAgAjYC7AEgAEH8AEEAIAEbNgLwAQsYACAAIAI2AtwBIABB+wBBACABGzYC4AELNAEBfwJAIAAoAgQoAggiAUUNACABLQAAQQRxRQ0AIAFB+P4AIAAQCw8LIAFB+P4AIAAQCgsRACAAIAEgAkHr7wBBAhClCQvoAwEFf0GKKCEEAkAgACgCJCIFRQ0AIAUoAgAiBkUNAEEBIAEgAmoiB3RBfyABdGohCCAGQSRqIQYCQAJAAkACQAJAAkAgA0EBcQRAIAggBS8BCiIEIAUvAQxycQ0BC0EAIQQgA0EGaw4FAgYGBgEGCwJAIANBBHFFDQAgBiABQQJ0aiIDKAIAIgdBAkgNACADIAdBAWs2AgAgBSAEIAhBf3NxOwEKDAULIAAoAggoAigoAgxBAiABQfgAaiACEP4DIgQNBSAGIAFBAnRqQQAgAkECdBBGGiAFIAhBf3MiACAFLwEKcTsBCiAFIAUvAQwgAHE7AQxBAA8LIAEgByABIAdKGyEDIAEhBANAIAMgBEcEQCAEQQJ0IQcgBEEBaiEEIAYgB2ooAgBFDQEMAwsLIAAoAggoAigoAgxBASABQfgAaiACEP4DIgQNBCAFIAUvAQwgCHI7AQwDQCABIANGDQQgBiABQQJ0akF/NgIAIAFBAWohAQwACwALIAggBS8BCiIDcQ0DIAYgAUECdGoiBigCACIEQQBODQELQQUPCyAFIAQEfyADBSAAKAIIKAIoKAIMQQAgAUH4AGogAhD+AyIEDQIgBigCACEEIAUvAQoLIAhyOwEKIAYgBEEBajYCAAtBAA8LIAQLEQAgACABIAJB9KoBQQEQpQkLKQAgACABIAIgAyAEQfgAQQAgBRtB+QBBACAGG0H6AEEAIAcbQQEQxwYLMwACQCAARQ0AIAAoAgBFDQAgACAAIAEgAiADIAQgBRBADwsgACAAIAEgAiADIAQgBRA8CxQAIABB9wBBACABGyACEIoKGkEACwQAQQELsAIBBn8CQCABQQJGBEACQEKq1arVqtWq1ap/IAIoAgAiATMBEIinQQFxRQRAQqrVqtWq1arVqn8gAigCBDMBEIhCAYNQDQELIAAQbA8LIAEQSiEDIAIoAgQQSiEIIAMQdkEBahDRASIFRQ0BIAUhBANAIAghAiADEPsBIgYEQANAIAIQ+wEiB0UgBiAHRnJFBEADQCACLQABIAJBAWohAkHAAXFBgAFGDQALDAELCyACIQEgBwRAA0AgAS0AASABQQFqIQFBwAFxQYABRg0ACyAEIAIgASACayIBELMJIAFqIQQLA0AgAy0AASADQQFqIgEhA0HAAXFBgAFGDQALDAELCyAEQQA6AAAgACAFQX9BfxBcIAUQRQ8LQbbKAUHYrQFBqwdBu6sBEAAACyAAEG8LtgICBH4CfwJAIAFBAkYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQSiEHIAIoAgQQWSIEQgBTBEAgAEGV6QBBfxBxDwsCQCAHELoGIgGsIgUgBFkEQCAHEOwEIgFFDQMgACABQX9BfxBcDAELIAcQdiIIIASnIAFrakEBahDRASIBRQ0CIAQgBX1CAYhCAXwhBkIBIQMgASECA0AgAyAGUUUEQCACQSA6AAAgA0IBfCEDIAJBAWohAgwBCwsgBkL/////D4MhAyACIAcQ9wIgCGohAgNAIAMgBXwgBFVFBEAgAkEgOgAAIANCAXwhAyACQQFqIQIMAQsLIAJBADoAAAsgACABQX9BfxBcIAEQRQ8LQbbKAUHYrQFB8AZBiK0BEAAACyAAEG8LgAICAn4BfwJAIAFBAkYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQSiEBIAIoAgQQWSIDQgBTBEAgAEGV6QBBfxBxDwsCQCABELoGIgKsIgQgA1kEQCABEOwEIgFFDQMgACABQX9BfxBcDAELIAEQdiIFIAOnIAJrakEBahDRASICRQ0CIAMgBH1CAXwhBCACIAEQ9wIiASAFaiECQgEhAwNAIAMgBFFFBEAgAkEgOgAAIANCAXwhAyACQQFqIQIMAQsLIAJBADoAAAsgACABQX9BfxBcIAEQRQ8LQbbKAUHYrQFBuQZB1KsBEAAACyAAEG8L9QECAn4BfwJAIAFBAkYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQSiEFIAIoAgQQWSIDQgBTBEAgAEGV6QBBfxBxDwsCQCAFELoGIgGsIgQgA1kEQCAFEOwEIgFFDQMgACABQX9BfxBcDAELIAUQdiADpyABa2pBAWoQ0QEiAUUNAiADIAR9QgF8IQRCASEDIAEhAgNAIAMgBFFFBEAgAkEgOgAAIANCAXwhAyACQQFqIQIMAQsLIAIgBRD3AhoLIAAgAUF/QX8QXCABEEUPC0G2ygFB2K0BQYMGQYmsARAAAAsgABBvCwwAIAAQtAkgACgCMAvZAQEFfwJAIAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQSiICEOwEIgVFDQFBASEGIAUhBANAIAItAAAiAQRAQQEhByACQQFqIQIgBCABwCIDQSBGIANBCUZyBH8gAQVBACEHAn8gBkEBRgRAIAMQsgkMAQsgA0EgciADIANBwQBrQRpJGwsLOgAAIARBAWohBCAHIQYMAQsLIARBADoAACAAIAVBf0F/EFwgBRBFDwtBm8wBQditAUHUBUHJqwEQAAALIAAQbwvdAQEEfyABQQFGBEBCqtWq1arVqtWqfyACKAIAIgEzARCIQgGDUEUEQCAAEGwPCyABEEoiAxB2IgFBAWoQ0QEiBEUEQCAAEG8PCyABIARqIgFBADoAACABQQFrIQIDQCADIgEQ+wEEQANAIAEtAAEgAUEBaiIGIQFBwAFxQYABRg0AC0EBIQEDQCADIAYgAWsiBUsEQCAGIQMMAwUgAiAFLQAAOgAAIAFBAWohASACQQFrIQIMAQsACwALCyAAIARBf0F/EFwgBBBFDwtBsK0BQditAUGrCkHNrAEQAAALjAICAn8BfiABQQJGBEACQEKq1arVqtWq1ap/IAIoAgAiATMBEIinQQFxRQRAQqrVqtWq1arVqn8gAigCBDMBEIhCAYNQDQELIAAQbA8LIAEQSiEBIAIoAgQQWSEFIAEhAgNAIAIQ+wEEQANAIAItAAEgAkEBaiECQcABcUGAAUYNAAsgA0EBaiEDDAELCyADIAWnayIDQQAgA0EAShshAwNAIANBAExFBEAgA0EBayEDA0AgAS0AASABQQFqIQFBwAFxQYABRg0ACwwBCwsgAiABa0EBahDRASICRQRAIAAQbw8LIAAgAiABEPcCIgBBf0F/EFwgABBFDwtBtsoBQditAUHZCEGLqwEQAAAL6wEBA38gAUECRgRAAkBCqtWq1arVqtWqfyACKAIAIgEzARCIp0EBcUUEQEKq1arVqtWq1ap/IAIoAgQzARCIQgGDUA0BCyAAEGwPCyABEEohASACKAIEEFmnIgJBACACQQBKGyEEIAEhAgNAIAIQ+wFFIAMgBEZyRQRAIANBAWohAwNAIAItAAEgAkEBaiECQcABcUGAAUYNAAsMAQsLIAIgAWsiAkEBahDRASIDRQRAIAAQbw8LIAMgASACELMJIgEgAmpBADoAACAAIAFBf0F/EFwgARBFDwtBtsoBQditAUGxCEGVqwEQAAALhwMBCX8CQAJAAkAgAUF+cUECRgRAAkBCqtWq1arVqtWqfyACKAIAIgMzARCIp0EBcUUEQEKq1arVqtWq1ap/IAIoAgQzARCIQgGDUA0BCyAAEGwPCyADEEoiCUUNAyACKAIEEEohAyABQQNGBEBBASACKAIIEFmnIgEgAUEBTBtBAWshBQsgCS0AAEUNAgNAIAMQ+wFFIAQgBUZyDQIgBEEBaiEEA0AgAy0AASADQQFqIQNBwAFxQYABRg0ACwwACwALQazKAUHYrQFBjghB7KoBEAAAC0EAIQQDQCAJIQIgAyEBIAMQ+wFFDQEDQCACEPsBIQcgARD7ASEKA0AgAi0AASACQQFqIgshAkHAAXFBgAFGDQALIAEhAgNAIAItAAEgAkEBaiIBIQJBwAFxQYABRg0ACyAKRSAHRXJFBEAgCyECIAcgCkYNAQsLIAcEQANAIAMtAAEgA0EBaiEDQcABcUGAAUYNAAsgBkEBaiEGDAELCyAFIAZqQQFqIQQLIAAgBBCKAQsLxQECAn4CfwJAIAFBAkcNAEKq1arVqtWq1ap/IAIoAgAzARCIp0EBcQ0AIAIoAgQQWSIEQgBTBEAgAEGV6QBBfxBxDwsgAigCABBeIgYgBKdsQQFqENEBIgFBACAGQQFqENEBIgUbRQRAIAAQbyABBEAgARBFCyAFRQ0BIAUQRQ8LIAUgAigCABBKEPcCIQIDQCADIARRRQRAIAEgBiADp2xqIAIQ9wIaIANCAXwhAwwBCwsgACABQX9BfxBcIAEQRSACEEULCw8AIABEGC1EVPshCUAQbQuEAQEBfCABQQFGBEACQAJAAkAgAigCACIBLwEQQT9xQfD/AWotAABBAWsOBQACAgIBAgsgACABEFkQhQEPCyAAEGwPCyAAAn4gARBgnCIDmUQAAAAAAADgQ2MEQCADsAwBC0KAgICAgICAgIB/CxCFAQ8LQZvMAUHYrQFBhQVBp6sBEAAAC4QBAQF8IAFBAUYEQAJAAkACQCACKAIAIgEvARBBP3FB8P8Bai0AAEEBaw4FAAICAgECCyAAIAEQWRCFAQ8LIAAQbA8LIAACfiABEGCbIgOZRAAAAAAAAOBDYwRAIAOwDAELQoCAgICAgICAgH8LEIUBDwtBm8wBQditAUHsBEGArAEQAAALawIBfgF8IAFBAUYEQAJAAkACQCACKAIAIgEvARBBP3FB8P8Bai0AAEEBaw4FAAICAgECCyAAIAEQWSIDIAN+EIUBDwsgABBsDwsgACABEGAiBCAEohBtDwtBm8wBQditAUGCBEHirAEQAAALWAEBfCABQQFGBEBCqtWq1arVqtWqfyACKAIAIgEzARCIQgGDUEUEQCAAEGwPCyABEGAhA0GQiARBADYCACAAIAOfEG0PC0GbzAFB2K0BQfcCQfqqARAAAAuoAQIBfgF8IAFBAUYEQAJAAkACQCACKAIAIgEvARBBP3FB8P8Bai0AAEEBaw4FAAICAgECCyAAQgFCf0IAIAEQWSIDQgBSGyADQgBVGxCFAQ8LIAAQbA8LIABEAAAAAAAA8D9EAAAAAAAA8L9EAAAAAAAAAAAgARBgIgREAAAAAAAAAABjGyAERAAAAAAAAAAAZBsQbQ8LQZvMAUHYrQFBzgRB7qsBEAAAC8QQAwl8BH4FfyABQQJGBEACQEKq1arVqtWq1ap/IAIoAgAiATMBEIinQQFxRQRAQqrVqtWq1arVqn8gAigCBDMBEIhCAYNQDQELIAAQbA8LIAEQYCEDIAIoAgQQYCEFQZCIBEEANgIAIAACfEQAAAAAAADwPyEGAkACQAJAIAW9IgxCIIgiDqciFEH/////B3EiACAMpyIRckUNACADvSINpyITRSANQiCIIg9CgIDA/wNRcQ0AIAMgBaAgD6ciAkH/////B3EiAUGAgMD/B0sgAUGAgMD/B0YgE0EAR3FyIABBgIDA/wdLckUgEUUgAEGAgMD/B0dycUUNAxoCQAJAAkACQAJAAn9BACANQgBZDQAaQQIgAEH///+ZBEsNABpBACAAQYCAwP8DSQ0AGiAAQRR2IRIgAEGAgICKBEkNAUEAIBFBswggEmsiEHYiEiAQdCARRw0AGkECIBJBAXFrCyEQIBENAiAAQYCAwP8HRw0BIAFBgIDA/wNrIBNyRQ0FIAFBgIDA/wNJDQMgBUQAAAAAAAAAACAMQgBZGwwICyARDQEgAEGTCCASayIRdiISIBF0IABHDQBBAiASQQFxayEQCyAAQYCAwP8DRgRAIAMgDEIAWQ0HGkQAAAAAAADwPyADowwHCyADIAOiIA5CgICAgARRDQYaIA5CgICA/wNSIA1CAFNyDQAgA58MBgsgA5khBCATDQECQCACQQBIBEAgAkGAgICAeEYgAkGAgMD/e0ZyIAJBgIBARnINAQwDCyACRSACQYCAwP8HRnINACACQYCAwP8DRw0CC0QAAAAAAADwPyAEoyAEIAxCAFMbIQYgDUIAWQ0CIBAgAUGAgMD/A2tyRQRAIAYgBqEiAyADowwGCyAGmiAGIBBBAUYbDAULRAAAAAAAAAAAIAWaIAxCAFkbDAQLAkAgDUIAWQ0AAkACQCAQDgIAAQILIAMgA6EiAyADowwFC0QAAAAAAADwvyEGCwJ8IABBgYCAjwRPBEAgAEGBgMCfBE8EQEQAAAAAAADwf0QAAAAAAAAAACAMQgBTGyABQf//v/8DTQ0GGkQAAAAAAADwf0QAAAAAAAAAACAUQQBKGwwGCyAGRJx1AIg85Dd+okScdQCIPOQ3fqIiAyAGRFnz+MIfbqUBokRZ8/jCH26lAaIiByAMQgBTGyABQf7/v/8DTQ0FGiADIAcgFEEAShsgAUGBgMD/A08NBRogBEQAAAAAAADwv6AiA0RE3134C65UPqIgAyADokQAAAAAAADgPyADIANEAAAAAAAA0L+iRFVVVVVVVdU/oKKhokT+gitlRxX3v6KgIgQgBCADRAAAAGBHFfc/oiIEoL1CgICAgHCDvyIDIAShoQwBCyAERAAAAAAAAEBDoiIDIAQgAUGAgMAASSIAGyEEIAO9QiCIpyABIAAbIhBB//8/cSIBQYCAwP8DciECIBBBFHVBzHdBgXggABtqIRBBACEAAkAgAUGPsQ5JDQAgAUH67C5JBEBBASEADAELIAFBgICA/wNyIQIgEEEBaiEQCyAAQQN0IgFBwCpqKwMAIAS9Qv////8PgyACrUIghoS/IgcgAUGwKmorAwAiCKEiCUQAAAAAAADwPyAIIAegoyIKoiIEvUKAgICAcIO/IgMgAyADoiILRAAAAAAAAAhAoCAKIAkgAyAAQRJ0IAJBAXZqQYCAoIACaq1CIIa/IgmioSADIAcgCSAIoaGioaIiByAEIAOgoiAEIASiIgMgA6IgAyADIAMgAyADRO9ORUoofso/okRl28mTSobNP6CiRAFBHalgdNE/oKJETSaPUVVV1T+gokT/q2/btm3bP6CiRAMzMzMzM+M/oKKgIgigvUKAgICAcIO/IgOiIgkgByADoiAEIAggA0QAAAAAAAAIwKAgC6GhoqAiBKC9QoCAgIBwg78iA0T1AVsU4C8+vqIgBCADIAmhoUT9AzrcCcfuP6KgoCIEIAFB0CpqKwMAIgcgBCADRAAAAOAJx+4/oiIEoKAgELciCKC9QoCAgIBwg78iAyAIoSAHoSAEoaELIQQgBSAMQoCAgIBwg78iB6EgA6IgBCAFoqAiBSADIAeiIgOgIgS9IgynIQACQCAMQiCIpyIBQYCAwIQETgRAIAFBgIDAhARrIAByDQMgBUT+gitlRxWXPKAgBCADoWRFDQEMAwsgAUGA+P//B3FBgJjDhARJDQAgAUGA6Lz7A2ogAHINAyAFIAQgA6FlRQ0ADAMLQQAhACAGAnwgAUH/////B3EiAkGBgID/A08EfkEAQYCAwAAgAkEUdkH+B2t2IAFqIgFB//8/cUGAgMAAckGTCCABQRR2Qf8PcSICa3YiAGsgACAMQgBTGyEAIAUgA0GAgEAgAkH/B2t1IAFxrUIghr+hIgOgvQUgDAtCgICAgHCDvyIGRAAAAABDLuY/oiIEIAUgBiADoaFE7zn6/kIu5j+iIAZEOWyoDGFcIL6ioCIGoCIDIAMgAyADIAOiIgUgBSAFIAUgBUTQpL5yaTdmPqJE8WvSxUG9u76gokQs3iWvalYRP6CiRJO9vhZswWa/oKJEPlVVVVVVxT+goqEiBaIgBUQAAAAAAAAAwKCjIAMgBiADIAShoSIDoiADoKGhRAAAAAAAAPA/oCIDvSIMQiCIpyAAQRR0aiIBQf//P0wEQCADIAAQhwQMAQsgDEL/////D4MgAa1CIIaEvwuiIQYLIAYMAgsgBkScdQCIPOQ3fqJEnHUAiDzkN36iDAELIAZEWfP4wh9upQGiRFnz+MIfbqUBogsQbQ8LQbbKAUHYrQFBogRBsasBEAAAC68EAgd8An4gAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgAAJ8AkACfwJAIAO9IgpC/////////wdXBEBEAAAAAAAA8L8gAyADoqMgA0QAAAAAAAAAAGENBBogCkIAWQ0BIAMgA6FEAAAAAAAAAACjDAQLIApC//////////f/AFYNAkGBeCEBIApCIIgiC0KAgMD/A1IEQCALpwwCC0GAgMD/AyAKpw0BGkQAAAAAAAAAAAwDC0HLdyEBIANEAAAAAAAAUEOivSIKQiCIpwtB4r4laiIAQRR2IAFqtyIIRABgn1ATRNM/oiIJIApC/////w+DIABB//8/cUGewZr/A2qtQiCGhL9EAAAAAAAA8L+gIgUgBSAFRAAAAAAAAOA/oqIiBqG9QoCAgIBwg78iB0QAACAVe8vbP6IiBKAiAyAEIAkgA6GgIAUgBUQAAAAAAAAAQKCjIgMgBiADIAOiIgMgA6IiBCAEIAREn8Z40Amawz+iRK94jh3Fccw/oKJEBPqXmZmZ2T+goiADIAQgBCAERERSPt8S8cI/okTeA8uWZEbHP6CiRFmTIpQkSdI/oKJEk1VVVVVV5T+goqCgoiAFIAehIAahoCIDRAAAIBV7y9s/oiAIRDYr8RHz/lk9oiADIAegRNWtmso4lLs9oqCgoKAhAwsgAwsQbQ8LQZvMAUHYrQFB2QNBmq0BEAAAC1oBAXwgAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgACADEJ8EEG0PC0GbzAFB2K0BQdgDQbmsARAAAAtaAQF8IAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQYCEDQZCIBEEANgIAIAAgAxDEBhBtDwtBm8wBQditAUHaA0HdqwEQAAALDAAgABC0CSAAKAIsC2QBAXwgAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgAEQAAAAAAADwPyADELUJoxBtDwtBm8wBQditAUHIA0GSrAEQAAALWgEBfCABQQFGBEBCqtWq1arVqtWqfyACKAIAIgEzARCIQgGDUEUEQCAAEGwPCyABEGAhA0GQiARBADYCACAAIAMQtQkQbQ8LQZvMAUHYrQFBxgNBsKwBEAAAC+oBAgN8AX4gAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQRBkIgEQQA2AgAgAAJ8RAAAAAAAAOA/IASmIQUCQCAEmSIDvSIGQv////+fyIvDwABYBEAgAxD6AyEDIAZC//////////c/WARAIAZCgICAgICAgKg+VA0CIAUgAyADoCADIAOiIANEAAAAAAAA8D+go6GiDAMLIAUgAyADIANEAAAAAAAA8D+go6CiDAILIAMgBSAFoBCrCSEECyAECxBtDwtBm8wBQditAUG2A0GmrAEQAAAL8AECAXwBfiABQQFGBEBCqtWq1arVqtWqfyACKAIAIgEzARCIQgGDUEUEQCAAEGwPCyABEGAhA0GQiARBADYCACAAAnwgA5kiA70iBEL/////n8iL8z9YBEBEAAAAAAAA8D8gBEKAgICAgICAqD5UDQEaIAMQ+gMiAyADoiADRAAAAAAAAPA/oCIDIAOgo0QAAAAAAADwP6AMAQsgBEL/////n8iLw8AAWARAIAMQxAYiA0QAAAAAAADwPyADo6BEAAAAAAAA4D+iDAELIANEAAAAAAAA8D8QqwkLEG0PC0GbzAFB2K0BQb4DQZysARAAAAtkAQF8IAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQYCEDQZCIBEEANgIAIABEAAAAAAAA8D8gAxC2CaMQbQ8LQZvMAUHYrQFBpgNBg6sBEAAAC1oBAXwgAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgACADELYJEG0PC0GbzAFB2K0BQaUDQfirARAAAAubAgICfAF/IAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQYCEDQZCIBEEANgIAIAAjAEEQayIBJAACQCADvUIgiKdB/////wdxIgBB+8Ok/wNNBEAgAEGAgMDyA0kNASADRAAAAAAAAAAAQQAQ/AMhAwwBCyAAQYCAwP8HTwRAIAMgA6EhAwwBCyADIAEQtwYhACABKwMIIQQgASsDACEDAkACQAJAAkAgAEEDcUEBaw4DAQIDAAsgAyAEQQEQ/AMhAwwDCyADIAQQ+wMhAwwCCyADIARBARD8A5ohAwwBCyADIAQQ+wOaIQMLIAFBEGokACADEG0PC0GbzAFB2K0BQaMDQearARAAAAuTAgICfAF/IAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQYCEDQZCIBEEANgIAIAAjAEEQayIAJAACfCADvUIgiKdB/////wdxIgFB+8Ok/wNNBEBEAAAAAAAA8D8gAUGewZryA0kNARogA0QAAAAAAAAAABD7AwwBCyADIAOhIAFBgIDA/wdPDQAaIAMgABC3BiEBIAArAwghAyAAKwMAIQQCQAJAAkACQCABQQNxQQFrDgMBAgMACyAEIAMQ+wMMAwsgBCADQQEQ/AOaDAILIAQgAxD7A5oMAQsgBCADQQEQ/AMLIABBEGokABBtDwtBm8wBQditAUGkA0GfqwEQAAALJAAgACABIAJB/KwBQfMDRAAAAAAAgGZARBgtRFT7IQlAEKYJCyQAIAAgASACQcGsAUHyA0QYLURU+yEJQEQAAAAAAIBmQBCmCQv/AQEGfyMAQRBrIgMkACABQQJGBEACQAJAQqrVqtWq1arVqn8gAigCACIBMwEQiKdBAXFFBEBCqtWq1arVqtWqfyACKAIEMwEQiEIBg1ANAQsgABBsDAELIAEQSiACKAIEEEohAiADQQhqIgEQuAkgAiADELgJIAEhAiADIQEDQCAFQQRGRQRAIAIQ+wEhByABEPsBIQgDQCACLQABIAJBAWohAkHAAXFBgAFGDQALA0AgAS0AASABQQFqIQFBwAFxQYABRg0ACyAFQQFqIQUgBCAHIAhGaiEEDAELCyAAIAQQigELIANBEGokAA8LQbbKAUHYrQFBkA1B7awBEAAAC8wBAwJ8AX4BfyABQQFGBEBCqtWq1arVqtWqfyACKAIAIgEzARCIQgGDUEUEQCAAEGwPCyABEGAhBEGQiARBADYCACAAIASZIQMCQAJ8IAS9IgVCNIinQf8PcSIAQf0HTQRAIABB3wdJDQIgAyADoCIEIAMgBKJEAAAAAAAA8D8gA6GjoAwBCyADRAAAAAAAAPA/IAOhoyIDIAOgCxC5BkQAAAAAAADgP6IhAwsgA5ogAyAFQgBTGxBtDwtBm8wBQditAUGaA0GvrAEQAAAL9wEDAnwBfgF/IAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQYCEEQZCIBEEANgIAIAAgBJkhAwJAIAS9IgVCNIinQf8PcSIAQZkITwRAIAMQnwRE7zn6/kIu5j+gIQMMAQsgAEGACE8EQCADIAOgRAAAAAAAAPA/IAMgBCAEokQAAAAAAADwP6CfoKOgEJ8EIQMMAQsgAEHlB0kNACADIAQgBKIiAyADRAAAAAAAAPA/oJ9EAAAAAAAA8D+go6AQuQYhAwsgA5ogAyAFQgBTGxBtDwtBm8wBQditAUGSA0GlrAEQAAALzAEBAXwgAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgAAJ8IAO9QjSIp0H/D3EiAEH/B00EQCADRAAAAAAAAPC/oCIDIAMgA6IgAyADoKCfoBC5BgwBCyAAQZgITQRAIAMgA6BEAAAAAAAA8L8gAyADokQAAAAAAADwv6CfIAOgo6AQnwQMAQsgAxCfBETvOfr+Qi7mP6ALEG0PC0GbzAFB2K0BQYoDQZusARAAAAuiBAMCfAF+An8gAUECRgRAAkBCqtWq1arVqtWqfyACKAIAIgEzARCIp0EBcUUEQEKq1arVqtWq1ap/IAIoAgQzARCIQgGDUA0BCyAAEGwPCyAAAnwgARBgIQMgA71C////////////AINCgYCAgICAgPj/AFQgAigCBBBgIgS9Qv///////////wCDQoCAgICAgID4/wBYcUUEQCADIASgDAELIAS9IgVCIIinIgJBgIDA/wNrIAWnIgZyRQRAIAMQuwYMAQsgAkEedkECcSIHIAO9IgVCP4inciEAAkAgBUIgiKdB/////wdxIgEgBadyRQRAAkACQCAAQQJrDgIAAQMLRBgtRFT7IQlADAMLRBgtRFT7IQnADAILRBgtRFT7Ifk/IAOmIAJB/////wdxIgIgBnJFDQEaAkAgAkGAgMD/B0YEQCABQYCAwP8HRw0BIABBA3RBoLkDaisDAAwDC0QYLURU+yH5PyADpiABQYCAwP8HRyACQYCAgCBqIAFPcUUNAhoCfCAHBEBEAAAAAAAAAAAgAUGAgIAgaiACSQ0BGgsgAyAEo5kQuwYLIQMCQAJAAkAgAEEBaw4DAAECBAsgA5oMBAtEGC1EVPshCUAgA0QHXBQzJqahvKChDAMLIANEB1wUMyamobygRBgtRFT7IQnAoAwCCyAAQQN0QcC5A2orAwAhAwsgAwsQbQ8LQbbKAUHYrQFBugRBka0BEAAAC1oBAXwgAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgACADELsGEG0PC0GbzAFB2K0BQfwCQferARAAAAuMAwIEfAF+IAFBAUYEQEKq1arVqtWq1ap/IAIoAgAiATMBEIhCAYNQRQRAIAAQbA8LIAEQYCEDQZCIBEEANgIAIAACfCADvSIHQiCIp0H/////B3EiAEGAgMD/A08EQCADRBgtRFT7Ifk/okQAAAAAAABwOKAgB6cgAEGAgMD/A2tyRQ0BGkQAAAAAAAAAACADIAOhowwBCwJAIABB/////gNNBEAgAEGAgEBqQYCAgPIDSQ0BIAMgAyADohD5A6IgA6AMAgtEAAAAAAAA8D8gA5mhRAAAAAAAAOA/oiIFnyEDIAUQ+QMhBgJ8IABBs+a8/wNPBEBEGC1EVPsh+T8gAyAGoiADoCIDIAOgRAdcFDMmppG8oKEMAQtEGC1EVPsh6T8gA71CgICAgHCDvyIEIASgoSADIAOgIAaiRAdcFDMmppE8IAUgBCAEoqEgAyAEoKMiAyADoKGhoUQYLURU+yHpP6ALIgOaIAMgB0IAUxshAwsgAwsQbQ8LQZvMAUHYrQFB+wJB5asBEAAAC4IDAgJ8AX4gAUEBRgRAQqrVqtWq1arVqn8gAigCACIBMwEQiEIBg1BFBEAgABBsDwsgARBgIQNBkIgEQQA2AgAgAAJ8IAO9IgVCIIinQf////8HcSIAQYCAwP8DTwRARAAAAAAAAAAARBgtRFT7IQlAIAVCAFkbIAWnIABBgIDA/wNrckUNARpEAAAAAAAAAAAgAyADoaMMAQsCfCAAQf////4DTQRARBgtRFT7Ifk/IABBgYCA4wNJDQEaRAdcFDMmppE8IAMgAyADohD5A6KhIAOhRBgtRFT7Ifk/oAwCCyAFQgBTBEBEGC1EVPsh+T8gA0QAAAAAAADwP6BEAAAAAAAA4D+iIgOfIgQgBCADEPkDokQHXBQzJqaRvKCgoSIDIAOgDAILRAAAAAAAAPA/IAOhRAAAAAAAAOA/oiIDnyIEIAMQ+QOiIAMgBL1CgICAgHCDvyIDIAOioSAEIAOgo6AgA6AiAyADoAsLEG0PC0GbzAFB2K0BQfoCQZ6rARAAAAuLAQIBfAJ+IAIoAjxBAEwEQAJAIAIrAxgiAyABIAIpAyAiAXwiBKe3ZUUNACACKQMQIgW5IAOhIAUgAX2nt2UEQCACIAIpAyhCAXw3AyggAikDMFAEQCACIAIpAwAgADQCAHw3AwAMAgsgAiAAKwMAIAIrAwigOQMIDAELIAJBATYCPAsgAiAENwMgCwssAQF/IABBABBiIgEEQCABIAEpAxBCA365RAAAAAAAANA/ojkDGCAAELwGCwspAQF/IABBABBiIgEEQCABIAEpAxC5RAAAAAAAANA/ojkDGCAAELwGCwspAQF/IABBABBiIgEEQCABIAEpAxC5RAAAAAAAAOA/ojkDGCAAELwGCwuJBAICfwV+IwBBgAFrIgMkAEEMIQQCQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAUEBaw4UAAsLAQMCCwsLBAsGBQsLBwsLCwgJCyACIAAtABA2AgAMCQsgAiAAKAIUNgIADAgLIAAgAigCADYCKAwHCyAAKAIoQQBMDQYgAikDACAAKAIMIANBIGpBwNYDKAIAEQAABEBBig4hBAwICyAANAIoIgV8QgF9IgYgBiAFgX0iBiADKQM4IgVXDQYgBkIBfSIIIAM0AkAiB3whCSAFIAUgB4FCf4V8IQUDQCAFIAd8IgUgCVkNByAAIAUgCCAFIAZTGyIFQfz7AUEBEM4JQQFGDQALQYoGIQQMBwsgAEEEIAIQuQkMBQsgAEEQIAIQuQkMBAsgAyAAKAIEKAIQNgIAIAJBi+gAIAMQezYCAAwDC0EAIQQgACgCBDQCCBBWIgFFDQMgACgCBCgCCCABEP4JGiACIAE2AgAMAwsgAiAAELcJNgIADAELIAFBKEcNAUEAIQQgAkEANgIAIAAoAiQiAEUNASAAKAIAIANCADcDOCADQgU3AzAgA0L7ADcDKCADQgA3AyAgA0EBOwEgKAIMIAMgA0EgajYCEEEMIANBEGpB2NYDKAIAEQMAQQBIBEBBih4hBAwCCyACIAMvASBBAkc2AgAMAQtBACEECyADQYABaiQAIAQLiAECAX4BfAJAAkAgAikDMFAEQCABIAIpAyAiA1EEQAwDCyABIANXDQEgADQCACEDIAJCATcDKCACIAE3AyAgAiADNwMADwsgASACKQMgIgNRBEAMAgsgASADVw0AIAArAwAhBCACQgE3AyggAiABNwMgIAIgBDkDCAsPCyACIAIpAyhCAXw3AygLYwECfwJAIABBABBiIgFFDQAgASgCOCICRQ0AIAIoAgBB9QAgARC7CSABKAI4KAIAEO0EIAEoAjgQ+AEgASkDKEIBUg0AIAEpAzBQBEAgACABKQMAEIUBDwsgACABKwMIEG0LCyABAnxBf0EBIAArAwAiAiABKwMAIgNjG0EAIAIgA2IbCyABAn5Bf0EBIAApAwAiAiABKQMAIgNTG0EAIAIgA1IbC9QCAwF/AX4BfAJAIAFBAUYEQCACKAIAEPwCIgNBBUYNAQJAAkACQAJAIABBwAAQYiIBKAI4RQRAIAFBDBCpBCIANgI4IANBAUcNAiAAQfMANgIEIAFCADcDMCABIAEpAxBCAXw3AxAMAQsgASABKQMQQgF8NwMQIAEpAzBCAFINAgsgAigCABBZIQRBCBCpBCIAIAQ3AwAMAgsgAUIBNwMwIABB9AA2AgQgASABKQMQQgF8NwMQCyACKAIAEGAhBUEIEKkEIgAgBTkDAAsgASgCOCIBKAIEIQIDQCABKAIAIgNFBEBBGBCpBCICQgE3AxAgAiAANgIIIAEgAjYCAA8LIAMoAgggACACEQAAIgMEQCABKAIAIANBAExBAnRqIQEMAQUgASgCACIBIAEpAxBCAXw3AxAgABD4AQwDCwALAAtBm8wBQditAUGKC0H57wAQAAALCzYDAXwBfwF+AkAgAEEAEGIiAkUNACACKQMQIgNCAlMNACACKwMIIANCAX26oyEBCyAAIAEQbQs3AwF8AX8BfgJAIABBABBiIgJFDQAgAikDECIDQgJTDQAgAisDCCADQgF9uqOfIQELIAAgARBtC3sBA3wgAUEBRgRAIABBGBBiIQAgAigCABD8AkEFRwRAIAAgACkDEEIBfDcDECACKAIAEGAhBCAAIAArAwAiAyAEIAOhIgMgACkDELmjoCIFOQMAIAAgAyAEIAWhoiAAKwMIoDkDCAsPC0GbzAFB2K0BQfMKQYLwABAAAAuSAQEDfwN/IAFBKEYEfwNAIAJBBkZFBEAgACACQQR0IgFBoLUDaigCAEEBQQFBAEEAIAFBqLUDaigCACABQay1A2ooAgAQyQYaIAJBAWohAgwBCwtBAAUgACABQQxsIgNBwLEDaigCACADQcSxA2osAABBAUEAIANByLEDaigCAEEAQQAQyQYaIAFBAWohAQwBCwsLKAEBfyABIAAtABAEf0EBBSAAKAIYQQBBnNYDKAIAEQAAC0U2AgBBAAsGAEHZygELkQ8BDn8jAEGAAmsiBiQAIAZBPGogASACQQBBARDBBiICRQRAIAYoAjwhCSAGQQA2AvgBIAlBATYCACAGQagBakEAQdAAEEYaIABB5ixBAEEAQQAQswEiAkUEQCAAQcHMAUEAQQBBABCzASECCyAGQfQBaiEOIAZBwAFqIQ8gBkG4AWohECAGQbABaiENIAZBrAFqIQwgBkG8AWohEQJAAkADQCACDQEgCRDECUHkAEYEQCAJKAJMIQogCSgCUCELAkACfyAGKAL4ASICRQRAIAAgCSgCOEEAIAZBqAFqIAQgBRC+BgwBCyAHIQEgCiACIAhBAWoQYUUNASAAIAkoAjggAiAGQagBaiAEIAUQvgYLIgINAyAGQagBahC/CSAGKAK8ARBFIAYoAqwBEJcBGiAGKAKwARCXARogBigCtAEQlwEaIAZBADYCzAEgBiAANgKoASAMQgA3AhAgDEIANwIIIAxCADcCACAGQQA2AvQBIAZBADoA8AEgBkEBNgLQASAGQQA2AuABIAZCADcC2AECQCADRQ0AIAUgCiADEQAADQAgBiAKNgIwIAZBi+gAIAZBMGoQeyIBNgL4ASABRQRAQQchAgwFCyABEHYhCCAGIAE2ArwBQQEhB0EAIQIMAwsgCSgCXCESQQAgAEHV+gAgCiAQIAZB+AFqIBFBACAPIA4Q9QQiAg0DQQAhASAGKAK4ASIIQQAgCEEAShshEyAGKALAASEKQQAhAgNAIAIgE0ZFBEAgAkEBaiIHIAEgAiAKai0AABshASAHIQIMAQsLAn8gCEUEQCAGIAYoAvgBNgIAQRFB6uQAIAYQjwFBAQwBCyAIIAtIBEAgBiAGKAL4ATYCECAGIAg2AhQgBiALNgIYQRFBiY0BIAZBEGoQjwFBAQwBCwJAIAEgC0wEQCAKIBIgCxB6RQ0BCyAGIAYoAvgBNgIgQRFBoNsAIAZBIGoQjwFBAQwBCyAGIAs2ArgBIAYoAvgBIgFByssBEHVFBEAgAEHKywEgBkGoAWoQvgkiAg0FIAAgDUHI3QEQvQkiAg0FIAAgDEG43AEQvQkiAg0FIAZBATYCzAFBAAwBCyAAIAEgBkGoAWoQvgkiAg0EIAYoAvgBIQFBACECIAZBADYC/AEgBkEANgJIIAZCADcDQCAGQUBrIgdBidQBIAZB/AFqIggQfyAHIAEgCBCpAiAHQfT5ASAIEH9B/PsBIQFBACEIA0AgAiAGKAK4ASIHIAIgB0obIQsgBigCwAEhCgJAA0AgAiALRg0BIAIgCmotAABFBEAgAkEBaiECDAELCyAGQUBrIgcgASAGQfwBaiIBEH8gByAGKAK8ASACQQJ0aigCACABEKkCIAdB3sEBIAEQfyAHIAJBAWoiAiABEIEEIAhBAWohCEHV+gEhAQwBCwsgByAISgRAIAZBQGsiAUHQwQEgBkH8AWoiAhB/IAEgBigCuAFBAWogAhCBBCABQfT2ASACEH9B/PsBIQFBACECA0AgAiAGKAK4ASIHIAIgB0obIQcgBigCwAEhCAJAA0AgAiAHRg0BIAIgCGotAAAEQCACQQFqIQIMAQsLIAZBQGsiByABIAZB/AFqIgEQfyAHIAYoArwBIAJBAnRqKAIAIAEQqQIgB0HYwQEgARB/IAcgAkEBaiICIAEQgQRB1voBIQEMAQsLIAZBQGtB2eUBIAZB/AFqEH8LIAYoAkAhASAGKAL8ASICRQRAIAAgASAGKAJEIAxBABDaASECCyABEEUgAg0EIAYoAvgBIQFBACECIAZBADYC/AEgBkEANgJIIAZCADcDQCAGQUBrIgdB99MBIAZB/AFqIggQfyAHIAEgCBCpAiAHQe7lASAIEH8DQCAGKAK4ASACSgRAIAIEQCAGQUBrQcj7ASAGQfwBahB/CyAGQUBrIAYoArwBIAJBAnRqKAIAIAZB/AFqEKkCIAJBAWohAgwBCwsgBkFAa0HFwQEgBkH8AWoQf0EBIQIDQCACIAYoArgBTkUEQCAGQUBrQePBASAGQfwBahB/IAJBAWohAgwBCwsgBkFAa0HZ5QEgBkH8AWoQfyAGKAJAIQEgBigC/AEiAkUEQCAAIAEgBigCRCANQQAQ2gEhAgsgARBFIAINBCAGQQA2AswBQQALIQEgBigC+AEQTCEIC0EBIQdBACECIAENAUEAIQcgACAJIAZBqAFqIAQgBRDACSECDAELCyAJKAI4IQEgCRDxBCICDQEgACABIAYoAvgBIAZBqAFqIAQgBRC+BiICDQFBACECIABBCiAGQfwBaiAGQaQBakEAEPgHGiAGKAL8ASIBRQ0BIAZBQGsiAkEAQeQAEEYaIAYgATYCkAFBE0EAIAVBBSACIAQRAwAbIQIMAQsgCRDxBBoLIABB0dIBQQBBAEEAELMBGgJAIAJFBEAgAEGcLUEAQQBBABCzASECDAELIABBgC1BAEEAQQAQswEaIABBnC1BAEEAQQAQswEaCyAGQagBahC/CSAGKAKwARCXARogBigCrAEQlwEaIAYoArQBEJcBGiAGKAK8ARBFIAYoAtgBEEUgBigC5AEQRQsgBkGAAmokACACC7kIAgx/AX4jAEHgAGsiBCQAIARBDGpBAEEsEEYaIAQgATYCGCAEIAA2AhwgBEEANgJQIARBADYCRCAEQUBrQQA2AgAgBEIANwNIIARCADcDOCADBEAgA0EANgIAIAJBADYCAAsCQAJAA0BBACEGIAdBAXQhDCAHQQN0Ig2tIRADQCAMQQAgDEEAShshCyAHQQAgB0EAShshBQNAIAQgBEEMaiIJQQIQhgIiATYCWCABDQQgBCgCFCIAIAQoAhxODQMCQCAEKAIYIABqIgotAAAiAUEXRwRAIAFBCUYiCyABQRJGckUEQCABQdQARw0CIAQgAEEBajYCFCAEIAkgBEHcAGoQwgkiATYCWCABDQcgBCgCFCIFIAQoAhhqIgAgBEHEAGoQ7QEhASAEQQA2AjwgBEE4aiAAIAFqIAQoAkQiByAEQdgAaiIBENsBIARByABqIghB1AAgARC0ASAIIAAgBCgCXCIAIAEQ2wEgBCgCWCIBBEAgBCgCOCEIDAgLIAQgACAFajYCFCAGEEUgBCgCOCEIDAULIAotAAEhCiAEIABBAmo2AhRBACEFQQAhAUEAIQADQCAAIAEgB05yRQRAAkAgBEEMaiIJIAVBCmoQhgIiAA0AIAVBAWohACAEKAIYIAQoAhRqIg4gBWotAAAiD0EDa0H/AXFBAU0EQCAJIAAgDmogBEHcAGoQ7QEgAGogBCgCXGoiBRCGAiEADAELIAVBCWogACAPQQFrQf8BcUECSRshBUEAIQALIAFBAWohAQwBCwsgBCAANgJYIARByABqIgBBEkEJIAsbIARB2ABqIgEQtAEgACAKIAEQtAEgACAEKAIUIgAgBCgCGGogBSABENsBIAQgACAFajYCFCAEKAJYIgFFDQMMBgsgBkUEQCAQEFYiBkUEQEEAIQZBByEBDAcLIAZBACANEEYaCyAEQcgAaiIBQRcgBEHYAGoiCRC0ASABIAotAAEgCRC0ASAEIABBAmo2AhQgBCAEQQxqIgEgB0EAIAZBABDyBCIANgJYIABFBEAgBCABIAdBACAGIAdBAnRqQQAQ8gQ2AlgLQQAhAEEAIQEDQCABIAVGRQRAIARByABqIAZBACAHIAEgCGotAAAbIAFqQQJ0aigCACAEQdgAahC/BiABQQFqIQEMAQsLA0AgACAFRgRAAkBBACEBA0AgASALRg0BIAYgAUECdGooAgAQgQEgAUEBaiEBDAALAAsFQQAhASAEQcgAaiAAIAhqLQAABH9BAAUgBiAAQQJ0aigCAAsgBEHYAGoQvwYgAEEBaiEADAELCyAGQQAgDRBGGiAEKAJYIgFFDQEMBQsLCwtBhIgOEEdBCyEBDAELQQAhASACRSADRXINACACIAQoAkw2AgAgAyAEKAJINgIAIARBADYCSAsgBCgCSBBFIAYQRSAIEEUgBEHgAGokACABC3cBAn8gACgCGCECIAAtABAEQCAAIAE6ABBBnH8gAkEAQQAQHxCRARpBAA8LAkAgAkH/A0Hc1wMoAgARAAAiAkEASARAQQUhAkGQiAQoAgAiAUEURg0BIAEQ8AQiA0EFRg0BIAAgATYCFCADDwsgACABOgAQCyACCw8AIAAgASACQQBBABDBBgsZACABQQBIBEAgACgCDA8LIAAgATYCDCABC1gCAn8BfiMAQeAAayICJAACQCAAKAIMIAJBwNYDKAIAEQAABEAgAEGQiAQoAgA2AhRBig4hAwwBCyABIAIpAxgiBEIAIARCAVIbNwMACyACQeAAaiQAIAMLrwwCEH8BfiMAQTBrIgMkAEEVIQQCQCABRSACRXINACAAKAIAIQ8gA0EANgIYIANCADcDECABQQA2AgAgAkEANgIAIAAoAhwiBA0AIAAoAgBBtT1BAEEAQQAQswEiBA0AIABBQGshCEEAIQQDQAJAIAQNACAIKAIAIghFDQBBACEEIAgoAiBFDQEgCCgCBCEFIANBADYCCCAIKAIIIQQgAyAAIAgQygkiBjYCDAJAIAYNACAIKAIIIARGDQAgAyAAIAgQyQk2AgwLIANBEGoiBEHUACADQQxqIgcQtAEgBCAIKAIIIAcQwgYgBCAIKAIcIAgoAgggBxDbASAEIAgoAgQiBCAEEHZBAWogBxDbAUEAIQ1BACEHIAMoAgwiBEUEQCADIA9BACAAKAIEIAUgCCgCECAIKAIIIAgoAhQgCCgCHCADQQhqEMYJIgQ2AgwgAygCCCEHCyADKAIUIRAgBCEFA0ACQCANIAgoAiROIAVyRQRAIAgoAiggDUECdGohBkEAIQUDQCAFDQIgBigCACIMRQ0CIAwoAgwhBiAIKAIcIQsgCCgCCCEJQQAhBEEAIQUDQCAGIQoCQAJ/AkAgBSAJTiAEckUEQCAGQQFqIQZBACEEAkACQAJAAkAgCi0AAA4GBwABAgMHAwsgBSALai0AAEUNBCAHIAVBAWogBhDJAhCTBAwFCyAFIAtqLQAARQ0DIAcgBUEBaiAGEMkCvxDkBgwECyAGIANBIGoQ7QEgBmohBiADKAIgIQogBSALai0AAAR/IAcgBUEBaiAGIApBfxCQCgVBAAshBCAGIApqIQYMBAsgBiADQSBqEO0BIAZqIQYgAygCICEKIAUgC2otAAAEfyAHIAVBAWogBiAKQX8Q5QYFQQALIQQgBiAKaiEGDAMLIAMgBDYCDAJAIAQNACAHELoBIQQgDC0AACEFAkACQCAEQeQARgRAAkAgBUESRgRAIANBEGoiBUESIANBDGoiBBC0ASAFIAwtAAEgBBC0AUEAIQUDQCAFIAgoAghODQIgA0EQaiAHIAUgA0EMahDFCSAFQQFqIQUMAAsACyAIKAIcIRFBACEFIANBADYCLCADQQA2AiggA0IANwMgIAwoAgwhBiADKAIUIRIgA0EQaiIEQRcgA0EsaiIJELQBIAQgDC0AASAJELQBQQEhCgNAQQAhCQJAAkAgBwR/IAcvAZABBUEACyAFSwRAAkACQAJ/AkACQAJAIAYtAAAiBEEBaw4FAQECAgACCyAHIAUQ9AJBBUchBEEBDAILQQkhCUEAIQsgByAFEPQCIARHDQMgBkEBahDJAiETIARBAUcNAiAHIAUQsgMgE1ENBQwDCyAGQQFqIANBHGoQ7QFBAWohCSADKAIcIQsCQAJAIAcgBRD0AiAERw0AIAcgBRCLAiALRw0AQQAhBCALRQ0BIAYgCWogByAFEIsFIAsQekUNAQtBASEECyAJIAtqCyEJQQAgCiAEGyIKIQsgBA0BDAMLIAcgBRCKBSATv2ENAgsgA0EQaiAGIAkgA0EsaiIEENsBIANBIGogByAFIAQQxQkgCyEKDAILAkAgCgRAIAMgEjYCFCADKAIgIQUMAQsgA0EQaiADKAIgIgUgAygCJCADQSxqENsBCyAFEEUgAyADKAIsIgQ2AgwMBQsCQCAFIBFqLQAARQRAIANBEGpBACADQSxqELQBDAELIANBEGogBiAJIANBLGoQ2wELIANBIGpBACADQSxqELQBCyAFQQFqIQUgBiAJaiEGDAALAAsgAygCDCEEDAELIAVBEkYNASADQQA2AiAgA0EQaiIFQQkgA0EgaiIEELQBIAUgDC0AASAEELQBIAUgDCgCDCAMKAIIIAQQ2wEgAyADKAIgIgQ2AgwLIAQNAQsgAyAHENkBIgQ2AgwLIAxBEGohBiAEIQUMBAtBAAshBCAKQQlqIQYLIAVBAWohBQwACwALAAsgBxCXARogAyAOIAMoAhQiBSAFIBBGGyIONgIUDAMLIA1BAWohDQwACwALCwJ/IAQEQCADKAIQDAELIAEgDjYCACACIAMoAhA2AgBBACEEQQALEEUgD0HJPUEAQQBBABCzARoLIANBMGokACAEC4kCAQZ/IwBBEGsiBSQAIAAoAgAiAygChAIhASADQgA3AoQCIAUgATYCDCAFQQxqIQYCQANAIAYhBCABRQ0BIAFBPGohBiAAIAFHIAEoAjwhAQ0ACyAEIAE2AgAgBSgCDCIERQ0AIAMgBDYChAIgA0HsADYCiAILIAAoAjgQgQEgACgCQCECA0AgAgRAIAIoAgBBACEDA0AgAyACKAIkTkUEQCACKAIoIANBAnRqKAIAIQEDQCABBEAgASgCECAAIAEQ+AIhAQwBCwsgA0EBaiEDDAELCyACKAIsEJcBGiAAIAIoAhQQ+AIgACACKAIoEPgCIAAgAhD4AiECDAELCyAAEEUgBUEQaiQAC5MBAQF/IwBBEGsiASQAAkAgACgCDBDVBgRAIABBkIgEKAIANgIUQYoIIQJBighB26oBIAAoAiBB+8kCENwBDAELIAAtABJBCHFFDQAgACgCICABQQxqQdDXAygCABEAAEUEQCABKAIMENUGGiAAIAEoAgxBicoCEMwCCyAAIAAvARJB9/8DcTsBEgsgAUEQaiQAIAILbwEDfyMAQRBrIgMkACADQQA2AgwgACgCACABIANBDGogACgCBBEDACEFIAMoAgwhBAJAIAFBAUcgBXINAEKq1arVqtWq1ap/IAQzARCIQgGDUA0AIAAoAhQoAjghBAsgAiAENgIAIANBEGokACAFCw8AIAAoAgAgACgCDBEBAAsPACAAKAIAIAAoAhARAQALbwEDfyMAQRBrIgMkACADQQA2AgwgACgCACABIANBDGogACgCCBEDACEFIAMoAgwhBAJAIAFBAUcgBXINAEKq1arVqtWq1ap/IAQzARCIQgGDUA0AIAAoAhQoAjghBAsgAiAENgIAIANBEGokACAFC/EBAQR/IAMQTEEBaiEIIAJBF0chCQNAAkACQAJAIAAEQCAAKAIMRQ0DIAAoAhwNAyADIAAoAgQgCBBhDQMgBBBMQQFqIQcgAEFAayIKIQECQANAIAEoAgAiAQRAIAEoAgQgBCAHEGENAQwCCwsgACgCFEUNAiAAKAIkIgEEQCAAKAIgIAQgAREAAEUNAwsgACAEEMwJIgENAyAKKAIAIQcDQCAHIgFFDQMgASgCACIHDQALCyAAQQA2AhwgAiAFIAAgARDLCSAJDQNBEiAGIAAgARDLCQwDCw8LQQAhAQsgACABNgIcCyAAKAI8IQAMAAsAC5EEAQZ/IwBBEGsiCCQAAkACQCAAKAKMAiIFBEAgBSgCCEESRw0BC0Gf1AUQiAFBFSEEDAELIAUoAlAiBARAIAQgAcEQ6AEhAQtBGSEEIAFBAEgNACABIAUoAgQiAy4BNE4NAAJAIAUoAigiBEUEQCAAIAMoAiQQxQIiBq0QZiIDRQ0BAkAgBSgCBCgCJEEAIAYgAxDVBCIERQRAIAUgBUEQaiAGIAMQjQoiBDYCKCAEDQFBByEECyAAIAMQTQwDCyAFIAM2AgwLIAIgBCgCBCABQShsaiIDNgIAIAUoAkwiBi4BICABRgRAIAMgBSkDOBCHAQwBCyAGKAIEIQcgBSgCKC8BFCABTQRAQQAhBAJAIAcgAUEMbGoiBy8BCEUEQEHQnAIhAwwBCyAFKAJUIgNFBEAgBSAAIAYuASJBAnSsEFciAzYCVCADRQ0DCyADIAFBAnRqKAIAIgMNACAIQQA2AgwgACAFKAJMKAI0IAcvAQhBBHRqQQhrKAIAIAAtAFQgBy0ABSAIQQxqEMUDIgQgCCgCDCIDckUEQEHT1AUQR0ELIQQLIAFBAnQiASAFKAJUaiADNgIAIAUoAlQgAWooAgAhAwsgAiADNgIADAILQQAhBCAHIAFBDGxqLQAFQcUARw0BIAMtABBBJHFFDQEgAxCCBgwBC0EAIQQLIAAgBBCZASAAIAQQlgEgCEEQaiQAC4gDAQR/AkACQCAAKAKMAiIEBEAgBCgCCCIFQQlHDQELQbHVBRCIAUEVIQMMAQsCQCAFQRdGDQAgBCgCUCIDRQ0AIAMgAcEQ6AEhAQtBGSEDIAFBAEgNACABIAQoAgQuATQiBk4NAAJAAkAgBUESRgRAIAQoAiwiA0UEQCAEKAIAKAJYIAQoAjBBKGxqIgUtABFBBHEEQCAFEN8BIgMNBQsgBEEQaiAFKAIMIAUoAggQjQoiA0UNAyAEIAM2AiwLIAMoAgQgAUEobGohBSAEKAJMLgEgIAFGBEAgBSAEKQNAEIcBDAILQdCcAiAFIAEgAy8BFE8bIQUMAQsgBCgCSCIDRQRAIAQgACAGQShsrRBXIgM2AkggA0UNAgsgAyABQShsaiIFLwEQDQAgBCgCTC4BICABRgRAIAUgBCkDQBCHAQwBCyAFIAQoAgAoAlggBCgCMEEobGogAUEobGpBKGoQngMiAw0CCyACIAU2AgBBACEDDAELQQchAwsgACADEJkBIAAgAxCWAQsWACAAKAKMAiIARQRAQQAPCyAALwEWC1oCAX8BfiAAKAIMIAAoAigiAkEASgR+IAEgAq0iA3xCAX0iASABIAOBfQUgAQsQyAlFBEBBAA8LIABBkIgEKAIANgIUQYoMQYuJASAAKAIgQajKAhDcAUGKDAsaACAAKAKMAiIARQRAQQAPCyAAKAIAKALYAQunAQEDfyABEEwhBCACQQA2AgAgBEHZAGqtEFYiA0UEQEEHDwsgA0EIakEAQdAAEEYaIANBATYCDCADIANB2ABqIgU2AgQgAyAANgIAIAUgASAEQQFqEEQaIANB6AA2AlQgA0HpADYCUCADQeoANgJMIANB6wA2AkggAyAANgJEIABB7AA2AogCIAAoAoQCIQEgACADNgKEAiADIAE2AjwgAiADNgIAQQALHAEBfyAAQTFNBH8gAEECdEHQrwNqKAIABUEACwsdACAAIAEQlAciAEUEQEF/DwsgACgCBC8BGEEBcQsdACAAIAEQlAciAEUEQEEADwsgACgCBCgCABCRBgsqAQF/AkAgAUEASA0AIAAoAhQgAUwNACAAKAIQIAFBBHRqKAIAIQILIAILGgAgABDNCSIARQRAQQAPCyAAEEwgAGpBAWoLEAAgAEUEQEEADwsgABD4AwtgAQF/IABFIAFBAEhyBH9BAAUgABD4AyIAEEwgAGohAANAIABBAWohAiAALQABIgBFIAFBAExyRQRAIAIQTCACakEBaiIAEEwgAGohACABQQFrIQEMAQsLIAJBACAAGwsLwAECAn8BfiADQQF0IgNBACADQQBKGyEDIAAQdiABEHZqIAIQdmpBCmqtIQcDQCADIAVGRQRAIAcgBCAFQQJ0aigCABB2QQFqrXwhByAFQQFqIQUMAQsLIAcQViIGRQRAQQAPC0EAIQUgBkEANgAAIAZBBGoiBiAAEPYEIQADQCADIAVGRQRAIAAgBCAFQQJ0aigCABD2BCEAIAVBAWohBQwBCwsgAEEAOgAAIABBAWogARD2BCACEPYEQQA7AAAgBgveDQMKfwF+AXwjAEEQayICJAAgAiABNgIIQQAhAQJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAQQVrDh0AAQMEGBcWFRQaEhEPEAwOGhMKCwkaCAINBwYaBRoLQZSQBEH4jARBhAEQRBoMGQtB+IwEQZSQBEGEARBEGgwYCyACIAIoAggiAUEEajYCCCABKAIAIQAgAiABQQhqNgIIIAEoAgQiAQRAIAEoAhAoAgwoAgAiASAAIAEbIQALQQAhAUHs0gMgADYCAEH4jARBADYCAAwXCyACIAIoAggiAEEEajYCCCAAKAIAIQMgAiAAQQhqNgIIIAMpAyAhDCAAKAIEBEAgAyAMQoCAgICAAYQ3AyAMFwsgAyAMQv//////foM3AyAMFgsgAiACKAIIIgBBBGo2AgggACgCACEEIAIgAEEIajYCCCAAKAIEIQtBfyEBIAQQrgMiA0UgBEEHakEIbUEBaqwQuQEiB0VyQoAEEFYiCEVyDRRBAEEBEJ8CGkEAQQEgCBCHBiACQQA2AgxBACEAA0ACQAJ/AkACQCALIABBAnRqIgEoAgAiCQ4GAwAAAQEAAQsgASABKAIIIgUgASgCDGo2AghBBCEGIAVBAWsMAQtBBCACQQxqEOABQQIhBiACKAIMCyEFIAEgASgCBCIBQQFrNgIEIAZBACABQQFMGyAAaiEAIAIgBUH/////B3EgBG8iATYCDEEBIAFBAWoiAUEHcXQhBSAHIAFBA3ZqIgYtAAAhCiAJQQFxBEAgBiAFIApyOgAAIAlBBUYNAiADIAEQnwJFDQJBfyEBDBcFIAYgCiAFQX9zcToAACADIAEgCBCHBgwCCwALCyADIARBAWoQ4gQgBGsgA0EAEOIEaiADKAIAaiEBIARBACAEQQBKG0EBaiEEQQEhAANAIAIgADYCDCAAIARGDRUgByAAQQN2ai0AACAAQQdxdkEBcSADIAAQ7gNHBEAgACEBDBYFIABBAWohAAwBCwALAAsgAigCCEEHakF4cSIAKwMAIQ0gACgCDCAAKAIIIAIgAEEUajYCCCAAKAIQIQAgDRDECiIENgIAIAQQzAoiDDcDACAAIAwQzAE2AgAMFAsgAiACKAIIIgBBBGo2AgggACgCACEDIAIgAEEIajYCCCAAKAIEIQACQAJAAkACQCADDgQAAQIDFwsgAEHkjgQoAgA2AgAMFgtB5I4EIAAoAgA2AgAMFQsgAEHojgQoAgA2AgAMFAtB6I4EIAAoAgA2AgAMEwsgAiACKAIIIgBBCGo2AgggACgCBEIANwMADBILIAIgAigCCCIAQQRqNgIIIAAoAgAoAgAiAC8BECIDQQRxRQ0RIAAgA0Hb/wNxQSByOwEQDBELIAIgAigCCCIDQQRqNgIIIAMoAgAhACACIANBCGo2AgggACADKAIEEOwBIgRBAEgNECAAIAQ6ALABIAAgAygCCEEBcSIEOgCxASAAIAAtALIBQf0BcSAEQQF0cjoAsgEgAiADQRBqNgIIIAAgAygCDCIDNgKsASAEIANFcg0QIAAQgwIMEAtBqNIDKAIARSEBDA8LIAIgAigCCCIAQQRqNgIIIAAoAgAgAiAAQQhqNgIIIAAoAgQ2AqgBDA4LIAIgAigCCCIAQQRqNgIIQeTSAyAAKAIANgIADA0LIAIgAigCCCIAQQRqNgIIQeHQAyAAKAIAOgAADAwLIAIgAigCCCIAQQRqNgIIQejQAyAAKAIANgIADAsLIAIgAigCCCIAQQRqNgIIIAAoAgAiACAAKAIYQSBzNgIYDAoLIAIgAigCCCIAQQRqNgIIQdzSAyAAKAIAIgM2AgAgA0ECRgRAIAIgAEEIajYCCEHg0gMgACgCBDYCAAwKC0Hg0gNBADYCAAwJCyACIAIoAggiAEEEajYCCCAAKAIAIQMgAiAAQQhqNgIIIAAoAgQgAygCUDYCAAwICyACIAIoAggiAEEEajYCCCAAKAIAIAIgAEEIajYCCCAAKAIENgJQDAcLQZLEByEBDAYLIAIgAigCCCIAQQRqNgIIIAAoAgAhAQwFCyACQQA2AgQgAigCBCEBDAQLIAIgAigCCCIAQQRqNgIIQfDVAygCACEBIAAoAgAiAEUNA0Hw1QMgADYCAAwDCyACIAIoAggiAEEEajYCCCAAKAIAIQMgAiAAQQhqNgIIQeSPBCAAKAIENgIAQeCPBCADNgIADAILIAIgAigCCCIAQQRqNgIIQdjSAyAAKAIAIgA2AgAgAEUNAUEAIAARAQAhAQwBCyAIEEUgBxBFIAMQoQILIAJBEGokACABCxEAIABBf0H/ASABGzYCSEEACy8BAn9B1IwEKAIAIgEEfyABIABB6AdsQQAgAEEAThsgASgCPBEAAEHoB20FQQALCwcAIAAtAFULuAEBAn8gACIFQZQEaiEAAn8CQAJAAkADQCAAIgQoAgAiAEUNASAAQQxqIAEQsAENAAsgACgCCCIBBEAgACgCBCABEQQACyACDQEgBCAAKAIANgIAIAAQRQwCCyACRQ0BIAEQdiIEQRFqrRBWIgBFBEBBByADRQ0DGiACIAMRBABBBw8LIABBDGogASAEQQFqEEQaIAAgBSgClAQ2AgAgBSAANgKUBAsgACADNgIIIAAgAjYCBAtBAAsLLAAgAEGUBGohAANAIAAoAgAiAEUEQEEADwsgAEEMaiABELABDQALIAAoAgQLHAAgACABNgKgAiAAIAI2ApwCIABBADYCmAJBAAtkAQJ/A0AgAiAAIAMgASACEM4JIgRMIgUgBEEATHJFBEAgASAEaiEBIAIgBGshAiADIAStfCEDDAELCyAFBEBBAA8LAkAgBEEATg0AIAAoAhRBM0YNAEGKBg8LIABBADYCFEENCxwAIAAgATYCoAIgAEEANgKcAiAAIAI2ApgCQQALPAACQCAAIAFBfxDgBiIBRQRAQQAhBAwBCyAAIAEgAkH/AXEgAyAEQQAQ+QIhBCAAIAEQTQsgACAEEJYBCxEAIAAgASACIAMgBEEAENAJC30BAn8gAUEANgIAQQAQ6gEiAkF/IABBwI4CIAAbQQJBABCpAwJAIAJBARCaAiIARQRAQQchAAwBCyAAIAFBBkEAEMYGIgANAEEAIQAgASgCACIBKAIQKAIMIgMtAE5BAXENACABQQI6AFQgA0ECOgBNCyACEIEBIABB/wFxCw0AIAAgASACIAMQxgYLDgAgASAANQIENwMAQQAL6gQCAn8CfiMAQRBrIgQkAAJAAkACQAJAAkACQAJAAkACQAJAAkAgAg4JAAECAwQFBgcJCAsgACgCGCICRQRAIAAoAhBBAUYNCiAAENEJIgMgACgCECICRg0KIAIgA2shAiAAKAIsIANqIgAtAABB2wBGBEAgAEEBaiAEQQhqIAJBAWtBARC/AhogASAEKQMIEIUBDAsLIABBAWoiAy0AAEEiRgRAIAEgAEECaiACQQNrQX8QXAwLCyABIAMgAkEBa0F/EFwMCgsgAC0AFEEMRgRAIABBqAFqIAAoAgggAUEBEIEFDAoLIAEgACgCICACQRhsakEIaykDABCFAQwJCyAAQagBaiAAEIUEIgIgAUEBEIEFIAIgACgCqAFqLQAAQQ9xQQtJDQggASgCACIAQcoAOgATIAAgAC8BEEGAEHI7ARAMCAsgASAAEIUEIAAoAqgBai0AAEEPcUECdEHgrANqKAIAQX9BABBcDAcLIAAQhQQiAiAAKAKoAWotAABBD3FBCksNBiAAQagBaiACIAFBARCBBQwGCyABIAA1AggQhQEMBQsgACgCGCICRQ0EIAAtABVFDQQgASAAKAIgIAJBGGxqQRhrNQIAEIUBDAQLIAApAzgiBiEFIAAoAhgEQCAAENMJIAApAzghBQsgASAAKAIsIAVBf0EBEK8CIAAgBjcDOAwDCyAAENEJIQIgASAAKAIsIAKtQX9BARCvAgwCCyABIAAoAiwgACgCEEEAEFwMAQsgACgCtAEiAkUEQCABIAAoAqgBIAAoAqwBQX8QsQIMAQsgASACQX9BfxBcCyAEQRBqJABBAAsNACAAKAIIIAAoAgxPC7MEAQh/IwBBEGsiAyQAIABBqAFqIQYCQAJAIAAtABUEQCADQQA2AgwgABCFBCIEIAAoAqgBai0AACEBIAYgBCADQQxqEHkhBQJAAkAgAUEPcUENa0F+SSIHRQRAAkAgACgCGCIBIAAoAhwiAkkEQCAAKAIgIQIMAQsgACgCJCAAKAIgIAJBAXRBA2oiAa1CGH4QtwEiAkUNAyAAIAI2AiAgACABNgIcIAAoAhghAQsgACgCCCEIIAIgAUEYbGoiAiAENgIEIAIgCDYCACADKAIMIQggAkJ/NwMQIAIgCCAEIAVqIgRqNgIIIAIgACkDOD4CDEEAIQICQCABRQ0AIAAtABRFDQAgABDTCUEHQQAgAC0AQRshAiAAKAIYIQELIAAgBDYCCCAAIAFBAWoiATYCGAwBCyAAIAMoAgwgBCAFamoiBDYCCCAAKAIYIQELIAACfwJAA0AgAQRAIAQgACgCICABQRhsaiIFQRBrKAIASQ0CIAAgAUEBayIBNgIYIAAgBUEMazUCADcDOEEAIQcMAQsLQQAgB0UNARoMBAsgBw0DIAYoAgAgBUEUaygCAGotAABBD3ELOgAUDAILQQchAgwCCyADQQA2AgggACAGIAAQhQQiASADQQhqEHkgAWogAygCCGo2AggLAkAgAC0AFEELRw0AIAAoAhgiAUUNACAAKAIgIAFBGGxqQQhrIgEgASkDAEIBfDcDAAsgACAAKAIEQQFqNgIECyADQRBqJAAgAgvpBQECfyMAQSBrIgIkACAAEIYEAkACQCABRQ0AIABBqAFqQQBBOBBGIQUgAEEBNgLAASAAIAAoAiQ2ArgBIAQoAgAQjgQhBiAEKAIAIQMCQAJAIAYEQCAAIAMQXjYCrAEgACAEKAIAEKsBNgKoAQwBCyAAIAMQSjYCtAEgACAEKAIAEF42ArwBIAAoArQBRQRAIABCADcDCAwDCyAFQQAQggVFDQAgAC0AywENASAAKAIAKAIIEEVBmbwBQQAQeyEBIAAoAgAgATYCCCAAEIYEQQFBByAAKAIAKAIIGyEEDAMLAkAgAUEDRgRAIAQoAgQQSiIDRQ0DIAMtAABBJEcEQCAAKAIAKAIIEEUgAiADNgIQQeK7ASACQRBqEHshASAAKAIAIAE2AgggABCGBEEBQQcgACgCACgCCBshBAwFCyAAIAMQTDYCEAJAAkAgAy0AAUUEQEEAIQEgAEEAOgAUDAELIAVBACADQQFqQQAQ/AEiAUF9TwRAIAFBfkYEQEEAIQQgAEEAOgAUIABCADcDCAwICyAAKAIAKAIIEEUgAiADNgIAQeK7ASACEHshASAAKAIAIAE2AgggABCGBEEBQQcgACgCACgCCBshBAwHCyAAKALYASIEBEAgAEEMOgAUIAAgBDYCCAwCCyAAQQs6ABQLIAAgATYCCAsgAEEoaiADIAAoAhAQiQIMAQtBACEBIABBADoAFCAAQQA2AgggAEEBNgIQIABBKGpBnO8BQQEQiQILQQAhBCAAQQA2AhggACAFIAEgAkEcahB5IAFqIgMgAigCHGo2AgwgACgCqAEgAWoiBS0AAEEPcUELSQ0CIAAtABUNAiAAIAM2AgggACAFLQAAQQ9xOgAUIAAgACgCJEIYEFciAzYCICADRQ0AIABCgYCAgBA3AxggA0IANwMQIAMgACgCDDYCCCAAKAIIIQAgAyABNgIEIAMgADYCAAwCC0EHIQQMAQtBACEECyACQSBqJAAgBAsSACAAEIYEIAAoAiQgABBIQQALGwAgACABENQJIgBFBEAgASgCAEEBOgAVCyAACw0AIAAoAgwgABBIQQALugIBB38jAEEQayIEQn83AgggASgCACIAQQAgAEEAShshByABKAIEIQADQCADIAdGRQRAAkAgACgCACIGQQhIDQBBASAGQQhrIgh0IQYgAC0ABUUEQCACIAZyIQIMAQsgAC0ABEECRw0AIARBCGogCEECdGogAzYCACAFIAZyIQULIABBDGohACADQQFqIQMMAQsLAkAgASgCCEEATA0AIAEoAgwiACgCAEEATg0AIAAtAAQNACABQQE2AiALQRMhACACIAVBf3NxRQRAQQAhACABAn9BACAEKAIIIgJBAEgNABogAUKAgICAgICA+D83AyggASgCECIFIAJBA3RqIgJBAToABCACQQE2AgBBASAEKAIMIgRBAEgNABogBSAEQQN0aiIDQQE6AAQgA0ECNgIAQQMLNgIUCyAAC4sCAQV/IAEhBiACIQUDQAJAAkACfwJAAkACQCAAKAIMIAMQ0glCAFkEQAJAIAAoAgwgBiAFQeTWAygCABEDACIEIAVGBEAgBSEEDAELIARBAEgEQEGQiAQoAgAiCEEbRg0JIAAgCDYCFEEAIQcMAQsgBA0GQQAhBAsgAiAEIAdqIgVHDQEMBgsgAEGQiAQoAgAiBDYCFCACQX9GDQUMAQsgBUEATg0BIAAoAhQhBAtBisIAIARBHUYgBEE8RnIgBEHEAEZyDQEaQYoCDwsgAEEANgIUIAEgBWpBACACIAVrEEYaQYoECw8LIAQgBmohBiAEIAdqIQcgBSAEayEFIAMgBK18IQMMAQsLQQALPAAgAEGn2wEQpgUiAQR/IAEFIAQgAEIQEFciAjYCACACRQRAQQcPCyAAQQJBABCHChogAiAANgIMQQALCw4AIAEgADQCCDcDAEEAC8MEAQh/IAAoAhgiCiAAKAIMIgZBFGxqIQQCQAJAAkACQAJAAkACQCAAKAIAIgcoAhAEQCACQQRGDQECQCACQQJKDQAgACgCIA0AIAcoAgwoAhAgBCgCDEEEdGoiAygCDCEFIAQoAgghCCAAIAMoAgA2AiQgBUEQaiEDAkACQANAIAMoAgAiA0UNASADKAIIIgktACtBAUYNACAJKAIUIAhHDQALIAkoAgAhAyAAQeiSATYCICAAIAM2AigMAQsgACgCKCEDCyADDQAgBUEgaiEDA0AgAygCACIDRQ0BIAMoAggiBSgCLCAIRw0AIAUoAgAhBSAAQdYvNgIgIAAgBTYCKAwACwALIAJBFGohAgsCQAJAAkACQAJAAkACQCACDhgAAQIDBAUGBQcICA0NDQ0NDQ0NDQkKCwwNCyABIAYQigEMDAsgASAELQAAQQJ0QeCSAmooAgBBf0EAEFwMCwsgASAEKAIEEIoBDAoLIAEgBCgCCBCKAQwJCyABIAQoAgwQigEMCAsgACgCHCIDRQRAIAAgBygCDCAEEJwJIgM2AhwLIAJBBUcNByABIANBf0EAEFwMBwsgASAELwECEIoBDAYLIAAoAgggBkEBakYNBSAKKAIQIgAEQCABIABBA2pBf0EAEFwMBgsgAUGB3AFBBEEAEFwMBQsgAUEAEIoBDAQLIAEgACgCIEF/QQAQXAwDCyABIAAoAiRBf0EAEFwMAgsgASAAKAIoQX9BABBcDAELIAEgBC0AAEHxAEYQigELQQALCAAgACgCGEULxQEAIwBBEGsiAiQAIAAoAgAhAyAAENYJIAAgAUU2AhQgAEIANwMIAkBChICQgICAgAIgBCgCACIBMwEQiEIBg1BFBEAgARBKIgFFBEBBByEBDAILIAMoAgwgAUF/IABBBGpBABDaASEBIABBATYCEAwBCyAAIAFBseoAEJgKNgIEQQAhAQsCQCAAKAIERQRAIAJBwpwBQc6VASADKAIQGzYCACADQdQ6IAIQezYCCEEBIQEMAQsgABDVCRoLIAJBEGokACABCw0AIAAQ1gkgABBFQQALNQEBf0LYABBWIgJFBEBBBw8LIAJBAEHYABBGIgIgACgCDDYCRCACQQE7AUAgASACNgIAQQAL4wEBB38gACgCECEAIAFC5AA3AzAgAUKAgICAgIDArMAANwMoIAFBADYCFEEEQQogABsiBUEBciEGIAEoAgAiAEEAIABBAEobIQcgAUEUaiEIIAEoAgQhAEETIQQDQCACIAdGRQRAAkAgAC0ABUUNAAJAIAAtAAQiA0HHAEcEQCADQQJHDQIgACgCACAGRw0CIAEoAhAgAkEDdGoiA0EBOgAEQQAhBAwBCyAAKAIAIAVHDQEgASgCECACQQN0akEBOgAEIAghAwsgA0EBNgIACyAAQQxqIQAgAkEBaiECDAELCyAEC1cAIAAgAUEAR0ECdEGwrwNqKAIAEKYFIgMEfyADBSAEQhQQViICNgIAIAJFBEBBBw8LIAJCADcCACACIAA2AgwgAkEANgIIIAIgAUEAR0EBdDYCEEEACwtGAQJ/IwBBEGsiASQAIAEgADYCDCAAQc6VAUGohwRBABCIBSICRQRAIABBwpwBQaiHBCABQQxqEIgFIQILIAFBEGokACACC0ABAn8DQCACQQFLIAFyRQRAIAAgAkEDdCIBQaCvA2ooAgAgAUGkrwNqKAIAQQAQiAUhASACQQFqIQIMAQsLIAELHwEBf0EAIQBB2NIDKAIAIgEEf0H0AyABEQEABUEACwttACACQQFrIQADQAJAIAFFBEBBACEBDAELIAAgAWotAABBIEcNACABQQFrIQEMAQsLIARBAWshAANAAkAgA0UEQEEAIQMMAQsgACADai0AAEEgRw0AIANBAWshAwwBCwsgAyABIAIgAyAEEM4KCxwAIAIgBCABIAMgASADSBsQYSIAIAEgA2sgABsLDQAgACABQQZBABDGBgsHACAAEMMCCxAAIABFBEBBAA8LIAAoAkwLNgEBf0EHIQECQCAARQ0AIAAtAGEQ6gJFBEBBkZwLEIgBQRUPCyAALQBXDQAgACgCQCEBCyABC14BAX9BoI0CIQECQCAARQ0AIAAtAGEQ6gJFBEBBwI0CDwsgAC0AVw0AIAAoAqQCEKIDIgFFBEAgACAAKAJAIgEgARDDAkEAELIBIAAoAqQCEKIDIQELIAAQ1AQLIAELLAEBf0F/IQECQCAARQ0AIAAtAGEQ6gJFDQAgACgCQEUNACAAKAJEIQELIAELGAAgACABNgKQAiAAKAKUAiAAIAI2ApQCCyMAIAAgAUEAIAFBAEoiARs2ApQCIABBJEEAIAEbNgKQAkEACzQBAX8gACgC+AEiBARAIAAoAvQBIAQRBAALIAAgAzYC+AEgACACNgL0ASAAIAE2AvwBQQALGAAgACABNgLoASAAKALkASAAIAI2AuQBCxgAIAAgATYC8AEgACgC7AEgACACNgLsAQsYACAAQQAQ1wkaIAAoAhgQRSAAEMUGQQALGAAgACABNgLgASAAKALcASAAIAI2AtwBCycAIAAgAzYC2AEgACACQQAgARsiAjYC1AEgACABQQAgAhs6AF5BAAsyACMAQRBrIgEkACABIAAoAgQoAgg2AgAgAEGRNCABEHsiAEF/EHEgABBFIAFBEGokAAszACAAIAAgAUF/EOAGIgEgAiADIAQgBSAGIAdBAEEAQQAQxAMhAiAAIAEQSCAAIAIQlgELGwAgACABIAIgAyAEQQAgBSAGIAcgCCAJEMgGCwsAIAAoAqgCQQBHCwYAQdyPAgsKACAAQQE2AqgCCzgAIABBADYCyAMgACABQQAgAUEASiIBGzYC9AMgACAAQQAgARs2AsQDIABBI0EAIAEbNgLAA0EACy4AIAAgAUEAIAFBAEoiARs2AvwCIAAgAkEAIAEbNgL0AiAAIANBACABGzYC+AILJAAgAEEANgL0AyAAQQA2AsgDIAAgAjYCxAMgACABNgLAA0EACwkAIABBARDaCQttAQN/An8gAQRAIAAgARDsASIBQR91IAFqDAELQQAhASAAKAIUQQFrCyEEQX8hAgNAIAEgBEpFBEAgACgCECABQQR0aigCBCIDBH8gAy0ACAVBAAsiAyACIAIgA0gbIQIgAUEBaiEBDAELCyACCwcAIAAoAnALcAACf0F/IAFFDQAaQQAhAAN/QRwgAEEcRg0BGiABIABBDGxBgNYDaigCABCwAQR/IABBAWohAAwBBSAACwsLIQADQCAAQRxGBEBBAA8LIABBAWoiAEEMbCIBQYTWA2ooAgBFDQALIAFBgNYDaigCAAsHACAAKAJoC8MCAgJ/An4jAEEQayIDJAAgAyACNgIMQQAhAgJAAkACQAJAIAFB6AdrDgIAAQILIAMgAygCDCIBQQRqNgIMIAAoAhAgASgCADYCAAwCCyADIAMoAgwiAUEEajYCDCABKAIEIQIgASgCACEEIAMgAUEMajYCDCAAIAQgAiABKAIIENwJIQIMAQsDQCACQRJGBEBBASECDAILIAJBA3QgAkEBaiECQZCMAmoiBCgCACABRw0ACyADIAMoAgwiAUEEajYCDCABKAIAIQIgAyABQQhqNgIMIAApAyAhBSABKAIEIQECQCAAAn4gAkEASgRAIAUgBDUCBIQMAQsgAg0BIAUgBDUCBEJ/hYMLIgY3AyAgBSAGUQ0AIABBABCkAgtBACECIAFFDQAgASAAKQMgIAQ1AgSDQgBSNgIACyADQRBqJAAgAgvFAQEGfwNAAkAgAgR/IAIFIAMgACgCFEgNAUEACyIBQQUgASAEGyACGw8LQQAhAgJAIAAoAhAgA0EEdGooAgQiAUUNACABLQAIQQJHDQAgASgCBCgCACIFKAIsIQECQCAFLQAPDQAgBSgC5AEoAgAQ3AQhBgNAIAEgBiICRXINASACKAIQIQZBACEBIAIpAyBCAFINACAFIAIQ8gohAQwACwALQQAgASABQQVGIgEbIQJBASAEIAEbIQQLIANBAWohAwwACwALBwAgACgCDAuyAQEBf0Go0gMoAgAEQBCJCkGo0gNBADYCAAtBuNIDKAIABEBByNEDKAIAIgAEQEHA0QMoAgAgABEEAAtBuNIDQQA2AgALQbTSAygCAARAQZDRAygCACIABEBBlNEDKAIAIAARBAALQfCMBEIANwMAQeiMBEIANwMAQeCMBEIANwMAQdiMBEIANwMAQbTSA0EANgIAQYSOBEEANgIAC0Gw0gMoAgAEQEGw0gNBADYCAAtBAAsKACAAQQdqQXhxCwoAIABBCGsoAgAL3QgCDX8BfiMAQRBrIgokAAJ/An8gAUEIaiEHIABBCGsiCUUEQCAHEPkBDAELIAdBQE8EQEGQiARBMDYCAEEADAELAn9BECAHQQtqQXhxIAdBC0kbIQQgCUEIayIAKAIEIghBeHEhAgJAIAhBA3FFBEAgBEGAAkkNASAEQQRqIAJNBEAgACEDIAIgBGtB9IsEKAIAQQF0TQ0CC0EADAILIAAgAmohBQJAIAIgBE8EQCACIARrIgNBEEkNASAAIAhBAXEgBHJBAnI2AgQgACAEaiICIANBA3I2AgQgBSAFKAIEQQFyNgIEIAIgAxC5BAwBC0GsiAQoAgAgBUYEQEGgiAQoAgAgAmoiAiAETQ0CIAAgCEEBcSAEckECcjYCBCAAIARqIgMgAiAEayICQQFyNgIEQaCIBCACNgIAQayIBCADNgIADAELQaiIBCgCACAFRgRAQZyIBCgCACACaiICIARJDQICQCACIARrIgNBEE8EQCAAIAhBAXEgBHJBAnI2AgQgACAEaiIGIANBAXI2AgQgACACaiICIAM2AgAgAiACKAIEQX5xNgIEDAELIAAgCEEBcSACckECcjYCBCAAIAJqIgMgAygCBEEBcjYCBEEAIQMLQaiIBCAGNgIAQZyIBCADNgIADAELIAUoAgQiBkECcQ0BIAZBeHEgAmoiCyAESQ0BIAsgBGshDSAFKAIMIQICQCAGQf8BTQRAIAUoAggiAyACRgRAQZSIBEGUiAQoAgBBfiAGQQN2d3E2AgAMAgsgAyACNgIMIAIgAzYCCAwBCyAFKAIYIQwCQCACIAVHBEAgBSgCCCIDIAI2AgwgAiADNgIIDAELAkAgBSgCFCIDBH8gBUEUagUgBSgCECIDRQ0BIAVBEGoLIQYDQCAGIQ4gAyICQRRqIQYgAigCFCIDDQAgAkEQaiEGIAIoAhAiAw0ACyAOQQA2AgAMAQtBACECCyAMRQ0AAkAgBSgCHCIDQQJ0QcSKBGoiBigCACAFRgRAIAYgAjYCACACDQFBmIgEQZiIBCgCAEF+IAN3cTYCAAwCCyAMQRBBFCAMKAIQIAVGG2ogAjYCACACRQ0BCyACIAw2AhggBSgCECIDBEAgAiADNgIQIAMgAjYCGAsgBSgCFCIDRQ0AIAIgAzYCFCADIAI2AhgLIA1BD00EQCAAIAhBAXEgC3JBAnI2AgQgACALaiIDIAMoAgRBAXI2AgQMAQsgACAIQQFxIARyQQJyNgIEIAAgBGoiAyANQQNyNgIEIAAgC2oiAiACKAIEQQFyNgIEIAMgDRC5BAsgACEDCyADCyIABEAgAEEIagwBC0EAIAcQ+QEiAEUNABogACAJQXxBeCAJQQRrKAIAIgNBA3EbIANBeHFqIgMgByADIAdJGxBEGiAJEPgBIAALIgAEQCAAIAGsNwMAIABBCGoMAQsgCSkDACEPIAogATYCBCAKIA8+AgBBB0GRzgAgChCPAUEACyAKQRBqJAALCgAgAEEIaxD4AQs/AQJ/QQAhAAJAA0AgAEEdRg0BIABBDGwhAiAAQQFqIQAgASACQYDWA2oiAigCABCwAQ0ACyACKAIEIQMLIAMLRgECfyMAQRBrIgEkAAJ/IABBCGoQ+QEiAgRAIAIgAKw3AwAgAkEIagwBCyABIAA2AgBBB0H4KyABEI8BQQALIAFBEGokAAsuAAJAIAEtAABB9gBHDQAgAS0ABEGAAXFFDQAgACgCACAAKAIYIAEQrgEaC0EAC/cDAQZ/IwBB0AJrIgEkACAAKAIAKAIUIQUgAigCABBKIQMgAigCBBBKIQYgBSgC7AIhCCAFQQA2AuwCIANFIAZFckUEQAJAIAFBOGoiByADIAUgBkEAEIkEIgNFBEAgAUIANwMoIAFBADYCMCABQQA2AhggAUIANwMgIAFCADcCECABQeAANgIMIAFB5AA2AgggASABQSBqNgIcIAEgBzYCBAJAAkAgASgCrAIiAwRAIAMtACtBAkYEQCADKAIsIgQgBCgCBEH///9+cTYCBCABQQA2AkQgByAEQQAQ5QFBByABKAJEIAUtAFcbIgMNAyABQQRqIAQQgwEaDAILIAFBBGogAygCEBB8GkEAIQMDQCADIAEoAqwCIgQuASJODQIgAUEEaiAEIAQoAgQgA0EMbGovAQgQpQEQZxogA0EBaiEDDAALAAsgASgCsAIiAwRAIAFBBGoiBCADKAIoEHwaIAQgASgCsAIoAiQQZxoMAQsgAUE4ahD5BCIDDQEgAUEEaiABKAK0AhDMBgsgACABQSBqIAZBAEEAEMsGIQMLIAUgASgCIBD4BCADRQ0BCwJAIANBAUcNACAFKQMgQoGAgIABg0IBUg0AIAAgAigCBBD+AQwBCyAAIAMQswILIAFBOGoQiAQLIAUgCDYC7AIgAUHQAmokAAv/AgIHfwJ+IwBBsAJrIgEkACAAKAIAKAIUIQQgAigCABBZIQogAigCBBBKIQYgAigCCBBZIQsgBCgCECAKpyICQQR0aigCACEDIAQoAuwCIQggBEEANgLsAgJAIAFBGGogAyAEIAYgAkEBRhCJBCICDQACQAJAIAEoAowCIgJFDQAgAi4BIiIDQQFGDQAgC6ciBSADSA0BC0GmoAcQR0ELIQIMAQsgAUEYaiIJQQAgBUEMbCIHIAIoAgRqKAIAEK4BIQMCQCAFIAIuASJBAWtIBEAgCUEAIAIoAgQgB2ooAgwQrgEoAgQhBSADKAIEIQIMAQsgBiACKAIsaiEFIAMoAgQhAgNAIAItAAAiB0UgB0EsRnINASADIAJBAWsiAjYCBAwACwALIAEgBTYCCCABIAY2AgQgASACIAZrNgIAIAAgBEGs1AAgARBYIgJBf0F/EFwgAhBFQQAhAgsgAUEYahCIBCAEIAg2AuwCIAIEQCAAIAIQswILIAFBsAJqJAALrwMCB38EfiMAQcACayIBJAAgACgCACgCFCEDIAIoAgAQSiEGIAIoAgQQSiEFIAIoAhAQWSELIAMpAyAhDCACKAIUEEohByACKAIYEFkhDSADKALsAiEJIANBADYC7AIgBkUgBUVyRQRAIAMpAyAhCiANpwRAIAMgCkL/////eYM3AyALIAFBKGoiCCAGIAMgBSALpxCJBCEEIAMgAykDICAKQoCAgIAGg4Q3AyBBASEFAkACQCAEDQACQCAMQoCAgCCDIgpCAFINACABKAKcAiIERQ0AIAQtACtBAkcNACABQgA3AiAgAUIANwIYIAFCADcCECABQgA3AgggASAINgIEIAggBCgCLCABQQRqEOUBIAEoAlBBAEcgASgCNEEAR3EhBQwBCyABKAKkAiIERQ0BIAMgClAEfyABQShqEPkEDQEgASgCpAIFIAQLKAIYEGMgAyAGEOwBRw0BIABBARCKAQwBCyAFRSAHRXINACADKQMgQoGAgIABg0IBUQ0AIAAgByACKAIIIAIoAgwgAUEoahDKBgsgAUEoahCIBAsgAyAJNgLsAiABQcACaiQAC0ABAX8CQCABLQAAQagBRw0AIAEtAAdBA3ENACAAKAIYIgIoAgwgASgCKEcNACAAKAIAIAIgAUEoahCuARoLQQALewEFfyABLwEGQaAIcQRAQQEPCyABKAIgIgNFBEBBAg8LIAAoAhghBCADQQhqIQUDQCADKAIAIAJKBEAgBSACQTBsaiIGKAIIIAQoAgxGBEAgACgCACAEIAYoAgAQrgEaCyACQQFqIQIMAQsLIAAgAUFAaygCABCzBUEAC7MHAgl/AX4jAEHwAmsiASQAIAAoAgAoAhQhBiACKAIAEEohAyACKAIMEEohCSACKAIQEEohByACKAIUEEohCiACKAIYEFkhDCAKRSAJRSAHRXJyRQRAIAYoAuwCIQsgBkEANgLsAiABQQA2AlAgAUIANwNIIAFCADcDQCAGIAcgAxCYASEEIAFBADYCOCABQgA3AjAgASAENgJMIAFB4gA2AiwgAUHjADYCKCABIAFBQGs2AjwgASABQdgAaiIINgIkAkAgCCADIAYgCSAMpxCJBCIDDQAgBikDICIMp0GAgIAgcSEFAkACQCABKALM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AoABQQFrNgIMIAFBKGoiAkGfhQEgARBVIAAgAhClBQsgAUGgAWokAAvaDAMFfwF8AX4jAEGwA2siAyQAAkAgAUUNACACKAIAEEoiBkUNACAAIAFBAWsgAkEEaiADQYADaiICEMoCDQAgACgCACgCFCgCeCEBIANBADsB/AIgA0EANgL4AiADIAE2AvQCIANBADYC8AIgA0IANwLoAiACEJIBIAIQhwJBACECQQAhAQNAAkAgASAGai0AACIEQSVHBEAgBA0BIAEgAksEQCADQegCaiACIAZqIAEgAmsQZAsgACADQegCahClBQwDCyABIAJLBEAgA0HoAmogAiAGaiABIAJrEGQLIAFBAmohAgJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgBiABQQFqIgFqLQAAIgRBxgBrDjIBAgMEBhQUCBQUCRQKDA0PEBEUEhQUFBQUFBQUFBQVFQACFBQFAwQHFBQJFBQLFA4UDhMLIANEHVpkO9//TUAgAysDoAMiCCAIRB1aZDvf/01AZBs5AxAgA0HoAmpBuoUBIANBEGoQVQwWCyADIAMoAogDNgIgIAMgAykCjAM3AiQgA0HoAmpBpqMBIANBIGoQVQwVCyADQbgCaiIFIANBgANqQTAQRBogA0EAOgDhAiADIAMpA7gCQQMgAykDgANCgNzMFHxCgLiZKX+nQQdva0GAuJkpbKx8NwO4AiAFEIsEIAMoAsACIQUgBEHnAEYEQCADIAVB5ABvNgIwIANB6AJqQbCjASADQTBqEFUMFQsgAyAFNgJAIANB6AJqQY2jASADQUBrEFUMFAsgAyADKAKUAzYCUCADQegCakGwowFBtaMBIARByABGGyADQdAAahBVDBMLIAMgAygClAMiBUEMayAFIAVBDEobIgVBDCAFGzYCYCADQegCakGwowFBtaMBIARByQBGGyADQeAAahBVDBILIAMgA0GAA2oQ+gRBAWo2AnAgA0HoAmpBkqMBIANB8ABqEFUMEQsgAyADKQOAA7lEAAAAAHCZlEGjOQOAASADQegCakGnhAEgA0GAAWoQVQwQCyADIAMoAowDNgKQASADQegCakGwowEgA0GQAWoQVQwPCyADIAMoApgDNgKgASADQegCakGwowEgA0GgAWoQVQwOCyADKAKUA0EMTgRAIANB6AJqQaS9AUH9+wAgBEHwAEYbQQIQZAwOCyADQegCakGtvQFBgv0AIARB8ABGG0ECEGQMDQsgAyADKQKUAzcDsAEgA0HoAmpBnKMBIANBsAFqEFUMDAsgAykDgAMhCSADLQCsA0EEcQRAIAMgCUKAxMzyg/kvfblEAAAAAABAj0CjOQPQASADQegCakHBhQEgA0HQAWoQVQwMCyADIAlC6Ad/QsDSjcWRBn03A8ABIANB6AJqQfOXASADQcABahBVDAsLIAMCfyADKwOgAyIImUQAAAAAAADgQWMEQCAIqgwBC0GAgICAeAs2AuABIANB6AJqQbCjASADQeABahBVDAoLIAMgAykClAM3A/ABIAMCfyADKwOgAyIImUQAAAAAAADgQWMEQCAIqgwBC0GAgICAeAs2AvgBIANB6AJqQZejASADQfABahBVDAkLIANB6AJqQQEgAykDgANCgJTmPXxCgLiZKX+nQQdvIgVBMGoiB0E3IAUbIAcgBEH1AEYbwBDvAgwICyADIANBgANqEPoEIAMpA4ADQoCU5j18QoC4mSl/p0EHb2tBB2pBB202AoACIANB6AJqQbCjASADQYACahBVDAcLIANBuAJqIgQgA0GAA2pBMBBEGiADQQA6AOECIAMgAykDuAJBAyADKQOAA0KA3MwUfEKAuJkpf6dBB29rQYC4mSlsrHw3A7gCIAQQiwQgAyAEEPoEQQdtQQFqNgKQAiADQegCakGwowEgA0GQAmoQVQwGCyADIANBgANqEPoEIAMpA4ADQoDczBR8QoC4mSl/p0EHb2tBB2pBB202AqACIANB6AJqQbCjASADQaACahBVDAULIAMgAygCiAM2ArACIANB6AJqQY2jASADQbACahBVDAQLIARBJUYNAgsgA0HoAmoQmwIMBAsgAyADKAKQAzYCACADQegCakGwowFBtaMBIARB5ABGGyADEFUMAQsgA0HoAmpBAUElEO8CCyABQQFqIQEMAAsACyADQbADaiQAC2wCAX8BfiMAQTBrIgMkAAJAIAAgASACIAMQygINACADEJIBIAMpAwAhBCADLQAsQQRxBEAgACAEQoDEzPKD+S99uUQAAAAAAECPQKMQbQwBCyAAIARC6Ad/QsDSjcWRBn0QhQELIANBMGokAAs8AQF/IwBBMGsiAyQAIAAgASACIAMQygJFBEAgAxCSASAAIAMpAwC5RAAAAABwmZRBoxBtCyADQTBqJAALwAEAIwBBoCBrIgAkACAAQQA2ApwgIABCADcCjCAgACACNgKYICAAIAM2ApQgAn8gAS0AAEEvRwRAIABBgCBBqNYDKAIAEQAARQRAQfTgAhDuAUEOQYCXASABQfTgAhDcAUEODAILIABBjCBqIAAQzwYLIABBjCBqIAEQzwYgAyAAKAKcICIBakEAOgAAAkAgAUECTgRAIAAoAowgRQ0BC0H64AIQ7gFBDgwBCyAAKAKQIEEAR0EJdAsgAEGgIGokAAtqACMAQeAAayIAJAACQCACRQRAQQAhAiADIAEgAEG01gMoAgARAAAEf0EABSAAKAIEQYDgA3FBgIACRyAAKQMYQgBVcgs2AgAMAQsgAyABQQZBnNYDKAIAEQAARTYCAAsgAEHgAGokAEEACzoBAn8gAEEIaiECA0AgASAAKAIETkUEQCACIAFBAnRqKAIAEK8BIAFBAWohAQwBCwsgACgCACAAEE0LCQAgAEEAEPEJCwkAIABBARDxCQuKAQEBfyAAQYABEGIiAQRAAkACQCABKAIERQRAIAEgADYCACABQQE7ARggAUIANwMQIAFC5AA3AwggASABQRpqNgIEQfsAIQMMAQtBLCEDIAEpAxBCAlQNAQsgASADEHQLIAEgADYCACABIAIoAgAQSiIAIAAQTBCABSABQToQdCABIAIoAgQQjwQLC9oBAgJ+BH8gAEEAEGIiAgRAIAIpAxAhAyACKAIEIQZBACEBQQEhAAJAA0AgAyAArSIEWA0BIAAgBmoiCC0AACIHQSxHIAFyIAVyBEACQAJAIAdB3ABHBEAgB0EiRw0BIAFFIQEMAgsgAEEBaiEADAELIAEEQEEBIQEMAQsgBSAHQd8BcSIBQdsARmogAUHdAEZrIQVBACEBCyAAQQFqIQAMAQsLIAIgAyAEfSIDNwMQIAZBAWogCEEBaiADp0EBaxCeARogBiACKAIQakEAOgAADwsgAkIBNwMQCwsJACAAQQAQ8gkLoAEBAX8jAEEQayIDJABBACEAAkAgAUHE1wMoAgARAQBBf0YEQEGKLiEAQZCIBCgCAEEsRg0BQYoUIQBBihRBp/8AIAFBxd8CENwBDAELIAJBAXFFDQAgASADQQxqQdDXAygCABEAAA0AIAMoAgwQ1QYEQEGKCkHgqgEgAUHP3wIQ3AFBigohAAtBACADKAIMQdHfAhDMAgsgA0EQaiQAIAALBAAjAAsJACAAQQEQ8gkLcgEBfyAAQYABEGIiAQRAAkACQCABKAIERQRAIAEgADYCACABQQE7ARggAUIANwMQIAFC5AA3AwggASABQRpqNgIEQdsAIQMMAQtBLCEDIAEpAxBCAlQNAQsgASADEHQLIAEgADYCACABIAIoAgAQjwQLC6oCAgJ/AX4jAEFAaiIEJABBASEDAkACQCABQQJGBEAgAigCBBBZIgVCAX1CDlYNASAFpyEDCwJAAkACQCACKAIAIgEvARBBP3FB8P8Bai0AAEEEaw4CAAQBCyABEI4ERQ0AIANBBHEEQEEBIQEMAgsgA0EIcUUEQEEAIQEMAgsgBEEQakEAQTAQRhogBCACKAIAEKsBNgIIIAQgAigCABBeIgE2AgwgBEEIakEAIAFBARCDBUUhAQwBC0EAIQEgA0EDcUUNACAAIAIoAgBBAhCuAiICBEACQCACLQAjBEAgABBvDAELIAItACINACADQQJxRQRAIAItACUNAQtBASEBCyACEK8BDAELIAAQbwsgACABEIoBDAELIABB38gBQX8QcQsgBEFAayQAC5gBAQJ/IAAgAigCAEEAEK4CIgQEQAJAAkACQCABQQJHDQAgAigCBBBKIgFFDQIgAS0AAEEkRw0BIARBACABQQFqQQAQ/AEiA0F9SQ0AAkAgA0EDag4CAgMACyAAQZm8AUF/EHEMAgsgACAEKAIAIANqLQAAQQ9xQQJ0QeCsA2ooAgBBf0EAEFwMAQsgACABEJAECyAEEK8BCwsoACABQQBKBEAgAUEBcUUEQCAAQb6WARD0CQ8LIAAgASACQQIQ8wkLC2kAIwBBgAFrIgEkACABQQE7ARggAUIANwMQIAFC5AA3AwggASABQRpqNgIEIAEgADYCACABIAIoAgAQjwQgAUEAQQAQigIgACgCACIAQcoAOgATIAAgAC8BEEGAEHI7ARAgAUGAAWokAAvCAQECfyMAQaABayIDJAAgA0EANgIcIANCADcCFCADIAAgAigCAEEAEK4CIgQ2AgwgBARAIAMgADYCICADQgA3AzAgA0LkADcDKCADIANBOmo2AiQgA0EBOwE4IAMgA0EgajYCECADAn8CQCABQQFHBEAgAyACKAIEEEoiADYCFCAADQELIANB1fsBNgIUQQQMAQsgABB2CzYCGCADQQxqQQAQ1wYaIANBIGpBAEEAEIoCIAMoAgwQrwELIANBoAFqJAALZQAgACACKAIAQQEQrgIiAQRAIAAgAigCBEEAEK4CIgIEQAJAAkACQAJAIAFBACACQQAQ2AYOBAACAgECCyAAIAEQ2gYMAgsgABBvDAELIABBmbwBQX8QcQsgAhCvAQsgARCvAQsL9gEBA38jAEGAAWsiAyQAAkAgAUEBcQRAIABBkMMAQX8QcQwBCyADIAA2AgAgA0EBOwEYIANCADcDECADQuQANwMIIAMgA0EaajYCBCADQfsAEHQDQCABIARKBEBChICQgICAgAIgAiAEQQJ0aiIFKAIAMwEQiKdBAXEEQCADEIQFIAMgBSgCABBKIAUoAgAQXhCABSADQToQdCADIAUoAgQQjwQgBEECaiEEDAIFIABB67IBQX8QcSADEM0CDAMLAAsLIANB/QAQdCADQQBBABCKAiAAKAIAIgBBygA6ABMgACAALwEQQYAQcjsBEAsgA0GAAWokAAtBAQF/IAFBAEoEQCAAKAIEKAIIQQRxIQMgAUEBcUUEQCAAQcY+QZ43IAMbEPQJDwsgACABIAJBBEEDIAMbEPMJCwvPBgENfyMAQYABayIDJAACQCABQQJIDQAgACACKAIAQQAQrgIiBkUNACAAKAIEKAIIIQkgAyAANgIAIANBATsBGCADQgA3AxAgA0LkADcDCCADIANBGmoiCzYCBCABQQJGIgxFBEAgA0HbABB0CyAJQQpxIQ0gCUEBcSEOIAlBA3EhD0EBIQoDQAJAAkACQAJAAkACQAJAAkAgASAKRwRAIAIgCkECdGoiCCgCABBKIgVFDQggBRBMIQcgBS0AAEEkRgRAIAZBACAFQQFqQQAQ/AEhBAwFCyAPRQ0FIAMgADYCACADQQE7ARggA0IANwMQIANC5AA3AwggAyALNgIEQQAhBELQoMGCBSAIKAIAMwEQiEIBg1BFBEAgA0GNsAFBARCfASAFLQAAQS1GBEAgA0Ge7wFBARCfAQsgAyAFIAcQiQIgA0GLsAFBAhCfAQwECwNAIAQgB0YNAiAEIAVqIARBAWohBC0AACIIQd8ARg0AIAhB0IACai0AAEEGcQ0ACyAFLQAAQdsARyAHQQJNckUEQCAFIAdqQQFrLQAAQd0ARg0DCyADQZD1AUECEJ8BIAMgBSAHEIkCIANBkfUBQQEQnwEMAwsgAUECRg0HIANB3QAQdCADQQBBABCKAiAJQQhxDQcgACgCACIAQcoAOgATIAAgAC8BEEGAEHI7ARAMBwsgA0Gt1AFBARCfAQsgAyAFIAcQiQILIAMQ2QYaIAZBACADKAIEQQAQ/AEhBCADEM0CCyAGKAIEIARLBEAgAUECRw0CIA4EQCADQQE7ARggA0IANwMQIANC5AA3AwggAyALNgIEIAMgADYCACAGIAQgAxCsAhogA0EAQQAQigIgAxDNAiAAKAIAIgRBygA6ABMgBCAELwEQQYAQcjsBEAwECyAGIAQgAEEAEIEFIA0NAyAGKAIAIARqLQAAQQ9xQQtJDQMgACgCACIEQcoAOgATIAQgBC8BEEGAEHI7ARAMAwsCQAJAIARBAmoOAgABAgsgDA0EIAMQhAUgA0HI/QBBBBCfAQwDCyAAQZm8AUF/EHEMAwsgACAFEJAEDAILIAMQhAUgBiAEIAMQrAIaCyAKQQFqIQoMAQsLIAMQzQIgBhCvAQsgA0GAAWokAAuSAgIDfwF+IwBBQGoiASQAIAFBCGoiBEEAQTgQRhogASAAKAIAKAIUNgIYIAIoAgAQjgQhBSACKAIAIQMCQAJ+IAUEQCABIAMQqwE2AgggASACKAIAEF4iAjYCDCAEQQAgAkEBEIMFrQwBCyABIAMQSiIDNgIUIANFDQEgASACKAIAEF42AhxCACABQQhqQQAQggVFDQAaQn8gAS0AKw0AGkEAIQIgASgCFCEDIAEoAiQhBQNAAkAgAiAFRg0AIAIgA2otAAAiBEUNACACQQFqIQIgBiAEQcABcUGAAUetfCEGDAELCyAGQgF8CyEGIAFBCGoQrQIgBkIAUwRAIAAQbwwBCyAAIAYQhQELIAFBQGskAAu2AQIDfwF+IAAgAigCAEEAEK4CIgQEQEEBIQUCQAJAIAFBAkcNACACKAIEEEoiAkUNASAEQQBB+cABIAJBAWogAi0AAEEkRxtBABD8ASIBQX1JBEAgASEDDAELQQAhBQJAAkACQCABQQNqDgIAAwELIAAgAhCQBAwBCyAAQZm8AUF/EHELCyAEKAIAIANqLQAAQQ9xQQtGBEAgBCADEPUJrSEGCyAFRQ0AIAAgBhCFAQsgBBCvAQsLpQEBAn8jAEGAAWsiAyQAIAMgADYCACADQQE7ARggA0IANwMQIANC5AA3AwggAyADQRpqNgIEIANB2wAQdCABQQAgAUEAShshAQNAIAEgBEZFBEAgAxCEBSADIAIgBEECdGooAgAQjwQgBEEBaiEEDAELCyADQd0AEHQgA0EAQQAQigIgACgCACIAQcoAOgATIAAgAC8BEEGAEHI7ARAgA0GAAWokAAu1AQEEfwJAIAFBAEwNACAAIAIoAgAgAUEBRxCuAiIDRQ0AQQEhBAJAAkACQANAIAEgBEYNASACIARBAnRqKAIAEEoiBUUNAyAFLQAAQSRHDQIgBS0AAUUNAyADQQA2AiggA0EBOgAnIARBAWohBCADQQAgBUEBakEAEPwBIgZBfUkgBkF+RnINAAsgBkF9Rg0BIABBmbwBQX8QcQwCCyAAIAMQ2gYMAQsgACAFEJAECyADEK8BCws8AQF8IAIoAgAQ/AJBA2tBfk8EQCAAQX8gAigCABBgIgNEAAAAAAAAAABkIANEAAAAAAAAAABjGxCKAQsL4AEBAn8CQEKq1arVqtWq1ap/IAIoAgAzARCIp0EBcQ0AIABBJBBiIgBFDQAgAigCABBKGiACKAIAEF4hAiAAIAAoAhgiA0EBazYCGAJAIAAoAiAiAQRAIANBAkgNASABKAIAIQQgASABQQRqIANBAnRBCGsQngEaIAIgBGohAgwBCyAAKAIcIAJqIQILAkAgAiAAKAIQIgFOBEAgAEEANgIQDAELIAAgASACayIBNgIQIAAoAgQiAyACIANqIAEQngEaIAAoAhANAQsgAEEANgIMIAAoAiAQRSAAQQA2AiALC4cBAQJ/IABBABBiIgIEQAJAIAItABQiAUEHRwRAIAFBEkcNASAAENgCDwsgABBvDwsgAigCECEBIAACfwJAIAIoAhhBAEoEQCABDQEgAEH8+wFBAUEAEFwPCyABDQBBACEBQQAMAQsgAigCBCABakEAOgAAIAIoAhAhASACKAIECyABQX8QXAsLHQEBfyAAQQAQYiIBBEAgACABEKUFIAEoAiAQRQsLhQMBA38CQEKq1arVqtWq1ap/IAIoAgAzARCIp0EBcQ0AIABBJBBiIgNFDQAgAygCDCEEIAMgACgCACgCFCgCeDYCDAJAIAFBAUYEQCAEBEAgA0EBQSwQ7wIMAgsgA0EBNgIcDAELIAIoAgQhAAJAAkACQCAEBEAgABBKIQAgAigCBBBeIQQCQCAARQRAQQAhBAwBCyADIAAgBBBkCyADKAIgIQAgAygCHCAERgRAIABFDQUMAgsgAA0BIAMoAhhBAnRBBGqtEFYiAUUNA0EBIAMoAhgiACAAQQFMG0EBayEFQQAhAANAIAAgBUYNAyABIABBAnRqIAMoAhw2AgAgAEEBaiEADAALAAsgAyAAEF42AhwMAwsgACADKAIYQQJ0rRCnASIBRQ0BCyADKAIYIgBBAEoEQCAAQQJ0IAFqQQRrIAQ2AgALIAMgATYCIAwBCyADQQcQqAMLIAMgAygCGEEBajYCGCACKAIAEEohACACKAIAEF4hASAARQ0AIAMgACABEGQLCz4AIABBCBBiIQACQCABBEBC1arVqtWq1arVACACKAIAMwEQiEIBg1ANAQsgAEUNACAAIAApAwBCAX03AwALCxoAIAAgAEEAEGIiAAR+IAApAwAFQgALEIUBCz4AIABBCBBiIQACQCABBEBC1arVqtWq1arVACACKAIAMwEQiEIBg1ANAQsgAEUNACAAIAApAwBCAXw3AwALC2oDAX8BfgJ8AkAgAEEAEGIiAUUNACABKQMYIgJCAFcNACAAAnwgAS0AIARAIAErAwAiAyABKwMIIgSgIAMgBL1C////////////AINCgICAgICAgPj/AFQbDAELIAEpAxC5CyACuqMQbQsLXQECfCAAAnxEAAAAAAAAAAAgAEEAEGIiAEUNABogAC0AIARAIAArAwAiASAAKwMIIgKgIAEgAr1C////////////AINCgICAgICAgPj/AFQbDAELIAApAxC5CxBtC6YBAgF+AX8gAEEoEGIiAEUgAigCABD8AiIEQQVGckUEQCAAIAApAxhCAX03AxggAC0AIEUEQCACKAIAEFkhAyAAIAApAxAgA303AxAPCyACKAIAIQEgBEEBRgRAIAEQWSIDQoCAgICAgICAgH9SBEAgAEIAIAN9EIUFDwsgAEL///////////8AEIUFIABEAAAAAAAA8D8QtQMPCyAAIAEQYJoQtQMLC30CAX8CfAJAIABBABBiIgFFDQAgASkDGEIAVw0AIAEtACAEQCABLQAhBEAgAEG7MEF/EHEPCyABKwMAIQIgASsDCCIDvUL///////////8A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KAIUIgIEQCABIAI2AiAgA0Go1AEgAUEgahBVCyABQThqIgMgBSgCECgCABDPASAHKAIAIgIEQCABIAI2AhAgA0GDugEgAUEQahBVCyABQThqENgBIgNFDQAgBSgCDCADQX8gAEEEakEAENoBIQIgAxBFIAIEQCABIAUoAgwQ8wI2AgAgBUGL6AAgARB7NgIIDAILIAAQhAshAgwBC0EHIQILIAFB0ABqJAAgAgsNACAAEKAHIAAQRUEACzYBAX9CGBBWIgJFBEBBBw8LIAJCADcDACACQgA3AxAgAkIANwMIIAIgADYCACABIAI2AgBBAAukAgEGfyMAQRBrIQMgAUKAgICAgICA+D83AygCQCAALQAURQ0AIAEoAgQhAiADQgA3AgggASgCACIFQQAgBUEAShshBQNAIAQgBUcEQAJAIAIoAgAiBiAALQAVIgdIDQAgAi0ABEECRw0AIAItAAVFBEBBEw8LIANBCGogBiAHa0ECdGogBEEBajYCAAsgAkEMaiECIARBAWohBAwBCwsgAygCCCIARQRAIAFC/////wc3AzAgAUKAgID+////78EANwMoDAELIAEoAhAiAiAAQQN0akEIayIAQQE6AAQgAEEBNgIAIAFCFDcDMCABQoCAgICAgICawAA3AyggAygCDCIABEAgAEEDdCACakEIayIAQQE6AAQgAEECNgIAC0EADwtBAAuuAwEDfyMAQZACayICJAAgAkEAOwGMAiACQgA3AoQCIAJByAE2AoACIAJBADYC+AEgAiACQTBqNgL8ASACQfgBakGMMBDPASABLQAGIQNBKCEGA0AgByABLQAHT0UEQCACIAY2AgAgAiADQQJ0QcCnAmooAgA2AgQgAkH4AWpB+/ABIAIQVSADQQFqIQMgB0EBaiEHQSwhBgwBCwsgB0UEQCACIAEoAgA2AiAgAkH4AWpBgvEBIAJBIGoQVUEBIQcLQQAhBiABLQAFIgNBIHEEfyACQfgBakHsvAEQzwFBASEGIAEtAAUFIAMLQf8BcUHAAE8EQCACQfgBakH4vAEQzwEgBkEBaiEGCyACQfgBaiIDQdnlAUEBEGQgAxDYARoCQAJAIAAgAkEwahCmBSIIRQRAQhgQViIDRQRAQQchCAwCCyADQRBqQgA3AgAgA0IANwIIIANCADcCACADIAE2AhAgAyAHOgAVIAMgADYCDCADIAY6ABRBACEIDAILIAIgABDzAjYCECAFQYvoACACQRBqEHs2AgALQQAhAwsgBCADNgIAIAJBkAJqJAAgCAsLv+kD2AIAQYAIC/kOTm8gZXJyb3IgaW5mb3JtYXRpb24ASWxsZWdhbCBieXRlIHNlcXVlbmNlAERvbWFpbiBlcnJvcgBSZXN1bHQgbm90IHJlcHJlc2VudGFibGUATm90IGEgdHR5AFBlcm1pc3Npb24gZGVuaWVkAE9wZXJhdGlvbiBub3QgcGVybWl0dGVkAE5vIHN1Y2ggZmlsZSBvciBkaXJlY3RvcnkATm8gc3VjaCBwcm9jZXNzAEZpbGUgZXhpc3RzAFZhbHVlIHRvbyBsYXJnZSBmb3IgZGF0YSB0eXBlAE5vIHNwYWNlIGxlZnQgb24gZGV2aWNlAE91dCBvZiBtZW1vcnkAUmVzb3VyY2UgYnVzeQBJbnRlcnJ1cHRlZCBzeXN0ZW0gY2FsbABSZXNvdXJjZSB0ZW1wb3JhcmlseSB1bmF2YWlsYWJsZQBJbnZhbGlkIHNlZWsAQ3Jvc3MtZGV2aWNlIGxpbmsAUmVhZC1vbmx5IGZpbGUgc3lzdGVtAERpcmVjdG9yeSBub3QgZW1wdHkAQ29ubmVjdGlvbiByZXNldCBieSBwZWVyAE9wZXJhdGlvbiB0aW1lZCBvdXQAQ29ubmVjdGlvbiByZWZ1c2VkAEhvc3QgaXMgZG93bgBIb3N0IGlzIHVucmVhY2hhYmxlAEFkZHJlc3MgaW4gdXNlAEJyb2tlbiBwaXBlAEkvTyBlcnJvcgBObyBzdWNoIGRldmljZSBvciBhZGRyZXNzAEJsb2NrIGRldmljZSByZXF1aXJlZABObyBzdWNoIGRldmljZQBOb3QgYSBkaXJlY3RvcnkASXMgYSBkaXJlY3RvcnkAVGV4dCBmaWxlIGJ1c3kARXhlYyBmb3JtYXQgZXJyb3IASW52YWxpZCBhcmd1bWVudABBcmd1bWVudCBsaXN0IHRvbyBsb25nAFN5bWJvbGljIGxpbmsgbG9vcABGaWxlbmFtZSB0b28gbG9uZwBUb28gbWFueSBvcGVuIGZpbGVzIGluIHN5c3RlbQBObyBmaWxlIGRlc2NyaXB0b3JzIGF2YWlsYWJsZQBCYWQgZmlsZSBkZXNjcmlwdG9yAE5vIGNoaWxkIHByb2Nlc3MAQmFkIGFkZHJlc3MARmlsZSB0b28gbGFyZ2UAVG9vIG1hbnkgbGlua3MATm8gbG9ja3MgYXZhaWxhYmxlAFJlc291cmNlIGRlYWRsb2NrIHdvdWxkIG9jY3VyAFN0YXRlIG5vdCByZWNvdmVyYWJsZQBQcmV2aW91cyBvd25lciBkaWVkAE9wZXJhdGlvbiBjYW5jZWxlZABGdW5jdGlvbiBub3QgaW1wbGVtZW50ZWQATm8gbWVzc2FnZSBvZiBkZXNpcmVkIHR5cGUASWRlbnRpZmllciByZW1vdmVkAERldmljZSBub3QgYSBzdHJlYW0ATm8gZGF0YSBhdmFpbGFibGUARGV2aWNlIHRpbWVvdXQAT3V0IG9mIHN0cmVhbXMgcmVzb3VyY2VzAExpbmsgaGFzIGJlZW4gc2V2ZXJlZABQcm90b2NvbCBlcnJvcgBCYWQgbWVzc2FnZQBGaWxlIGRlc2NyaXB0b3IgaW4gYmFkIHN0YXRlAE5vdCBhIHNvY2tldABEZXN0aW5hdGlvbiBhZGRyZXNzIHJlcXVpcmVkAE1lc3NhZ2UgdG9vIGxhcmdlAFByb3RvY29sIHdyb25nIHR5cGUgZm9yIHNvY2tldABQcm90b2NvbCBub3QgYXZhaWxhYmxlAFByb3RvY29sIG5vdCBzdXBwb3J0ZWQAU29ja2V0IHR5cGUgbm90IHN1cHBvcnRlZABOb3Qgc3VwcG9ydGVkAFByb3RvY29sIGZhbWlseSBub3Qgc3VwcG9ydGVkAEFkZHJlc3MgZmFtaWx5IG5vdCBzdXBwb3J0ZWQgYnkgcHJvdG9jb2wAQWRkcmVzcyBub3QgYXZhaWxhYmxlAE5ldHdvcmsgaXMgZG93bgBOZXR3b3JrIHVucmVhY2hhYmxlAENvbm5lY3Rpb24gcmVzZXQgYnkgbmV0d29yawBDb25uZWN0aW9uIGFib3J0ZWQATm8gYnVmZmVyIHNwYWNlIGF2YWlsYWJsZQBTb2NrZXQgaXMgY29ubmVjdGVkAFNvY2tldCBub3QgY29ubmVjdGVkAENhbm5vdCBzZW5kIGFmdGVyIHNvY2tldCBzaHV0ZG93bgBPcGVyYXRpb24gYWxyZWFkeSBpbiBwcm9ncmVzcwBPcGVyYXRpb24gaW4gcHJvZ3Jlc3MA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X3N0b3JlX2RpcmVjdG9yeQBub3QgYSB3cml0YWJsZSBkaXJlY3RvcnkAb3BlbkRpcmVjdG9yeQBzaHJpbmtfbWVtb3J5AG91dCBvZiBtZW1vcnkAZmFpbGVkIHRvIGFsbG9jYXRlICV1IGJ5dGVzIG9mIG1lbW9yeQBIQVZJTkcgY2xhdXNlIG9uIGEgbm9uLWFnZ3JlZ2F0ZSBxdWVyeQB0ZW1wb3JhcnkASW50Q29weQBTQ29weQBWRGVzdHJveQBTQVZFUE9JTlQgY2hhbmdlc2V0X2FwcGx5AFJPTExCQUNLIFRPIGNoYW5nZXNldF9hcHBseQBSRUxFQVNFIGNoYW5nZXNldF9hcHBseQBNdWx0aXBseQBxdWVyeV9vbmx5AHVubGlrZWx5AHRhYmxlICIlcyIgaGFzIG1vcmUgdGhhbiBvbmUgcHJpbWFyeSBrZXkAZm9yZWlnbiBrZXkAanNvbl9ncm91cF9hcnJheQBqc29uYl9ncm91cF9hcnJheQBqc29uX2FycmF5AGpzb25iX2FycmF5AGp1bGlhbmRheQB2YWN1dW1fJTAxNmxseAB1bml4AHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgATElLRSBvciBHTE9CIHBhdHRlcm4gdG9vIGNvbXBsZXgAdW5oZXgAY2hhcmluZGV4AE9wZW5BdXRvaW5kZXgAYXV0b21hdGljX2luZGV4AGF1dG8taW5kZXgAb3JwaGFuIGluZGV4AERyb3BJbmRleAB0YmwsIGlkeABSZW9wZW5JZHgAbWF4AE1lbU1heAAlMDJ4ADB4AENSRUFURSBUQUJMRSB4AHJ3AHBzb3cAaW1wbGllc19ub25udWxsX3JvdwBub3cAaW50ZWdlciBvdmVyZmxvdwB3aW5kb3cAc2hhZG93AFJlc3VsdFJvdwBJZk51bGxSb3cAbmV3AG5vIHN1Y2ggdmlldwBjYW5ub3QgbW9kaWZ5ICVzIGJlY2F1c2UgaXQgaXMgYSB2aWV3AENhbm5vdCBhZGQgYSBjb2x1bW4gdG8gYSB2aWV3AGNhbm5vdCBVUFNFUlQgYSB2aWV3AFByZXYAc3RkZXYAICVsbHUAJWMldQBGYWlsZWQgdG8gcmVhZCBwdHJtYXAga2V5PSV1ACUuKno6JXUAT2Zmc2V0ICV1IG91dCBvZiByYW5nZSAldS4uJXUAaW52YWxpZCBwYWdlIG51bWJlciAldQBmYWlsZWQgdG8gZ2V0IHBhZ2UgJXUAMm5kIHJlZmVyZW5jZSB0byBwYWdlICV1AEZyYWdtZW50YXRpb24gb2YgJXUgYnl0ZXMgcmVwb3J0ZWQgYXMgJXUgb24gcGFnZSAldQBmcmVlbGlzdCBsZWFmIGNvdW50IHRvbyBiaWcgb24gcGFnZSAldQBNdWx0aXBsZSB1c2VzIGZvciBieXRlICV1IG9mIHBhZ2UgJXUAJXMgaXMgJXUgYnV0IHNob3VsZCBiZSAldQB1bmFibGUgdG8gdXNlIGZ1bmN0aW9uICVzIGluIHRoZSByZXF1ZXN0ZWQgY29udGV4dABTb3J0ZXJOZXh0AFZOZXh0AGluY29tcGxldGUgaW5wdXQAYnVzeV90aW1lb3V0AGxvY2FsaG9zdABjYW5ub3QgZHJvcCBjb2x1bW4gIiVzIjogbm8gb3RoZXIgY29sdW1ucyBleGlzdABwZXJzaXN0AGZvcmVpZ25fa2V5X2xpc3QAaW5kZXhfbGlzdABmdW5jdGlvbl9saXN0AGNvbGxhdGlvbl9saXN0AGRhdGFiYXNlX2xpc3QAbW9kdWxlX2xpc3QAUFJBR01BIHRhYmxlX2xpc3QAcHJhZ21hX2xpc3QAc2V0IGxpc3QAVmFsdWVMaXN0AHNxbGl0ZV9yZW5hbWVfdGVzdABSb3dTZXRUZXN0AFNlcXVlbmNlVGVzdABmYXN0AExhc3QAQ2FzdABzcXJ0AFNvcnRlclNvcnQAIlwvYmZucnQAanNvbl9pbnNlcnQAanNvbmJfaW5zZXJ0AElkeEluc2VydABTb3J0ZXJJbnNlcnQAcmVzdGFydABjb3QAQml0Tm90AElmTm90AFBhZ2Vjb3VudABmcmVlbGlzdF9jb3VudABtYXhfcGFnZV9jb3VudABQUkFHTUEgIiV3Ii5wYWdlX2NvdW50AFJlc2V0Q291bnQAd2FsX2F1dG9jaGVja3BvaW50AHdhbF9jaGVja3BvaW50AENoZWNrcG9pbnQAU2F2ZXBvaW50AGEgQ0hFQ0sgY29uc3RyYWludAAlc09OIENPTkZMSUNUIGNsYXVzZSBkb2VzIG5vdCBtYXRjaCBhbnkgUFJJTUFSWSBLRVkgb3IgVU5JUVVFIGNvbnN0cmFpbnQAQ3Vyc29ySGludABwYXJlbnQARElTVElOQ1QgYWdncmVnYXRlcyBtdXN0IGhhdmUgZXhhY3RseSBvbmUgYXJndW1lbnQAY29tbWVudABBUEkgY2FsbGVkIHdpdGggZmluYWxpemVkIHByZXBhcmVkIHN0YXRlbWVudABBUEkgY2FsbGVkIHdpdGggTlVMTCBwcmVwYXJlZCBzdGF0ZW1lbnQAYXJndW1lbnQgdG8gJXMoKSBpcyBub3QgYSB2YWxpZCBTUUwgc3RhdGVtZW50AE1heFBnY250AGRlZmF1bHQgdmFsdWUgb2YgY29sdW1uIFslc10gaXMgbm90IGNvbnN0YW50AE11c3RCZUludABDYW5ub3QgYWRkIGEgY29sdW1uIHdpdGggbm9uLWNvbnN0YW50IGRlZmF1bHQASGFsdABzdGF0X2luaXQASW5pdABBdXRvQ29tbWl0AGFuYWx5c2lzX2xpbWl0AHNvZnRfaGVhcF9saW1pdABoYXJkX2hlYXBfbGltaXQAam91cm5hbF9zaXplX2xpbWl0AE9mZnNldExpbWl0AFNlZWtIaXQAT04gY2xhdXNlIHJlZmVyZW5jZXMgdGFibGVzIHRvIGl0cyByaWdodABTaGlmdFJpZ2h0AGhnaHQAU2hpZnRMZWZ0AE9mZnNldAByZXNldABTQVZFUE9JTlQgY2hhbmdlc2V0AFJFTEVBU0UgY2hhbmdlc2V0AGpzb25fc2V0AGpzb25iX3NldAB0b28gbWFueSBjb2x1bW5zIGluIHJlc3VsdCBzZXQAJXIgT1JERVIgQlkgdGVybSBkb2VzIG5vdCBtYXRjaCBhbnkgY29sdW1uIGluIHRoZSByZXN1bHQgc2V0AHN0YXRfZ2V0AHNxbGl0ZV9jb21waWxlb3B0aW9uX2dldABzb3VyY2UgYW5kIGRlc3RpbmF0aW9uIG11c3QgYmUgZGlzdGluY3QAc3RyaWN0AE5vQ29uZmxpY3QAanNvbl9ncm91cF9vYmplY3QAanNvbmJfZ3JvdXBfb2JqZWN0AGpzb25fb2JqZWN0AGpzb25iX29iamVjdABqc29uX2V4dHJhY3QAanNvbmJfZXh0cmFjdABTdWJ0cmFjdABsc3RhdABmc3RhdAB0YmwsaWR4LHN0YXQAdGJsLCA/Miwgc3RhdAB1bnN1cHBvcnRlZCBmaWxlIGZvcm1hdABncm91cF9jb25jYXQAQ29uY2F0AEx0AEd0AGRlZmVyX2ZvcmVpZ25fa2V5cwBhbHdheXMAcGFyYW1ldGVycyBhcmUgbm90IGFsbG93ZWQgaW4gdmlld3MAY29uY2F0X3dzAHN0YXR1cwBzeW5jaHJvbm91cwBpbmRleCAlcyBhbHJlYWR5IGV4aXN0cwBvdXRwdXQgZmlsZSBhbHJlYWR5IGV4aXN0cwAlcyAlVCBhbHJlYWR5IGV4aXN0cwB0cmlnZ2VyICVUIGFscmVhZHkgZXhpc3RzAE5vdEV4aXN0cwBpZ25vcmVfY2hlY2tfY29uc3RyYWludHMAQ0hFQ0sgY29uc3RyYWludHMAZXhwcmVzc2lvbnMgcHJvaGliaXRlZCBpbiBQUklNQVJZIEtFWSBhbmQgVU5JUVVFIGNvbnN0cmFpbnRzAGpzb25fb2JqZWN0KCkgcmVxdWlyZXMgYW4gZXZlbiBudW1iZXIgb2YgYXJndW1lbnRzAGpzb25fJXMoKSBuZWVkcyBhbiBvZGQgbnVtYmVyIG9mIGFyZ3VtZW50cwB1bmFibGUgdG8gZGVsZXRlL21vZGlmeSB1c2VyLWZ1bmN0aW9uIGR1ZSB0byBhY3RpdmUgc3RhdGVtZW50cwB1bmFibGUgdG8gZGVsZXRlL21vZGlmeSBjb2xsYXRpb24gc2VxdWVuY2UgZHVlIHRvIGFjdGl2ZSBzdGF0ZW1lbnRzAHJldmVyc2VfdW5vcmRlcmVkX3NlbGVjdHMAaWlzc3Nzc3MAaXNzAGNhbm5vdCBvcGVuIHNhdmVwb2ludCAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCByZWxlYXNlIHNhdmVwb2ludCAtIFNRTCBzdGF0ZW1lbnRzIGluIHByb2dyZXNzAGNhbm5vdCBjb21taXQgdHJhbnNhY3Rpb24gLSBTUUwgc3RhdGVtZW50cyBpbiBwcm9ncmVzcwBjYW5ub3QgVkFDVVVNIC0gU1FMIHN0YXRlbWVudHMgaW4gcHJvZ3Jlc3MAeFJhbmRvbW5lc3MAYWNjZXNzAHhBY2Nlc3MAcGFyYW1ldGVycwByZWN1cnNpdmVfdHJpZ2dlcnMAdGhlIElOREVYRUQgQlkgY2xhdXNlIGlzIG5vdCBhbGxvd2VkIG9uIFVQREFURSBvciBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAdGhlIE5PVCBJTkRFWEVEIGNsYXVzZSBpcyBub3QgYWxsb3dlZCBvbiBVUERBVEUgb3IgREVMRVRFIHN0YXRlbWVudHMgd2l0aGluIHRyaWdnZXJzAHF1YWxpZmllZCB0YWJsZSBuYW1lcyBhcmUgbm90IGFsbG93ZWQgb24gSU5TRVJULCBVUERBVEUsIGFuZCBERUxFVEUgc3RhdGVtZW50cyB3aXRoaW4gdHJpZ2dlcnMAQ2hpbGQgcGFnZSBkZXB0aCBkaWZmZXJzAHVuYWJsZSB0byBjbG9zZSBkdWUgdG8gdW5maW5hbGl6ZWQgc3RhdGVtZW50cyBvciB1bmZpbmlzaGVkIGJhY2t1cHMAYWNvcwBJZlBvcwBjb21waWxlX29wdGlvbnMARElTVElOQ1QgaXMgbm90IHN1cHBvcnRlZCBmb3Igd2luZG93IGZ1bmN0aW9ucwBGSUxURVIgY2xhdXNlIG1heSBvbmx5IGJlIHVzZWQgd2l0aCBhZ2dyZWdhdGUgd2luZG93IGZ1bmN0aW9ucwBub24tZGV0ZXJtaW5pc3RpYyBmdW5jdGlvbnMAaW5kZXggZXhwcmVzc2lvbnMAU0VMRUNUcyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgJXMgZG8gbm90IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHJlc3VsdCBjb2x1bW5zAHZpcnR1YWwgdGFibGVzIGNhbm5vdCB1c2UgY29tcHV0ZWQgY29sdW1ucwBnZW5lcmF0ZWQgY29sdW1ucwB0YWJsZSAlcyBoYXMgJWQgdmFsdWVzIGZvciAlZCBjb2x1bW5zAHJhZGlhbnMAYWxsIFZBTFVFUyBtdXN0IGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHRlcm1zAGVtcHR5X3Jlc3VsdF9jYWxsYmFja3MATG9hZEFuYWx5c2lzAGZsZ3MAZmxhZ3MAdmZzACVkIGNvbHVtbnMgYXNzaWduZWQgJWQgdmFsdWVzAEpTT04gY2Fubm90IGhvbGQgQkxPQiB2YWx1ZXMAZmFpbGVkIG1lbW9yeSByZXNpemUgJXUgdG8gJXUgYnl0ZXMAcGFydGlhbCBpbmRleCBXSEVSRSBjbGF1c2VzAHNob3J0X2NvbHVtbl9uYW1lcwBmdWxsX2NvbHVtbl9uYW1lcwB1bmFibGUgdG8gb3BlbiBhIHRlbXBvcmFyeSBkYXRhYmFzZSBmaWxlIGZvciBzdG9yaW5nIHRlbXBvcmFyeSB0YWJsZXMAY2Fubm90IGNyZWF0ZSB0cmlnZ2VycyBvbiBzaGFkb3cgdGFibGVzAGNhbm5vdCBjcmVhdGUgdHJpZ2dlcnMgb24gdmlydHVhbCB0YWJsZXMAJXMgUkVUVVJOSU5HIGlzIG5vdCBhdmFpbGFibGUgb24gdmlydHVhbCB0YWJsZXMAY2Fubm90IGpvaW4gdXNpbmcgY29sdW1uICVzIC0gY29sdW1uIG5vdCBwcmVzZW50IGluIGJvdGggdGFibGVzAEFVVE9JTkNSRU1FTlQgbm90IGFsbG93ZWQgb24gV0lUSE9VVCBST1dJRCB0YWJsZXMAJXMgY2Fubm90IHVzZSB2YXJpYWJsZXMAdG9vIG1hbnkgU1FMIHZhcmlhYmxlcwBzdWJxdWVyaWVzAGNhbm5vdCB1c2Ugd2luZG93IGZ1bmN0aW9ucyBpbiByZWN1cnNpdmUgcXVlcmllcwBzcWxpdGUzX2dldF90YWJsZSgpIGNhbGxlZCB3aXRoIHR3byBvciBtb3JlIGluY29tcGF0aWJsZSBxdWVyaWVzAGNvdW50X2NoYW5nZXMAdG90YWxfY2hhbmdlcwBkZWdyZWVzAFJFVFVSTklORyBtYXkgbm90IHVzZSAiVEFCTEUuKiIgd2lsZGNhcmRzAHRocmVhZHMAeERldmljZUNoYXJhY3RlcmlzdGljcwBhYnMALiUuKnMAQ1JFQVRFICVzICUuKnMAQ1JFQVRFJXMgSU5ERVggJS4qcwBpbnZhbGlkIHVyaSBhdXRob3JpdHk6ICUuKnMAdW5rbm93biB0YWJsZSBvcHRpb246ICUuKnMAJS4qcyVzACwlcyVzJXMAU0NBTiAlcyVzJXMAc3FsaXRlX2FsdGVydGFiXyVzAFNDQU4gJWQgQ09OU1RBTlQgUk9XJXMAJVElcwAweCV4OiVzACVkOiVzACVzOiAlcy4lcy4lcwBtaXNzaW5nIGRhdGF0eXBlIGZvciAlcy4lcwBjYW5ub3Qgc3RvcmUgJXMgdmFsdWUgaW4gJXMgY29sdW1uICVzLiVzAG5vbi0lcyB2YWx1ZSBpbiAlcy4lcwBURVhUIHZhbHVlIGluICVzLiVzAE5VTEwgdmFsdWUgaW4gJXMuJXMATlVNRVJJQyB2YWx1ZSBpbiAlcy4lcwAlczogJXMuJXMAbm8gc3VjaCB0YWJsZSBjb2x1bW46ICVzLiVzAERFTEVURSBGUk9NICVRLiVzAC4uJXMAJS4xOHMtJXMAc3VicnRuc2lnOiVkLCVzACBVU0lORyBJTlRFR0VSIFBSSU1BUlkgS0VZICglcwB1c2UgRFJPUCBWSUVXIHRvIGRlbGV0ZSB2aWV3ICVzAHJvdyBub3QgaW4gUFJJTUFSWSBLRVkgb3JkZXIgZm9yICVzAG1pc3VzZSBvZiBhbGlhc2VkIHdpbmRvdyBmdW5jdGlvbiAlcwB0b28gbWFueSBjb2x1bW5zIG9uICVzAHRvbyBtYW55IGNvbHVtbnMgaW4gJXMAJXMgcHJvaGliaXRlZCBpbiAlcwBDSEVDSyBjb25zdHJhaW50IGZhaWxlZCBpbiAlcwBub24tZGV0ZXJtaW5pc3RpYyB1c2Ugb2YgJXMoKSBpbiAlcwByZWNvdmVyZWQgJWQgcGFnZXMgZnJvbSAlcwBtaXN1c2Ugb2YgYWxpYXNlZCBhZ2dyZWdhdGUgJXMAdW5rbm93biBkYXRhYmFzZSAlcwAlcyAlVCBjYW5ub3QgcmVmZXJlbmNlIG9iamVjdHMgaW4gZGF0YWJhc2UgJXMAY2Fubm90IGRldGFjaCBkYXRhYmFzZSAlcwBhIEpPSU4gY2xhdXNlIGlzIHJlcXVpcmVkIGJlZm9yZSAlcwBjYW5ub3Qgb3BlbiB2YWx1ZSBvZiB0eXBlICVzAGNhbm5vdCBmc3RhdCBkYiBmaWxlICVzAHJlY292ZXJlZCAlZCBmcmFtZXMgZnJvbSBXQUwgZmlsZSAlcwBzcWxpdGUzY2hhbmdlc2V0X2FwcGx5KCk6IHByaW1hcnkga2V5IG1pc21hdGNoIGZvciB0YWJsZSAlcwBQUklNQVJZIEtFWSBtaXNzaW5nIG9uIHRhYmxlICVzAHVzZSBEUk9QIFRBQkxFIHRvIGRlbGV0ZSB0YWJsZSAlcwB0aGVyZSBpcyBhbHJlYWR5IGFuIGluZGV4IG5hbWVkICVzAHRhYmxlICVTIGhhcyBubyBjb2x1bW4gbmFtZWQgJXMAdGhlcmUgaXMgYWxyZWFkeSBhIHRhYmxlIG5hbWVkICVzAHN0YXRlbWVudCBhYm9ydHMgYXQgJWQ6IFslc10gJXMAQ09WRVJJTkcgSU5ERVggJXMAdW5zdXBwb3J0ZWQgdXNlIG9mIE5VTExTICVzAEFUVEFDSCAlUSBBUyAlcwBVU0UgVEVNUCBCLVRSRUUgRk9SICVzAC0tIFRSSUdHRVIgJXMAUklHSFQtSk9JTiAlcwA+PyBBTkQgJXMAJXo6ICVzAHJlY3Vyc2l2ZSByZWZlcmVuY2UgaW4gYSBzdWJxdWVyeTogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGNhbGxlZCByZWN1cnNpdmVseTogJXMAbm8gc3VjaCBpbmRleDogJXMAbm8gc3VjaCB3aW5kb3c6ICVzAGNhbm5vdCBvdmVycmlkZSAlcyBvZiB3aW5kb3c6ICVzAGNhbm5vdCBvcGVuIHZpZXc6ICVzAG5vIHN1Y2ggc2F2ZXBvaW50OiAlcwBjYW5ub3Qgb3BlbiB0YWJsZSB3aXRoIGdlbmVyYXRlZCBjb2x1bW5zOiAlcwBubyBzdWNoIHZmczogJXMAbXVsdGlwbGUgcmVjdXJzaXZlIHJlZmVyZW5jZXM6ICVzAGVycm9yIGluICVzICVzJXMlczogJXMAZXJyb3IgaW4gJXMgJXMgYWZ0ZXIgJXM6ICVzAG5vIHN1Y2ggY29sdW1uOiAlcwBmaWxlIHJlbmFtZWQgd2hpbGUgb3BlbjogJXMAZmlsZSB1bmxpbmtlZCB3aGlsZSBvcGVuOiAlcwB1bnN1cHBvcnRlZCBlbmNvZGluZzogJXMAY2Fubm90IGxpbWl0IFdBTCBzaXplOiAlcwBNSiBkZWxldGU6ICVzAHRhcmdldCBvYmplY3QvYWxpYXMgbWF5IG5vdCBhcHBlYXIgaW4gRlJPTSBjbGF1c2U6ICVzAG9iamVjdCBuYW1lIHJlc2VydmVkIGZvciBpbnRlcm5hbCB1c2U6ICVzAHVua25vd24gZGF0YWJhc2U6ICVzAHVuYWJsZSB0byBvcGVuIGRhdGFiYXNlOiAlcwBubyBzdWNoIGRhdGFiYXNlOiAlcwB0aGVyZSBpcyBhbHJlYWR5IGFub3RoZXIgdGFibGUgb3IgaW5kZXggd2l0aCB0aGlzIG5hbWU6ICVzAGR1cGxpY2F0ZSBjb2x1bW4gbmFtZTogJXMAZHVwbGljYXRlIFdJVEggdGFibGUgbmFtZTogJXMAbm8gc3VjaCBtb2R1bGU6ICVzAG11bHRpcGxlIGxpbmtzIHRvIGZpbGU6ICVzAGNhbm5vdCBvcGVuIHZpcnR1YWwgdGFibGU6ICVzAHNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkoKTogbm8gc3VjaCB0YWJsZTogJXMAbXVsdGlwbGUgcmVmZXJlbmNlcyB0byByZWN1cnNpdmUgdGFibGU6ICVzAG5vIHN1Y2ggJXMgbW9kZTogJXMATUogY29sbGlkZTogJXMAbm8gc3VjaCBjb2xsYXRpb24gc2VxdWVuY2U6ICVzAGNpcmN1bGFyIHJlZmVyZW5jZTogJXMAY2Fubm90IG9wZW4gdGFibGUgd2l0aG91dCByb3dpZDogJXMAJXMgbW9kZSBub3QgYWxsb3dlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGZhaWxlZDogJXMAYXV0b21hdGljIGV4dGVuc2lvbiBsb2FkaW5nIGZhaWxlZDogJXMAdnRhYmxlIGNvbnN0cnVjdG9yIGRpZCBub3QgZGVjbGFyZSBzY2hlbWE6ICVzAGFib3J0IGF0ICVkIGluIFslc106ICVzAC0tICVzACV6IC0gJXMAb3NfdW5peC5jOiVkOiAoJWQpICVzKCVzKSAtICVzAHdyAHJpZ2h0c3RyAGxlZnRzdHIAaW5zdHIAc3Vic3RyAGV4cHJfaW1wbGllc19leHByAHRoZSAiLiIgb3BlcmF0b3IAbmVhciAiJVQiOiBzeW50YXggZXJyb3IAaW50ZXJuYWwgcXVlcnkgcGxhbm5lciBlcnJvcgB1bmtub3duIGVycm9yAGRvbWFpbiBlcnJvcgBub3QgYW4gZXJyb3IAU1FMIGxvZ2ljIGVycm9yAGRpc2sgSS9PIGVycm9yAHhHZXRMYXN0RXJyb3IAZmxvb3IAcm1kaXIAbWtkaXIAcG93ZXIAbG93ZXIAc3FsaXRlX3RlbXBfbWFzdGVyAHNxbGl0ZV9tYXN0ZXIAUmVzZXRTb3J0ZXIARmtDb3VudGVyAHN0bXQtcG9pbnRlcgBBUEkgY2FsbCB3aXRoICVzIGRhdGFiYXNlIGNvbm5lY3Rpb24gcG9pbnRlcgBzdHJmaWx0ZXIAVkZpbHRlcgBFU0NBUEUgZXhwcmVzc2lvbiBtdXN0IGJlIGEgc2luZ2xlIGNoYXJhY3RlcgB1cHBlcgBwcm9wZXIAeFNobUJhcnJpZXIAY2Fubm90IHVzZSBSRVRVUk5JTkcgaW4gYSB0cmlnZ2VyAERyb3BUcmlnZ2VyAHNlY29uZCBhcmd1bWVudCB0byBudGhfdmFsdWUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAYXJndW1lbnQgb2YgbnRpbGUgbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXIAZnJhbWUgc3RhcnRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBmcmFtZSBlbmRpbmcgb2Zmc2V0IG11c3QgYmUgYSBub24tbmVnYXRpdmUgaW50ZWdlcgBJbnRlZ2VyAFJvd2lkICVsbGQgb3V0IG9mIG9yZGVyAFJlbWFpbmRlcgBmcmFtZSBzdGFydGluZyBvZmZzZXQgbXVzdCBiZSBhIG5vbi1uZWdhdGl2ZSBudW1iZXIAZnJhbWUgZW5kaW5nIG9mZnNldCBtdXN0IGJlIGEgbm9uLW5lZ2F0aXZlIG51bWJlcgBhZGRyAHBhZHIAY2hhcgB5ZWFyAENsZWFyAEJpdE9yAHNlcQBDb2xsU2VxAEVsc2VFcQByZWdleHAAT3BlbkR1cABOb29wAFNBVkVQT0lOVCByZXBsYWNlX29wAFJFTEVBU0UgcmVwbGFjZV9vcABKdW1wAC91c3IvdG1wAC92YXIvdG1wAHRlbXAAY3VycmVudF90aW1lc3RhbXAAeFN0ZXAAQWdnU3RlcABtb2RlU3RlcAB2YXJpYW5jZVN0ZXAAeFNsZWVwAG11bm1hcAB4U2htVW5tYXAAbW1hcABtcmVtYXAAeFNobU1hcABzcWxpdGVfcmV0dXJuaW5nXyVwAHZ0YWI6JXAAYXV0bwBHb3RvAGludG8AaW5jcmVtZW50YWxfdmFjdXVtIGVuYWJsZWQgd2l0aCBhIG1heCByb290cGFnZSBvZiB6ZXJvAElmTm90WmVybwBEZWNySnVtcFplcm8ARmtJZlplcm8Ac2Vxbm8AaW5kZXhfeGluZm8AdGFibGVfeGluZm8AaW5kZXhfaW5mbwB0YWJsZV9pbmZvAE9wZW5Qc2V1ZG8AZmNob3duAEJlZ2luU3VicnRuAFJldHVybgBqc29uAG5vIHF1ZXJ5IHNvbHV0aW9uAGluZGV4IGNvcnJ1cHRpb24AZGF0YWJhc2UgY29ycnVwdGlvbgBmcmVlIHNwYWNlIGNvcnJ1cHRpb24AanNvbl9lcnJvcl9wb3NpdGlvbgB1bmtub3duIGNvbHVtbiAiJXMiIGluIGZvcmVpZ24ga2V5IGRlZmluaXRpb24AJXMueEJlc3RJbmRleCBtYWxmdW5jdGlvbgBhdXRob3JpemVyIG1hbGZ1bmN0aW9uACUjVCgpIG1heSBub3QgYmUgdXNlZCBhcyBhIHdpbmRvdyBmdW5jdGlvbgAnJXMnIGlzIG5vdCBhIGZ1bmN0aW9uAEZ1bmN0aW9uAGNhbm5vdCBzdGFydCBhIHRyYW5zYWN0aW9uIHdpdGhpbiBhIHRyYW5zYWN0aW9uAGNhbm5vdCBjaGFuZ2UgJXMgd2FsIG1vZGUgZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgB0ZW1wb3Jhcnkgc3RvcmFnZSBjYW5ub3QgYmUgY2hhbmdlZCBmcm9tIHdpdGhpbiBhIHRyYW5zYWN0aW9uAGNhbm5vdCBWQUNVVU0gZnJvbSB3aXRoaW4gYSB0cmFuc2FjdGlvbgBTYWZldHkgbGV2ZWwgbWF5IG5vdCBiZSBjaGFuZ2VkIGluc2lkZSBhIHRyYW5zYWN0aW9uAFRyYW5zYWN0aW9uAFBlcm11dGF0aW9uAHVua25vd24gb3BlcmF0aW9uAHVuc3VwcG9ydGVkIGZyYW1lIHNwZWNpZmljYXRpb24AUkFOR0Ugd2l0aCBvZmZzZXQgUFJFQ0VESU5HL0ZPTExPV0lORyByZXF1aXJlcyBvbmUgT1JERVIgQlkgZXhwcmVzc2lvbgB0b28gbWFueSBsZXZlbHMgb2YgdHJpZ2dlciByZWN1cnNpb24AdXNlcl92ZXJzaW9uAHNxbGl0ZV92ZXJzaW9uAGRhdGFfdmVyc2lvbgBzY2hlbWFfdmVyc2lvbgBzcWxpdGVfZHJvcF9jb2x1bW4Ac3FsaXRlX3JlbmFtZV9jb2x1bW4AYWZ0ZXIgZHJvcCBjb2x1bW4Abm8gc3VjaCBjb2x1bW4AbXVzdCBoYXZlIGF0IGxlYXN0IG9uZSBub24tZ2VuZXJhdGVkIGNvbHVtbgBjYW5ub3QgdXNlIERFRkFVTFQgb24gYSBnZW5lcmF0ZWQgY29sdW1uAGFkZCBjb2x1bW4AQ2Fubm90IGFkZCBhIFBSSU1BUlkgS0VZIGNvbHVtbgBDYW5ub3QgYWRkIGEgVU5JUVVFIGNvbHVtbgBjYW5ub3QgYWRkIGEgU1RPUkVEIGNvbHVtbgBWQ29sdW1uAGJ1aWx0aW4AYXNpbgBhdCBtb3N0ICVkIHRhYmxlcyBpbiBhIGpvaW4AbWluAG9yaWdpbgBWQmVnaW4AbWFpbgBleHBsYWluAEV4cGxhaW4Ac2lnbgBvcGVuAHhPcGVuAElmTm90T3BlbgBTb3J0ZXJPcGVuAFZPcGVuAElmU2l6ZUJldHdlZW4AaGlkZGVuAGF0YW4AbWVkaWFuAFNlZWtTY2FuAFZJbml0SW4AYXV0b192YWN1dW0AaW5jcmVtZW50YWxfdmFjdXVtAEluY3JWYWN1dW0Ac3VtAGZsZXhudW0AcG0AZHJvcCBjb2x1bW4gZnJvbQAvZGV2L3VyYW5kb20AQWRkSW1tAHJ0cmltAGx0cmltAHJlYWRvbmx5X3NobQAlcy1zaG0AUkFJU0UoKSBtYXkgb25seSBiZSB1c2VkIHdpdGhpbiBhIHRyaWdnZXItcHJvZ3JhbQBQcm9ncmFtAFBhcmFtAGZjbnRsAGlvY3RsAHhGaWxlQ29udHJvbABsb2NraW5nIHByb3RvY29sAG5jb2wAbm90bnVsbABpZm51bGwAL2Rldi9udWxsAGRhdGFiYXNlIG9yIGRpc2sgaXMgZnVsbABOb3ROdWxsAFNvZnROdWxsAElzTnVsbABaZXJvT3JOdWxsAEhhbHRJZk51bGwAY29sbABjYWNoZV9zcGlsbABSb3dDZWxsAGNlaWwAZGV0YWlsAHBhZGwAdW5peC1leGNsAHRibAB3YWwAdmlydHVhbAB0b3RhbABpbmNyZW1lbnRhbABPcGVuRXBoZW1lcmFsAHhGaW5hbABBZ2dGaW5hbABub3JtYWwAcGFydGlhbAByZWFsAFJlYWwAcGsAb2sAdW5saW5rAHJlYWRsaW5rAEZpbmlzaFNlZWsARGVmZXJyZWRTZWVrAG5vbG9jawB4VW5sb2NrAEN1cnNvclVubG9jawAlcy5sb2NrAHhMb2NrAEN1cnNvckxvY2sAeFNobUxvY2sAVGFibGVMb2NrAHhDaGVja1Jlc2VydmVkTG9jawBpbnRlZ3JpdHlfY2hlY2sAZm9yZWlnbl9rZXlfY2hlY2sAcXVpY2tfY2hlY2sAY2VsbF9zaXplX2NoZWNrAEZrQ2hlY2sAVHlwZUNoZWNrAFZDaGVjawBJbnRlZ3JpdHlDawBpc3Npc2kAaXNpc2kAcGkAc2lzc2lpAGlzc2lzaWkAc3NzaWlpAGNvdGgAbW9udGgAanNvbl9hcnJheV9sZW5ndGgAb2N0ZXRfbGVuZ3RoAG92ZXJmbG93IGxpc3QgbGVuZ3RoAHdkdGgAc3RhdF9wdXNoAGFjb3NoAGFzaW5oAGF0YW5oAGpzb25fcGF0Y2gAanNvbmJfcGF0Y2gAZGF0YXR5cGUgbWlzbWF0Y2gAYWJicmV2aWF0ZWQgcXVlcnkgYWxnb3JpdGhtIHNlYXJjaAB1bml4ZXBvY2gAc3FsaXRlX2F0dGFjaABzcWxpdGVfZGV0YWNoAGpzb25fZWFjaABhdmcAbmFyZwBzcWxpdGVfbG9nAHN0YXRlbWVudCB0b28gbG9uZwBjYW5ub3Qgb3BlbiAlcyBjb2x1bW4gZm9yIHdyaXRpbmcAc3Vic3RyaW5nAFN0cmluZwBjZWlsaW5nAGVuY29kaW5nAHN0cmluZyBvciBibG9iIHRvbyBiaWcAc3RyaW5nX2FnZwBSZWxlYXNlUmVnACUuMTZnACUhMC4xNWcAJSEuMTVnAHByaW50ZgB0eXBlb2YAbW9kZW9mAG91dCBvZgByZW5hbWUgY29sdW1ucyBvZgBpbmYALUluZgBudWxsaWYAaWlmAG9mZgB0aW1lZGlmZgAwMTIzNDU2Nzg5YWJjZGVmAElmACVjJTA0ZC0lMDJkLSUwMmQgJTAyZDolMDJkOiUwNi4zZgAlLjNmADUwZgA0MGYAJSEuKmYAZ2V0cGFnZXNpemUAbW1hcF9zaXplAGNhY2hlX3NpemUAcGFnZV9zaXplAG9wdGltaXplAHhTZWN0b3JTaXplAHhGaWxlU2l6ZQBqc29uX3JlbW92ZQBqc29uYl9yZW1vdmUATW92ZQBjYW5ub3QgY29tbWl0IC0gbm8gdHJhbnNhY3Rpb24gaXMgYWN0aXZlAGNhbm5vdCByb2xsYmFjayAtIG5vIHRyYW5zYWN0aW9uIGlzIGFjdGl2ZQBleGNsdXNpdmUAdHJ1ZQBJc1RydWUAdW5pcXVlAGRmbHRfdmFsdWUAQ2Fubm90IGFkZCBhIFJFRkVSRU5DRVMgY29sdW1uIHdpdGggbm9uLU5VTEwgZGVmYXVsdCB2YWx1ZQBBZ2dWYWx1ZQBqc29uX3F1b3RlAHB3cml0ZQB4V3JpdGUAT3BlbldyaXRlAG9uX2RlbGV0ZQBzZWN1cmVfZGVsZXRlAElkeERlbGV0ZQBwcml2YXRlAGFnZ3JlZ2F0ZQBjcmVhdGUAVkNyZWF0ZQBvbl91cGRhdGUAVlVwZGF0ZQBjdXJyZW50X2RhdGUAZmFsbG9jYXRlAGZ0cnVuY2F0ZQB4VHJ1bmNhdGUAcmVwbGljYXRlAGJhZCBwYXJhbWV0ZXIgb3Igb3RoZXIgQVBJIG1pc3VzZQB0b28gbWFueSB0ZXJtcyBpbiAlcyBCWSBjbGF1c2UAdG9vIG1hbnkgdGVybXMgaW4gT1JERVIgQlkgY2xhdXNlAGFnZ3JlZ2F0ZSBmdW5jdGlvbnMgYXJlIG5vdCBhbGxvd2VkIGluIHRoZSBHUk9VUCBCWSBjbGF1c2UAUEFSVElUSU9OIGNsYXVzZQBhIE5BVFVSQUwgam9pbiBtYXkgbm90IGhhdmUgYW4gT04gb3IgVVNJTkcgY2xhdXNlAGRhdGFiYXNlICVzIGlzIGFscmVhZHkgaW4gdXNlAGRlc3RpbmF0aW9uIGRhdGFiYXNlIGlzIGluIHVzZQBBZ2dJbnZlcnNlAHJldmVyc2UAY2xvc2UAeENsb3NlAGZhbHNlAGF0dGVtcHQgdG8gd3JpdGUgYSByZWFkb25seSBkYXRhYmFzZQBjb3JydXB0IGRhdGFiYXNlAGF0dGFjaGVkIGRhdGFiYXNlcyBtdXN0IHVzZSB0aGUgc2FtZSB0ZXh0IGVuY29kaW5nIGFzIG1haW4gZGF0YWJhc2UAZmlsZSBpcyBub3QgYSBkYXRhYmFzZQB0ZW1wX3N0b3JlAHNxbGl0ZTNjaGFuZ2VzZXRfYXBwbHkoKTogdGFibGUgJXMgaGFzICVkIGNvbHVtbnMsIGV4cGVjdGVkICVkIG9yIG1vcmUAJXMgY2xhdXNlIHNob3VsZCBjb21lIGFmdGVyICVzIG5vdCBiZWZvcmUARXhwaXJlAHNxdWFyZQBleHByX2NvbXBhcmUAU29ydGVyQ29tcGFyZQBzdWJ0eXBlAFNldFN1YnR5cGUAR2V0U3VidHlwZQBDbHJTdWJ0eXBlAGpzb25fdHlwZQBJc1R5cGUASWZOb0hvcGUAdW5peC1ub25lAEluaXRDb3JvdXRpbmUARW5kQ29yb3V0aW5lAGxvY2FsdGltZQBzdHJmdGltZQBkYXRldGltZQBjdXJyZW50X3RpbWUAeEN1cnJlbnRUaW1lAHhGdWxsUGF0aG5hbWUAYWZ0ZXIgcmVuYW1lAG5vbi10ZXh0IGZpbGVuYW1lAFZSZW5hbWUAYW1iaWd1b3VzIGNvbHVtbiBuYW1lAHRlbXBvcmFyeSB0cmlnZ2VyIG1heSBub3QgaGF2ZSBxdWFsaWZpZWQgbmFtZQBsb3dlcl9xdWFydGlsZQB1cHBlcl9xdWFydGlsZQB1bml4LWRvdGZpbGUAY2Fubm90IG9wZW4gZmlsZQB1bmFibGUgdG8gb3BlbiBkYXRhYmFzZSBmaWxlAGltbXV0YWJsZQBBYm9ydGFibGUAbGVnYWN5X2FsdGVyX3RhYmxlAHNxbGl0ZV9yZW5hbWVfdGFibGUAY2Fubm90IGNyZWF0ZSB0cmlnZ2VyIG9uIHN5c3RlbSB0YWJsZQB2aXJ0dWFsIHRhYmxlAG5vIHN1Y2ggdGFibGUAbnVtYmVyIG9mIGNvbHVtbnMgaW4gZm9yZWlnbiBrZXkgZG9lcyBub3QgbWF0Y2ggdGhlIG51bWJlciBvZiBjb2x1bW5zIGluIHRoZSByZWZlcmVuY2VkIHRhYmxlAGxvY2FsIHRpbWUgdW5hdmFpbGFibGUAYW5vdGhlciByb3cgYXZhaWxhYmxlAG5vIG1vcmUgcm93cyBhdmFpbGFibGUAVmFyaWFibGUARHJvcFRhYmxlAHV0ZjE2bGUAVVRGMTZsZQBVVEYtMTZsZQBjYXNlX3NlbnNpdGl2ZV9saWtlAFNldENvb2tpZQBSZWFkQ29va2llAGNhY2hlAGNvbHVtbiBpbmRleCBvdXQgb2YgcmFuZ2UAbm90aWZpY2F0aW9uIG1lc3NhZ2UAd2FybmluZyBtZXNzYWdlAGludmFsaWQgcm9vdHBhZ2UARXh0ZW5kcyBvZmYgZW5kIG9mIHBhZ2UATUFYX1BBR0VfQ09VTlQ9MHhmZmZmZmZmZQBqc29uX3RyZWUAQ3JlYXRlQnRyZWUAam91cm5hbF9tb2RlAGxvY2tpbmdfbW9kZQBvcGNvZGUAdW5pY29kZQBieXRlY29kZQBKb3VybmFsTW9kZQBEaXZpZGUAY29hbGVzY2UAc3FsaXRlX3NlcXVlbmNlAFNlcXVlbmNlAGRpZmZlcmVuY2UAdmFyaWFuY2UAT25jZQBUcmFjZQBqc29uX3JlcGxhY2UAanNvbmJfcmVwbGFjZQB1dGYxNmJlAFVURjE2YmUAVVRGLTE2YmUATmUATGUAR2UAMjBjOjIwZQAyMGI6MjBlACUhMC4yMGUAZ2V0Y3dkAE1ha2VSZWNvcmQAdGhzdG5kcmQAbGlrZWxpaG9vZABmY2htb2QAcm91bmQATm90Rm91bmQAc3Vic2Vjb25kAFJld2luZABlbmQAU2Vla0VuZABCaXRBbmQAb2xkAG5vIHN1Y2ggcm93aWQ6ICVsbGQAWWllbGQAbGFzdF9pbnNlcnRfcm93aWQAJXMucm93aWQAU0VMRUNUKkZST00iJXciLiVzIE9SREVSIEJZIHJvd2lkAFNFTEVDVCpGUk9NIiV3Ii4lcyBXSEVSRSAlcyBPUkRFUiBCWSByb3dpZABJZHhSb3dpZABOZXdSb3dpZABTZWVrUm93aWQAZ2V0ZXVpZABpbnZhbGlkAGpzb25fdmFsaWQAZmtpZABjaWQAYXBwbGljYXRpb25faWQAc3FsaXRlX3NvdXJjZV9pZABub3QgYXV0aG9yaXplZAB1bmFibGUgdG8gaWRlbnRpZnkgdGhlIG9iamVjdCB0byBiZSByZWluZGV4ZWQAdmlld3MgbWF5IG5vdCBiZSBpbmRleGVkAHZpcnR1YWwgdGFibGVzIG1heSBub3QgYmUgaW5kZXhlZAB0YWJsZSAlcyBtYXkgbm90IGJlIGluZGV4ZWQAcmVhZF91bmNvbW1pdHRlZAByZWN1cnNpdmUgYWdncmVnYXRlIHF1ZXJpZXMgbm90IHN1cHBvcnRlZABxdWVyeSBhYm9ydGVkAHJvd3MgaW5zZXJ0ZWQAaW50ZXJydXB0ZWQAY2hlY2twb2ludGVkAGFjY2VzcyB0byAleiBpcyBwcm9oaWJpdGVkAGFjY2VzcyB0byB2aWV3ICIlcyIgcHJvaGliaXRlZAByb3dzIGRlbGV0ZWQAZ2VuZXJhdGVkAHJvd3MgdXBkYXRlZABub3R1c2VkAHJvdyB2YWx1ZSBtaXN1c2VkAHRhYmxlc191c2VkAHNxbGl0ZV9jb21waWxlb3B0aW9uX3VzZWQAUGFnZSAldTogbmV2ZXIgdXNlZABDb2x1bW5zVXNlZABzdG9yZWQAdmlydHVhbCB0YWJsZXMgbWF5IG5vdCBiZSBhbHRlcmVkAHZpZXcgJXMgbWF5IG5vdCBiZSBhbHRlcmVkAHRhYmxlICVzIG1heSBub3QgYmUgYWx0ZXJlZABzaGFyZWQAaW5kZXggYXNzb2NpYXRlZCB3aXRoIFVOSVFVRSBvciBQUklNQVJZIEtFWSBjb25zdHJhaW50IGNhbm5vdCBiZSBkcm9wcGVkAHRhYmxlICVzIG1heSBub3QgYmUgZHJvcHBlZAB2aWV3ICVzIGlzIGNpcmN1bGFybHkgZGVmaW5lZAB1bm9wZW5lZABkYXRhYmFzZSBkaXNrIGltYWdlIGlzIG1hbGZvcm1lZAAlcyBjb25zdHJhaW50IGZhaWxlZABGT1JFSUdOIEtFWSBjb25zdHJhaW50IGZhaWxlZABkYXRhYmFzZSAlcyBpcyBsb2NrZWQAZGF0YWJhc2UgaXMgbG9ja2VkAGRhdGFiYXNlIHRhYmxlIGlzIGxvY2tlZABhdXRob3JpemF0aW9uIGRlbmllZABhY2Nlc3MgcGVybWlzc2lvbiBkZW5pZWQAdGFibGUgJVMgaGFzICVkIGNvbHVtbnMgYnV0ICVkIHZhbHVlcyB3ZXJlIHN1cHBsaWVkAHRlbXBvcmFyeSB0YWJsZSBuYW1lIG11c3QgYmUgdW5xdWFsaWZpZWQAdGFibGUgJXMgbWF5IG5vdCBiZSBtb2RpZmllZABjb25mbGljdGluZyBPTiBDT05GTElDVCBjbGF1c2VzIHNwZWNpZmllZABubyB0YWJsZXMgc3BlY2lmaWVkAGRhdGFiYXNlIGlzIGFscmVhZHkgYXR0YWNoZWQAZGF0YWJhc2Ugc2NoZW1hIGhhcyBjaGFuZ2VkAGV4Y2x1ZGVkAFBhZ2UgJXU6IHBvaW50ZXIgbWFwIHJlZmVyZW5jZWQAUm93U2V0QWRkAEZpbHRlckFkZABwcmVhZAB4UmVhZABSb3dTZXRSZWFkAE9wZW5SZWFkACUwNGQAJTAzZAAlMDJkOiUwMmQ6JTAyZAAlMDRkLSUwMmQtJTAyZAAlMmQANDBmLTIxYS0yMWQANTBmLTIwYS0yMGQANDBmLTIwYS0yMGQAc3FsaXRlX3N0YXQlZABjb2x1bW4lZABzcWxpdGVfYXV0b2luZGV4XyVzXyVkAHZhcmlhYmxlIG51bWJlciBtdXN0IGJlIGJldHdlZW4gPzEgYW5kID8lZAB1bmFibGUgdG8gZ2V0IHRoZSBwYWdlLiBlcnJvciBjb2RlPSVkAGsoJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHJvb3RwYWdlPSVkIFdIRVJFICMlZCBBTkQgcm9vdHBhZ2U9IyVkAFVQREFURSAlUS5zcWxpdGVfbWFzdGVyIFNFVCB0eXBlPSclcycsIG5hbWU9JVEsIHRibF9uYW1lPSVRLCByb290cGFnZT0jJWQsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHR5cGU9J3RhYmxlJywgbmFtZT0lUSwgdGJsX25hbWU9JVEsIHJvb3RwYWdlPTAsIHNxbD0lUSBXSEVSRSByb3dpZD0jJWQAdG9vIG1hbnkgYXR0YWNoZWQgZGF0YWJhc2VzIC0gbWF4ICVkAHRvbyBtYW55IGFyZ3VtZW50cyBvbiAlcygpIC0gbWF4ICVkAGV4cGVjdGVkICVkIGNvbHVtbnMgZm9yICclcycgYnV0IGdvdCAlZABhdHRlbXB0IHRvIG9wZW4gIiVzIiBhcyBmaWxlIGRlc2NyaXB0b3IgJWQAYnRyZWVJbml0UGFnZSgpIHJldHVybnMgZXJyb3IgY29kZSAlZAAlciAlcyBCWSB0ZXJtIG91dCBvZiByYW5nZSAtIHNob3VsZCBiZSBiZXR3ZWVuIDEgYW5kICVkAHN1Yi1zZWxlY3QgcmV0dXJucyAlZCBjb2x1bW5zIC0gZXhwZWN0ZWQgJWQASU4oLi4uKSBlbGVtZW50IGhhcyAlZCB0ZXJtJXMgLSBleHBlY3RlZCAlZAAlc0xJU1QgU1VCUVVFUlkgJWQAUkVVU0UgTElTVCBTVUJRVUVSWSAlZAAlc1NDQUxBUiBTVUJRVUVSWSAlZABSRVVTRSBTVUJRVUVSWSAlZABJTkRFWCAlZAB0b28gbWFueSBGUk9NIGNsYXVzZSB0ZXJtcywgbWF4OiAlZAByd2MAdXRjAGRlc2MAY2hlY2twb2ludF9mdWxsZnN5bmMAZnVsbF9mc3luYwB4U3luYwBjaGFyaW5kZXhGdW5jAHNxcnRGdW5jAGNvdEZ1bmMAcmlnaHRGdW5jAGxlZnRGdW5jAGFjb3NGdW5jAGZsb29yRnVuYwBwb3dlckZ1bmMAc3RyZmlsdGVyRnVuYwBwcm9wZXJGdW5jAHBhZHJGdW5jAGV4cEZ1bmMAYXNpbkZ1bmMAc2lnbkZ1bmMAYXRhbkZ1bmMAY2VpbEZ1bmMAcGFkbEZ1bmMAY290aEZ1bmMAYWNvc2hGdW5jAGFzaW5oRnVuYwBhdGFuaEZ1bmMAbG9nRnVuYwByYWQyZGVnRnVuYwByZXZlcnNlRnVuYwBQdXJlRnVuYwBzcXVhcmVGdW5jAGRpZmZlcmVuY2VGdW5jAGRlZzJyYWRGdW5jAHBhZGNGdW5jAGF0bjJGdW5jAGxvZzEwRnVuYwBlbmMAbnVtZXJpYwAxPT1hcmdjAFNxbEV4ZWMAc3Vic2VjAHBhZGMAJS40YyVzJS4xNmMAZGVwcy9leHRlbnNpb24tZnVuY3Rpb25zLmMAJXMvZXRpbHFzXyVsbHglYwBHb3N1YgBnbG9iAHplcm9ibG9iAHJhbmRvbWJsb2IAQmxvYgBqc29uYgBtZW1kYgBSb3dEYXRhAFNvcnRlckRhdGEAc3FsaXRlX3RlbXBfc2NoZW1hAHNxbGl0ZV9zY2hlbWEAd3JpdGFibGVfc2NoZW1hAHRydXN0ZWRfc2NoZW1hAGNvcnJ1cHQgc2NoZW1hAFBhcnNlU2NoZW1hAHNxbGl0ZV8AcHJhZ21hXwBTUUxJVEVfAF9ST1dJRF8AJXMgYXQgbGluZSAlZCBvZiBbJS4xMHNdAGJpbmQgb24gYSBidXN5IHByZXBhcmVkIHN0YXRlbWVudDogWyVzXQBbJWxsZF0AW10AWwBMRUZULU1PU1QgU1VCUVVFUlkAQ09NUE9VTkQgUVVFUlkAQU5ZAGdlbmVyYXRlZCBjb2x1bW5zIGNhbm5vdCBiZSBwYXJ0IG9mIHRoZSBQUklNQVJZIEtFWQBBVVRPSU5DUkVNRU5UIGlzIG9ubHkgYWxsb3dlZCBvbiBhbiBJTlRFR0VSIFBSSU1BUlkgS0VZAEZPUkVJR04gS0VZAFVTRSBURU1QIEItVFJFRSBGT1IgJXNPUkRFUiBCWQBVU0UgVEVNUCBCLVRSRUUgRk9SIExBU1QgJWQgVEVSTVMgT0YgT1JERVIgQlkAR1JPVVAgQlkAaWlzWABpc2lYAEFVVE9NQVRJQyBQQVJUSUFMIENPVkVSSU5HIElOREVYAEFVVE9NQVRJQyBDT1ZFUklORyBJTkRFWAAtbWolMDZYOSUwMlgAU0NBTiBDT05TVEFOVCBST1cAVklFVwBqc29uX29iamVjdCgpIGxhYmVscyBtdXN0IGJlIFRFWFQARklSU1QATEFTVABFWENFUFQAIElOVABJZHhMVABTZWVrTFQAU0VUIERFRkFVTFQAT01JVF9BVVRPSU5JVABNVVRFWF9PTUlUAENPTU1JVABMSU1JVABSSUdIVABJZHhHVABTZWVrR1QATEVGVABESVNUSU5DVABSRVNUUklDVABJTlRFUlNFQ1QAdG9vIG1hbnkgdGVybXMgaW4gY29tcG91bmQgU0VMRUNUAHVua25vd24gam9pbiB0eXBlOiAlVCVzJVQlcyVUAC0lVAB0b28gbWFueSBhcmd1bWVudHMgb24gZnVuY3Rpb24gJVQAdW5rbm93biBkYXRhYmFzZSAlVABmb3JlaWduIGtleSBvbiAlcyBzaG91bGQgcmVmZXJlbmNlIG9ubHkgb25lIGNvbHVtbiBvZiB0YWJsZSAlVABDUkVBVEUgVklSVFVBTCBUQUJMRSAlVABoZXggbGl0ZXJhbCB0b28gYmlnOiAlcyUjVABubyBzdWNoIGZ1bmN0aW9uOiAlI1QAbm90IGF1dGhvcml6ZWQgdG8gdXNlIGZ1bmN0aW9uOiAlI1QAREVGQVVMVF9SRUNVUlNJVkVfVFJJR0dFUlMATElLRV9ET0VTTlRfTUFUQ0hfQkxPQlMAJXMgJVMAU0NBTiAlUwBubyBzdWNoIGluZGV4OiAlUwBjYW5ub3QgY3JlYXRlICVzIHRyaWdnZXIgb24gdmlldzogJVMAbm8gc3VjaCB0cmlnZ2VyOiAlUwBjYW5ub3QgY3JlYXRlIElOU1RFQUQgT0YgdHJpZ2dlciBvbiB0YWJsZTogJVMATUFURVJJQUxJWkUgJSFTAENPLVJPVVRJTkUgJSFTAFVTSU5HIElOREVYICVzIEZPUiBJTi1PUEVSQVRPUgBVU0lORyBST1dJRCBTRUFSQ0ggT04gVEFCTEUgJXMgRk9SIElOLU9QRVJBVE9SAE1VTFRJLUlOREVYIE9SAFNRTElURV9UTVBESVIAQ1JFQVRFIEJMT09NIEZJTFRFUgBBRlRFUgBJTlRFR0VSAE9SREVSAERFTEVURSBGUk9NICVRLiVzIFdIRVJFICVzPSVRAG5hbWU9JVEgQU5EIHNxbD0lUQBERUxFVEUgRlJPTSAlUS5zcWxpdGVfc2VxdWVuY2UgV0hFUkUgbmFtZT0lUQBBVFRBQ0ggeCBBUyAlUQBVUERBVEUgIiV3Ii5zcWxpdGVfc2VxdWVuY2Ugc2V0IG5hbWUgPSAlUSBXSEVSRSBuYW1lID0gJVEAVVBEQVRFICIldyIuc3FsaXRlX21hc3RlciBTRVQgc3FsID0gcHJpbnRmKCclJS4lZHMsICcsc3FsKSB8fCAlUSB8fCBzdWJzdHIoc3FsLDErbGVuZ3RoKHByaW50ZignJSUuJWRzJyxzcWwpKSkgV0hFUkUgdHlwZSA9ICd0YWJsZScgQU5EIG5hbWUgPSAlUQBiYWQgSlNPTiBwYXRoOiAlUQBTRVRVUABHUk9VUABSRUNVUlNJVkUgU1RFUABTTmFOAFFOYU4AbWFsZm9ybWVkIEpTT04ATk8gQUNUSU9OAEVOQUJMRV9TRVNTSU9OAE9NSVRfTE9BRF9FWFRFTlNJT04AVU5JT04AIExFRlQtSk9JTgBCRUdJTgAsYXJnIEhJRERFTgAsc2NoZW1hIEhJRERFTgBTQ0FOAERFRkFVTFRfQVVUT1ZBQ1VVTQAgTlVNAFBNAFJUUklNAEFNAENhbm5vdCBhZGQgYSBOT1QgTlVMTCBjb2x1bW4gd2l0aCBkZWZhdWx0IHZhbHVlIE5VTEwATk9UIE5VTEwAU0VUIE5VTEwAVU5JT04gQUxMACBSRUFMAEVOQUJMRV9QUkVVUERBVEVfSE9PSwBDSEVDSwBhYm9ydCBkdWUgdG8gUk9MTEJBQ0sATUFUQ0gAU0VBUkNIAFVTSU5HACBVTklRVUUARU5BQkxFX0JBVENIX0FUT01JQ19XUklURQBERUxFVEUAVVBEQVRFACV1LVJPVyBWQUxVRVMgQ0xBVVNFAFJFTEVBU0UATk9DQVNFAEJFRk9SRQBPTUlUX0RFQ0xUWVBFAE5PTkUASWR4TEUAU2Vla0xFAFRBQkxFADE2TEUAT01JVF9TSEFSRURfQ0FDSEUASWR4R0UAU2Vla0dFACVzIFVTSU5HIFRFTVAgQi1UUkVFAENBU0NBREUAMTZCRQBST1dJRABPSUQAT01JVF9ERVBSRUNBVEVEAERJUkVDVF9PVkVSRkxPV19SRUFEAFNZU1RFTV9NQUxMT0MAQkxPQgBCQkIARU5BQkxFX0JZVEVDT0RFX1ZUQUIAVVNFX0FMTE9DQQBAACVzOiAiJXMiIC0gc2hvdWxkIHRoaXMgYmUgYSBzdHJpbmcgbGl0ZXJhbCBpbiBzaW5nbGUtcXVvdGVzPwAlcz0/AHJvd2lkPT8AKSBWQUxVRVMoPwAgQU5EICg/ACBJUyA/ACA9ID8ALCA/ADxleHByPgAtPj4ALT4APABCRUdJTiBJTU1FRElBVEU7IENPTU1JVDsASU5TRVJUIElOVE8gJVEuc3FsaXRlX21hc3RlciBWQUxVRVMoJ2luZGV4JywlUSwlUSwjJWQsJVEpOwBDUkVBVEUgVEFCTEUgeCh0eXBlIFRFWFQsc2NoZW1hIFRFWFQsbmFtZSBURVhULHdyIElOVCxzdWJwcm9nIFRFWFQsc3RtdCBISURERU4pOwBDUkVBVEUgVEFCTEUgeChhZGRyIElOVCxvcGNvZGUgVEVYVCxwMSBJTlQscDIgSU5ULHAzIElOVCxwNCBURVhULHA1IElOVCxjb21tZW50IFRFWFQsc3VicHJvZyBURVhULG5leGVjIElOVCxuY3ljbGUgSU5ULHN0bXQgSElEREVOKTsAVVBEQVRFICVRLnNxbGl0ZV9tYXN0ZXIgU0VUIHRibF9uYW1lID0gJVEsIG5hbWUgPSBDQVNFIFdIRU4gdHlwZT0ndGFibGUnIFRIRU4gJVEgV0hFTiBuYW1lIExJS0UgJ3NxbGl0ZVhfYXV0b2luZGV4JSUnIEVTQ0FQRSAnWCcgICAgICBBTkQgdHlwZT0naW5kZXgnIFRIRU4gJ3NxbGl0ZV9hdXRvaW5kZXhfJyB8fCAlUSB8fCBzdWJzdHIobmFtZSwlZCsxOCkgRUxTRSBuYW1lIEVORCBXSEVSRSB0YmxfbmFtZT0lUSBDT0xMQVRFIG5vY2FzZSBBTkQgKHR5cGU9J3RhYmxlJyBPUiB0eXBlPSdpbmRleCcgT1IgdHlwZT0ndHJpZ2dlcicpOwA6bWVtb3J5OgBmaWxlOgAtOWU5OTkAOS4wZTk5OQArLSAKCTAxMjM0NTY3ODkAXHUwMDA5AFN0cmluZzgAdXRmOABVVEY4AFVURi04AE1BWF9GVU5DVElPTl9BUkc9MTI3AENPTVBJTEVSPWNsYW5nLTE5LjEuNwBERUZBVUxUX1NFQ1RPUl9TSVpFPTQwOTYAREVGQVVMVF9QQUdFX1NJWkU9NDA5NgBNQVhfVkFSSUFCTEVfTlVNQkVSPTMyNzY2AE1BWF9QQUdFX1NJWkU9NjU1MzYAVVRGMTYAVVRGLTE2AHA1AHRvbyBtYW55IHJlZmVyZW5jZXMgdG8gIiVzIjogbWF4IDY1NTM1AEZMQUdTIHBhcmFtZXRlciB0byBqc29uX3ZhbGlkKCkgbXVzdCBiZSBiZXR3ZWVuIDEgYW5kIDE1AHNxbGl0ZV9zdGF0NABwNABERUZBVUxUX0ZJTEVfRk9STUFUPTQAeEN1cnJlbnRUaW1lSW50NjQAcHdyaXRlNjQAcHJlYWQ2NABNQUxMT0NfU09GVF9MSU1JVD0xMDI0AHNxbGl0ZV9zdGF0MwBwMwBwMgBhdG4yAGF0YW4yAERFRkFVTFRfU1lOQ0hST05PVVM9MgBhcmdjPT0zIHx8YXJnYz09MgBNQVhfREVGQVVMVF9QQUdFX1NJWkU9ODE5MgAyMDI0LTEwLTIxIDE2OjMwOjIyIDAzYTk3MDNlMjdjNDQ0MzdjMzkzNjNkMGJhZjgyZGI0ZWJjOTQ1MzhhMGYyODQxMWM4NWRkYTE1NmY4MmFsdDEAU0VMRUNUIHRibCxpZHgsc3RhdCBGUk9NICVRLnNxbGl0ZV9zdGF0MQBBZ2dTdGVwMQBERUZBVUxUX1dBTF9TWU5DSFJPTk9VUz0xAEFUT01JQ19JTlRSSU5TSUNTPTEAVEVNUF9TVE9SRT0xAGFyZ2M9PTEAREVGQVVMVF9KT1VSTkFMX1NJWkVfTElNSVQ9LTEAUFJBR01BIGRlZmVyX2ZvcmVpZ25fa2V5cyA9IDEALCAxAFNFTEVDVCdJTlNFUlQgSU5UTyAlcy4nfHxxdW90ZShuYW1lKXx8JyBTRUxFQ1QqRlJPTSIldyIuJ3x8cXVvdGUobmFtZSlGUk9NICVzLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0ndGFibGUnQU5EIGNvYWxlc2NlKHJvb3RwYWdlLDEpPjAAU0VMRUNUIHNxbCBGUk9NICIldyIuc3FsaXRlX3NjaGVtYSBXSEVSRSB0eXBlPSd0YWJsZSdBTkQgbmFtZTw+J3NxbGl0ZV9zZXF1ZW5jZScgQU5EIGNvYWxlc2NlKHJvb3RwYWdlLDEpPjAAREVGQVVMVF9NRU1TVEFUVVM9MABEUVM9MABNQVhfV09SS0VSX1RIUkVBRFM9MABERUZBVUxUX1dPUktFUl9USFJFQURTPTAATUFYX0VYUFJfREVQVEg9MABNQVhfTU1BUF9TSVpFPTAAREVGQVVMVF9NTUFQX1NJWkU9MABUSFJFQURTQUZFPTAAOTIyMzM3MjAzNjg1NDc3NTgwAERFRkFVTFRfUENBQ0hFX0lOSVRTWj0yMABsb2cxMABNQVhfQVRUQUNIRUQ9MTAAXHUwMABNQVhfQ09NUE9VTkRfU0VMRUNUPTUwMAA/MDAwAE1BWF9DT0xVTU49MjAwMABERUZBVUxUX0NBQ0hFX1NJWkU9LTIwMDAAREVGQVVMVF9XQUxfQVVUT0NIRUNLUE9JTlQ9MTAwMABNQVhfVFJJR0dFUl9ERVBUSD0xMDAwAFx1MDAwMABNQVhfTElLRV9QQVRURVJOX0xFTkdUSD01MDAwMABNQVhfVkRCRV9PUD0yNTAwMDAwMDAATUFYX0xFTkdUSD0xMDAwMDAwMDAwAE1BWF9TUUxfTEVOR1RIPTEwMDAwMDAwMDAAc2Vjb25kIGFyZ3VtZW50IHRvICUjVCgpIG11c3QgYmUgYSBjb25zdGFudCBiZXR3ZWVuIDAuMCBhbmQgMS4wAFBSQUdNQSBkZWZlcl9mb3JlaWduX2tleXMgPSAwAFNFTEVDVCAwLCAndGJsJywgICcnLCAwLCAnJywgMSAgICAgVU5JT04gQUxMIFNFTEVDVCAxLCAnaWR4JywgICcnLCAwLCAnJywgMiAgICAgVU5JT04gQUxMIFNFTEVDVCAyLCAnc3RhdCcsICcnLCAwLCAnJywgMAAvcHJvYy9zZWxmL2ZkLwBJTlNFUlQgSU5UTyBtYWluLgBERUxFVEUgRlJPTSBtYWluLgBVUERBVEUgbWFpbi4AJVEuAE4uAC0ALABub3NraXBzY2FuKgB1bm9yZGVyZWQqAHN6PVswLTldKgBfcm93aWRfLCAqACBBTkQgKD8lZCBPUiA/JWQgSVMgJXcuJXcpAChzdWJxdWVyeS0ldSkAKGpvaW4tJXUpAEJhZCBwdHIgbWFwIGVudHJ5IGtleT0ldSBleHBlY3RlZD0oJXUsJXUpIGdvdD0oJXUsJXUpAG1heCByb290cGFnZSAoJXUpIGRpc2FncmVlcyB3aXRoIGhlYWRlciAoJXUpAENSRUFURSBUQUJMRSB4KHR5cGUgdGV4dCxuYW1lIHRleHQsdGJsX25hbWUgdGV4dCxyb290cGFnZSBpbnQsc3FsIHRleHQpACBBTkQgKD82IE9SID8zIElTIHN0YXQpAENSRUFURSBUQUJMRSAlUS4lcyglcykAYXV0b21hdGljIGluZGV4IG9uICVzKCVzKQBBTlkoJXMpAG1hbGZvcm1lZCBkYXRhYmFzZSBzY2hlbWEgKCVzKQBTRUxFQ1QgJXMlcyBGUk9NICVRLiVRIFdIRVJFICglcykgSVMgKCVzKQBNRVJHRSAoJXMpAENSRUFURSBUQUJMRSAlUS5zcWxpdGVfc2VxdWVuY2UobmFtZSxzZXEpAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9kcm9wX2NvbHVtbiglZCwgc3FsLCAlZCkgV0hFUkUgKHR5cGU9PSd0YWJsZScgQU5EIHRibF9uYW1lPSVRIENPTExBVEUgbm9jYXNlKQBtZW1kYiglcCwlbGxkKQAlcyglZCkAemVyb2Jsb2IoJWQpAChibG9iKQBVU0UgVEVNUCBCLVRSRUUgRk9SICVzKE9SREVSIEJZKQBVU0UgVEVNUCBCLVRSRUUgRk9SICVzKERJU1RJTkNUKQBVUERBVEUgIiV3Ii5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgJWQpIFdIRVJFIG5hbWUgTk9UIExJS0UgJ3NxbGl0ZVhfJSUnIEVTQ0FQRSAnWCcgIEFORCAodHlwZSAhPSAnaW5kZXgnIE9SIHRibF9uYW1lID0gJVEpAENSRUFURSBUQUJMRSB4KGtleSx2YWx1ZSx0eXBlLGF0b20saWQscGFyZW50LGZ1bGxrZXkscGF0aCxqc29uIEhJRERFTixyb290IEhJRERFTikAKE5VTEwpAChGSykAPzEsIChDQVNFIFdIRU4gPzI9WCcnIFRIRU4gTlVMTCBFTFNFID8yIEVORCkAJWM/KQBERUxFVEUgRlJPTSBtYWluLnNxbGl0ZV9zdGF0MSBXSEVSRSB0Ymw9PzEgQU5EIGlkeCBJUyBDQVNFIFdIRU4gbGVuZ3RoKD8yKT0wIEFORCB0eXBlb2YoPzIpPSdibG9iJyBUSEVOIE5VTEwgRUxTRSA/MiBFTkQgQU5EICg/NCBPUiBzdGF0IElTID8zKQBJTlNFUlQgSU5UTyBtYWluLnNxbGl0ZV9zdGF0MSBWQUxVRVMoPzEsIENBU0UgV0hFTiBsZW5ndGgoPzIpPTAgQU5EIHR5cGVvZig/Mik9J2Jsb2InIFRIRU4gTlVMTCBFTFNFID8yIEVORCwgPzMpAElOU0VSVCBJTlRPICVzLnNxbGl0ZV9zY2hlbWEgU0VMRUNUKkZST00gIiV3Ii5zcWxpdGVfc2NoZW1hIFdIRVJFIHR5cGUgSU4oJ3ZpZXcnLCd0cmlnZ2VyJykgT1IodHlwZT0ndGFibGUnQU5EIHJvb3RwYWdlPTApAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICVzKCkAbWlzdXNlIG9mICVzIGZ1bmN0aW9uICUjVCgpAHdyb25nIG51bWJlciBvZiBhcmd1bWVudHMgdG8gZnVuY3Rpb24gJSNUKCkAdW5zYWZlIHVzZSBvZiAlI1QoKQBPUkRFUiBCWSBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAEZJTFRFUiBtYXkgbm90IGJlIHVzZWQgd2l0aCBub24tYWdncmVnYXRlICUjVCgpAHVua25vd24gZnVuY3Rpb246ICUjVCgpAG1pc3VzZSBvZiBhZ2dyZWdhdGU6ICUjVCgpAGFtYmlndW91cyByZWZlcmVuY2UgdG8gJXMgaW4gVVNJTkcoKQBVUERBVEUgdGVtcC5zcWxpdGVfbWFzdGVyIFNFVCBzcWwgPSBzcWxpdGVfcmVuYW1lX2NvbHVtbihzcWwsIHR5cGUsIG5hbWUsICVRLCAlUSwgJWQsICVRLCAlZCwgMSkgV0hFUkUgdHlwZSBJTiAoJ3RyaWdnZXInLCAndmlldycpAFVQREFURSBzcWxpdGVfdGVtcF9zY2hlbWEgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfdGFibGUoJVEsIHR5cGUsIG5hbWUsIHNxbCwgJVEsICVRLCAxKSwgdGJsX25hbWUgPSBDQVNFIFdIRU4gdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UgQU5EICAgc3FsaXRlX3JlbmFtZV90ZXN0KCVRLCBzcWwsIHR5cGUsIG5hbWUsIDEsICdhZnRlciByZW5hbWUnLCAwKSBUSEVOICVRIEVMU0UgdGJsX25hbWUgRU5EIFdIRVJFIHR5cGUgSU4gKCd2aWV3JywgJ3RyaWdnZXInKQBQUkFHTUEgJyVxJy50YWJsZV9pbmZvKCclcScpAElOU0VSVCBJTlRPICVRLnNxbGl0ZV9tYXN0ZXIgVkFMVUVTKCd0cmlnZ2VyJywlUSwlUSwwLCdDUkVBVEUgVFJJR0dFUiAlcScpAAopAEJMT09NIEZJTFRFUiBPTiAlUyAoAFNFTEVDVCBzcWwgRlJPTSAiJXciLnNxbGl0ZV9zY2hlbWEgV0hFUkUgdHlwZT0naW5kZXgnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0naW5kZXgnAG5hbWU9JyVxJyBBTkQgdHlwZT0naW5kZXgnAERFTEVURSBGUk9NICVRLnNxbGl0ZV9tYXN0ZXIgV0hFUkUgbmFtZT0lUSBBTkQgdHlwZT0ndHJpZ2dlcicAREVMRVRFIEZST00gJVEuc3FsaXRlX21hc3RlciBXSEVSRSB0YmxfbmFtZT0lUSBhbmQgdHlwZSE9J3RyaWdnZXInAHRibF9uYW1lPSclcScgQU5EIHR5cGUhPSd0cmlnZ2VyJwAnJS4qcScAdHlwZT0ndHJpZ2dlcicgQU5EIG5hbWU9JyVxJwBpbmRleCAnJXEnAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfdGFibGUoJVEsIHR5cGUsIG5hbWUsIHNxbCwgJVEsICVRLCAlZCkgV0hFUkUgKHR5cGUhPSdpbmRleCcgT1IgdGJsX25hbWU9JVEgQ09MTEFURSBub2Nhc2UpQU5EICAgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJwBTRUxFQ1QgQ0FTRSBXSEVOIHF1aWNrX2NoZWNrIEdMT0IgJ0NIRUNLKicgVEhFTiByYWlzZShBQk9SVCwnQ0hFQ0sgY29uc3RyYWludCBmYWlsZWQnKSBXSEVOIHF1aWNrX2NoZWNrIEdMT0IgJ25vbi0qIHZhbHVlIGluKicgVEhFTiByYWlzZShBQk9SVCwndHlwZSBtaXNtYXRjaCBvbiBERUZBVUxUJykgRUxTRSByYWlzZShBQk9SVCwnTk9UIE5VTEwgY29uc3RyYWludCBmYWlsZWQnKSBFTkQgIEZST00gcHJhZ21hX3F1aWNrX2NoZWNrKCVRLCVRKSBXSEVSRSBxdWlja19jaGVjayBHTE9CICdDSEVDSyonIE9SIHF1aWNrX2NoZWNrIEdMT0IgJ05VTEwqJyBPUiBxdWlja19jaGVjayBHTE9CICdub24tKiB2YWx1ZSBpbionAFVQREFURSAiJXciLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgoJVEsIHNxbClXSEVSRSBuYW1lIE5PVCBMSUtFICdzcWxpdGVYXyUlJyBFU0NBUEUgJ1gnIEFORCBzcWwgTk9UIExJS0UgJ2NyZWF0ZSB2aXJ0dWFsJSUnAFVQREFURSB0ZW1wLnNxbGl0ZV9tYXN0ZXIgU0VUIHNxbCA9IHNxbGl0ZV9yZW5hbWVfcXVvdGVmaXgoJ3RlbXAnLCBzcWwpV0hFUkUgbmFtZSBOT1QgTElLRSAnc3FsaXRlWF8lJScgRVNDQVBFICdYJyBBTkQgc3FsIE5PVCBMSUtFICdjcmVhdGUgdmlydHVhbCUlJwBzcWxpdGVcXyUAJAAjAFNFTEVDVCpGUk9NIiV3IgBTRUxFQ1QqRlJPTSIldyIuIiV3IgBTRUxFQ1QgcmFpc2UoQUJPUlQsJVEpIEZST00gIiV3Ii4iJXciAEFOQUxZWkUgIiV3Ii4iJXciAGZvcmVpZ24ga2V5IG1pc21hdGNoIC0gIiV3IiByZWZlcmVuY2luZyAiJXciAGRvdWJsZS1xdW90ZWQgc3RyaW5nIGxpdGVyYWw6ICIldyIALiIlLipzIgBzeW50YXggZXJyb3IgYWZ0ZXIgY29sdW1uIG5hbWUgIiUuKnMiACVjIiVzIgAoIiVzIgBjYW5ub3QgJXMgJXMgIiVzIgBnZW5lcmF0ZWQgY29sdW1uIGxvb3Agb24gIiVzIgBjYW5ub3QgSU5TRVJUIGludG8gZ2VuZXJhdGVkIGNvbHVtbiAiJXMiAGVycm9yIGluIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgBjYW5ub3QgVVBEQVRFIGdlbmVyYXRlZCBjb2x1bW4gIiVzIgAlcyBpbiAiJXMiAHRyaWdnZXIgIiVzIiBtYXkgbm90IHdyaXRlIHRvIHNoYWRvdyB0YWJsZSAiJXMiAFVQU0VSVCBub3QgaW1wbGVtZW50ZWQgZm9yIHZpcnR1YWwgdGFibGUgIiVzIgB1bnNhZmUgdXNlIG9mIHZpcnR1YWwgdGFibGUgIiVzIgBjYW5ub3QgY3JlYXRlIGEgVEVNUCBpbmRleCBvbiBub24tVEVNUCB0YWJsZSAiJXMiAG5vIHN1Y2ggaW5kZXg6ICIlcyIAdW5rbm93biBkYXRhdHlwZSBmb3IgJXMuJXM6ICIlcyIAY2Fubm90IGRyb3AgJXMgY29sdW1uOiAiJXMiAG5vIHN1Y2ggY29sdW1uOiAiJXMiAHVucmVjb2duaXplZCB0b2tlbjogIiVzIgBcIgBubyBzdWNoIGNvbHVtbjogIiVUIgB1bnJlY29nbml6ZWQgdG9rZW46ICIlVCIALiIAd2Vla2RheSAAbm9uLXVuaXF1ZSBlbnRyeSBpbiBpbmRleCAAd3JvbmcgIyBvZiBlbnRyaWVzIGluIGluZGV4IAAgdmFsdWVzIGRpZmZlciBmcm9tIGluZGV4IAAgbWlzc2luZyBmcm9tIGluZGV4IAAgb2YgaW5kZXggAHJvd2lkIG5vdCBhdCBlbmQtb2YtcmVjb3JkIGZvciByb3cgACVyIABzdGFydCBvZiAAIFVTSU5HIENPVkVSSU5HIElOREVYIAAgVklSVFVBTCBUQUJMRSBJTkRFWCAAIFNFVCAAIE9SIABTRUxFQ1QgMSBGUk9NICIldyIuc3FsaXRlX21hc3Rl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B04HPgfpBuYG6QYeB+kG6QbBBlEH+Qb5Bj4HlQYfBx8HMAcwB/IG9gZ1B5UG8wbyBv0GCAerBn8HkweTB5wHnAecB58InwifCJ8InwifCJ8InwifCJ8InwifCJ8InwifCEUADQRPAEAEiwKsBIcF3QWfBVkFrAWPA7sE9AW9BQ8GHwYiBlgGaAZsBtsFoAUkBrgFPQYTAQ4DMgZwBo4GEQaSBpcGbAXeBaAGqgY0Bs4Fswe3B6UHHAe0B7UHrQevBzsHMQdFB7EHsQe2BzwHuAc/B70HzgdCB08HsQdQB5YHsAexB0AHoAehB6MHpAdZB2gHvAdSB94H3wfNB3EHRAeiB88HrAeeB8oHZgeBB+QH4gfqB3sHgwfsB8AH9Af4B/8H+QfTB9wHAgi7BwEICAjbB/wHCQgACI4HDwgQCBEIDQgSCBQIyQenBxUIFwi6Bw4IGwimBxkIFggYCBwIHgjaB+sH5gcaCO8H4wchCCIILggtCC8IMAglCL8Hwgc0CBkINQg4CDsIPQg8CD4IPwhCCEkIQwhECEUIRghKCEsITAjXB9QH1QfWB00IUAhZCFoIaAgAABQBFQEWAfAA8QDgAMIA4gDCAPAA8QDCANgA3ADCAOoA/QDCAP8AEwDgACkB/QDCAP8AzQDUANUAzQDZANoAHwDNAMIA2QDaAMIA2QDaACcA2QDaADgBKwAsAC0APAEvADAAMQAyADMANAA1ADYANwA4ADkAOgATAPAA8QDCAPAA8QDCAP4A8ADxABQBFQEWAekA/QD+AP8A/QD+AP8A2QD9AO8A/wArACwALQAHAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AA4BHgEWABcAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAUgAvADAAMQAyALoAuwC8AL0AvgC/AL0AVwC/AFkAxAATAMYAxAA9AcYAPwEZAMIAzQAqAQ4BzQBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgArACwALQALAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ADwAiwCMAPAA8QDWAPAA8QA3ATgBZgBGAO8APAHCABMA/QBNAP8A/QB6AP8ANwA4ADkAOgA7AM8AWADCAFoADAHCAF0ADAFrAGwAbQBuAG8AcABxAHIALwBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgByAHUAdgB3ABQBFQEWASwBEwDCACwBFAEVARYBZwBoAGkAagBrAGwAbQBuAG8AcABxAHIANwA4ADkAOgCSAMIAKwAsAC0ALwAvADAAMQAyADMANAA1ADYANwA4ADkAOgBSAIEAggA8AIEAggDZANoAdABEABkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAFwCEACYBZwBoAGkAagBrAGwAbQBuAG8AcABxAHIA2QB5ADIBwgA0ARoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAdACLAIwA2QB1AHYAdwB4ABMAwgB7AHwAfQAYAG0AbgBvAHAAcQByAIUAPAA3ATgB+gDCAPwAPAETAMIApgCnACsALAAtAM0ALwAwADEAMgAzADQANQA2ADcAOAA5ADoA2QDaAD0BPgErACwALQAIAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AIsAjADwAPEAiwCMALwAvQC+AL8AdQB2AHcA5wDEAP0AxgD/AMIAwgACAQMBkgDNAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAG0A1ADVAOwA7QDZANoAwgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCAHgA8ADxAHsAfAB9AIgAwgATAEoAPACNABcAhQD9AMIA/wBSAMIANQE2Af4AHQA9AT4BwgAhABYAxwAMAQcB7wArACwALQCXAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ANkA2gDCADwAEwCSAB4B8gAXAGsAbABCAMwALAHOAIAASQA8AHQAdQB2AHcACQF5AKUAPACLAIwAKwAsAC0AgQAvADAAMQAyADMANAA1ADYANwA4ADkAOgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgCaAMIAnADCAHUAdgB3ABgBGwHNAGUA3AAfARMAFAAyARYANAF1AHYAdwDTANQA1QDZANoAdQB2AOwA7QAkAHoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIA8ADxAMIAPADCAMIAwgDCABMAwgA8AMIAFwD9AM4A/wBJAP4AEwCaAJsAnABIABQBFQEWAQcB2QDaANkA2gAPASsALAAtAA8BLwAwADEAMgAzADQANQA2ADcAOAA5ADoAtwDCAB0BZQATANYAPADyABcAawBsAG0AdQB2AHcAEAD+AHMA/gB1AHYAdwDCADwAegAHAc0ACAErACwALQAIAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AGcAaABpAGoAawBsAG0AbgBvAHAAcQByAJoAmwCcAJ0AngDwAPEAdQB2AHcAZQDNAHUAEwAUADIBFgA0Af0ASgD/AE4AzQBQAHUAdgB3AHYAJQG3ACQAegBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCACYB8ADxANMA1ADVAJAAEwAXADwAGQAXAPAA8QD9APUA/wAPAJoAmwCcAEgA2QDaAMIA/QAAAf8AgACBAIIAKwAsAC0AFgAvADAAMQAyADMANAA1ADYANwA4ADkAOgC3ABMATQBlABMAgACBAIIAFwBrAGwAPAD+AFgAFQBaAD0AcwBdAHUAdgB3AO8AFgB6ADwAwgDNACsALAAtAM0ALwAwADEAMgAzADQANQA2ADcAOAA5ADoAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAmgCbAJwAnQCeADwA8ADxADwAdADwAPEAdQB2AHcAkgDCABMAUQD9ABMB/wAYAP0AYgD/AHUAdgB3ALcAFgDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAJcAwgAOAZgAFgAXAMIAGQATAMoA2QDaABcAbQDPADoBOwF8AHUAdgB3AHUAdgB3ADwA6AAWABcAEwAZAC8BMAErACwALQAWAC8AMAAxADIAMwA0ADUANgA3ADgAOQA6AA4B4wBgADwAKwAsAC0AogAvADAAMQAyADMANAA1ADYANwA4ADkAOgByAHAAcQByAMIAPAB4AHkAegB7AHwAfQB+AHUAdgB3AGYAGQCEAGsAbADCAMIA4wBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCAMIAZgDCAHUAdgB3AOkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAwgDCABMAwgDZANoAdQB2AHcA8QCaAJAAnACHAPIAiQCKAIIAEwDoAMIA/QAXAP8A2QDaANkA2gDyABAABwAIAAkAGQAFAQYBCQHCABMA6ACZAOgAKwAsAC0AoAAvADAAMQAyADMANAA1ADYANwA4ADkAOgDCAOMA2QDaACsALAAtAMIALwAwADEAMgAzADQANQA2ADcAOAA5ADoAMgGPADQB2QDaACYBDABNABYAFwDZANoAwgBOADIBUAA0AcIA6AD+AFoAGwB1AF0AZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAKgDCACMAwgDZANoA1gDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAMIA7wBAAMIA2QDaANkA2gDRANIA2QDaAEoAzwBDABYAwgBNABMA6AD1AOgASwAYADgB6ADZANoAPAEZAFoAAAFmAF0AnwDlAKEA5wATANkA2gCiACsALAAtAKAALwAwADEAMgAzADQANQA2ADcAOAA5ADoAEwAXACABGQArACwALQAlAS8AMAAxADIAMwA0ADUANgA3ADgAOQA6AIMAFgATARgAKwAsAC0AwgAvADAAMQAyADMANAA1ADYANwA4ADkAOgDCAMIAawBsAGcAaABpAGoAawBsAG0AbgBvAHAAcQByAMIAGQDCADwAwgA6ATsBwgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgATAMIAwgDZANoA2QDaABkAZwBoAGkAagBrAGwAbQBuAG8AcABxAHIAlgB3AAkBOAFDANkA2gA8ARMA7wDCAMIAgACBAIIACQEJAdEA0gAfAP4AdgD+AFYAPADCAJAAJwATAIIAEwE4AV8ALAAtADwBLwAwADEAMgAzADQANQA2ADcAOAA5ADoA2QDaABgAwgCZAAwALQB3AC8AMAAxADIAMwA0ADUANgA3ADgAOQA6ABsAOgE7ARYAOAEYANkA2gA8AXQAdQAWAJAAGQB2ACoAkwDCADwAEwAUAH8AFgDCAGcAaABpAGoAawBsAG0AbgBvAHAAcQByACQAQACRAMIA2QDaAMIANgBnAGgAaQBqAGsAbABtAG4AbwBwAHEAcgDCABYANgEZADwAwgDZANoAwgDZANoAwgAEAcIALQEuAUgABgEGAcIAdgAKAQoB2QDaAMIAUgD1ANkA2gDCANkA2gDCANkA2gDZANoAAAE8ABgAwgDZANoAwgBlAMIA9QDZANoAwgBrAGwA2QDaABYA2QDaAAABcwD1AHUAdgB3ANkA2gB6ANkA2gDZANoAAAEWANkA2gB0AAIBAwGSABMAFADCABYAiwCMAJYAlwCIABcAwgAZAMIAjQDCAMIAPgAkAHYAmgCbAJwAnQCeAGQAkQDCAJoAwgCcADEAwgAXAMIAGQDZANoA2QDaAMIAAQE8AI8AwgA8AMIAeQB6ALcA2QDaANkA2gBIANkA2gDZANoAhgAXAMIAGQDZANoABwAIAEEBVgDZANoAwgB6AFsAEwAUABcAFgAZABcAjgAZAIQAZQDZANoAwgDCAMIAawBsACQAwgDCANkA2gDCAHMAwgB1AHYAdwDCAHYAegDCABcAwgAZANkA2gDZANoAwgCOADwA2QDaAMIA2QDaANkA2gBUAFUA2QDaAEgA2QDaANkA2gA8ABcAPAAZAJoAmwCcAJ0AngBWAJoAwgCcAMIAWwATABQAFwAWABkAwgAXAMIAGQBlABcAwgAZAMIAwgBrAGwAJAC3ANkA2gDZANoAcwDCAHUAdgB3ANkA2gB6AMIA7QDCANkA2gDZANoAwgDCABcAPAAZAHYAFwB2ABkA2QDaABcAwgAZAMIASADZANoA2QDaABcAwgAZAMIAmgCbAJwAnQCeAFYAFwDCABkAwgBbANkA2gDZANoAwgDCAMIAwgDCAGUAwgDZANoAIgHCAGsAbADCALcA2QDaAMIAwgBzAMIAdQB2AHcAwgDzAHoAwgAhAcIAwgDCAMIAAQEBAQEB9AABAcAAEQHXAA0B9gArAQ0BJwH3ABEB9wD2ACcB5gAFAeIABQEFAREBEQGaAJsAnACdAJ4AAAABAAIA3QDcAAUA3AD6ANwABQEKAAsADAANAA4A+gAaAREAxQA9ABMAFAD2ABYAtwD0AI4AyQDJACYAHgArASAAyQCYABYAlwAkACsBKwAoAOsAEgDuAB0B7gDuACgB7gDJACgBEgEQARIAyADrAJYA6wD3APcA9wA8APcAEgESARAByQDIAJ8APwAkAUcAyQBIAMgAFgDJAN4AyABPAMkA3gBSACMBdADbAEEAyADbANsA5AAWAH8A4QCmAN4AGADhAHIAYwAcAd0AZQAcAeQAMwE7AdsAawBsANsA2wDbAMkAXABAAXMAQAF1AHYAdwDeAFMAegALAQsBlQCSABMAFAAWABYAFwH6AIYAyQCUAJ8A+QCLAIwA+wCNABkAGQEkAJMA+wD4APcAywANAMMABgDDAJoAmwCcAJ0AngDBADEBwQCjAMEAMQEuAdYA0AA8ANYA0ADfAN8ABADWANYAAwAWANcA1gBIANAApAC3ANcADwAXABAAFwCMAIMAmAAZAI8AFAAQABgAAQCRAI8AgwCDAD4AJQA2ADYAmAA2ADYAZQCDAHUAIgABAI4AawBsABYABQB0AKIARQAZAHMATAB1AHYAdwABAAIAegBFAAUAKQCOAHQAFAAKAAsADAANAA4AGAATABEAhAAFAH4AFgCNAEQACgALAAwADQAOABYAHgARACAAFgAWAJoAmwCcAJ0AngAoABcARAA8AB4AGAAgAGEAHAAWAEQAFwAlACIAKACWABYAGQAXABcAFwAWAGIAFwC3ABcAdQAiABYAGQBZAEcAjgCQAEwAIgAXACIATABPAFcAIgBSACIAXgBHACIAFgAYACwAIgAZABkATwAXABcAUgCPABcAYwCPABcAFgALABkAFwAZABYAFgAWAAEAFwAXAGMAiAAWABYAjgCOAI4AGQAZABcADwABAEIBQgFCAUIBQgFCAUIBQgFCAYYAQgFCAUIBQgGLAIwAQgFCAUIBQgFCAUIBQgGGAEIBQgFCAUIBiwCMAEIBQgFCAUIBQgFCAUIBQgGjAEIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBowBCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAUIBQgFCAboAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugC6ALoAugBB4OMCC9ErggB/AOoAGgEaATAFQAIbBcwBIQEhAUACVgZ9AUACMAU9AkACMgKdARQFBgY9AuEBMgIMAswBywEuAlIAUgDXAyYBdwEzADMA8gE9AD0A2ANSAFIAKQaJAIoAWwAHAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAJ0BIAEgAbYAIAEgAeEBGAIgASABggB/AOoAsAE9Ag0CMgI9Ai0CMgIKBT0CpQEyAokAigBbAC8CzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAKAHMAY4B4QSGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEsABoEGgQoBCsE5wQBAAEARgICAOsERQKWBOsElgRBAZ0BmwBBATAGmwB7AXAA8gE9BcgBKwE9BYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAYkAigBbAFEEzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAtARAATcCIAEgARsBIAEgAQsCCwLiBIsABQYHANYA9wE9ApEEMgI9Ah4EMgKIAIgAiACIAIEAkQEjAucBkQT1ACAGkQT1AIUAhQCEAIQAhACDAIAAwwEFAYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAcMBtAS1BLQEggB/AOoAxwGdAbYAxwGCAH8A6gCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGIAIgAiACIABoCQAKJAIoAWwAFAcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIACwA2AFaAbQE2AFaATMAMwCiAV0AnQCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGmAGsBKgGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwENBc0BIganAXkBEwGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGiAUABNwIMBbQEtQS0BAEBnQHjAf8B/AH7AV4AhACEAIQAgwCAAMMB+gG0BCQCJAKEAUACgAEHAJ0BJgLlAAoCiQCKAFsAEgLMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAzADMALgZ8AYkAigBbAEsBzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAQAE3AiABIAFAATcCQgZGAgIA6wS0BLUEtARcBkEBPQKbADICQALnBQgB5wAIAj0FhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBBwLnBekFNQU1BVIAUgDyAYYAhgCGAIYAhQCFAIQAhACEAIMAgADDAZsFAQEgASAB/wH8AfsBsAMgBp0B+wO0BK8DaAH6AT0CPgYyAiwAPwInAicCLQJTBC4GIAJAAlMEKAChAfUAEwLhBYkAigBbANsAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAUQBRAAEFtASdASkC5wUwAAACwAG/Ae0BQgLHAUICWAEtALQE0QS0BLUEtASsAdMEngByA0ABNwKJAIoAWwDSBMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAdQEQALUBEkBtAS1BLQEgwHsAZMBEAR+AekBewA4AiEGBAB5AbQEtQS0BDoCOgI6AlIAUgByAwUEMwUzBTsCBASGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEgASABAQW0BEACpwFAAiAGnQGnAcQBegF2Az0C/wQyAi4ALQIUAgQEBAQGBDUCggB/AOoALAJSAFIAUgBSAN8BiQCKAFsAzgHMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACkBOcB4gUQBJ0BBgC0BDIAbwN5AHkAtAO0BLUEtARmAS0CegA8AcQBQQLEARcCtAQEBLcBLwHUAIkAigBbANUAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBBAQEBAYEBwQjACABIAG0BLUEtAQQBDsFFQJ7ADgCIQYEAHkBPQL7AzICYQH9BGQBtAS1BLQEBQToAaQEOwIEBIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAUACVwEgASABwQHBAcEBywOdAVsGxAGPA6MEIAEgAT0C0AEyAu4ABAQEBAYENQJSAFIA8gE9ApsBMgJYAdMBTAGJAIoAWwDFAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAKQEEAKRBBAEnQFWBFYE7wERBHkAeQC0BD0BHAJeA5EE3AR6AJEExAFBAsQBPAXGAAQEtAThAQ4CiQCKAFsAMALMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwEEBAQEBgQHBCMAtAQgASABtATdASABIAG0BLUEtAQbAuEBtQHWAT0CqwUyAmwBPQKBBDICtAS1BLQEpAQFAEAChgCGAIYAhgCFAIUAhACEAIQAgwCAAMMB3QDWAC4BYAB9BHkG6AB5Bp0BiAETABMAAAS1A5YBdQE7Bj0EtAS1BLQEtAS1BLQEtASqAX0EegadAXoGewaPAYkAigBbAAMAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAMAEfBQICtASJAIoAWwDaBcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIALIBgwCAAMMBdwG0BBIBIwF0AQUCbwEEAgYBtAS1BLQEewTjAGsBwAG/AZsFIAYeBYYAhgCGAIYAhQCFAIQAhACEAIMAgADDASAGQAJ7BOcBtAS1BLQEugGGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwGCAUAC5QFAAhMAEwC0BLUEtARBBdQEygPUBD4CLwCoA6gD2QGdAa8BEAY9AmUEMgITABMAEwATADEAUAFSA1MDVANvAFgFOwGtAUACnQGxAVUBMgGJAIoAWwBzAMwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAEACHQVSAFIAiQCKAFsAEQLMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAhBt4AeQETABMAMQFmBJEEjgF8BBYAFgDyAU0BIQZPAXkBQAK2Ab0BkQRnBOYBkQSGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwFoBEAChgNAApEAkQAGAEAChgCGAIYAhgCFAIUAhACEAIQAgwCAAMMB1gA4BZoDQAITABMAEwATAAIFowETABMAmwOcAQMCjQBAApEEnQHOANEBzwCHA9cAJwYoApMAkwAHAOMAkQSbAeIEkQR4ADMBdQAzAZ0BQgBCAE4BiQCKAFsAdwDMBMwEJwQqBB0EHQSHAIcAiACIAIgAiACdAR0B0QDJA4kAigBbANcBzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAswEKAKoFCwGJAH4AWwCbBcwEzAQnBCoEHQQdBIcAhwCIAIgAiACIAJsFmwWaAZkBhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBQALJA0ACyATyAXUBOwYSBoYAhgCGAIYAhQCFAIQAhACEAIMAgADDARQCyQFAAlIAUgBSAFIAbwCGAIYAhgCGAIUAhQCEAIQAhACDAIAAwwFtAOkArgEoBiICQwBDAAcAnQFfASYCDgYEAQMBAgHuAbsBOQKjAdcDvgHIBMIBIQK3BEACyQPYA50B2wGpBSYGnASKAFsABwDMBMwEJwQqBB0EHQSHAIcAiACIAIgAiAAVABUACwFAAiwBZgRbAOkAzATMBCcEKgQdBB0EhwCHAIgAiACIAIgAZwR1ATsGoQAlBhAANQA1AAcAbAAVAiYAyQN9ALcEaAScBEACyAR7ADgCfQMEAEQBhgCGAIYAhgCFAIUAhACEAIQAgwCAAMMBOwI0AhYCQAJEAEQAQAInAIYAhgCGAIYAhQCFAIQAhACEAIMAgADDAUACoAAjBscExAFAAjYANgBAAkUARQBAAlYFQAKkAbgANQLPASkBQALIBM8BKQFGAEYAQAIsANoBRwBHAEACSABIAEACSQBJADcANwCbAWoD8gBAAjgAOABAAhAEQALeATkAOQBAAnkAeQA7ADsAFwA8ADwAmwF6AD8BxAFBAsQBSgBKAAQESwBLAEwATACbASIBFAAUAGwAHwHnACkCewA4AkUBBABAATcCYQDaALADeARIAZABQAKvA0ACZAWoATsCagMEBAQEBgQHBCMAJQEWAkACUARAAlAECQBAAlYBQAJvAE0ATQCPAI8AQALNAMQB3gBjBXkDQAKFA4QDpASQAJAATgBOADUCPgA+AE8ATwBDAf0DQAIKAT8APwCMA40DNQYeAlAAUABAAnMBHQJ7ADgC4AEEAAoB4gH0AAoBcgEQBEAAQABAAtIBQAJ5AHkAOwIVBkACqgCqAEACegBAAsQBQQLEAUACeQMEBEACpQBAAm8AqwCrAFcAVwBRAVAGxAFBAEEA+gVTAFMAkgCSANoD2wNUAFQANQKoAKgAlACUAEQEWwEIBG8ABAQEBAYEBwQjAB4CTwRAAk8EQAIfAnsAOAL4AQQABwFAAmkB+QVvABAEQARAAgcBQALqAXkAeQA7AqQEjgCOAKkAqQB6AEACxAFBAsQBogCiAAQEQAIzAkACmACYAJcAlwBcAWAFzgPEAQoBRASuAwgEfQCVAJUAqwNAAn0AQAI1ApYAlgBWAFYAaANgAZ8AQAIEBAQEBgQHBCMAHgKtA0ACfQBjAR0CWABYAFUAVQBlAWcBLAUcBW4BEAR4ATQANADzAW0FeQB5AJoFpAQ6ADoAUgVeBXoAnwXEAUECxAEJBacABAQABRgB9ATzBPUESQZPBTgBOQEMADoBjQGNBeAAiAUnAe0AgQVTAVQBkgUtAVkB5AHkAFsFGwVcBVoFkQWUAQQEBAQGBAcEIwBBBqgExgH9AXEBJAHeBdIA3QVZBYwBjAGLARUBiQHTADYCWwNMBtwEewA4AocBBACkBN8ADgENBgsG2QTvALoARwGmAWAAwwDcADsC6wC0AEYBvADUAb4A4wW/AMAAXADBANUBXwCOBQ0A9gH3AJYFbQDHAJIB3AGVAcQB2AWUBZMFDgDrAfsAZgDxAe4F8QAZATUC/QDLAGIB9AH+AK8A9gSXASsAXgEGAi8FtAH/AC4FLQUmBWgAfQNaBuUAmAG4AVkGuQHwADYBEAUQBDcBJQUPAjoGEQV5AHkAcAEPBVgGDAENASwGegArBsQBQQLEAXYBvAEEBHIFcQWMACkCWgA4AgsABADLBX8BngGBAW4AdADYAEABNwJGBSsCKgA+ATsCGQJFBYUBhgFDAq4EFAEXARYBBAQEBAYEBwQjAEQCnwHxBMoB7ASgAbkA/gWsAMQB/wWtAJwANAFOA/0F/AXFAdkA4QBZADUCrgBCAaQE4gDsAE4EmgBMBEoBsAC7AMcEvQCdA1IB8wBcBPYAwgCxALIAqQGrAWIAYwDEAGQAZQAQBLMAXwT4AFsE+QB5AHkAGACjAPoAXQFUBAoBegDWBMQBQQLEAagExgEEBMgAJAHwAfwAyQBdA4wBjAGLARUBiQEPAPUBWwNyASQBAAHKACoC+QGMAYwBiwEVAYkBZwDvAFsDRwEZABoABAQEBAYEBwQjAEYBagH+AXsD7wBtAUcBAQKIA2kANQGkALUAGwBGAWoACQJrAKEELQSDBBEAggQcAaQEHgHSAwkBzAB9AJME8QDmAMwDlwQcAIgEHQCbBK8AlQQeACsAHwCaBPEAIAApACUCCAAhANAAbwCvADsELgQrAHEALATwAHIAMAQiADEEMQJkBHYADwEkABIAqgQJBGkD8ACnA3wAJQAQAREBUQY8ArcAmQCKAakE6AToBOgE6AToBOgE6AToBOgEngHoBOgE6AToBEABNwLoBOgE6AToBOgE6AToBJ4B6AToBOgE6ARAATcC6AToBOgE6AToBOgE6AToBMoB6AToBOgE6AToBOgE6AToBOgE6AToBOgE6ATKAQAAfwZ/Bn8G0wXmBFcF5gTmBOYE5gTTBdMF0wXmBOYE5gTmBOYE5gR1BXUFCAYHBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBNIF5gTmBOYE5gQqBioG5gTmBOYE5gTmBBsGGgbmBOYE5gR+BeYEhQXmBOYE5gTmBOYE1AXVBeYE5gTmBOYEBwYJBuQFjAWLBYoFiQX2BWkFgwV8BYAFzwXQBc4FaQbVBdQF5gR/Ba8FvwWuBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gS3Bb4FvQW8BcUFuwW4BbEFsAWyBbMF/gTmBPsEMQXmBOYE5gTmBOYEtAUHBagFpwWmBeYEwgW1BcEFwAUPBk8GTgblBeYE5gTmBOYE5gTmBCoG5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gRrBSoGKgbmBAcFKgYqBmwFbAUDBQMFbwUWBk4FTgVOBU4FVwVOBeYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBAwGCgbmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gRTBeYE5gTmBOYE5gTmBOYE5gTmBOYESAbmBPEFPwVTBVMFUwVTBVUFQAU+BU0FCAXtBHcGjwWEBVQFhAV0BoIFjwWPBYIFjwVUBXQGGAVeBhMFdQV1BXUFawVrBWsFawVvBW8F0QVUBU0F5gR3BncGXQVdBXYGdgZdBeUFZgaYBTQFOgU6BToFOgVdBfgEggVmBmYGggWYBTQFggU0BYIFXQX4BPUFcQZdBfgE2wVdBfgEXQX4BNsFMgUyBTIFJwXmBOYE2wUyBRgFMgUnBTIFMgU8BuYE3wXfBdsFXQU0BjQGeAV4BX0FbwXWBV0F5gR9BXsFeQWCBSoFSwZLBkcGRwZHBnwGfAYWBlcGBwUHBQcFBwVXBhoFGgUIBQgFBwVXBuYE5gTmBOYE5gTmBFIG5gQRBuYFYQXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBBwG5gTmBOYE5gTmBOYE5gTmBOYE5gTmBJ0F5gTpBBMG5gTmBOYE5gTmBOYE5gTmBIYFhwViBeYE5gTmBOYE5gTmBOYElQXmBOYE5gSQBeYE5gTmBOYE5gTmBOYE5gRzBuYE5gTmBOYE5gTmBPQF8wXmBOYEXwXmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBBYF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBHoF5gTmBOYE5gTmBOYE5gTmBOYE5gTmBOYE5gTmBDkGcAXmBOYE5gTmBGoG5gTmBOYE5gRIBeYE5gTmBOYE5gTmBOYE5gTmBOYEYgZCBZ4F5gShBfwE5gTyBOYE5gQAAAkAQdCPAwuyBr4AvgC9AL8AwADAAMAAwAC/AL8AvwC/AL8AxADGAMgAyADHAMcAxQDFAMwAzADOAM4AzwDRANEA0QDSANYA1wDYANgA2ADYANgA2ADYANgA2ADYANgA2ADYAOEA4QDdAN0A3wDfAOIA4gDiAOIA4wDjAOMA4wDjAOAA4ADkAOQA5ADLAOYA5wDnAOcA5wDnAOoA2wDbAOsA6wDsAOwAvwDuAO4AvwC/AL8AzQDNAM0A8ADzAPMA8wDxAPEA/QDxAP8A/wD0APQA9AAAAfUA9QD1AAEBAQH2APYAAwEDAQIBAgECAQIBAgHJAMkA7wDvAAgBCAEIAQgBBAEEAQQBBAEFAQUBBQEKAQYBBgH6APoA6ADoANwA3ADcAAsBCwELAfgA+AD5APkA+wD7APsA+wC/APcA9wANAQ0BDQENAb8ADgEOAQ4BDgG/AL8AEQERAREBEQERAREBEgEPAQ8BEAEQAQkBCQHaANoA2gDaANkA2QDZANoA2gDaANoA2gDaANoA2gDaANkA2gDaANoA2gDaANoA2gDaANoAFAHaANoA2gDaANoA2gDaANoA2gDaANoA2gAVARUB2gAWARYB2gDaANoA2gDaANoAGQEZARoBGgEYAQcB/gD+ABcBFwG/ABsBGwHeAN4A6QDpABwBHAG/AL8AvwAdAR0BvwC/AL8AvwC/ANQA1QC/AB8BIQEhASEBIgEiASIBJAEkASABIAEmAScBJwElASUBJQElAdoA2gDtAO0A7QC/AL8AvwApASkBvwC/AL8AvwC/AL8AvwAqAb8AvwC/ACwBLgEvAS8BMAEMAQwBMwEzATMBMgE0AfIA8gA1ATYBNwE3ATcBNwE3ATgBOAE4ATwBPgE+AT8BPwE9AT0BQAFAAUEBQQFBAfwAEwETARMBOwE7AToB2QC6ALsAuwC8ALwAvADBAMEAwQDDAMMAvwDMAMoAygDCAMIA0QDSANMA0wDQANAA2ADYANgAywDlAOUA5gDqAOwA8ADxAAABAQEKARIB2gAUARgBBwEeAR4BHgEeAR4B1AAjASMBJgEnASgBKAErASsBLQEtAS4BMQExATEBDAE1ATcBAEGQlgML5ANLAAAAJAAKAF4AAAA1AAkAhwAAAF4AAQBWAAAAUAAAAAkACwAnAAIARwAAAHoAAABC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", self.location.href).href;
      }
      var wasmBinaryFile;
      function getBinarySync(file) {
        if (file == wasmBinaryFile && wasmBinary) {
          return new Uint8Array(wasmBinary);
        }
        if (readBinary) {
          return readBinary(file);
        }
        throw "both async and sync fetching of the wasm failed";
      }
      function getBinaryPromise(binaryFile) {
        if (!wasmBinary) {
          return readAsync(binaryFile).then((response) => new Uint8Array(response), () => getBinarySync(binaryFile));
        }
        return Promise.resolve().then(() => getBinarySync(binaryFile));
      }
      function instantiateArrayBuffer(binaryFile, imports, receiver) {
        return getBinaryPromise(binaryFile).then((binary) => WebAssembly.instantiate(binary, imports)).then(receiver, (reason) => {
          err(`failed to asynchronously prepare wasm: ${reason}`);
          abort(reason);
        });
      }
      function instantiateAsync(binary, binaryFile, imports, callback) {
        if (!binary && typeof WebAssembly.instantiateStreaming == "function" && !isDataURI(binaryFile) && typeof fetch == "function") {
          return fetch(binaryFile, { credentials: "same-origin" }).then((response) => {
            var result = WebAssembly.instantiateStreaming(response, imports);
            return result.then(callback, function(reason) {
              err(`wasm streaming compile failed: ${reason}`);
              err("falling back to ArrayBuffer instantiation");
              return instantiateArrayBuffer(binaryFile, imports, callback);
            });
          });
        }
        return instantiateArrayBuffer(binaryFile, imports, callback);
      }
      function getWasmImports() {
        return { a: wasmImports };
      }
      function createWasm() {
        function receiveInstance(instance, module) {
          wasmExports = instance.exports;
          wasmMemory = wasmExports["la"];
          updateMemoryViews();
          wasmTable = wasmExports["of"];
          addOnInit(wasmExports["ma"]);
          removeRunDependency();
          return wasmExports;
        }
        addRunDependency();
        function receiveInstantiationResult(result) {
          receiveInstance(result["instance"]);
        }
        var info = getWasmImports();
        if (Module2["instantiateWasm"]) {
          try {
            return Module2["instantiateWasm"](info, receiveInstance);
          } catch (e) {
            err(`Module.instantiateWasm callback failed with error: ${e}`);
            readyPromiseReject(e);
          }
        }
        wasmBinaryFile ?? (wasmBinaryFile = findWasmBinary());
        instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);
        return {};
      }
      var tempDouble;
      var tempI64;
      class ExitStatus {
        constructor(status) {
          __publicField(this, "name", "ExitStatus");
          this.message = `Program terminated with exit(${status})`;
          this.status = status;
        }
      }
      var callRuntimeCallbacks = (callbacks) => {
        while (callbacks.length > 0) {
          callbacks.shift()(Module2);
        }
      };
      function getValue(ptr, type = "i8") {
        if (type.endsWith("*")) type = "*";
        switch (type) {
          case "i1":
            return HEAP8[ptr];
          case "i8":
            return HEAP8[ptr];
          case "i16":
            return HEAP16[ptr >> 1];
          case "i32":
            return HEAP32[ptr >> 2];
          case "i64":
            abort("to do getValue(i64) use WASM_BIGINT");
          case "float":
            return HEAPF32[ptr >> 2];
          case "double":
            return HEAPF64[ptr >> 3];
          case "*":
            return HEAPU32[ptr >> 2];
          default:
            abort(`invalid type for getValue: ${type}`);
        }
      }
      Module2["noExitRuntime"] || true;
      function setValue(ptr, value2, type = "i8") {
        if (type.endsWith("*")) type = "*";
        switch (type) {
          case "i1":
            HEAP8[ptr] = value2;
            break;
          case "i8":
            HEAP8[ptr] = value2;
            break;
          case "i16":
            HEAP16[ptr >> 1] = value2;
            break;
          case "i32":
            HEAP32[ptr >> 2] = value2;
            break;
          case "i64":
            abort("to do setValue(i64) use WASM_BIGINT");
          case "float":
            HEAPF32[ptr >> 2] = value2;
            break;
          case "double":
            HEAPF64[ptr >> 3] = value2;
            break;
          case "*":
            HEAPU32[ptr >> 2] = value2;
            break;
          default:
            abort(`invalid type for setValue: ${type}`);
        }
      }
      var stackRestore = (val) => __emscripten_stack_restore(val);
      var stackSave = () => _emscripten_stack_get_current();
      var UTF8Decoder = typeof TextDecoder != "undefined" ? new TextDecoder() : void 0;
      var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {
        var endIdx = idx + maxBytesToRead;
        var endPtr = idx;
        while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;
        if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {
          return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));
        }
        var str = "";
        while (idx < endPtr) {
          var u0 = heapOrArray[idx++];
          if (!(u0 & 128)) {
            str += String.fromCharCode(u0);
            continue;
          }
          var u1 = heapOrArray[idx++] & 63;
          if ((u0 & 224) == 192) {
            str += String.fromCharCode((u0 & 31) << 6 | u1);
            continue;
          }
          var u2 = heapOrArray[idx++] & 63;
          if ((u0 & 240) == 224) {
            u0 = (u0 & 15) << 12 | u1 << 6 | u2;
          } else {
            u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | heapOrArray[idx++] & 63;
          }
          if (u0 < 65536) {
            str += String.fromCharCode(u0);
          } else {
            var ch = u0 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          }
        }
        return str;
      };
      var UTF8ToString = (ptr, maxBytesToRead) => ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : "";
      var ___assert_fail = (condition, filename, line, func) => abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : "unknown filename", line, func ? UTF8ToString(func) : "unknown function"]);
      var PATH = { isAbs: (path) => path.charAt(0) === "/", splitPath: (filename) => {
        var splitPathRe = /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
        return splitPathRe.exec(filename).slice(1);
      }, normalizeArray: (parts2, allowAboveRoot) => {
        var up = 0;
        for (var i = parts2.length - 1; i >= 0; i--) {
          var last2 = parts2[i];
          if (last2 === ".") {
            parts2.splice(i, 1);
          } else if (last2 === "..") {
            parts2.splice(i, 1);
            up++;
          } else if (up) {
            parts2.splice(i, 1);
            up--;
          }
        }
        if (allowAboveRoot) {
          for (; up; up--) {
            parts2.unshift("..");
          }
        }
        return parts2;
      }, normalize: (path) => {
        var isAbsolute = PATH.isAbs(path), trailingSlash = path.substr(-1) === "/";
        path = PATH.normalizeArray(path.split("/").filter((p) => !!p), !isAbsolute).join("/");
        if (!path && !isAbsolute) {
          path = ".";
        }
        if (path && trailingSlash) {
          path += "/";
        }
        return (isAbsolute ? "/" : "") + path;
      }, dirname: (path) => {
        var result = PATH.splitPath(path), root = result[0], dir = result[1];
        if (!root && !dir) {
          return ".";
        }
        if (dir) {
          dir = dir.substr(0, dir.length - 1);
        }
        return root + dir;
      }, basename: (path) => {
        if (path === "/") return "/";
        path = PATH.normalize(path);
        path = path.replace(/\/$/, "");
        var lastSlash = path.lastIndexOf("/");
        if (lastSlash === -1) return path;
        return path.substr(lastSlash + 1);
      }, join: (...paths) => PATH.normalize(paths.join("/")), join2: (l, r) => PATH.normalize(l + "/" + r) };
      var initRandomFill = () => {
        if (typeof crypto == "object" && typeof crypto["getRandomValues"] == "function") {
          return (view) => crypto.getRandomValues(view);
        } else abort("initRandomDevice");
      };
      var randomFill = (view) => (randomFill = initRandomFill())(view);
      var PATH_FS = { resolve: (...args2) => {
        var resolvedPath = "", resolvedAbsolute = false;
        for (var i = args2.length - 1; i >= -1 && !resolvedAbsolute; i--) {
          var path = i >= 0 ? args2[i] : FS.cwd();
          if (typeof path != "string") {
            throw new TypeError("Arguments to path.resolve must be strings");
          } else if (!path) {
            return "";
          }
          resolvedPath = path + "/" + resolvedPath;
          resolvedAbsolute = PATH.isAbs(path);
        }
        resolvedPath = PATH.normalizeArray(resolvedPath.split("/").filter((p) => !!p), !resolvedAbsolute).join("/");
        return (resolvedAbsolute ? "/" : "") + resolvedPath || ".";
      }, relative: (from, to) => {
        from = PATH_FS.resolve(from).substr(1);
        to = PATH_FS.resolve(to).substr(1);
        function trim(arr) {
          var start2 = 0;
          for (; start2 < arr.length; start2++) {
            if (arr[start2] !== "") break;
          }
          var end2 = arr.length - 1;
          for (; end2 >= 0; end2--) {
            if (arr[end2] !== "") break;
          }
          if (start2 > end2) return [];
          return arr.slice(start2, end2 - start2 + 1);
        }
        var fromParts = trim(from.split("/"));
        var toParts = trim(to.split("/"));
        var length2 = Math.min(fromParts.length, toParts.length);
        var samePartsLength = length2;
        for (var i = 0; i < length2; i++) {
          if (fromParts[i] !== toParts[i]) {
            samePartsLength = i;
            break;
          }
        }
        var outputParts = [];
        for (var i = samePartsLength; i < fromParts.length; i++) {
          outputParts.push("..");
        }
        outputParts = outputParts.concat(toParts.slice(samePartsLength));
        return outputParts.join("/");
      } };
      var FS_stdin_getChar_buffer = [];
      var lengthBytesUTF8 = (str) => {
        var len = 0;
        for (var i = 0; i < str.length; ++i) {
          var c = str.charCodeAt(i);
          if (c <= 127) {
            len++;
          } else if (c <= 2047) {
            len += 2;
          } else if (c >= 55296 && c <= 57343) {
            len += 4;
            ++i;
          } else {
            len += 3;
          }
        }
        return len;
      };
      var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {
        if (!(maxBytesToWrite > 0)) return 0;
        var startIdx = outIdx;
        var endIdx = outIdx + maxBytesToWrite - 1;
        for (var i = 0; i < str.length; ++i) {
          var u = str.charCodeAt(i);
          if (u >= 55296 && u <= 57343) {
            var u1 = str.charCodeAt(++i);
            u = 65536 + ((u & 1023) << 10) | u1 & 1023;
          }
          if (u <= 127) {
            if (outIdx >= endIdx) break;
            heap[outIdx++] = u;
          } else if (u <= 2047) {
            if (outIdx + 1 >= endIdx) break;
            heap[outIdx++] = 192 | u >> 6;
            heap[outIdx++] = 128 | u & 63;
          } else if (u <= 65535) {
            if (outIdx + 2 >= endIdx) break;
            heap[outIdx++] = 224 | u >> 12;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          } else {
            if (outIdx + 3 >= endIdx) break;
            heap[outIdx++] = 240 | u >> 18;
            heap[outIdx++] = 128 | u >> 12 & 63;
            heap[outIdx++] = 128 | u >> 6 & 63;
            heap[outIdx++] = 128 | u & 63;
          }
        }
        heap[outIdx] = 0;
        return outIdx - startIdx;
      };
      function intArrayFromString(stringy, dontAddNull, length2) {
        var len = length2 > 0 ? length2 : lengthBytesUTF8(stringy) + 1;
        var u8array = new Array(len);
        var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
        if (dontAddNull) u8array.length = numBytesWritten;
        return u8array;
      }
      var FS_stdin_getChar = () => {
        if (!FS_stdin_getChar_buffer.length) {
          var result = null;
          if (typeof window != "undefined" && typeof window.prompt == "function") {
            result = window.prompt("Input: ");
            if (result !== null) {
              result += "\n";
            }
          }
          if (!result) {
            return null;
          }
          FS_stdin_getChar_buffer = intArrayFromString(result, true);
        }
        return FS_stdin_getChar_buffer.shift();
      };
      var TTY = { ttys: [], init() {
      }, shutdown() {
      }, register(dev, ops) {
        TTY.ttys[dev] = { input: [], output: [], ops };
        FS.registerDevice(dev, TTY.stream_ops);
      }, stream_ops: { open(stream) {
        var tty = TTY.ttys[stream.node.rdev];
        if (!tty) {
          throw new FS.ErrnoError(43);
        }
        stream.tty = tty;
        stream.seekable = false;
      }, close(stream) {
        stream.tty.ops.fsync(stream.tty);
      }, fsync(stream) {
        stream.tty.ops.fsync(stream.tty);
      }, read(stream, buffer, offset, length2, pos) {
        if (!stream.tty || !stream.tty.ops.get_char) {
          throw new FS.ErrnoError(60);
        }
        var bytesRead = 0;
        for (var i = 0; i < length2; i++) {
          var result;
          try {
            result = stream.tty.ops.get_char(stream.tty);
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
          if (result === void 0 && bytesRead === 0) {
            throw new FS.ErrnoError(6);
          }
          if (result === null || result === void 0) break;
          bytesRead++;
          buffer[offset + i] = result;
        }
        if (bytesRead) {
          stream.node.timestamp = Date.now();
        }
        return bytesRead;
      }, write(stream, buffer, offset, length2, pos) {
        if (!stream.tty || !stream.tty.ops.put_char) {
          throw new FS.ErrnoError(60);
        }
        try {
          for (var i = 0; i < length2; i++) {
            stream.tty.ops.put_char(stream.tty, buffer[offset + i]);
          }
        } catch (e) {
          throw new FS.ErrnoError(29);
        }
        if (length2) {
          stream.node.timestamp = Date.now();
        }
        return i;
      } }, default_tty_ops: { get_char(tty) {
        return FS_stdin_getChar();
      }, put_char(tty, val) {
        if (val === null || val === 10) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0) tty.output.push(val);
        }
      }, fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          out(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      }, ioctl_tcgets(tty) {
        return { c_iflag: 25856, c_oflag: 5, c_cflag: 191, c_lflag: 35387, c_cc: [3, 28, 127, 21, 4, 0, 1, 0, 17, 19, 26, 0, 18, 15, 23, 22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0] };
      }, ioctl_tcsets(tty, optional_actions, data) {
        return 0;
      }, ioctl_tiocgwinsz(tty) {
        return [24, 80];
      } }, default_tty1_ops: { put_char(tty, val) {
        if (val === null || val === 10) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        } else {
          if (val != 0) tty.output.push(val);
        }
      }, fsync(tty) {
        if (tty.output && tty.output.length > 0) {
          err(UTF8ArrayToString(tty.output));
          tty.output = [];
        }
      } } };
      var zeroMemory = (address, size2) => {
        HEAPU8.fill(0, address, address + size2);
      };
      var alignMemory = (size2, alignment) => Math.ceil(size2 / alignment) * alignment;
      var mmapAlloc = (size2) => {
        size2 = alignMemory(size2, 65536);
        var ptr = _emscripten_builtin_memalign(65536, size2);
        if (ptr) zeroMemory(ptr, size2);
        return ptr;
      };
      var MEMFS = { ops_table: null, mount(mount) {
        return MEMFS.createNode(null, "/", 16895, 0);
      }, createNode(parent, name, mode, dev) {
        if (FS.isBlkdev(mode) || FS.isFIFO(mode)) {
          throw new FS.ErrnoError(63);
        }
        MEMFS.ops_table || (MEMFS.ops_table = { dir: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, lookup: MEMFS.node_ops.lookup, mknod: MEMFS.node_ops.mknod, rename: MEMFS.node_ops.rename, unlink: MEMFS.node_ops.unlink, rmdir: MEMFS.node_ops.rmdir, readdir: MEMFS.node_ops.readdir, symlink: MEMFS.node_ops.symlink }, stream: { llseek: MEMFS.stream_ops.llseek } }, file: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: { llseek: MEMFS.stream_ops.llseek, read: MEMFS.stream_ops.read, write: MEMFS.stream_ops.write, allocate: MEMFS.stream_ops.allocate, mmap: MEMFS.stream_ops.mmap, msync: MEMFS.stream_ops.msync } }, link: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr, readlink: MEMFS.node_ops.readlink }, stream: {} }, chrdev: { node: { getattr: MEMFS.node_ops.getattr, setattr: MEMFS.node_ops.setattr }, stream: FS.chrdev_stream_ops } });
        var node = FS.createNode(parent, name, mode, dev);
        if (FS.isDir(node.mode)) {
          node.node_ops = MEMFS.ops_table.dir.node;
          node.stream_ops = MEMFS.ops_table.dir.stream;
          node.contents = {};
        } else if (FS.isFile(node.mode)) {
          node.node_ops = MEMFS.ops_table.file.node;
          node.stream_ops = MEMFS.ops_table.file.stream;
          node.usedBytes = 0;
          node.contents = null;
        } else if (FS.isLink(node.mode)) {
          node.node_ops = MEMFS.ops_table.link.node;
          node.stream_ops = MEMFS.ops_table.link.stream;
        } else if (FS.isChrdev(node.mode)) {
          node.node_ops = MEMFS.ops_table.chrdev.node;
          node.stream_ops = MEMFS.ops_table.chrdev.stream;
        }
        node.timestamp = Date.now();
        if (parent) {
          parent.contents[name] = node;
          parent.timestamp = node.timestamp;
        }
        return node;
      }, getFileDataAsTypedArray(node) {
        if (!node.contents) return new Uint8Array(0);
        if (node.contents.subarray) return node.contents.subarray(0, node.usedBytes);
        return new Uint8Array(node.contents);
      }, expandFileStorage(node, newCapacity) {
        var prevCapacity = node.contents ? node.contents.length : 0;
        if (prevCapacity >= newCapacity) return;
        var CAPACITY_DOUBLING_MAX = 1024 * 1024;
        newCapacity = Math.max(newCapacity, prevCapacity * (prevCapacity < CAPACITY_DOUBLING_MAX ? 2 : 1.125) >>> 0);
        if (prevCapacity != 0) newCapacity = Math.max(newCapacity, 256);
        var oldContents = node.contents;
        node.contents = new Uint8Array(newCapacity);
        if (node.usedBytes > 0) node.contents.set(oldContents.subarray(0, node.usedBytes), 0);
      }, resizeFileStorage(node, newSize) {
        if (node.usedBytes == newSize) return;
        if (newSize == 0) {
          node.contents = null;
          node.usedBytes = 0;
        } else {
          var oldContents = node.contents;
          node.contents = new Uint8Array(newSize);
          if (oldContents) {
            node.contents.set(oldContents.subarray(0, Math.min(newSize, node.usedBytes)));
          }
          node.usedBytes = newSize;
        }
      }, node_ops: { getattr(node) {
        var attr = {};
        attr.dev = FS.isChrdev(node.mode) ? node.id : 1;
        attr.ino = node.id;
        attr.mode = node.mode;
        attr.nlink = 1;
        attr.uid = 0;
        attr.gid = 0;
        attr.rdev = node.rdev;
        if (FS.isDir(node.mode)) {
          attr.size = 4096;
        } else if (FS.isFile(node.mode)) {
          attr.size = node.usedBytes;
        } else if (FS.isLink(node.mode)) {
          attr.size = node.link.length;
        } else {
          attr.size = 0;
        }
        attr.atime = new Date(node.timestamp);
        attr.mtime = new Date(node.timestamp);
        attr.ctime = new Date(node.timestamp);
        attr.blksize = 4096;
        attr.blocks = Math.ceil(attr.size / attr.blksize);
        return attr;
      }, setattr(node, attr) {
        if (attr.mode !== void 0) {
          node.mode = attr.mode;
        }
        if (attr.timestamp !== void 0) {
          node.timestamp = attr.timestamp;
        }
        if (attr.size !== void 0) {
          MEMFS.resizeFileStorage(node, attr.size);
        }
      }, lookup(parent, name) {
        throw MEMFS.doesNotExistError;
      }, mknod(parent, name, mode, dev) {
        return MEMFS.createNode(parent, name, mode, dev);
      }, rename(old_node, new_dir, new_name) {
        if (FS.isDir(old_node.mode)) {
          var new_node;
          try {
            new_node = FS.lookupNode(new_dir, new_name);
          } catch (e) {
          }
          if (new_node) {
            for (var i in new_node.contents) {
              throw new FS.ErrnoError(55);
            }
          }
        }
        delete old_node.parent.contents[old_node.name];
        old_node.parent.timestamp = Date.now();
        old_node.name = new_name;
        new_dir.contents[new_name] = old_node;
        new_dir.timestamp = old_node.parent.timestamp;
      }, unlink(parent, name) {
        delete parent.contents[name];
        parent.timestamp = Date.now();
      }, rmdir(parent, name) {
        var node = FS.lookupNode(parent, name);
        for (var i in node.contents) {
          throw new FS.ErrnoError(55);
        }
        delete parent.contents[name];
        parent.timestamp = Date.now();
      }, readdir(node) {
        var entries = [".", ".."];
        for (var key of Object.keys(node.contents)) {
          entries.push(key);
        }
        return entries;
      }, symlink(parent, newname, oldpath) {
        var node = MEMFS.createNode(parent, newname, 511 | 40960, 0);
        node.link = oldpath;
        return node;
      }, readlink(node) {
        if (!FS.isLink(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        return node.link;
      } }, stream_ops: { read(stream, buffer, offset, length2, position) {
        var contents = stream.node.contents;
        if (position >= stream.node.usedBytes) return 0;
        var size2 = Math.min(stream.node.usedBytes - position, length2);
        if (size2 > 8 && contents.subarray) {
          buffer.set(contents.subarray(position, position + size2), offset);
        } else {
          for (var i = 0; i < size2; i++) buffer[offset + i] = contents[position + i];
        }
        return size2;
      }, write(stream, buffer, offset, length2, position, canOwn) {
        if (buffer.buffer === HEAP8.buffer) {
          canOwn = false;
        }
        if (!length2) return 0;
        var node = stream.node;
        node.timestamp = Date.now();
        if (buffer.subarray && (!node.contents || node.contents.subarray)) {
          if (canOwn) {
            node.contents = buffer.subarray(offset, offset + length2);
            node.usedBytes = length2;
            return length2;
          } else if (node.usedBytes === 0 && position === 0) {
            node.contents = buffer.slice(offset, offset + length2);
            node.usedBytes = length2;
            return length2;
          } else if (position + length2 <= node.usedBytes) {
            node.contents.set(buffer.subarray(offset, offset + length2), position);
            return length2;
          }
        }
        MEMFS.expandFileStorage(node, position + length2);
        if (node.contents.subarray && buffer.subarray) {
          node.contents.set(buffer.subarray(offset, offset + length2), position);
        } else {
          for (var i = 0; i < length2; i++) {
            node.contents[position + i] = buffer[offset + i];
          }
        }
        node.usedBytes = Math.max(node.usedBytes, position + length2);
        return length2;
      }, llseek(stream, offset, whence) {
        var position = offset;
        if (whence === 1) {
          position += stream.position;
        } else if (whence === 2) {
          if (FS.isFile(stream.node.mode)) {
            position += stream.node.usedBytes;
          }
        }
        if (position < 0) {
          throw new FS.ErrnoError(28);
        }
        return position;
      }, allocate(stream, offset, length2) {
        MEMFS.expandFileStorage(stream.node, offset + length2);
        stream.node.usedBytes = Math.max(stream.node.usedBytes, offset + length2);
      }, mmap(stream, length2, position, prot, flags) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        var ptr;
        var allocated;
        var contents = stream.node.contents;
        if (!(flags & 2) && contents && contents.buffer === HEAP8.buffer) {
          allocated = false;
          ptr = contents.byteOffset;
        } else {
          allocated = true;
          ptr = mmapAlloc(length2);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          if (contents) {
            if (position > 0 || position + length2 < contents.length) {
              if (contents.subarray) {
                contents = contents.subarray(position, position + length2);
              } else {
                contents = Array.prototype.slice.call(contents, position, position + length2);
              }
            }
            HEAP8.set(contents, ptr);
          }
        }
        return { ptr, allocated };
      }, msync(stream, buffer, offset, length2, mmapFlags) {
        MEMFS.stream_ops.write(stream, buffer, 0, length2, offset, false);
        return 0;
      } } };
      var asyncLoad = (url, onload, onerror, noRunDep) => {
        var dep = getUniqueRunDependency(`al ${url}`);
        readAsync(url).then((arrayBuffer) => {
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency();
        }, (err2) => {
          if (onerror) {
            onerror();
          } else {
            throw `Loading data file "${url}" failed.`;
          }
        });
        if (dep) addRunDependency();
      };
      var FS_createDataFile = (parent, name, fileData, canRead, canWrite, canOwn) => {
        FS.createDataFile(parent, name, fileData, canRead, canWrite, canOwn);
      };
      var preloadPlugins = Module2["preloadPlugins"] || [];
      var FS_handledByPreloadPlugin = (byteArray, fullname, finish, onerror) => {
        if (typeof Browser != "undefined") Browser.init();
        var handled = false;
        preloadPlugins.forEach((plugin) => {
          if (handled) return;
          if (plugin["canHandle"](fullname)) {
            plugin["handle"](byteArray, fullname, finish, onerror);
            handled = true;
          }
        });
        return handled;
      };
      var FS_createPreloadedFile = (parent, name, url, canRead, canWrite, onload, onerror, dontCreateFile, canOwn, preFinish) => {
        var fullname = name ? PATH_FS.resolve(PATH.join2(parent, name)) : parent;
        function processData(byteArray) {
          function finish(byteArray2) {
            preFinish == null ? void 0 : preFinish();
            if (!dontCreateFile) {
              FS_createDataFile(parent, name, byteArray2, canRead, canWrite, canOwn);
            }
            onload == null ? void 0 : onload();
            removeRunDependency();
          }
          if (FS_handledByPreloadPlugin(byteArray, fullname, finish, () => {
            onerror == null ? void 0 : onerror();
            removeRunDependency();
          })) {
            return;
          }
          finish(byteArray);
        }
        addRunDependency();
        if (typeof url == "string") {
          asyncLoad(url, processData, onerror);
        } else {
          processData(url);
        }
      };
      var FS_modeStringToFlags = (str) => {
        var flagModes = { r: 0, "r+": 2, w: 512 | 64 | 1, "w+": 512 | 64 | 2, a: 1024 | 64 | 1, "a+": 1024 | 64 | 2 };
        var flags = flagModes[str];
        if (typeof flags == "undefined") {
          throw new Error(`Unknown file open mode: ${str}`);
        }
        return flags;
      };
      var FS_getMode = (canRead, canWrite) => {
        var mode = 0;
        if (canRead) mode |= 292 | 73;
        if (canWrite) mode |= 146;
        return mode;
      };
      var FS = { root: null, mounts: [], devices: {}, streams: [], nextInode: 1, nameTable: null, currentPath: "/", initialized: false, ignorePermissions: true, ErrnoError: class {
        constructor(errno) {
          __publicField(this, "name", "ErrnoError");
          this.errno = errno;
        }
      }, filesystems: null, syncFSRequests: 0, readFiles: {}, FSStream: class {
        constructor() {
          __publicField(this, "shared", {});
        }
        get object() {
          return this.node;
        }
        set object(val) {
          this.node = val;
        }
        get isRead() {
          return (this.flags & 2097155) !== 1;
        }
        get isWrite() {
          return (this.flags & 2097155) !== 0;
        }
        get isAppend() {
          return this.flags & 1024;
        }
        get flags() {
          return this.shared.flags;
        }
        set flags(val) {
          this.shared.flags = val;
        }
        get position() {
          return this.shared.position;
        }
        set position(val) {
          this.shared.position = val;
        }
      }, FSNode: class {
        constructor(parent, name, mode, rdev) {
          __publicField(this, "node_ops", {});
          __publicField(this, "stream_ops", {});
          __publicField(this, "readMode", 292 | 73);
          __publicField(this, "writeMode", 146);
          __publicField(this, "mounted", null);
          if (!parent) {
            parent = this;
          }
          this.parent = parent;
          this.mount = parent.mount;
          this.id = FS.nextInode++;
          this.name = name;
          this.mode = mode;
          this.rdev = rdev;
        }
        get read() {
          return (this.mode & this.readMode) === this.readMode;
        }
        set read(val) {
          val ? this.mode |= this.readMode : this.mode &= ~this.readMode;
        }
        get write() {
          return (this.mode & this.writeMode) === this.writeMode;
        }
        set write(val) {
          val ? this.mode |= this.writeMode : this.mode &= ~this.writeMode;
        }
        get isFolder() {
          return FS.isDir(this.mode);
        }
        get isDevice() {
          return FS.isChrdev(this.mode);
        }
      }, lookupPath(path, opts = {}) {
        path = PATH_FS.resolve(path);
        if (!path) return { path: "", node: null };
        var defaults = { follow_mount: true, recurse_count: 0 };
        opts = Object.assign(defaults, opts);
        if (opts.recurse_count > 8) {
          throw new FS.ErrnoError(32);
        }
        var parts2 = path.split("/").filter((p) => !!p);
        var current = FS.root;
        var current_path = "/";
        for (var i = 0; i < parts2.length; i++) {
          var islast = i === parts2.length - 1;
          if (islast && opts.parent) {
            break;
          }
          current = FS.lookupNode(current, parts2[i]);
          current_path = PATH.join2(current_path, parts2[i]);
          if (FS.isMountpoint(current)) {
            if (!islast || islast && opts.follow_mount) {
              current = current.mounted.root;
            }
          }
          if (!islast || opts.follow) {
            var count = 0;
            while (FS.isLink(current.mode)) {
              var link = FS.readlink(current_path);
              current_path = PATH_FS.resolve(PATH.dirname(current_path), link);
              var lookup = FS.lookupPath(current_path, { recurse_count: opts.recurse_count + 1 });
              current = lookup.node;
              if (count++ > 40) {
                throw new FS.ErrnoError(32);
              }
            }
          }
        }
        return { path: current_path, node: current };
      }, getPath(node) {
        var path;
        while (true) {
          if (FS.isRoot(node)) {
            var mount = node.mount.mountpoint;
            if (!path) return mount;
            return mount[mount.length - 1] !== "/" ? `${mount}/${path}` : mount + path;
          }
          path = path ? `${node.name}/${path}` : node.name;
          node = node.parent;
        }
      }, hashName(parentid, name) {
        var hash2 = 0;
        for (var i = 0; i < name.length; i++) {
          hash2 = (hash2 << 5) - hash2 + name.charCodeAt(i) | 0;
        }
        return (parentid + hash2 >>> 0) % FS.nameTable.length;
      }, hashAddNode(node) {
        var hash2 = FS.hashName(node.parent.id, node.name);
        node.name_next = FS.nameTable[hash2];
        FS.nameTable[hash2] = node;
      }, hashRemoveNode(node) {
        var hash2 = FS.hashName(node.parent.id, node.name);
        if (FS.nameTable[hash2] === node) {
          FS.nameTable[hash2] = node.name_next;
        } else {
          var current = FS.nameTable[hash2];
          while (current) {
            if (current.name_next === node) {
              current.name_next = node.name_next;
              break;
            }
            current = current.name_next;
          }
        }
      }, lookupNode(parent, name) {
        var errCode = FS.mayLookup(parent);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        var hash2 = FS.hashName(parent.id, name);
        for (var node = FS.nameTable[hash2]; node; node = node.name_next) {
          var nodeName = node.name;
          if (node.parent.id === parent.id && nodeName === name) {
            return node;
          }
        }
        return FS.lookup(parent, name);
      }, createNode(parent, name, mode, rdev) {
        var node = new FS.FSNode(parent, name, mode, rdev);
        FS.hashAddNode(node);
        return node;
      }, destroyNode(node) {
        FS.hashRemoveNode(node);
      }, isRoot(node) {
        return node === node.parent;
      }, isMountpoint(node) {
        return !!node.mounted;
      }, isFile(mode) {
        return (mode & 61440) === 32768;
      }, isDir(mode) {
        return (mode & 61440) === 16384;
      }, isLink(mode) {
        return (mode & 61440) === 40960;
      }, isChrdev(mode) {
        return (mode & 61440) === 8192;
      }, isBlkdev(mode) {
        return (mode & 61440) === 24576;
      }, isFIFO(mode) {
        return (mode & 61440) === 4096;
      }, isSocket(mode) {
        return (mode & 49152) === 49152;
      }, flagsToPermissionString(flag) {
        var perms = ["r", "w", "rw"][flag & 3];
        if (flag & 512) {
          perms += "w";
        }
        return perms;
      }, nodePermissions(node, perms) {
        if (FS.ignorePermissions) {
          return 0;
        }
        if (perms.includes("r") && !(node.mode & 292)) {
          return 2;
        } else if (perms.includes("w") && !(node.mode & 146)) {
          return 2;
        } else if (perms.includes("x") && !(node.mode & 73)) {
          return 2;
        }
        return 0;
      }, mayLookup(dir) {
        if (!FS.isDir(dir.mode)) return 54;
        var errCode = FS.nodePermissions(dir, "x");
        if (errCode) return errCode;
        if (!dir.node_ops.lookup) return 2;
        return 0;
      }, mayCreate(dir, name) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
          return 20;
        } catch (e) {
        }
        return FS.nodePermissions(dir, "wx");
      }, mayDelete(dir, name, isdir) {
        var node;
        try {
          node = FS.lookupNode(dir, name);
        } catch (e) {
          return e.errno;
        }
        var errCode = FS.nodePermissions(dir, "wx");
        if (errCode) {
          return errCode;
        }
        if (isdir) {
          if (!FS.isDir(node.mode)) {
            return 54;
          }
          if (FS.isRoot(node) || FS.getPath(node) === FS.cwd()) {
            return 10;
          }
        } else {
          if (FS.isDir(node.mode)) {
            return 31;
          }
        }
        return 0;
      }, mayOpen(node, flags) {
        if (!node) {
          return 44;
        }
        if (FS.isLink(node.mode)) {
          return 32;
        } else if (FS.isDir(node.mode)) {
          if (FS.flagsToPermissionString(flags) !== "r" || flags & 512) {
            return 31;
          }
        }
        return FS.nodePermissions(node, FS.flagsToPermissionString(flags));
      }, MAX_OPEN_FDS: 4096, nextfd() {
        for (var fd = 0; fd <= FS.MAX_OPEN_FDS; fd++) {
          if (!FS.streams[fd]) {
            return fd;
          }
        }
        throw new FS.ErrnoError(33);
      }, getStreamChecked(fd) {
        var stream = FS.getStream(fd);
        if (!stream) {
          throw new FS.ErrnoError(8);
        }
        return stream;
      }, getStream: (fd) => FS.streams[fd], createStream(stream, fd = -1) {
        stream = Object.assign(new FS.FSStream(), stream);
        if (fd == -1) {
          fd = FS.nextfd();
        }
        stream.fd = fd;
        FS.streams[fd] = stream;
        return stream;
      }, closeStream(fd) {
        FS.streams[fd] = null;
      }, dupStream(origStream, fd = -1) {
        var _a2, _b2;
        var stream = FS.createStream(origStream, fd);
        (_b2 = (_a2 = stream.stream_ops) == null ? void 0 : _a2.dup) == null ? void 0 : _b2.call(_a2, stream);
        return stream;
      }, chrdev_stream_ops: { open(stream) {
        var _a2, _b2;
        var device = FS.getDevice(stream.node.rdev);
        stream.stream_ops = device.stream_ops;
        (_b2 = (_a2 = stream.stream_ops).open) == null ? void 0 : _b2.call(_a2, stream);
      }, llseek() {
        throw new FS.ErrnoError(70);
      } }, major: (dev) => dev >> 8, minor: (dev) => dev & 255, makedev: (ma, mi) => ma << 8 | mi, registerDevice(dev, ops) {
        FS.devices[dev] = { stream_ops: ops };
      }, getDevice: (dev) => FS.devices[dev], getMounts(mount) {
        var mounts = [];
        var check2 = [mount];
        while (check2.length) {
          var m = check2.pop();
          mounts.push(m);
          check2.push(...m.mounts);
        }
        return mounts;
      }, syncfs(populate, callback) {
        if (typeof populate == "function") {
          callback = populate;
          populate = false;
        }
        FS.syncFSRequests++;
        if (FS.syncFSRequests > 1) {
          err(`warning: ${FS.syncFSRequests} FS.syncfs operations in flight at once, probably just doing extra work`);
        }
        var mounts = FS.getMounts(FS.root.mount);
        var completed = 0;
        function doCallback(errCode) {
          FS.syncFSRequests--;
          return callback(errCode);
        }
        function done2(errCode) {
          if (errCode) {
            if (!done2.errored) {
              done2.errored = true;
              return doCallback(errCode);
            }
            return;
          }
          if (++completed >= mounts.length) {
            doCallback(null);
          }
        }
        mounts.forEach((mount) => {
          if (!mount.type.syncfs) {
            return done2(null);
          }
          mount.type.syncfs(mount, populate, done2);
        });
      }, mount(type, opts, mountpoint) {
        var root = mountpoint === "/";
        var pseudo = !mountpoint;
        var node;
        if (root && FS.root) {
          throw new FS.ErrnoError(10);
        } else if (!root && !pseudo) {
          var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
          mountpoint = lookup.path;
          node = lookup.node;
          if (FS.isMountpoint(node)) {
            throw new FS.ErrnoError(10);
          }
          if (!FS.isDir(node.mode)) {
            throw new FS.ErrnoError(54);
          }
        }
        var mount = { type, opts, mountpoint, mounts: [] };
        var mountRoot = type.mount(mount);
        mountRoot.mount = mount;
        mount.root = mountRoot;
        if (root) {
          FS.root = mountRoot;
        } else if (node) {
          node.mounted = mount;
          if (node.mount) {
            node.mount.mounts.push(mount);
          }
        }
        return mountRoot;
      }, unmount(mountpoint) {
        var lookup = FS.lookupPath(mountpoint, { follow_mount: false });
        if (!FS.isMountpoint(lookup.node)) {
          throw new FS.ErrnoError(28);
        }
        var node = lookup.node;
        var mount = node.mounted;
        var mounts = FS.getMounts(mount);
        Object.keys(FS.nameTable).forEach((hash2) => {
          var current = FS.nameTable[hash2];
          while (current) {
            var next = current.name_next;
            if (mounts.includes(current.mount)) {
              FS.destroyNode(current);
            }
            current = next;
          }
        });
        node.mounted = null;
        var idx = node.mount.mounts.indexOf(mount);
        node.mount.mounts.splice(idx, 1);
      }, lookup(parent, name) {
        return parent.node_ops.lookup(parent, name);
      }, mknod(path, mode, dev) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        if (!name || name === "." || name === "..") {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.mayCreate(parent, name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.mknod) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.mknod(parent, name, mode, dev);
      }, statfs(path) {
        var rtn = { bsize: 4096, frsize: 4096, blocks: 1e6, bfree: 5e5, bavail: 5e5, files: FS.nextInode, ffree: FS.nextInode - 1, fsid: 42, flags: 2, namelen: 255 };
        var parent = FS.lookupPath(path, { follow: true }).node;
        if (parent == null ? void 0 : parent.node_ops.statfs) {
          Object.assign(rtn, parent.node_ops.statfs(parent.mount.opts.root));
        }
        return rtn;
      }, create(path, mode = 438) {
        mode &= 4095;
        mode |= 32768;
        return FS.mknod(path, mode, 0);
      }, mkdir(path, mode = 511) {
        mode &= 511 | 512;
        mode |= 16384;
        return FS.mknod(path, mode, 0);
      }, mkdirTree(path, mode) {
        var dirs = path.split("/");
        var d = "";
        for (var i = 0; i < dirs.length; ++i) {
          if (!dirs[i]) continue;
          d += "/" + dirs[i];
          try {
            FS.mkdir(d, mode);
          } catch (e) {
            if (e.errno != 20) throw e;
          }
        }
      }, mkdev(path, mode, dev) {
        if (typeof dev == "undefined") {
          dev = mode;
          mode = 438;
        }
        mode |= 8192;
        return FS.mknod(path, mode, dev);
      }, symlink(oldpath, newpath) {
        if (!PATH_FS.resolve(oldpath)) {
          throw new FS.ErrnoError(44);
        }
        var lookup = FS.lookupPath(newpath, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var newname = PATH.basename(newpath);
        var errCode = FS.mayCreate(parent, newname);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.symlink) {
          throw new FS.ErrnoError(63);
        }
        return parent.node_ops.symlink(parent, newname, oldpath);
      }, rename(old_path, new_path) {
        var old_dirname = PATH.dirname(old_path);
        var new_dirname = PATH.dirname(new_path);
        var old_name = PATH.basename(old_path);
        var new_name = PATH.basename(new_path);
        var lookup, old_dir, new_dir;
        lookup = FS.lookupPath(old_path, { parent: true });
        old_dir = lookup.node;
        lookup = FS.lookupPath(new_path, { parent: true });
        new_dir = lookup.node;
        if (!old_dir || !new_dir) throw new FS.ErrnoError(44);
        if (old_dir.mount !== new_dir.mount) {
          throw new FS.ErrnoError(75);
        }
        var old_node = FS.lookupNode(old_dir, old_name);
        var relative = PATH_FS.relative(old_path, new_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(28);
        }
        relative = PATH_FS.relative(new_path, old_dirname);
        if (relative.charAt(0) !== ".") {
          throw new FS.ErrnoError(55);
        }
        var new_node;
        try {
          new_node = FS.lookupNode(new_dir, new_name);
        } catch (e) {
        }
        if (old_node === new_node) {
          return;
        }
        var isdir = FS.isDir(old_node.mode);
        var errCode = FS.mayDelete(old_dir, old_name, isdir);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        errCode = new_node ? FS.mayDelete(new_dir, new_name, isdir) : FS.mayCreate(new_dir, new_name);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!old_dir.node_ops.rename) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(old_node) || new_node && FS.isMountpoint(new_node)) {
          throw new FS.ErrnoError(10);
        }
        if (new_dir !== old_dir) {
          errCode = FS.nodePermissions(old_dir, "w");
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        FS.hashRemoveNode(old_node);
        try {
          old_dir.node_ops.rename(old_node, new_dir, new_name);
          old_node.parent = new_dir;
        } catch (e) {
          throw e;
        } finally {
          FS.hashAddNode(old_node);
        }
      }, rmdir(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, true);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.rmdir) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.rmdir(parent, name);
        FS.destroyNode(node);
      }, readdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        if (!node.node_ops.readdir) {
          throw new FS.ErrnoError(54);
        }
        return node.node_ops.readdir(node);
      }, unlink(path) {
        var lookup = FS.lookupPath(path, { parent: true });
        var parent = lookup.node;
        if (!parent) {
          throw new FS.ErrnoError(44);
        }
        var name = PATH.basename(path);
        var node = FS.lookupNode(parent, name);
        var errCode = FS.mayDelete(parent, name, false);
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        if (!parent.node_ops.unlink) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isMountpoint(node)) {
          throw new FS.ErrnoError(10);
        }
        parent.node_ops.unlink(parent, name);
        FS.destroyNode(node);
      }, readlink(path) {
        var lookup = FS.lookupPath(path);
        var link = lookup.node;
        if (!link) {
          throw new FS.ErrnoError(44);
        }
        if (!link.node_ops.readlink) {
          throw new FS.ErrnoError(28);
        }
        return link.node_ops.readlink(link);
      }, stat(path, dontFollow) {
        var lookup = FS.lookupPath(path, { follow: !dontFollow });
        var node = lookup.node;
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (!node.node_ops.getattr) {
          throw new FS.ErrnoError(63);
        }
        return node.node_ops.getattr(node);
      }, lstat(path) {
        return FS.stat(path, true);
      }, chmod(path, mode, dontFollow) {
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, { mode: mode & 4095 | node.mode & -4096, timestamp: Date.now() });
      }, lchmod(path, mode) {
        FS.chmod(path, mode, true);
      }, fchmod(fd, mode) {
        var stream = FS.getStreamChecked(fd);
        FS.chmod(stream.node, mode);
      }, chown(path, uid, gid, dontFollow) {
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: !dontFollow });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        node.node_ops.setattr(node, { timestamp: Date.now() });
      }, lchown(path, uid, gid) {
        FS.chown(path, uid, gid, true);
      }, fchown(fd, uid, gid) {
        var stream = FS.getStreamChecked(fd);
        FS.chown(stream.node, uid, gid);
      }, truncate(path, len) {
        if (len < 0) {
          throw new FS.ErrnoError(28);
        }
        var node;
        if (typeof path == "string") {
          var lookup = FS.lookupPath(path, { follow: true });
          node = lookup.node;
        } else {
          node = path;
        }
        if (!node.node_ops.setattr) {
          throw new FS.ErrnoError(63);
        }
        if (FS.isDir(node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!FS.isFile(node.mode)) {
          throw new FS.ErrnoError(28);
        }
        var errCode = FS.nodePermissions(node, "w");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        node.node_ops.setattr(node, { size: len, timestamp: Date.now() });
      }, ftruncate(fd, len) {
        var stream = FS.getStreamChecked(fd);
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(28);
        }
        FS.truncate(stream.node, len);
      }, utime(path, atime, mtime) {
        var lookup = FS.lookupPath(path, { follow: true });
        var node = lookup.node;
        node.node_ops.setattr(node, { timestamp: Math.max(atime, mtime) });
      }, open(path, flags, mode = 438) {
        if (path === "") {
          throw new FS.ErrnoError(44);
        }
        flags = typeof flags == "string" ? FS_modeStringToFlags(flags) : flags;
        if (flags & 64) {
          mode = mode & 4095 | 32768;
        } else {
          mode = 0;
        }
        var node;
        if (typeof path == "object") {
          node = path;
        } else {
          path = PATH.normalize(path);
          try {
            var lookup = FS.lookupPath(path, { follow: !(flags & 131072) });
            node = lookup.node;
          } catch (e) {
          }
        }
        var created = false;
        if (flags & 64) {
          if (node) {
            if (flags & 128) {
              throw new FS.ErrnoError(20);
            }
          } else {
            node = FS.mknod(path, mode, 0);
            created = true;
          }
        }
        if (!node) {
          throw new FS.ErrnoError(44);
        }
        if (FS.isChrdev(node.mode)) {
          flags &= -513;
        }
        if (flags & 65536 && !FS.isDir(node.mode)) {
          throw new FS.ErrnoError(54);
        }
        if (!created) {
          var errCode = FS.mayOpen(node, flags);
          if (errCode) {
            throw new FS.ErrnoError(errCode);
          }
        }
        if (flags & 512 && !created) {
          FS.truncate(node, 0);
        }
        flags &= -131713;
        var stream = FS.createStream({ node, path: FS.getPath(node), flags, seekable: true, position: 0, stream_ops: node.stream_ops, ungotten: [], error: false });
        if (stream.stream_ops.open) {
          stream.stream_ops.open(stream);
        }
        if (Module2["logReadFiles"] && !(flags & 1)) {
          if (!(path in FS.readFiles)) {
            FS.readFiles[path] = 1;
          }
        }
        return stream;
      }, close(stream) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (stream.getdents) stream.getdents = null;
        try {
          if (stream.stream_ops.close) {
            stream.stream_ops.close(stream);
          }
        } catch (e) {
          throw e;
        } finally {
          FS.closeStream(stream.fd);
        }
        stream.fd = null;
      }, isClosed(stream) {
        return stream.fd === null;
      }, llseek(stream, offset, whence) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (!stream.seekable || !stream.stream_ops.llseek) {
          throw new FS.ErrnoError(70);
        }
        if (whence != 0 && whence != 1 && whence != 2) {
          throw new FS.ErrnoError(28);
        }
        stream.position = stream.stream_ops.llseek(stream, offset, whence);
        stream.ungotten = [];
        return stream.position;
      }, read(stream, buffer, offset, length2, position) {
        if (length2 < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.read) {
          throw new FS.ErrnoError(28);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesRead = stream.stream_ops.read(stream, buffer, offset, length2, position);
        if (!seeking) stream.position += bytesRead;
        return bytesRead;
      }, write(stream, buffer, offset, length2, position, canOwn) {
        if (length2 < 0 || position < 0) {
          throw new FS.ErrnoError(28);
        }
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(31);
        }
        if (!stream.stream_ops.write) {
          throw new FS.ErrnoError(28);
        }
        if (stream.seekable && stream.flags & 1024) {
          FS.llseek(stream, 0, 2);
        }
        var seeking = typeof position != "undefined";
        if (!seeking) {
          position = stream.position;
        } else if (!stream.seekable) {
          throw new FS.ErrnoError(70);
        }
        var bytesWritten = stream.stream_ops.write(stream, buffer, offset, length2, position, canOwn);
        if (!seeking) stream.position += bytesWritten;
        return bytesWritten;
      }, allocate(stream, offset, length2) {
        if (FS.isClosed(stream)) {
          throw new FS.ErrnoError(8);
        }
        if (offset < 0 || length2 <= 0) {
          throw new FS.ErrnoError(28);
        }
        if ((stream.flags & 2097155) === 0) {
          throw new FS.ErrnoError(8);
        }
        if (!FS.isFile(stream.node.mode) && !FS.isDir(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (!stream.stream_ops.allocate) {
          throw new FS.ErrnoError(138);
        }
        stream.stream_ops.allocate(stream, offset, length2);
      }, mmap(stream, length2, position, prot, flags) {
        if ((prot & 2) !== 0 && (flags & 2) === 0 && (stream.flags & 2097155) !== 2) {
          throw new FS.ErrnoError(2);
        }
        if ((stream.flags & 2097155) === 1) {
          throw new FS.ErrnoError(2);
        }
        if (!stream.stream_ops.mmap) {
          throw new FS.ErrnoError(43);
        }
        if (!length2) {
          throw new FS.ErrnoError(28);
        }
        return stream.stream_ops.mmap(stream, length2, position, prot, flags);
      }, msync(stream, buffer, offset, length2, mmapFlags) {
        if (!stream.stream_ops.msync) {
          return 0;
        }
        return stream.stream_ops.msync(stream, buffer, offset, length2, mmapFlags);
      }, ioctl(stream, cmd, arg) {
        if (!stream.stream_ops.ioctl) {
          throw new FS.ErrnoError(59);
        }
        return stream.stream_ops.ioctl(stream, cmd, arg);
      }, readFile(path, opts = {}) {
        opts.flags = opts.flags || 0;
        opts.encoding = opts.encoding || "binary";
        if (opts.encoding !== "utf8" && opts.encoding !== "binary") {
          throw new Error(`Invalid encoding type "${opts.encoding}"`);
        }
        var ret;
        var stream = FS.open(path, opts.flags);
        var stat = FS.stat(path);
        var length2 = stat.size;
        var buf = new Uint8Array(length2);
        FS.read(stream, buf, 0, length2, 0);
        if (opts.encoding === "utf8") {
          ret = UTF8ArrayToString(buf);
        } else if (opts.encoding === "binary") {
          ret = buf;
        }
        FS.close(stream);
        return ret;
      }, writeFile(path, data, opts = {}) {
        opts.flags = opts.flags || 577;
        var stream = FS.open(path, opts.flags, opts.mode);
        if (typeof data == "string") {
          var buf = new Uint8Array(lengthBytesUTF8(data) + 1);
          var actualNumBytes = stringToUTF8Array(data, buf, 0, buf.length);
          FS.write(stream, buf, 0, actualNumBytes, void 0, opts.canOwn);
        } else if (ArrayBuffer.isView(data)) {
          FS.write(stream, data, 0, data.byteLength, void 0, opts.canOwn);
        } else {
          throw new Error("Unsupported data type");
        }
        FS.close(stream);
      }, cwd: () => FS.currentPath, chdir(path) {
        var lookup = FS.lookupPath(path, { follow: true });
        if (lookup.node === null) {
          throw new FS.ErrnoError(44);
        }
        if (!FS.isDir(lookup.node.mode)) {
          throw new FS.ErrnoError(54);
        }
        var errCode = FS.nodePermissions(lookup.node, "x");
        if (errCode) {
          throw new FS.ErrnoError(errCode);
        }
        FS.currentPath = lookup.path;
      }, createDefaultDirectories() {
        FS.mkdir("/tmp");
        FS.mkdir("/home");
        FS.mkdir("/home/web_user");
      }, createDefaultDevices() {
        FS.mkdir("/dev");
        FS.registerDevice(FS.makedev(1, 3), { read: () => 0, write: (stream, buffer, offset, length2, pos) => length2, llseek: () => 0 });
        FS.mkdev("/dev/null", FS.makedev(1, 3));
        TTY.register(FS.makedev(5, 0), TTY.default_tty_ops);
        TTY.register(FS.makedev(6, 0), TTY.default_tty1_ops);
        FS.mkdev("/dev/tty", FS.makedev(5, 0));
        FS.mkdev("/dev/tty1", FS.makedev(6, 0));
        var randomBuffer = new Uint8Array(1024), randomLeft = 0;
        var randomByte = () => {
          if (randomLeft === 0) {
            randomLeft = randomFill(randomBuffer).byteLength;
          }
          return randomBuffer[--randomLeft];
        };
        FS.createDevice("/dev", "random", randomByte);
        FS.createDevice("/dev", "urandom", randomByte);
        FS.mkdir("/dev/shm");
        FS.mkdir("/dev/shm/tmp");
      }, createSpecialDirectories() {
        FS.mkdir("/proc");
        var proc_self = FS.mkdir("/proc/self");
        FS.mkdir("/proc/self/fd");
        FS.mount({ mount() {
          var node = FS.createNode(proc_self, "fd", 16895, 73);
          node.node_ops = { lookup(parent, name) {
            var fd = +name;
            var stream = FS.getStreamChecked(fd);
            var ret = { parent: null, mount: { mountpoint: "fake" }, node_ops: { readlink: () => stream.path } };
            ret.parent = ret;
            return ret;
          } };
          return node;
        } }, {}, "/proc/self/fd");
      }, createStandardStreams(input, output, error) {
        if (input) {
          FS.createDevice("/dev", "stdin", input);
        } else {
          FS.symlink("/dev/tty", "/dev/stdin");
        }
        if (output) {
          FS.createDevice("/dev", "stdout", null, output);
        } else {
          FS.symlink("/dev/tty", "/dev/stdout");
        }
        if (error) {
          FS.createDevice("/dev", "stderr", null, error);
        } else {
          FS.symlink("/dev/tty1", "/dev/stderr");
        }
        FS.open("/dev/stdin", 0);
        FS.open("/dev/stdout", 1);
        FS.open("/dev/stderr", 1);
      }, staticInit() {
        FS.nameTable = new Array(4096);
        FS.mount(MEMFS, {}, "/");
        FS.createDefaultDirectories();
        FS.createDefaultDevices();
        FS.createSpecialDirectories();
        FS.filesystems = { MEMFS };
      }, init(input, output, error) {
        FS.initialized = true;
        input ?? (input = Module2["stdin"]);
        output ?? (output = Module2["stdout"]);
        error ?? (error = Module2["stderr"]);
        FS.createStandardStreams(input, output, error);
      }, quit() {
        FS.initialized = false;
        for (var i = 0; i < FS.streams.length; i++) {
          var stream = FS.streams[i];
          if (!stream) {
            continue;
          }
          FS.close(stream);
        }
      }, findObject(path, dontResolveLastLink) {
        var ret = FS.analyzePath(path, dontResolveLastLink);
        if (!ret.exists) {
          return null;
        }
        return ret.object;
      }, analyzePath(path, dontResolveLastLink) {
        try {
          var lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          path = lookup.path;
        } catch (e) {
        }
        var ret = { isRoot: false, exists: false, error: 0, name: null, path: null, object: null, parentExists: false, parentPath: null, parentObject: null };
        try {
          var lookup = FS.lookupPath(path, { parent: true });
          ret.parentExists = true;
          ret.parentPath = lookup.path;
          ret.parentObject = lookup.node;
          ret.name = PATH.basename(path);
          lookup = FS.lookupPath(path, { follow: !dontResolveLastLink });
          ret.exists = true;
          ret.path = lookup.path;
          ret.object = lookup.node;
          ret.name = lookup.node.name;
          ret.isRoot = lookup.path === "/";
        } catch (e) {
          ret.error = e.errno;
        }
        return ret;
      }, createPath(parent, path, canRead, canWrite) {
        parent = typeof parent == "string" ? parent : FS.getPath(parent);
        var parts2 = path.split("/").reverse();
        while (parts2.length) {
          var part = parts2.pop();
          if (!part) continue;
          var current = PATH.join2(parent, part);
          try {
            FS.mkdir(current);
          } catch (e) {
          }
          parent = current;
        }
        return current;
      }, createFile(parent, name, properties, canRead, canWrite) {
        var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(canRead, canWrite);
        return FS.create(path, mode);
      }, createDataFile(parent, name, data, canRead, canWrite, canOwn) {
        var path = name;
        if (parent) {
          parent = typeof parent == "string" ? parent : FS.getPath(parent);
          path = name ? PATH.join2(parent, name) : parent;
        }
        var mode = FS_getMode(canRead, canWrite);
        var node = FS.create(path, mode);
        if (data) {
          if (typeof data == "string") {
            var arr = new Array(data.length);
            for (var i = 0, len = data.length; i < len; ++i) arr[i] = data.charCodeAt(i);
            data = arr;
          }
          FS.chmod(node, mode | 146);
          var stream = FS.open(node, 577);
          FS.write(stream, data, 0, data.length, 0, canOwn);
          FS.close(stream);
          FS.chmod(node, mode);
        }
      }, createDevice(parent, name, input, output) {
        var _a2;
        var path = PATH.join2(typeof parent == "string" ? parent : FS.getPath(parent), name);
        var mode = FS_getMode(!!input, !!output);
        (_a2 = FS.createDevice).major ?? (_a2.major = 64);
        var dev = FS.makedev(FS.createDevice.major++, 0);
        FS.registerDevice(dev, { open(stream) {
          stream.seekable = false;
        }, close(stream) {
          var _a3;
          if ((_a3 = output == null ? void 0 : output.buffer) == null ? void 0 : _a3.length) {
            output(10);
          }
        }, read(stream, buffer, offset, length2, pos) {
          var bytesRead = 0;
          for (var i = 0; i < length2; i++) {
            var result;
            try {
              result = input();
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
            if (result === void 0 && bytesRead === 0) {
              throw new FS.ErrnoError(6);
            }
            if (result === null || result === void 0) break;
            bytesRead++;
            buffer[offset + i] = result;
          }
          if (bytesRead) {
            stream.node.timestamp = Date.now();
          }
          return bytesRead;
        }, write(stream, buffer, offset, length2, pos) {
          for (var i = 0; i < length2; i++) {
            try {
              output(buffer[offset + i]);
            } catch (e) {
              throw new FS.ErrnoError(29);
            }
          }
          if (length2) {
            stream.node.timestamp = Date.now();
          }
          return i;
        } });
        return FS.mkdev(path, mode, dev);
      }, forceLoadFile(obj) {
        if (obj.isDevice || obj.isFolder || obj.link || obj.contents) return true;
        if (typeof XMLHttpRequest != "undefined") {
          throw new Error("Lazy loading should have been performed (contents set) in createLazyFile, but it was not. Lazy loading only works in web workers. Use --embed-file or --preload-file in emcc on the main thread.");
        } else {
          try {
            obj.contents = readBinary(obj.url);
            obj.usedBytes = obj.contents.length;
          } catch (e) {
            throw new FS.ErrnoError(29);
          }
        }
      }, createLazyFile(parent, name, url, canRead, canWrite) {
        class LazyUint8Array {
          constructor() {
            __publicField(this, "lengthKnown", false);
            __publicField(this, "chunks", []);
          }
          get(idx) {
            if (idx > this.length - 1 || idx < 0) {
              return void 0;
            }
            var chunkOffset = idx % this.chunkSize;
            var chunkNum = idx / this.chunkSize | 0;
            return this.getter(chunkNum)[chunkOffset];
          }
          setDataGetter(getter) {
            this.getter = getter;
          }
          cacheLength() {
            var xhr = new XMLHttpRequest();
            xhr.open("HEAD", url, false);
            xhr.send(null);
            if (!(xhr.status >= 200 && xhr.status < 300 || xhr.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr.status);
            var datalength = Number(xhr.getResponseHeader("Content-length"));
            var header;
            var hasByteServing = (header = xhr.getResponseHeader("Accept-Ranges")) && header === "bytes";
            var usesGzip = (header = xhr.getResponseHeader("Content-Encoding")) && header === "gzip";
            var chunkSize = 1024 * 1024;
            if (!hasByteServing) chunkSize = datalength;
            var doXHR = (from, to) => {
              if (from > to) throw new Error("invalid range (" + from + ", " + to + ") or no bytes requested!");
              if (to > datalength - 1) throw new Error("only " + datalength + " bytes available! programmer error!");
              var xhr2 = new XMLHttpRequest();
              xhr2.open("GET", url, false);
              if (datalength !== chunkSize) xhr2.setRequestHeader("Range", "bytes=" + from + "-" + to);
              xhr2.responseType = "arraybuffer";
              if (xhr2.overrideMimeType) {
                xhr2.overrideMimeType("text/plain; charset=x-user-defined");
              }
              xhr2.send(null);
              if (!(xhr2.status >= 200 && xhr2.status < 300 || xhr2.status === 304)) throw new Error("Couldn't load " + url + ". Status: " + xhr2.status);
              if (xhr2.response !== void 0) {
                return new Uint8Array(xhr2.response || []);
              }
              return intArrayFromString(xhr2.responseText || "", true);
            };
            var lazyArray2 = this;
            lazyArray2.setDataGetter((chunkNum) => {
              var start2 = chunkNum * chunkSize;
              var end2 = (chunkNum + 1) * chunkSize - 1;
              end2 = Math.min(end2, datalength - 1);
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") {
                lazyArray2.chunks[chunkNum] = doXHR(start2, end2);
              }
              if (typeof lazyArray2.chunks[chunkNum] == "undefined") throw new Error("doXHR failed!");
              return lazyArray2.chunks[chunkNum];
            });
            if (usesGzip || !datalength) {
              chunkSize = datalength = 1;
              datalength = this.getter(0).length;
              chunkSize = datalength;
              out("LazyFiles on gzip forces download of the whole file when length is accessed");
            }
            this._length = datalength;
            this._chunkSize = chunkSize;
            this.lengthKnown = true;
          }
          get length() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._length;
          }
          get chunkSize() {
            if (!this.lengthKnown) {
              this.cacheLength();
            }
            return this._chunkSize;
          }
        }
        if (typeof XMLHttpRequest != "undefined") {
          if (!ENVIRONMENT_IS_WORKER) throw "Cannot do synchronous binary XHRs outside webworkers in modern browsers. Use --embed-file or --preload-file in emcc";
          var lazyArray = new LazyUint8Array();
          var properties = { isDevice: false, contents: lazyArray };
        } else {
          var properties = { isDevice: false, url };
        }
        var node = FS.createFile(parent, name, properties, canRead, canWrite);
        if (properties.contents) {
          node.contents = properties.contents;
        } else if (properties.url) {
          node.contents = null;
          node.url = properties.url;
        }
        Object.defineProperties(node, { usedBytes: { get: function() {
          return this.contents.length;
        } } });
        var stream_ops = {};
        var keys2 = Object.keys(node.stream_ops);
        keys2.forEach((key) => {
          var fn2 = node.stream_ops[key];
          stream_ops[key] = (...args2) => {
            FS.forceLoadFile(node);
            return fn2(...args2);
          };
        });
        function writeChunks(stream, buffer, offset, length2, position) {
          var contents = stream.node.contents;
          if (position >= contents.length) return 0;
          var size2 = Math.min(contents.length - position, length2);
          if (contents.slice) {
            for (var i = 0; i < size2; i++) {
              buffer[offset + i] = contents[position + i];
            }
          } else {
            for (var i = 0; i < size2; i++) {
              buffer[offset + i] = contents.get(position + i);
            }
          }
          return size2;
        }
        stream_ops.read = (stream, buffer, offset, length2, position) => {
          FS.forceLoadFile(node);
          return writeChunks(stream, buffer, offset, length2, position);
        };
        stream_ops.mmap = (stream, length2, position, prot, flags) => {
          FS.forceLoadFile(node);
          var ptr = mmapAlloc(length2);
          if (!ptr) {
            throw new FS.ErrnoError(48);
          }
          writeChunks(stream, HEAP8, ptr, length2, position);
          return { ptr, allocated: true };
        };
        node.stream_ops = stream_ops;
        return node;
      } };
      var SYSCALLS = { DEFAULT_POLLMASK: 5, calculateAt(dirfd, path, allowEmpty) {
        if (PATH.isAbs(path)) {
          return path;
        }
        var dir;
        if (dirfd === -100) {
          dir = FS.cwd();
        } else {
          var dirstream = SYSCALLS.getStreamFromFD(dirfd);
          dir = dirstream.path;
        }
        if (path.length == 0) {
          if (!allowEmpty) {
            throw new FS.ErrnoError(44);
          }
          return dir;
        }
        return PATH.join2(dir, path);
      }, doStat(func, path, buf) {
        var stat = func(path);
        HEAP32[buf >> 2] = stat.dev;
        HEAP32[buf + 4 >> 2] = stat.mode;
        HEAPU32[buf + 8 >> 2] = stat.nlink;
        HEAP32[buf + 12 >> 2] = stat.uid;
        HEAP32[buf + 16 >> 2] = stat.gid;
        HEAP32[buf + 20 >> 2] = stat.rdev;
        tempI64 = [stat.size >>> 0, (tempDouble = stat.size, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 24 >> 2] = tempI64[0], HEAP32[buf + 28 >> 2] = tempI64[1];
        HEAP32[buf + 32 >> 2] = 4096;
        HEAP32[buf + 36 >> 2] = stat.blocks;
        var atime = stat.atime.getTime();
        var mtime = stat.mtime.getTime();
        var ctime = stat.ctime.getTime();
        tempI64 = [Math.floor(atime / 1e3) >>> 0, (tempDouble = Math.floor(atime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 40 >> 2] = tempI64[0], HEAP32[buf + 44 >> 2] = tempI64[1];
        HEAPU32[buf + 48 >> 2] = atime % 1e3 * 1e3 * 1e3;
        tempI64 = [Math.floor(mtime / 1e3) >>> 0, (tempDouble = Math.floor(mtime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 56 >> 2] = tempI64[0], HEAP32[buf + 60 >> 2] = tempI64[1];
        HEAPU32[buf + 64 >> 2] = mtime % 1e3 * 1e3 * 1e3;
        tempI64 = [Math.floor(ctime / 1e3) >>> 0, (tempDouble = Math.floor(ctime / 1e3), +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 72 >> 2] = tempI64[0], HEAP32[buf + 76 >> 2] = tempI64[1];
        HEAPU32[buf + 80 >> 2] = ctime % 1e3 * 1e3 * 1e3;
        tempI64 = [stat.ino >>> 0, (tempDouble = stat.ino, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[buf + 88 >> 2] = tempI64[0], HEAP32[buf + 92 >> 2] = tempI64[1];
        return 0;
      }, doMsync(addr, stream, len, flags, offset) {
        if (!FS.isFile(stream.node.mode)) {
          throw new FS.ErrnoError(43);
        }
        if (flags & 2) {
          return 0;
        }
        var buffer = HEAPU8.slice(addr, addr + len);
        FS.msync(stream, buffer, offset, len, flags);
      }, getStreamFromFD(fd) {
        var stream = FS.getStreamChecked(fd);
        return stream;
      }, varargs: void 0, getStr(ptr) {
        var ret = UTF8ToString(ptr);
        return ret;
      } };
      function ___syscall_chmod(path, mode) {
        try {
          path = SYSCALLS.getStr(path);
          FS.chmod(path, mode);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_faccessat(dirfd, path, amode, flags) {
        try {
          path = SYSCALLS.getStr(path);
          path = SYSCALLS.calculateAt(dirfd, path);
          if (amode & ~7) {
            return -28;
          }
          var lookup = FS.lookupPath(path, { follow: true });
          var node = lookup.node;
          if (!node) {
            return -44;
          }
          var perms = "";
          if (amode & 4) perms += "r";
          if (amode & 2) perms += "w";
          if (amode & 1) perms += "x";
          if (perms && FS.nodePermissions(node, perms)) {
            return -2;
          }
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_fchmod(fd, mode) {
        try {
          FS.fchmod(fd, mode);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_fchown32(fd, owner, group) {
        try {
          FS.fchown(fd, owner, group);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      var syscallGetVarargI = () => {
        var ret = HEAP32[+SYSCALLS.varargs >> 2];
        SYSCALLS.varargs += 4;
        return ret;
      };
      var syscallGetVarargP = syscallGetVarargI;
      function ___syscall_fcntl64(fd, cmd, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          switch (cmd) {
            case 0: {
              var arg = syscallGetVarargI();
              if (arg < 0) {
                return -28;
              }
              while (FS.streams[arg]) {
                arg++;
              }
              var newStream;
              newStream = FS.dupStream(stream, arg);
              return newStream.fd;
            }
            case 1:
            case 2:
              return 0;
            case 3:
              return stream.flags;
            case 4: {
              var arg = syscallGetVarargI();
              stream.flags |= arg;
              return 0;
            }
            case 12: {
              var arg = syscallGetVarargP();
              var offset = 0;
              HEAP16[arg + offset >> 1] = 2;
              return 0;
            }
            case 13:
            case 14:
              return 0;
          }
          return -28;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_fstat64(fd, buf) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          return SYSCALLS.doStat(FS.stat, stream.path, buf);
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      var convertI32PairToI53Checked = (lo, hi) => hi + 2097152 >>> 0 < 4194305 - !!lo ? (lo >>> 0) + hi * 4294967296 : NaN;
      function ___syscall_ftruncate64(fd, length_low, length_high) {
        var length2 = convertI32PairToI53Checked(length_low, length_high);
        try {
          if (isNaN(length2)) return 61;
          FS.ftruncate(fd, length2);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      var stringToUTF8 = (str, outPtr, maxBytesToWrite) => stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);
      function ___syscall_getcwd(buf, size2) {
        try {
          if (size2 === 0) return -28;
          var cwd = FS.cwd();
          var cwdLengthInBytes = lengthBytesUTF8(cwd) + 1;
          if (size2 < cwdLengthInBytes) return -68;
          stringToUTF8(cwd, buf, size2);
          return cwdLengthInBytes;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_lstat64(path, buf) {
        try {
          path = SYSCALLS.getStr(path);
          return SYSCALLS.doStat(FS.lstat, path, buf);
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_mkdirat(dirfd, path, mode) {
        try {
          path = SYSCALLS.getStr(path);
          path = SYSCALLS.calculateAt(dirfd, path);
          path = PATH.normalize(path);
          if (path[path.length - 1] === "/") path = path.substr(0, path.length - 1);
          FS.mkdir(path, mode, 0);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_newfstatat(dirfd, path, buf, flags) {
        try {
          path = SYSCALLS.getStr(path);
          var nofollow = flags & 256;
          var allowEmpty = flags & 4096;
          flags = flags & ~6400;
          path = SYSCALLS.calculateAt(dirfd, path, allowEmpty);
          return SYSCALLS.doStat(nofollow ? FS.lstat : FS.stat, path, buf);
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_openat(dirfd, path, flags, varargs) {
        SYSCALLS.varargs = varargs;
        try {
          path = SYSCALLS.getStr(path);
          path = SYSCALLS.calculateAt(dirfd, path);
          var mode = varargs ? syscallGetVarargI() : 0;
          return FS.open(path, flags, mode).fd;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_readlinkat(dirfd, path, buf, bufsize) {
        try {
          path = SYSCALLS.getStr(path);
          path = SYSCALLS.calculateAt(dirfd, path);
          if (bufsize <= 0) return -28;
          var ret = FS.readlink(path);
          var len = Math.min(bufsize, lengthBytesUTF8(ret));
          var endChar = HEAP8[buf + len];
          stringToUTF8(ret, buf, bufsize + 1);
          HEAP8[buf + len] = endChar;
          return len;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_rmdir(path) {
        try {
          path = SYSCALLS.getStr(path);
          FS.rmdir(path);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_stat64(path, buf) {
        try {
          path = SYSCALLS.getStr(path);
          return SYSCALLS.doStat(FS.stat, path, buf);
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function ___syscall_unlinkat(dirfd, path, flags) {
        try {
          path = SYSCALLS.getStr(path);
          path = SYSCALLS.calculateAt(dirfd, path);
          if (flags === 0) {
            FS.unlink(path);
          } else if (flags === 512) {
            FS.rmdir(path);
          } else {
            abort("Invalid flags passed to unlinkat");
          }
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      var readI53FromI64 = (ptr) => HEAPU32[ptr >> 2] + HEAP32[ptr + 4 >> 2] * 4294967296;
      function ___syscall_utimensat(dirfd, path, times2, flags) {
        try {
          path = SYSCALLS.getStr(path);
          path = SYSCALLS.calculateAt(dirfd, path, true);
          var now = Date.now(), atime, mtime;
          if (!times2) {
            atime = now;
            mtime = now;
          } else {
            var seconds2 = readI53FromI64(times2);
            var nanoseconds = HEAP32[times2 + 8 >> 2];
            if (nanoseconds == 1073741823) {
              atime = now;
            } else if (nanoseconds == 1073741822) {
              atime = -1;
            } else {
              atime = seconds2 * 1e3 + nanoseconds / (1e3 * 1e3);
            }
            times2 += 16;
            seconds2 = readI53FromI64(times2);
            nanoseconds = HEAP32[times2 + 8 >> 2];
            if (nanoseconds == 1073741823) {
              mtime = now;
            } else if (nanoseconds == 1073741822) {
              mtime = -1;
            } else {
              mtime = seconds2 * 1e3 + nanoseconds / (1e3 * 1e3);
            }
          }
          if (mtime != -1 || atime != -1) {
            FS.utime(path, atime, mtime);
          }
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      var isLeapYear = (year) => year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
      var MONTH_DAYS_LEAP_CUMULATIVE = [0, 31, 60, 91, 121, 152, 182, 213, 244, 274, 305, 335];
      var MONTH_DAYS_REGULAR_CUMULATIVE = [0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334];
      var ydayFromDate = (date) => {
        var leap = isLeapYear(date.getFullYear());
        var monthDaysCumulative = leap ? MONTH_DAYS_LEAP_CUMULATIVE : MONTH_DAYS_REGULAR_CUMULATIVE;
        var yday = monthDaysCumulative[date.getMonth()] + date.getDate() - 1;
        return yday;
      };
      function __localtime_js(time_low, time_high, tmPtr) {
        var time = convertI32PairToI53Checked(time_low, time_high);
        var date = new Date(time * 1e3);
        HEAP32[tmPtr >> 2] = date.getSeconds();
        HEAP32[tmPtr + 4 >> 2] = date.getMinutes();
        HEAP32[tmPtr + 8 >> 2] = date.getHours();
        HEAP32[tmPtr + 12 >> 2] = date.getDate();
        HEAP32[tmPtr + 16 >> 2] = date.getMonth();
        HEAP32[tmPtr + 20 >> 2] = date.getFullYear() - 1900;
        HEAP32[tmPtr + 24 >> 2] = date.getDay();
        var yday = ydayFromDate(date) | 0;
        HEAP32[tmPtr + 28 >> 2] = yday;
        HEAP32[tmPtr + 36 >> 2] = -(date.getTimezoneOffset() * 60);
        var start2 = new Date(date.getFullYear(), 0, 1);
        var summerOffset = new Date(date.getFullYear(), 6, 1).getTimezoneOffset();
        var winterOffset = start2.getTimezoneOffset();
        var dst = (summerOffset != winterOffset && date.getTimezoneOffset() == Math.min(winterOffset, summerOffset)) | 0;
        HEAP32[tmPtr + 32 >> 2] = dst;
      }
      function __mmap_js(len, prot, flags, fd, offset_low, offset_high, allocated, addr) {
        var offset = convertI32PairToI53Checked(offset_low, offset_high);
        try {
          if (isNaN(offset)) return 61;
          var stream = SYSCALLS.getStreamFromFD(fd);
          var res = FS.mmap(stream, len, offset, prot, flags);
          var ptr = res.ptr;
          HEAP32[allocated >> 2] = res.allocated;
          HEAPU32[addr >> 2] = ptr;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      function __munmap_js(addr, len, prot, flags, fd, offset_low, offset_high) {
        var offset = convertI32PairToI53Checked(offset_low, offset_high);
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          if (prot & 2) {
            SYSCALLS.doMsync(addr, stream, len, flags, offset);
          }
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return -e.errno;
        }
      }
      var __tzset_js = (timezone, daylight, std_name, dst_name) => {
        var currentYear = (/* @__PURE__ */ new Date()).getFullYear();
        var winter = new Date(currentYear, 0, 1);
        var summer = new Date(currentYear, 6, 1);
        var winterOffset = winter.getTimezoneOffset();
        var summerOffset = summer.getTimezoneOffset();
        var stdTimezoneOffset = Math.max(winterOffset, summerOffset);
        HEAPU32[timezone >> 2] = stdTimezoneOffset * 60;
        HEAP32[daylight >> 2] = Number(winterOffset != summerOffset);
        var extractZone = (timezoneOffset) => {
          var sign = timezoneOffset >= 0 ? "-" : "+";
          var absOffset = Math.abs(timezoneOffset);
          var hours2 = String(Math.floor(absOffset / 60)).padStart(2, "0");
          var minutes2 = String(absOffset % 60).padStart(2, "0");
          return `UTC${sign}${hours2}${minutes2}`;
        };
        var winterName = extractZone(winterOffset);
        var summerName = extractZone(summerOffset);
        if (summerOffset < winterOffset) {
          stringToUTF8(winterName, std_name, 17);
          stringToUTF8(summerName, dst_name, 17);
        } else {
          stringToUTF8(winterName, dst_name, 17);
          stringToUTF8(summerName, std_name, 17);
        }
      };
      var _emscripten_date_now = () => Date.now();
      var _emscripten_get_now = () => performance.now();
      var getHeapMax = () => 2147483648;
      var growMemory = (size2) => {
        var b = wasmMemory.buffer;
        var pages = (size2 - b.byteLength + 65535) / 65536 | 0;
        try {
          wasmMemory.grow(pages);
          updateMemoryViews();
          return 1;
        } catch (e) {
        }
      };
      var _emscripten_resize_heap = (requestedSize) => {
        var oldSize = HEAPU8.length;
        requestedSize >>>= 0;
        var maxHeapSize = getHeapMax();
        if (requestedSize > maxHeapSize) {
          return false;
        }
        for (var cutDown = 1; cutDown <= 4; cutDown *= 2) {
          var overGrownHeapSize = oldSize * (1 + 0.2 / cutDown);
          overGrownHeapSize = Math.min(overGrownHeapSize, requestedSize + 100663296);
          var newSize = Math.min(maxHeapSize, alignMemory(Math.max(requestedSize, overGrownHeapSize), 65536));
          var replacement = growMemory(newSize);
          if (replacement) {
            return true;
          }
        }
        return false;
      };
      var ENV = {};
      var getExecutableName = () => thisProgram || "./this.program";
      var getEnvStrings = () => {
        if (!getEnvStrings.strings) {
          var lang = (typeof navigator == "object" && navigator.languages && navigator.languages[0] || "C").replace("-", "_") + ".UTF-8";
          var env2 = { USER: "web_user", LOGNAME: "web_user", PATH: "/", PWD: "/", HOME: "/home/web_user", LANG: lang, _: getExecutableName() };
          for (var x in ENV) {
            if (ENV[x] === void 0) delete env2[x];
            else env2[x] = ENV[x];
          }
          var strings = [];
          for (var x in env2) {
            strings.push(`${x}=${env2[x]}`);
          }
          getEnvStrings.strings = strings;
        }
        return getEnvStrings.strings;
      };
      var stringToAscii = (str, buffer) => {
        for (var i = 0; i < str.length; ++i) {
          HEAP8[buffer++] = str.charCodeAt(i);
        }
        HEAP8[buffer] = 0;
      };
      var _environ_get = (__environ, environ_buf) => {
        var bufSize = 0;
        getEnvStrings().forEach((string2, i) => {
          var ptr = environ_buf + bufSize;
          HEAPU32[__environ + i * 4 >> 2] = ptr;
          stringToAscii(string2, ptr);
          bufSize += string2.length + 1;
        });
        return 0;
      };
      var _environ_sizes_get = (penviron_count, penviron_buf_size) => {
        var strings = getEnvStrings();
        HEAPU32[penviron_count >> 2] = strings.length;
        var bufSize = 0;
        strings.forEach((string2) => bufSize += string2.length + 1);
        HEAPU32[penviron_buf_size >> 2] = bufSize;
        return 0;
      };
      function _fd_close(fd) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          FS.close(stream);
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return e.errno;
        }
      }
      function _fd_fdstat_get(fd, pbuf) {
        try {
          var rightsBase = 0;
          var rightsInheriting = 0;
          var flags = 0;
          {
            var stream = SYSCALLS.getStreamFromFD(fd);
            var type = stream.tty ? 2 : FS.isDir(stream.mode) ? 3 : FS.isLink(stream.mode) ? 7 : 4;
          }
          HEAP8[pbuf] = type;
          HEAP16[pbuf + 2 >> 1] = flags;
          tempI64 = [rightsBase >>> 0, (tempDouble = rightsBase, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 8 >> 2] = tempI64[0], HEAP32[pbuf + 12 >> 2] = tempI64[1];
          tempI64 = [rightsInheriting >>> 0, (tempDouble = rightsInheriting, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[pbuf + 16 >> 2] = tempI64[0], HEAP32[pbuf + 20 >> 2] = tempI64[1];
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return e.errno;
        }
      }
      var doReadv = (stream, iov, iovcnt, offset) => {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAPU32[iov >> 2];
          var len = HEAPU32[iov + 4 >> 2];
          iov += 8;
          var curr = FS.read(stream, HEAP8, ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) break;
        }
        return ret;
      };
      function _fd_read(fd, iov, iovcnt, pnum) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var num = doReadv(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return e.errno;
        }
      }
      function _fd_seek(fd, offset_low, offset_high, whence, newOffset) {
        var offset = convertI32PairToI53Checked(offset_low, offset_high);
        try {
          if (isNaN(offset)) return 61;
          var stream = SYSCALLS.getStreamFromFD(fd);
          FS.llseek(stream, offset, whence);
          tempI64 = [stream.position >>> 0, (tempDouble = stream.position, +Math.abs(tempDouble) >= 1 ? tempDouble > 0 ? +Math.floor(tempDouble / 4294967296) >>> 0 : ~~+Math.ceil((tempDouble - +(~~tempDouble >>> 0)) / 4294967296) >>> 0 : 0)], HEAP32[newOffset >> 2] = tempI64[0], HEAP32[newOffset + 4 >> 2] = tempI64[1];
          if (stream.getdents && offset === 0 && whence === 0) stream.getdents = null;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return e.errno;
        }
      }
      function _fd_sync(fd) {
        var _a2;
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          if ((_a2 = stream.stream_ops) == null ? void 0 : _a2.fsync) {
            return stream.stream_ops.fsync(stream);
          }
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return e.errno;
        }
      }
      var doWritev = (stream, iov, iovcnt, offset) => {
        var ret = 0;
        for (var i = 0; i < iovcnt; i++) {
          var ptr = HEAPU32[iov >> 2];
          var len = HEAPU32[iov + 4 >> 2];
          iov += 8;
          var curr = FS.write(stream, HEAP8, ptr, len, offset);
          if (curr < 0) return -1;
          ret += curr;
          if (curr < len) {
            break;
          }
        }
        return ret;
      };
      function _fd_write(fd, iov, iovcnt, pnum) {
        try {
          var stream = SYSCALLS.getStreamFromFD(fd);
          var num = doWritev(stream, iov, iovcnt);
          HEAPU32[pnum >> 2] = num;
          return 0;
        } catch (e) {
          if (typeof FS == "undefined" || !(e.name === "ErrnoError")) throw e;
          return e.errno;
        }
      }
      var adapters_support = function() {
        const handleAsync = typeof Asyncify === "object" ? Asyncify.handleAsync.bind(Asyncify) : null;
        Module2["handleAsync"] = handleAsync;
        const targets = /* @__PURE__ */ new Map();
        Module2["setCallback"] = (key, target) => targets.set(key, target);
        Module2["getCallback"] = (key) => targets.get(key);
        Module2["deleteCallback"] = (key) => targets.delete(key);
        adapters_support = function(isAsync, key, ...args2) {
          const receiver = targets.get(key);
          let methodName = null;
          const f = typeof receiver === "function" ? receiver : receiver[methodName = UTF8ToString(args2.shift())];
          if (isAsync) {
            if (handleAsync) {
              return handleAsync(() => f.apply(receiver, args2));
            }
            throw new Error("Synchronous WebAssembly cannot call async function");
          }
          const result = f.apply(receiver, args2);
          if (typeof (result == null ? void 0 : result.then) == "function") {
            console.error("unexpected Promise", f);
            throw new Error(`${methodName} unexpectedly returned a Promise`);
          }
          return result;
        };
      };
      function _ipp(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipp_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ippipppp(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ippipppp_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ippp(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ippp_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppi(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppi_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppiii(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppiii_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppiiip(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppiiip_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppip(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppip_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppj(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppj_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppp(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppp_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ippppi(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ippppi_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ippppij(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ippppij_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ippppip(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ippppip_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _ipppppip(...args2) {
        return adapters_support(false, ...args2);
      }
      function _ipppppip_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _vppippii(...args2) {
        return adapters_support(false, ...args2);
      }
      function _vppippii_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _vppp(...args2) {
        return adapters_support(false, ...args2);
      }
      function _vppp_async(...args2) {
        return adapters_support(true, ...args2);
      }
      function _vpppip(...args2) {
        return adapters_support(false, ...args2);
      }
      function _vpppip_async(...args2) {
        return adapters_support(true, ...args2);
      }
      var _proc_exit = (code) => {
        EXITSTATUS = code;
        quit_(code, new ExitStatus(code));
      };
      var exitJS = (status, implicit) => {
        EXITSTATUS = status;
        _proc_exit(status);
      };
      var handleException = (e) => {
        if (e instanceof ExitStatus || e == "unwind") {
          return EXITSTATUS;
        }
        quit_(1, e);
      };
      var uleb128Encode = (n, target) => {
        if (n < 128) {
          target.push(n);
        } else {
          target.push(n % 128 | 128, n >> 7);
        }
      };
      var sigToWasmTypes = (sig) => {
        var typeNames = { i: "i32", j: "i64", f: "f32", d: "f64", e: "externref", p: "i32" };
        var type = { parameters: [], results: sig[0] == "v" ? [] : [typeNames[sig[0]]] };
        for (var i = 1; i < sig.length; ++i) {
          type.parameters.push(typeNames[sig[i]]);
        }
        return type;
      };
      var generateFuncType = (sig, target) => {
        var sigRet = sig.slice(0, 1);
        var sigParam = sig.slice(1);
        var typeCodes = { i: 127, p: 127, j: 126, f: 125, d: 124, e: 111 };
        target.push(96);
        uleb128Encode(sigParam.length, target);
        for (var i = 0; i < sigParam.length; ++i) {
          target.push(typeCodes[sigParam[i]]);
        }
        if (sigRet == "v") {
          target.push(0);
        } else {
          target.push(1, typeCodes[sigRet]);
        }
      };
      var convertJsFunctionToWasm = (func, sig) => {
        if (typeof WebAssembly.Function == "function") {
          return new WebAssembly.Function(sigToWasmTypes(sig), func);
        }
        var typeSectionBody = [1];
        generateFuncType(sig, typeSectionBody);
        var bytes = [0, 97, 115, 109, 1, 0, 0, 0, 1];
        uleb128Encode(typeSectionBody.length, bytes);
        bytes.push(...typeSectionBody);
        bytes.push(2, 7, 1, 1, 101, 1, 102, 0, 0, 7, 5, 1, 1, 102, 0, 0);
        var module = new WebAssembly.Module(new Uint8Array(bytes));
        var instance = new WebAssembly.Instance(module, { e: { f: func } });
        var wrappedFunc = instance.exports["f"];
        return wrappedFunc;
      };
      var wasmTable;
      var getWasmTableEntry = (funcPtr) => wasmTable.get(funcPtr);
      var updateTableMap = (offset, count) => {
        if (functionsInTableMap) {
          for (var i = offset; i < offset + count; i++) {
            var item = getWasmTableEntry(i);
            if (item) {
              functionsInTableMap.set(item, i);
            }
          }
        }
      };
      var functionsInTableMap;
      var getFunctionAddress = (func) => {
        if (!functionsInTableMap) {
          functionsInTableMap = /* @__PURE__ */ new WeakMap();
          updateTableMap(0, wasmTable.length);
        }
        return functionsInTableMap.get(func) || 0;
      };
      var freeTableIndexes = [];
      var getEmptyTableSlot = () => {
        if (freeTableIndexes.length) {
          return freeTableIndexes.pop();
        }
        try {
          wasmTable.grow(1);
        } catch (err2) {
          if (!(err2 instanceof RangeError)) {
            throw err2;
          }
          throw "Unable to grow wasm table. Set ALLOW_TABLE_GROWTH.";
        }
        return wasmTable.length - 1;
      };
      var setWasmTableEntry = (idx, func) => wasmTable.set(idx, func);
      var addFunction = (func, sig) => {
        var rtn = getFunctionAddress(func);
        if (rtn) {
          return rtn;
        }
        var ret = getEmptyTableSlot();
        try {
          setWasmTableEntry(ret, func);
        } catch (err2) {
          if (!(err2 instanceof TypeError)) {
            throw err2;
          }
          var wrapped = convertJsFunctionToWasm(func, sig);
          setWasmTableEntry(ret, wrapped);
        }
        functionsInTableMap.set(func, ret);
        return ret;
      };
      var getCFunc = (ident) => {
        var func = Module2["_" + ident];
        return func;
      };
      var writeArrayToMemory = (array2, buffer) => {
        HEAP8.set(array2, buffer);
      };
      var stackAlloc = (sz) => __emscripten_stack_alloc(sz);
      var stringToUTF8OnStack = (str) => {
        var size2 = lengthBytesUTF8(str) + 1;
        var ret = stackAlloc(size2);
        stringToUTF8(str, ret, size2);
        return ret;
      };
      var ccall = (ident, returnType, argTypes, args2, opts) => {
        var toC = { string: (str) => {
          var ret2 = 0;
          if (str !== null && str !== void 0 && str !== 0) {
            ret2 = stringToUTF8OnStack(str);
          }
          return ret2;
        }, array: (arr) => {
          var ret2 = stackAlloc(arr.length);
          writeArrayToMemory(arr, ret2);
          return ret2;
        } };
        function convertReturnValue(ret2) {
          if (returnType === "string") {
            return UTF8ToString(ret2);
          }
          if (returnType === "boolean") return Boolean(ret2);
          return ret2;
        }
        var func = getCFunc(ident);
        var cArgs = [];
        var stack = 0;
        if (args2) {
          for (var i = 0; i < args2.length; i++) {
            var converter = toC[argTypes[i]];
            if (converter) {
              if (stack === 0) stack = stackSave();
              cArgs[i] = converter(args2[i]);
            } else {
              cArgs[i] = args2[i];
            }
          }
        }
        var ret = func(...cArgs);
        function onDone(ret2) {
          if (stack !== 0) stackRestore(stack);
          return convertReturnValue(ret2);
        }
        ret = onDone(ret);
        return ret;
      };
      var cwrap = (ident, returnType, argTypes, opts) => {
        var numericArgs = !argTypes || argTypes.every((type) => type === "number" || type === "boolean");
        var numericRet = returnType !== "string";
        if (numericRet && numericArgs && !opts) {
          return getCFunc(ident);
        }
        return (...args2) => ccall(ident, returnType, argTypes, args2);
      };
      var getTempRet0 = (val) => __emscripten_tempret_get();
      var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {
        maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
        if (maxBytesToWrite < 2) return 0;
        maxBytesToWrite -= 2;
        var startPtr = outPtr;
        var numCharsToWrite = maxBytesToWrite < str.length * 2 ? maxBytesToWrite / 2 : str.length;
        for (var i = 0; i < numCharsToWrite; ++i) {
          var codeUnit = str.charCodeAt(i);
          HEAP16[outPtr >> 1] = codeUnit;
          outPtr += 2;
        }
        HEAP16[outPtr >> 1] = 0;
        return outPtr - startPtr;
      };
      var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {
        maxBytesToWrite ?? (maxBytesToWrite = 2147483647);
        if (maxBytesToWrite < 4) return 0;
        var startPtr = outPtr;
        var endPtr = startPtr + maxBytesToWrite - 4;
        for (var i = 0; i < str.length; ++i) {
          var codeUnit = str.charCodeAt(i);
          if (codeUnit >= 55296 && codeUnit <= 57343) {
            var trailSurrogate = str.charCodeAt(++i);
            codeUnit = 65536 + ((codeUnit & 1023) << 10) | trailSurrogate & 1023;
          }
          HEAP32[outPtr >> 2] = codeUnit;
          outPtr += 4;
          if (outPtr + 4 > endPtr) break;
        }
        HEAP32[outPtr >> 2] = 0;
        return outPtr - startPtr;
      };
      var AsciiToString = (ptr) => {
        var str = "";
        while (1) {
          var ch = HEAPU8[ptr++];
          if (!ch) return str;
          str += String.fromCharCode(ch);
        }
      };
      var UTF16Decoder = typeof TextDecoder != "undefined" ? new TextDecoder("utf-16le") : void 0;
      var UTF16ToString = (ptr, maxBytesToRead) => {
        var endPtr = ptr;
        var idx = endPtr >> 1;
        var maxIdx = idx + maxBytesToRead / 2;
        while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;
        endPtr = idx << 1;
        if (endPtr - ptr > 32 && UTF16Decoder) return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
        var str = "";
        for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {
          var codeUnit = HEAP16[ptr + i * 2 >> 1];
          if (codeUnit == 0) break;
          str += String.fromCharCode(codeUnit);
        }
        return str;
      };
      var UTF32ToString = (ptr, maxBytesToRead) => {
        var i = 0;
        var str = "";
        while (!(i >= maxBytesToRead / 4)) {
          var utf32 = HEAP32[ptr + i * 4 >> 2];
          if (utf32 == 0) break;
          ++i;
          if (utf32 >= 65536) {
            var ch = utf32 - 65536;
            str += String.fromCharCode(55296 | ch >> 10, 56320 | ch & 1023);
          } else {
            str += String.fromCharCode(utf32);
          }
        }
        return str;
      };
      function intArrayToString(array2) {
        var ret = [];
        for (var i = 0; i < array2.length; i++) {
          var chr = array2[i];
          if (chr > 255) {
            chr &= 255;
          }
          ret.push(String.fromCharCode(chr));
        }
        return ret.join("");
      }
      FS.createPreloadedFile = FS_createPreloadedFile;
      FS.staticInit();
      MEMFS.doesNotExistError = new FS.ErrnoError(44);
      MEMFS.doesNotExistError.stack = "<generic error, no stack>";
      adapters_support();
      var wasmImports = { a: ___assert_fail, Y: ___syscall_chmod, $: ___syscall_faccessat, Z: ___syscall_fchmod, X: ___syscall_fchown32, b: ___syscall_fcntl64, W: ___syscall_fstat64, y: ___syscall_ftruncate64, Q: ___syscall_getcwd, U: ___syscall_lstat64, N: ___syscall_mkdirat, S: ___syscall_newfstatat, L: ___syscall_openat, J: ___syscall_readlinkat, I: ___syscall_rmdir, V: ___syscall_stat64, G: ___syscall_unlinkat, F: ___syscall_utimensat, w: __localtime_js, u: __mmap_js, v: __munmap_js, M: __tzset_js, n: _emscripten_date_now, m: _emscripten_get_now, D: _emscripten_resize_heap, O: _environ_get, P: _environ_sizes_get, o: _fd_close, E: _fd_fdstat_get, K: _fd_read, x: _fd_seek, R: _fd_sync, H: _fd_write, s: _ipp, t: _ipp_async, ga: _ippipppp, ka: _ippipppp_async, i: _ippp, j: _ippp_async, c: _ipppi, d: _ipppi_async, ca: _ipppiii, da: _ipppiii_async, ea: _ipppiiip, fa: _ipppiiip_async, g: _ipppip, h: _ipppip_async, z: _ipppj, A: _ipppj_async, e: _ipppp, f: _ipppp_async, aa: _ippppi, ba: _ippppi_async, B: _ippppij, C: _ippppij_async, p: _ippppip, q: _ippppip_async, ha: _ipppppip, ia: _ipppppip_async, ja: _vppippii, r: _vppippii_async, k: _vppp, l: _vppp_async, T: _vpppip, _: _vpppip_async };
      var wasmExports = createWasm();
      Module2["_sqlite3_status64"] = (a0, a1, a2, a3) => (Module2["_sqlite3_status64"] = wasmExports["na"])(a0, a1, a2, a3);
      Module2["_sqlite3_status"] = (a0, a1, a2, a3) => (Module2["_sqlite3_status"] = wasmExports["oa"])(a0, a1, a2, a3);
      Module2["_sqlite3_db_status"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_db_status"] = wasmExports["pa"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_msize"] = (a0) => (Module2["_sqlite3_msize"] = wasmExports["qa"])(a0);
      Module2["_sqlite3_vfs_find"] = (a0) => (Module2["_sqlite3_vfs_find"] = wasmExports["ra"])(a0);
      Module2["_sqlite3_vfs_register"] = (a0, a1) => (Module2["_sqlite3_vfs_register"] = wasmExports["sa"])(a0, a1);
      Module2["_sqlite3_vfs_unregister"] = (a0) => (Module2["_sqlite3_vfs_unregister"] = wasmExports["ta"])(a0);
      Module2["_sqlite3_release_memory"] = (a0) => (Module2["_sqlite3_release_memory"] = wasmExports["ua"])(a0);
      Module2["_sqlite3_soft_heap_limit64"] = (a0, a1) => (Module2["_sqlite3_soft_heap_limit64"] = wasmExports["va"])(a0, a1);
      Module2["_sqlite3_memory_used"] = () => (Module2["_sqlite3_memory_used"] = wasmExports["wa"])();
      Module2["_sqlite3_hard_heap_limit64"] = (a0, a1) => (Module2["_sqlite3_hard_heap_limit64"] = wasmExports["xa"])(a0, a1);
      Module2["_sqlite3_memory_highwater"] = (a0) => (Module2["_sqlite3_memory_highwater"] = wasmExports["ya"])(a0);
      Module2["_sqlite3_malloc"] = (a0) => (Module2["_sqlite3_malloc"] = wasmExports["za"])(a0);
      Module2["_sqlite3_malloc64"] = (a0, a1) => (Module2["_sqlite3_malloc64"] = wasmExports["Aa"])(a0, a1);
      Module2["_sqlite3_free"] = (a0) => (Module2["_sqlite3_free"] = wasmExports["Ba"])(a0);
      Module2["_sqlite3_realloc"] = (a0, a1) => (Module2["_sqlite3_realloc"] = wasmExports["Ca"])(a0, a1);
      Module2["_sqlite3_realloc64"] = (a0, a1, a2) => (Module2["_sqlite3_realloc64"] = wasmExports["Da"])(a0, a1, a2);
      Module2["_sqlite3_str_vappendf"] = (a0, a1, a2) => (Module2["_sqlite3_str_vappendf"] = wasmExports["Ea"])(a0, a1, a2);
      Module2["_sqlite3_str_append"] = (a0, a1, a2) => (Module2["_sqlite3_str_append"] = wasmExports["Fa"])(a0, a1, a2);
      Module2["_sqlite3_str_appendchar"] = (a0, a1, a2) => (Module2["_sqlite3_str_appendchar"] = wasmExports["Ga"])(a0, a1, a2);
      Module2["_sqlite3_str_appendall"] = (a0, a1) => (Module2["_sqlite3_str_appendall"] = wasmExports["Ha"])(a0, a1);
      Module2["_sqlite3_str_appendf"] = (a0, a1, a2) => (Module2["_sqlite3_str_appendf"] = wasmExports["Ia"])(a0, a1, a2);
      Module2["_sqlite3_str_finish"] = (a0) => (Module2["_sqlite3_str_finish"] = wasmExports["Ja"])(a0);
      Module2["_sqlite3_str_errcode"] = (a0) => (Module2["_sqlite3_str_errcode"] = wasmExports["Ka"])(a0);
      Module2["_sqlite3_str_length"] = (a0) => (Module2["_sqlite3_str_length"] = wasmExports["La"])(a0);
      Module2["_sqlite3_str_value"] = (a0) => (Module2["_sqlite3_str_value"] = wasmExports["Ma"])(a0);
      Module2["_sqlite3_str_reset"] = (a0) => (Module2["_sqlite3_str_reset"] = wasmExports["Na"])(a0);
      Module2["_sqlite3_str_new"] = (a0) => (Module2["_sqlite3_str_new"] = wasmExports["Oa"])(a0);
      Module2["_sqlite3_vmprintf"] = (a0, a1) => (Module2["_sqlite3_vmprintf"] = wasmExports["Pa"])(a0, a1);
      Module2["_sqlite3_mprintf"] = (a0, a1) => (Module2["_sqlite3_mprintf"] = wasmExports["Qa"])(a0, a1);
      Module2["_sqlite3_vsnprintf"] = (a0, a1, a2, a3) => (Module2["_sqlite3_vsnprintf"] = wasmExports["Ra"])(a0, a1, a2, a3);
      Module2["_sqlite3_snprintf"] = (a0, a1, a2, a3) => (Module2["_sqlite3_snprintf"] = wasmExports["Sa"])(a0, a1, a2, a3);
      Module2["_sqlite3_log"] = (a0, a1, a2) => (Module2["_sqlite3_log"] = wasmExports["Ta"])(a0, a1, a2);
      Module2["_sqlite3_randomness"] = (a0, a1) => (Module2["_sqlite3_randomness"] = wasmExports["Ua"])(a0, a1);
      Module2["_sqlite3_stricmp"] = (a0, a1) => (Module2["_sqlite3_stricmp"] = wasmExports["Va"])(a0, a1);
      Module2["_sqlite3_strnicmp"] = (a0, a1, a2) => (Module2["_sqlite3_strnicmp"] = wasmExports["Wa"])(a0, a1, a2);
      Module2["_sqlite3_os_init"] = () => (Module2["_sqlite3_os_init"] = wasmExports["Xa"])();
      Module2["_sqlite3_os_end"] = () => (Module2["_sqlite3_os_end"] = wasmExports["Ya"])();
      Module2["_sqlite3_serialize"] = (a0, a1, a2, a3) => (Module2["_sqlite3_serialize"] = wasmExports["Za"])(a0, a1, a2, a3);
      Module2["_sqlite3_prepare_v2"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_prepare_v2"] = wasmExports["_a"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_step"] = (a0) => (Module2["_sqlite3_step"] = wasmExports["$a"])(a0);
      Module2["_sqlite3_column_int64"] = (a0, a1) => (Module2["_sqlite3_column_int64"] = wasmExports["ab"])(a0, a1);
      Module2["_sqlite3_reset"] = (a0) => (Module2["_sqlite3_reset"] = wasmExports["bb"])(a0);
      Module2["_sqlite3_exec"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_exec"] = wasmExports["cb"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_column_int"] = (a0, a1) => (Module2["_sqlite3_column_int"] = wasmExports["db"])(a0, a1);
      Module2["_sqlite3_finalize"] = (a0) => (Module2["_sqlite3_finalize"] = wasmExports["eb"])(a0);
      Module2["_sqlite3_deserialize"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (Module2["_sqlite3_deserialize"] = wasmExports["fb"])(a0, a1, a2, a3, a4, a5, a6, a7);
      Module2["_sqlite3_database_file_object"] = (a0) => (Module2["_sqlite3_database_file_object"] = wasmExports["gb"])(a0);
      Module2["_sqlite3_backup_init"] = (a0, a1, a2, a3) => (Module2["_sqlite3_backup_init"] = wasmExports["hb"])(a0, a1, a2, a3);
      Module2["_sqlite3_backup_step"] = (a0, a1) => (Module2["_sqlite3_backup_step"] = wasmExports["ib"])(a0, a1);
      Module2["_sqlite3_backup_finish"] = (a0) => (Module2["_sqlite3_backup_finish"] = wasmExports["jb"])(a0);
      Module2["_sqlite3_backup_remaining"] = (a0) => (Module2["_sqlite3_backup_remaining"] = wasmExports["kb"])(a0);
      Module2["_sqlite3_backup_pagecount"] = (a0) => (Module2["_sqlite3_backup_pagecount"] = wasmExports["lb"])(a0);
      Module2["_sqlite3_clear_bindings"] = (a0) => (Module2["_sqlite3_clear_bindings"] = wasmExports["mb"])(a0);
      Module2["_sqlite3_value_blob"] = (a0) => (Module2["_sqlite3_value_blob"] = wasmExports["nb"])(a0);
      Module2["_sqlite3_value_text"] = (a0) => (Module2["_sqlite3_value_text"] = wasmExports["ob"])(a0);
      Module2["_sqlite3_value_bytes"] = (a0) => (Module2["_sqlite3_value_bytes"] = wasmExports["pb"])(a0);
      Module2["_sqlite3_value_bytes16"] = (a0) => (Module2["_sqlite3_value_bytes16"] = wasmExports["qb"])(a0);
      Module2["_sqlite3_value_double"] = (a0) => (Module2["_sqlite3_value_double"] = wasmExports["rb"])(a0);
      Module2["_sqlite3_value_int"] = (a0) => (Module2["_sqlite3_value_int"] = wasmExports["sb"])(a0);
      Module2["_sqlite3_value_int64"] = (a0) => (Module2["_sqlite3_value_int64"] = wasmExports["tb"])(a0);
      Module2["_sqlite3_value_subtype"] = (a0) => (Module2["_sqlite3_value_subtype"] = wasmExports["ub"])(a0);
      Module2["_sqlite3_value_pointer"] = (a0, a1) => (Module2["_sqlite3_value_pointer"] = wasmExports["vb"])(a0, a1);
      Module2["_sqlite3_value_text16"] = (a0) => (Module2["_sqlite3_value_text16"] = wasmExports["wb"])(a0);
      Module2["_sqlite3_value_text16be"] = (a0) => (Module2["_sqlite3_value_text16be"] = wasmExports["xb"])(a0);
      Module2["_sqlite3_value_text16le"] = (a0) => (Module2["_sqlite3_value_text16le"] = wasmExports["yb"])(a0);
      Module2["_sqlite3_value_type"] = (a0) => (Module2["_sqlite3_value_type"] = wasmExports["zb"])(a0);
      Module2["_sqlite3_value_encoding"] = (a0) => (Module2["_sqlite3_value_encoding"] = wasmExports["Ab"])(a0);
      Module2["_sqlite3_value_nochange"] = (a0) => (Module2["_sqlite3_value_nochange"] = wasmExports["Bb"])(a0);
      Module2["_sqlite3_value_frombind"] = (a0) => (Module2["_sqlite3_value_frombind"] = wasmExports["Cb"])(a0);
      Module2["_sqlite3_value_dup"] = (a0) => (Module2["_sqlite3_value_dup"] = wasmExports["Db"])(a0);
      Module2["_sqlite3_value_free"] = (a0) => (Module2["_sqlite3_value_free"] = wasmExports["Eb"])(a0);
      Module2["_sqlite3_result_blob"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_blob"] = wasmExports["Fb"])(a0, a1, a2, a3);
      Module2["_sqlite3_result_blob64"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_result_blob64"] = wasmExports["Gb"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_result_double"] = (a0, a1) => (Module2["_sqlite3_result_double"] = wasmExports["Hb"])(a0, a1);
      Module2["_sqlite3_result_error"] = (a0, a1, a2) => (Module2["_sqlite3_result_error"] = wasmExports["Ib"])(a0, a1, a2);
      Module2["_sqlite3_result_error16"] = (a0, a1, a2) => (Module2["_sqlite3_result_error16"] = wasmExports["Jb"])(a0, a1, a2);
      Module2["_sqlite3_result_int"] = (a0, a1) => (Module2["_sqlite3_result_int"] = wasmExports["Kb"])(a0, a1);
      Module2["_sqlite3_result_int64"] = (a0, a1, a2) => (Module2["_sqlite3_result_int64"] = wasmExports["Lb"])(a0, a1, a2);
      Module2["_sqlite3_result_null"] = (a0) => (Module2["_sqlite3_result_null"] = wasmExports["Mb"])(a0);
      Module2["_sqlite3_result_pointer"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_pointer"] = wasmExports["Nb"])(a0, a1, a2, a3);
      Module2["_sqlite3_result_subtype"] = (a0, a1) => (Module2["_sqlite3_result_subtype"] = wasmExports["Ob"])(a0, a1);
      Module2["_sqlite3_result_text"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_text"] = wasmExports["Pb"])(a0, a1, a2, a3);
      Module2["_sqlite3_result_text64"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_result_text64"] = wasmExports["Qb"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_result_text16"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_text16"] = wasmExports["Rb"])(a0, a1, a2, a3);
      Module2["_sqlite3_result_text16be"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_text16be"] = wasmExports["Sb"])(a0, a1, a2, a3);
      Module2["_sqlite3_result_text16le"] = (a0, a1, a2, a3) => (Module2["_sqlite3_result_text16le"] = wasmExports["Tb"])(a0, a1, a2, a3);
      Module2["_sqlite3_result_value"] = (a0, a1) => (Module2["_sqlite3_result_value"] = wasmExports["Ub"])(a0, a1);
      Module2["_sqlite3_result_error_toobig"] = (a0) => (Module2["_sqlite3_result_error_toobig"] = wasmExports["Vb"])(a0);
      Module2["_sqlite3_result_zeroblob"] = (a0, a1) => (Module2["_sqlite3_result_zeroblob"] = wasmExports["Wb"])(a0, a1);
      Module2["_sqlite3_result_zeroblob64"] = (a0, a1, a2) => (Module2["_sqlite3_result_zeroblob64"] = wasmExports["Xb"])(a0, a1, a2);
      Module2["_sqlite3_result_error_code"] = (a0, a1) => (Module2["_sqlite3_result_error_code"] = wasmExports["Yb"])(a0, a1);
      Module2["_sqlite3_result_error_nomem"] = (a0) => (Module2["_sqlite3_result_error_nomem"] = wasmExports["Zb"])(a0);
      Module2["_sqlite3_user_data"] = (a0) => (Module2["_sqlite3_user_data"] = wasmExports["_b"])(a0);
      Module2["_sqlite3_context_db_handle"] = (a0) => (Module2["_sqlite3_context_db_handle"] = wasmExports["$b"])(a0);
      Module2["_sqlite3_vtab_nochange"] = (a0) => (Module2["_sqlite3_vtab_nochange"] = wasmExports["ac"])(a0);
      Module2["_sqlite3_vtab_in_first"] = (a0, a1) => (Module2["_sqlite3_vtab_in_first"] = wasmExports["bc"])(a0, a1);
      Module2["_sqlite3_vtab_in_next"] = (a0, a1) => (Module2["_sqlite3_vtab_in_next"] = wasmExports["cc"])(a0, a1);
      Module2["_sqlite3_aggregate_context"] = (a0, a1) => (Module2["_sqlite3_aggregate_context"] = wasmExports["dc"])(a0, a1);
      Module2["_sqlite3_get_auxdata"] = (a0, a1) => (Module2["_sqlite3_get_auxdata"] = wasmExports["ec"])(a0, a1);
      Module2["_sqlite3_set_auxdata"] = (a0, a1, a2, a3) => (Module2["_sqlite3_set_auxdata"] = wasmExports["fc"])(a0, a1, a2, a3);
      Module2["_sqlite3_column_count"] = (a0) => (Module2["_sqlite3_column_count"] = wasmExports["gc"])(a0);
      Module2["_sqlite3_data_count"] = (a0) => (Module2["_sqlite3_data_count"] = wasmExports["hc"])(a0);
      Module2["_sqlite3_column_blob"] = (a0, a1) => (Module2["_sqlite3_column_blob"] = wasmExports["ic"])(a0, a1);
      Module2["_sqlite3_column_bytes"] = (a0, a1) => (Module2["_sqlite3_column_bytes"] = wasmExports["jc"])(a0, a1);
      Module2["_sqlite3_column_bytes16"] = (a0, a1) => (Module2["_sqlite3_column_bytes16"] = wasmExports["kc"])(a0, a1);
      Module2["_sqlite3_column_double"] = (a0, a1) => (Module2["_sqlite3_column_double"] = wasmExports["lc"])(a0, a1);
      Module2["_sqlite3_column_text"] = (a0, a1) => (Module2["_sqlite3_column_text"] = wasmExports["mc"])(a0, a1);
      Module2["_sqlite3_column_value"] = (a0, a1) => (Module2["_sqlite3_column_value"] = wasmExports["nc"])(a0, a1);
      Module2["_sqlite3_column_text16"] = (a0, a1) => (Module2["_sqlite3_column_text16"] = wasmExports["oc"])(a0, a1);
      Module2["_sqlite3_column_type"] = (a0, a1) => (Module2["_sqlite3_column_type"] = wasmExports["pc"])(a0, a1);
      Module2["_sqlite3_column_name"] = (a0, a1) => (Module2["_sqlite3_column_name"] = wasmExports["qc"])(a0, a1);
      Module2["_sqlite3_column_name16"] = (a0, a1) => (Module2["_sqlite3_column_name16"] = wasmExports["rc"])(a0, a1);
      Module2["_sqlite3_bind_blob"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_blob"] = wasmExports["sc"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_bind_blob64"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_bind_blob64"] = wasmExports["tc"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_bind_double"] = (a0, a1, a2) => (Module2["_sqlite3_bind_double"] = wasmExports["uc"])(a0, a1, a2);
      Module2["_sqlite3_bind_int"] = (a0, a1, a2) => (Module2["_sqlite3_bind_int"] = wasmExports["vc"])(a0, a1, a2);
      Module2["_sqlite3_bind_int64"] = (a0, a1, a2, a3) => (Module2["_sqlite3_bind_int64"] = wasmExports["wc"])(a0, a1, a2, a3);
      Module2["_sqlite3_bind_null"] = (a0, a1) => (Module2["_sqlite3_bind_null"] = wasmExports["xc"])(a0, a1);
      Module2["_sqlite3_bind_pointer"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_pointer"] = wasmExports["yc"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_bind_text"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_text"] = wasmExports["zc"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_bind_text64"] = (a0, a1, a2, a3, a4, a5, a6) => (Module2["_sqlite3_bind_text64"] = wasmExports["Ac"])(a0, a1, a2, a3, a4, a5, a6);
      Module2["_sqlite3_bind_text16"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_bind_text16"] = wasmExports["Bc"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_bind_value"] = (a0, a1, a2) => (Module2["_sqlite3_bind_value"] = wasmExports["Cc"])(a0, a1, a2);
      Module2["_sqlite3_bind_zeroblob"] = (a0, a1, a2) => (Module2["_sqlite3_bind_zeroblob"] = wasmExports["Dc"])(a0, a1, a2);
      Module2["_sqlite3_bind_zeroblob64"] = (a0, a1, a2, a3) => (Module2["_sqlite3_bind_zeroblob64"] = wasmExports["Ec"])(a0, a1, a2, a3);
      Module2["_sqlite3_bind_parameter_count"] = (a0) => (Module2["_sqlite3_bind_parameter_count"] = wasmExports["Fc"])(a0);
      Module2["_sqlite3_bind_parameter_name"] = (a0, a1) => (Module2["_sqlite3_bind_parameter_name"] = wasmExports["Gc"])(a0, a1);
      Module2["_sqlite3_bind_parameter_index"] = (a0, a1) => (Module2["_sqlite3_bind_parameter_index"] = wasmExports["Hc"])(a0, a1);
      Module2["_sqlite3_db_handle"] = (a0) => (Module2["_sqlite3_db_handle"] = wasmExports["Ic"])(a0);
      Module2["_sqlite3_stmt_readonly"] = (a0) => (Module2["_sqlite3_stmt_readonly"] = wasmExports["Jc"])(a0);
      Module2["_sqlite3_stmt_isexplain"] = (a0) => (Module2["_sqlite3_stmt_isexplain"] = wasmExports["Kc"])(a0);
      Module2["_sqlite3_stmt_explain"] = (a0, a1) => (Module2["_sqlite3_stmt_explain"] = wasmExports["Lc"])(a0, a1);
      Module2["_sqlite3_stmt_busy"] = (a0) => (Module2["_sqlite3_stmt_busy"] = wasmExports["Mc"])(a0);
      Module2["_sqlite3_next_stmt"] = (a0, a1) => (Module2["_sqlite3_next_stmt"] = wasmExports["Nc"])(a0, a1);
      Module2["_sqlite3_stmt_status"] = (a0, a1, a2) => (Module2["_sqlite3_stmt_status"] = wasmExports["Oc"])(a0, a1, a2);
      Module2["_sqlite3_sql"] = (a0) => (Module2["_sqlite3_sql"] = wasmExports["Pc"])(a0);
      Module2["_sqlite3_expanded_sql"] = (a0) => (Module2["_sqlite3_expanded_sql"] = wasmExports["Qc"])(a0);
      Module2["_sqlite3_value_numeric_type"] = (a0) => (Module2["_sqlite3_value_numeric_type"] = wasmExports["Rc"])(a0);
      Module2["_sqlite3_blob_open"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (Module2["_sqlite3_blob_open"] = wasmExports["Sc"])(a0, a1, a2, a3, a4, a5, a6, a7);
      Module2["_sqlite3_blob_close"] = (a0) => (Module2["_sqlite3_blob_close"] = wasmExports["Tc"])(a0);
      Module2["_sqlite3_blob_read"] = (a0, a1, a2, a3) => (Module2["_sqlite3_blob_read"] = wasmExports["Uc"])(a0, a1, a2, a3);
      Module2["_sqlite3_blob_write"] = (a0, a1, a2, a3) => (Module2["_sqlite3_blob_write"] = wasmExports["Vc"])(a0, a1, a2, a3);
      Module2["_sqlite3_blob_bytes"] = (a0) => (Module2["_sqlite3_blob_bytes"] = wasmExports["Wc"])(a0);
      Module2["_sqlite3_blob_reopen"] = (a0, a1, a2) => (Module2["_sqlite3_blob_reopen"] = wasmExports["Xc"])(a0, a1, a2);
      Module2["_sqlite3_set_authorizer"] = (a0, a1, a2) => (Module2["_sqlite3_set_authorizer"] = wasmExports["Yc"])(a0, a1, a2);
      Module2["_sqlite3_strglob"] = (a0, a1) => (Module2["_sqlite3_strglob"] = wasmExports["Zc"])(a0, a1);
      Module2["_sqlite3_strlike"] = (a0, a1, a2) => (Module2["_sqlite3_strlike"] = wasmExports["_c"])(a0, a1, a2);
      Module2["_sqlite3_errmsg"] = (a0) => (Module2["_sqlite3_errmsg"] = wasmExports["$c"])(a0);
      Module2["_sqlite3_auto_extension"] = (a0) => (Module2["_sqlite3_auto_extension"] = wasmExports["ad"])(a0);
      Module2["_sqlite3_cancel_auto_extension"] = (a0) => (Module2["_sqlite3_cancel_auto_extension"] = wasmExports["bd"])(a0);
      Module2["_sqlite3_reset_auto_extension"] = () => (Module2["_sqlite3_reset_auto_extension"] = wasmExports["cd"])();
      Module2["_sqlite3_prepare"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_prepare"] = wasmExports["dd"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_prepare_v3"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_prepare_v3"] = wasmExports["ed"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_prepare16"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_prepare16"] = wasmExports["fd"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_prepare16_v2"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_prepare16_v2"] = wasmExports["gd"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_prepare16_v3"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_prepare16_v3"] = wasmExports["hd"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_get_table"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_get_table"] = wasmExports["id"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_free_table"] = (a0) => (Module2["_sqlite3_free_table"] = wasmExports["jd"])(a0);
      Module2["_sqlite3_create_module"] = (a0, a1, a2, a3) => (Module2["_sqlite3_create_module"] = wasmExports["kd"])(a0, a1, a2, a3);
      Module2["_sqlite3_create_module_v2"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_create_module_v2"] = wasmExports["ld"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_drop_modules"] = (a0, a1) => (Module2["_sqlite3_drop_modules"] = wasmExports["md"])(a0, a1);
      Module2["_sqlite3_declare_vtab"] = (a0, a1) => (Module2["_sqlite3_declare_vtab"] = wasmExports["nd"])(a0, a1);
      Module2["_sqlite3_vtab_on_conflict"] = (a0) => (Module2["_sqlite3_vtab_on_conflict"] = wasmExports["od"])(a0);
      Module2["_sqlite3_vtab_config"] = (a0, a1, a2) => (Module2["_sqlite3_vtab_config"] = wasmExports["pd"])(a0, a1, a2);
      Module2["_sqlite3_vtab_collation"] = (a0, a1) => (Module2["_sqlite3_vtab_collation"] = wasmExports["qd"])(a0, a1);
      Module2["_sqlite3_vtab_in"] = (a0, a1, a2) => (Module2["_sqlite3_vtab_in"] = wasmExports["rd"])(a0, a1, a2);
      Module2["_sqlite3_vtab_rhs_value"] = (a0, a1, a2) => (Module2["_sqlite3_vtab_rhs_value"] = wasmExports["sd"])(a0, a1, a2);
      Module2["_sqlite3_vtab_distinct"] = (a0) => (Module2["_sqlite3_vtab_distinct"] = wasmExports["td"])(a0);
      Module2["_sqlite3_keyword_name"] = (a0, a1, a2) => (Module2["_sqlite3_keyword_name"] = wasmExports["ud"])(a0, a1, a2);
      Module2["_sqlite3_keyword_count"] = () => (Module2["_sqlite3_keyword_count"] = wasmExports["vd"])();
      Module2["_sqlite3_keyword_check"] = (a0, a1) => (Module2["_sqlite3_keyword_check"] = wasmExports["wd"])(a0, a1);
      Module2["_sqlite3_complete"] = (a0) => (Module2["_sqlite3_complete"] = wasmExports["xd"])(a0);
      Module2["_sqlite3_complete16"] = (a0) => (Module2["_sqlite3_complete16"] = wasmExports["yd"])(a0);
      Module2["_sqlite3_libversion"] = () => (Module2["_sqlite3_libversion"] = wasmExports["zd"])();
      Module2["_sqlite3_libversion_number"] = () => (Module2["_sqlite3_libversion_number"] = wasmExports["Ad"])();
      Module2["_sqlite3_threadsafe"] = () => (Module2["_sqlite3_threadsafe"] = wasmExports["Bd"])();
      Module2["_sqlite3_initialize"] = () => (Module2["_sqlite3_initialize"] = wasmExports["Cd"])();
      Module2["_sqlite3_shutdown"] = () => (Module2["_sqlite3_shutdown"] = wasmExports["Dd"])();
      Module2["_sqlite3_config"] = (a0, a1) => (Module2["_sqlite3_config"] = wasmExports["Ed"])(a0, a1);
      Module2["_sqlite3_db_mutex"] = (a0) => (Module2["_sqlite3_db_mutex"] = wasmExports["Fd"])(a0);
      Module2["_sqlite3_db_release_memory"] = (a0) => (Module2["_sqlite3_db_release_memory"] = wasmExports["Gd"])(a0);
      Module2["_sqlite3_db_cacheflush"] = (a0) => (Module2["_sqlite3_db_cacheflush"] = wasmExports["Hd"])(a0);
      Module2["_sqlite3_db_config"] = (a0, a1, a2) => (Module2["_sqlite3_db_config"] = wasmExports["Id"])(a0, a1, a2);
      Module2["_sqlite3_last_insert_rowid"] = (a0) => (Module2["_sqlite3_last_insert_rowid"] = wasmExports["Jd"])(a0);
      Module2["_sqlite3_set_last_insert_rowid"] = (a0, a1, a2) => (Module2["_sqlite3_set_last_insert_rowid"] = wasmExports["Kd"])(a0, a1, a2);
      Module2["_sqlite3_changes64"] = (a0) => (Module2["_sqlite3_changes64"] = wasmExports["Ld"])(a0);
      Module2["_sqlite3_changes"] = (a0) => (Module2["_sqlite3_changes"] = wasmExports["Md"])(a0);
      Module2["_sqlite3_total_changes64"] = (a0) => (Module2["_sqlite3_total_changes64"] = wasmExports["Nd"])(a0);
      Module2["_sqlite3_total_changes"] = (a0) => (Module2["_sqlite3_total_changes"] = wasmExports["Od"])(a0);
      Module2["_sqlite3_txn_state"] = (a0, a1) => (Module2["_sqlite3_txn_state"] = wasmExports["Pd"])(a0, a1);
      Module2["_sqlite3_close"] = (a0) => (Module2["_sqlite3_close"] = wasmExports["Qd"])(a0);
      Module2["_sqlite3_close_v2"] = (a0) => (Module2["_sqlite3_close_v2"] = wasmExports["Rd"])(a0);
      Module2["_sqlite3_busy_handler"] = (a0, a1, a2) => (Module2["_sqlite3_busy_handler"] = wasmExports["Sd"])(a0, a1, a2);
      Module2["_sqlite3_progress_handler"] = (a0, a1, a2, a3) => (Module2["_sqlite3_progress_handler"] = wasmExports["Td"])(a0, a1, a2, a3);
      Module2["_sqlite3_busy_timeout"] = (a0, a1) => (Module2["_sqlite3_busy_timeout"] = wasmExports["Ud"])(a0, a1);
      Module2["_sqlite3_interrupt"] = (a0) => (Module2["_sqlite3_interrupt"] = wasmExports["Vd"])(a0);
      Module2["_sqlite3_is_interrupted"] = (a0) => (Module2["_sqlite3_is_interrupted"] = wasmExports["Wd"])(a0);
      Module2["_sqlite3_create_function"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (Module2["_sqlite3_create_function"] = wasmExports["Xd"])(a0, a1, a2, a3, a4, a5, a6, a7);
      Module2["_sqlite3_create_function_v2"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (Module2["_sqlite3_create_function_v2"] = wasmExports["Yd"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
      Module2["_sqlite3_create_window_function"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) => (Module2["_sqlite3_create_window_function"] = wasmExports["Zd"])(a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
      Module2["_sqlite3_create_function16"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (Module2["_sqlite3_create_function16"] = wasmExports["_d"])(a0, a1, a2, a3, a4, a5, a6, a7);
      Module2["_sqlite3_overload_function"] = (a0, a1, a2) => (Module2["_sqlite3_overload_function"] = wasmExports["$d"])(a0, a1, a2);
      Module2["_sqlite3_trace_v2"] = (a0, a1, a2, a3) => (Module2["_sqlite3_trace_v2"] = wasmExports["ae"])(a0, a1, a2, a3);
      Module2["_sqlite3_commit_hook"] = (a0, a1, a2) => (Module2["_sqlite3_commit_hook"] = wasmExports["be"])(a0, a1, a2);
      Module2["_sqlite3_update_hook"] = (a0, a1, a2) => (Module2["_sqlite3_update_hook"] = wasmExports["ce"])(a0, a1, a2);
      Module2["_sqlite3_rollback_hook"] = (a0, a1, a2) => (Module2["_sqlite3_rollback_hook"] = wasmExports["de"])(a0, a1, a2);
      Module2["_sqlite3_autovacuum_pages"] = (a0, a1, a2, a3) => (Module2["_sqlite3_autovacuum_pages"] = wasmExports["ee"])(a0, a1, a2, a3);
      Module2["_sqlite3_wal_autocheckpoint"] = (a0, a1) => (Module2["_sqlite3_wal_autocheckpoint"] = wasmExports["fe"])(a0, a1);
      Module2["_sqlite3_wal_hook"] = (a0, a1, a2) => (Module2["_sqlite3_wal_hook"] = wasmExports["ge"])(a0, a1, a2);
      Module2["_sqlite3_wal_checkpoint_v2"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_wal_checkpoint_v2"] = wasmExports["he"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_wal_checkpoint"] = (a0, a1) => (Module2["_sqlite3_wal_checkpoint"] = wasmExports["ie"])(a0, a1);
      Module2["_sqlite3_error_offset"] = (a0) => (Module2["_sqlite3_error_offset"] = wasmExports["je"])(a0);
      Module2["_sqlite3_errmsg16"] = (a0) => (Module2["_sqlite3_errmsg16"] = wasmExports["ke"])(a0);
      Module2["_sqlite3_errcode"] = (a0) => (Module2["_sqlite3_errcode"] = wasmExports["le"])(a0);
      Module2["_sqlite3_extended_errcode"] = (a0) => (Module2["_sqlite3_extended_errcode"] = wasmExports["me"])(a0);
      Module2["_sqlite3_system_errno"] = (a0) => (Module2["_sqlite3_system_errno"] = wasmExports["ne"])(a0);
      Module2["_sqlite3_errstr"] = (a0) => (Module2["_sqlite3_errstr"] = wasmExports["oe"])(a0);
      Module2["_sqlite3_limit"] = (a0, a1, a2) => (Module2["_sqlite3_limit"] = wasmExports["pe"])(a0, a1, a2);
      Module2["_sqlite3_open"] = (a0, a1) => (Module2["_sqlite3_open"] = wasmExports["qe"])(a0, a1);
      Module2["_sqlite3_open_v2"] = (a0, a1, a2, a3) => (Module2["_sqlite3_open_v2"] = wasmExports["re"])(a0, a1, a2, a3);
      Module2["_sqlite3_open16"] = (a0, a1) => (Module2["_sqlite3_open16"] = wasmExports["se"])(a0, a1);
      Module2["_sqlite3_create_collation"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_create_collation"] = wasmExports["te"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_create_collation_v2"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3_create_collation_v2"] = wasmExports["ue"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_create_collation16"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_create_collation16"] = wasmExports["ve"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_collation_needed"] = (a0, a1, a2) => (Module2["_sqlite3_collation_needed"] = wasmExports["we"])(a0, a1, a2);
      Module2["_sqlite3_collation_needed16"] = (a0, a1, a2) => (Module2["_sqlite3_collation_needed16"] = wasmExports["xe"])(a0, a1, a2);
      Module2["_sqlite3_get_clientdata"] = (a0, a1) => (Module2["_sqlite3_get_clientdata"] = wasmExports["ye"])(a0, a1);
      Module2["_sqlite3_set_clientdata"] = (a0, a1, a2, a3) => (Module2["_sqlite3_set_clientdata"] = wasmExports["ze"])(a0, a1, a2, a3);
      Module2["_sqlite3_get_autocommit"] = (a0) => (Module2["_sqlite3_get_autocommit"] = wasmExports["Ae"])(a0);
      Module2["_sqlite3_table_column_metadata"] = (a0, a1, a2, a3, a4, a5, a6, a7, a8) => (Module2["_sqlite3_table_column_metadata"] = wasmExports["Be"])(a0, a1, a2, a3, a4, a5, a6, a7, a8);
      Module2["_sqlite3_sleep"] = (a0) => (Module2["_sqlite3_sleep"] = wasmExports["Ce"])(a0);
      Module2["_sqlite3_extended_result_codes"] = (a0, a1) => (Module2["_sqlite3_extended_result_codes"] = wasmExports["De"])(a0, a1);
      Module2["_sqlite3_file_control"] = (a0, a1, a2, a3) => (Module2["_sqlite3_file_control"] = wasmExports["Ee"])(a0, a1, a2, a3);
      Module2["_sqlite3_test_control"] = (a0, a1) => (Module2["_sqlite3_test_control"] = wasmExports["Fe"])(a0, a1);
      Module2["_sqlite3_create_filename"] = (a0, a1, a2, a3, a4) => (Module2["_sqlite3_create_filename"] = wasmExports["Ge"])(a0, a1, a2, a3, a4);
      Module2["_sqlite3_free_filename"] = (a0) => (Module2["_sqlite3_free_filename"] = wasmExports["He"])(a0);
      Module2["_sqlite3_uri_parameter"] = (a0, a1) => (Module2["_sqlite3_uri_parameter"] = wasmExports["Ie"])(a0, a1);
      Module2["_sqlite3_uri_key"] = (a0, a1) => (Module2["_sqlite3_uri_key"] = wasmExports["Je"])(a0, a1);
      Module2["_sqlite3_uri_boolean"] = (a0, a1, a2) => (Module2["_sqlite3_uri_boolean"] = wasmExports["Ke"])(a0, a1, a2);
      Module2["_sqlite3_uri_int64"] = (a0, a1, a2, a3) => (Module2["_sqlite3_uri_int64"] = wasmExports["Le"])(a0, a1, a2, a3);
      Module2["_sqlite3_filename_database"] = (a0) => (Module2["_sqlite3_filename_database"] = wasmExports["Me"])(a0);
      Module2["_sqlite3_filename_journal"] = (a0) => (Module2["_sqlite3_filename_journal"] = wasmExports["Ne"])(a0);
      Module2["_sqlite3_filename_wal"] = (a0) => (Module2["_sqlite3_filename_wal"] = wasmExports["Oe"])(a0);
      Module2["_sqlite3_db_name"] = (a0, a1) => (Module2["_sqlite3_db_name"] = wasmExports["Pe"])(a0, a1);
      Module2["_sqlite3_db_filename"] = (a0, a1) => (Module2["_sqlite3_db_filename"] = wasmExports["Qe"])(a0, a1);
      Module2["_sqlite3_db_readonly"] = (a0, a1) => (Module2["_sqlite3_db_readonly"] = wasmExports["Re"])(a0, a1);
      Module2["_sqlite3_compileoption_used"] = (a0) => (Module2["_sqlite3_compileoption_used"] = wasmExports["Se"])(a0);
      Module2["_sqlite3_compileoption_get"] = (a0) => (Module2["_sqlite3_compileoption_get"] = wasmExports["Te"])(a0);
      Module2["_sqlite3session_create"] = (a0, a1, a2) => (Module2["_sqlite3session_create"] = wasmExports["Ue"])(a0, a1, a2);
      Module2["_sqlite3session_delete"] = (a0) => (Module2["_sqlite3session_delete"] = wasmExports["Ve"])(a0);
      Module2["_sqlite3session_attach"] = (a0, a1) => (Module2["_sqlite3session_attach"] = wasmExports["We"])(a0, a1);
      Module2["_sqlite3session_changeset"] = (a0, a1, a2) => (Module2["_sqlite3session_changeset"] = wasmExports["Xe"])(a0, a1, a2);
      Module2["_sqlite3session_enable"] = (a0, a1) => (Module2["_sqlite3session_enable"] = wasmExports["Ye"])(a0, a1);
      Module2["_sqlite3changeset_start"] = (a0, a1, a2) => (Module2["_sqlite3changeset_start"] = wasmExports["Ze"])(a0, a1, a2);
      Module2["_sqlite3changeset_finalize"] = (a0) => (Module2["_sqlite3changeset_finalize"] = wasmExports["_e"])(a0);
      Module2["_sqlite3changeset_invert"] = (a0, a1, a2, a3) => (Module2["_sqlite3changeset_invert"] = wasmExports["$e"])(a0, a1, a2, a3);
      Module2["_sqlite3changeset_apply"] = (a0, a1, a2, a3, a4, a5) => (Module2["_sqlite3changeset_apply"] = wasmExports["af"])(a0, a1, a2, a3, a4, a5);
      Module2["_sqlite3_sourceid"] = () => (Module2["_sqlite3_sourceid"] = wasmExports["bf"])();
      Module2["_malloc"] = (a0) => (Module2["_malloc"] = wasmExports["cf"])(a0);
      Module2["_free"] = (a0) => (Module2["_free"] = wasmExports["df"])(a0);
      Module2["_RegisterExtensionFunctions"] = (a0) => (Module2["_RegisterExtensionFunctions"] = wasmExports["ef"])(a0);
      Module2["_getSqliteFree"] = () => (Module2["_getSqliteFree"] = wasmExports["ff"])();
      var _main = Module2["_main"] = (a0, a1) => (_main = Module2["_main"] = wasmExports["gf"])(a0, a1);
      Module2["_libauthorizer_set_authorizer"] = (a0, a1, a2) => (Module2["_libauthorizer_set_authorizer"] = wasmExports["hf"])(a0, a1, a2);
      Module2["_libfunction_create_function"] = (a0, a1, a2, a3, a4, a5, a6, a7) => (Module2["_libfunction_create_function"] = wasmExports["jf"])(a0, a1, a2, a3, a4, a5, a6, a7);
      Module2["_libhook_commit_hook"] = (a0, a1, a2) => (Module2["_libhook_commit_hook"] = wasmExports["kf"])(a0, a1, a2);
      Module2["_libhook_update_hook"] = (a0, a1, a2) => (Module2["_libhook_update_hook"] = wasmExports["lf"])(a0, a1, a2);
      Module2["_libprogress_progress_handler"] = (a0, a1, a2, a3) => (Module2["_libprogress_progress_handler"] = wasmExports["mf"])(a0, a1, a2, a3);
      Module2["_libvfs_vfs_register"] = (a0, a1, a2, a3, a4, a5) => (Module2["_libvfs_vfs_register"] = wasmExports["nf"])(a0, a1, a2, a3, a4, a5);
      var _emscripten_builtin_memalign = (a0, a1) => (_emscripten_builtin_memalign = wasmExports["pf"])(a0, a1);
      var __emscripten_tempret_get = () => (__emscripten_tempret_get = wasmExports["qf"])();
      var __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports["rf"])(a0);
      var __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports["sf"])(a0);
      var _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports["tf"])();
      Module2["_sqlite3_version"] = 5472;
      Module2["getTempRet0"] = getTempRet0;
      Module2["ccall"] = ccall;
      Module2["cwrap"] = cwrap;
      Module2["addFunction"] = addFunction;
      Module2["setValue"] = setValue;
      Module2["getValue"] = getValue;
      Module2["UTF8ToString"] = UTF8ToString;
      Module2["stringToUTF8"] = stringToUTF8;
      Module2["lengthBytesUTF8"] = lengthBytesUTF8;
      Module2["intArrayFromString"] = intArrayFromString;
      Module2["intArrayToString"] = intArrayToString;
      Module2["AsciiToString"] = AsciiToString;
      Module2["UTF16ToString"] = UTF16ToString;
      Module2["stringToUTF16"] = stringToUTF16;
      Module2["UTF32ToString"] = UTF32ToString;
      Module2["stringToUTF32"] = stringToUTF32;
      Module2["writeArrayToMemory"] = writeArrayToMemory;
      var calledRun;
      dependenciesFulfilled = function runCaller() {
        if (!calledRun) run2();
        if (!calledRun) dependenciesFulfilled = runCaller;
      };
      function callMain() {
        var entryFunction = _main;
        var argc = 0;
        var argv = 0;
        try {
          var ret = entryFunction(argc, argv);
          exitJS(ret, true);
          return ret;
        } catch (e) {
          return handleException(e);
        }
      }
      function run2() {
        if (runDependencies > 0) {
          return;
        }
        preRun();
        if (runDependencies > 0) {
          return;
        }
        function doRun() {
          var _a2;
          if (calledRun) return;
          calledRun = true;
          Module2["calledRun"] = true;
          if (ABORT) return;
          initRuntime();
          preMain();
          readyPromiseResolve(Module2);
          (_a2 = Module2["onRuntimeInitialized"]) == null ? void 0 : _a2.call(Module2);
          if (shouldRunNow) callMain();
          postRun();
        }
        if (Module2["setStatus"]) {
          Module2["setStatus"]("Running...");
          setTimeout(() => {
            setTimeout(() => Module2["setStatus"](""), 1);
            doRun();
          }, 1);
        } else {
          doRun();
        }
      }
      if (Module2["preInit"]) {
        if (typeof Module2["preInit"] == "function") Module2["preInit"] = [Module2["preInit"]];
        while (Module2["preInit"].length > 0) {
          Module2["preInit"].pop()();
        }
      }
      var shouldRunNow = true;
      if (Module2["noInitialRun"]) shouldRunNow = false;
      run2();
      (function() {
        const AsyncFunction2 = Object.getPrototypeOf(async function() {
        }).constructor;
        let pAsyncFlags = 0;
        Module2["set_authorizer"] = function(db, xAuthorizer, pApp) {
          if (pAsyncFlags) {
            Module2["deleteCallback"](pAsyncFlags);
            Module2["_sqlite3_free"](pAsyncFlags);
            pAsyncFlags = 0;
          }
          pAsyncFlags = Module2["_sqlite3_malloc"](4);
          setValue(pAsyncFlags, xAuthorizer instanceof AsyncFunction2 ? 1 : 0, "i32");
          const result = ccall("libauthorizer_set_authorizer", "number", ["number", "number", "number"], [db, xAuthorizer ? 1 : 0, pAsyncFlags]);
          if (!result && xAuthorizer) {
            Module2["setCallback"](pAsyncFlags, (_, iAction, p3, p4, p5, p6) => xAuthorizer(pApp, iAction, p3, p4, p5, p6));
          }
          return result;
        };
      })();
      (function() {
        const AsyncFunction2 = Object.getPrototypeOf(async function() {
        }).constructor;
        const FUNC_METHODS = ["xFunc", "xStep", "xFinal"];
        const mapFunctionNameToKey = /* @__PURE__ */ new Map();
        Module2["create_function"] = function(db, zFunctionName, nArg, eTextRep, pApp, xFunc, xStep, xFinal) {
          const pAsyncFlags = Module2["_sqlite3_malloc"](4);
          const target = { xFunc, xStep, xFinal };
          setValue(pAsyncFlags, FUNC_METHODS.reduce((mask, method, i) => {
            if (target[method] instanceof AsyncFunction2) {
              return mask | 1 << i;
            }
            return mask;
          }, 0), "i32");
          const result = ccall("libfunction_create_function", "number", ["number", "string", "number", "number", "number", "number", "number", "number"], [db, zFunctionName, nArg, eTextRep, pAsyncFlags, xFunc ? 1 : 0, xStep ? 1 : 0, xFinal ? 1 : 0]);
          if (!result) {
            if (mapFunctionNameToKey.has(zFunctionName)) {
              const oldKey = mapFunctionNameToKey.get(zFunctionName);
              Module2["deleteCallback"](oldKey);
            }
            mapFunctionNameToKey.set(zFunctionName, pAsyncFlags);
            Module2["setCallback"](pAsyncFlags, { xFunc, xStep, xFinal });
          }
          return result;
        };
      })();
      (function() {
        const AsyncFunction2 = Object.getPrototypeOf(async function() {
        }).constructor;
        let pAsyncFlags = 0;
        Module2["update_hook"] = function(db, xUpdateHook) {
          if (pAsyncFlags) {
            Module2["deleteCallback"](pAsyncFlags);
            Module2["_sqlite3_free"](pAsyncFlags);
            pAsyncFlags = 0;
          }
          pAsyncFlags = Module2["_sqlite3_malloc"](4);
          setValue(pAsyncFlags, xUpdateHook instanceof AsyncFunction2 ? 1 : 0, "i32");
          ccall("libhook_update_hook", "void", ["number", "number", "number"], [db, xUpdateHook ? 1 : 0, pAsyncFlags]);
          if (xUpdateHook) {
            Module2["setCallback"](pAsyncFlags, (_, iUpdateType, dbName, tblName, lo32, hi32) => xUpdateHook(iUpdateType, dbName, tblName, lo32, hi32));
          }
        };
      })();
      (function() {
        const AsyncFunction2 = Object.getPrototypeOf(async function() {
        }).constructor;
        let pAsyncFlags = 0;
        Module2["commit_hook"] = function(db, xCommitHook) {
          if (pAsyncFlags) {
            Module2["deleteCallback"](pAsyncFlags);
            Module2["_sqlite3_free"](pAsyncFlags);
            pAsyncFlags = 0;
          }
          pAsyncFlags = Module2["_sqlite3_malloc"](4);
          setValue(pAsyncFlags, xCommitHook instanceof AsyncFunction2 ? 1 : 0, "i32");
          ccall("libhook_commit_hook", "void", ["number", "number", "number"], [db, xCommitHook ? 1 : 0, pAsyncFlags]);
          if (xCommitHook) {
            Module2["setCallback"](pAsyncFlags, (_) => xCommitHook());
          }
        };
      })();
      (function() {
        const AsyncFunction2 = Object.getPrototypeOf(async function() {
        }).constructor;
        let pAsyncFlags = 0;
        Module2["progress_handler"] = function(db, nOps, xProgress, pApp) {
          if (pAsyncFlags) {
            Module2["deleteCallback"](pAsyncFlags);
            Module2["_sqlite3_free"](pAsyncFlags);
            pAsyncFlags = 0;
          }
          pAsyncFlags = Module2["_sqlite3_malloc"](4);
          setValue(pAsyncFlags, xProgress instanceof AsyncFunction2 ? 1 : 0, "i32");
          ccall("libprogress_progress_handler", "number", ["number", "number", "number", "number"], [db, nOps, xProgress ? 1 : 0, pAsyncFlags]);
          if (xProgress) {
            Module2["setCallback"](pAsyncFlags, (_) => xProgress(pApp));
          }
        };
      })();
      (function() {
        const VFS_METHODS = ["xOpen", "xDelete", "xAccess", "xFullPathname", "xRandomness", "xSleep", "xCurrentTime", "xGetLastError", "xCurrentTimeInt64", "xClose", "xRead", "xWrite", "xTruncate", "xSync", "xFileSize", "xLock", "xUnlock", "xCheckReservedLock", "xFileControl", "xSectorSize", "xDeviceCharacteristics", "xShmMap", "xShmLock", "xShmBarrier", "xShmUnmap"];
        const mapVFSNameToKey = /* @__PURE__ */ new Map();
        Module2["vfs_register"] = function(vfs, makeDefault) {
          let methodMask = 0;
          let asyncMask = 0;
          VFS_METHODS.forEach((method, i) => {
            if (vfs[method]) {
              methodMask |= 1 << i;
              if (vfs["hasAsyncMethod"](method)) {
                asyncMask |= 1 << i;
              }
            }
          });
          const vfsReturn = Module2["_sqlite3_malloc"](4);
          try {
            const result = ccall("libvfs_vfs_register", "number", ["string", "number", "number", "number", "number", "number"], [vfs.name, vfs.mxPathname, methodMask, asyncMask, makeDefault ? 1 : 0, vfsReturn]);
            if (!result) {
              if (mapVFSNameToKey.has(vfs.name)) {
                const oldKey = mapVFSNameToKey.get(vfs.name);
                Module2["deleteCallback"](oldKey);
              }
              const key = getValue(vfsReturn, "*");
              mapVFSNameToKey.set(vfs.name, key);
              Module2["setCallback"](key, vfs);
            }
            return result;
          } finally {
            Module2["_sqlite3_free"](vfsReturn);
          }
        };
      })();
      moduleRtn = readyPromise;
      return moduleRtn;
    };
  })();
  const loadSqlite3Wasm = async () => {
    const module = await Module();
    const sqlite3 = Factory(module);
    sqlite3.module = module;
    return sqlite3;
  };
  const rootHandlePromise = typeof navigator === "undefined" || navigator.storage === void 0 ? (
    // We're using a proxy here to make the promise reject lazy
    new Proxy({}, {
      get: () => Promise.reject(new Error(`Can't get OPFS root handle in this environment as navigator.storage is undefined`))
    })
  ) : navigator.storage.getDirectory();
  const getDirHandle = async (absDirPath) => {
    const rootHandle = await rootHandlePromise;
    if (absDirPath === void 0)
      return rootHandle;
    let dirHandle = rootHandle;
    const directoryStack = absDirPath == null ? void 0 : absDirPath.split("/").filter(Boolean);
    while (directoryStack.length > 0) {
      dirHandle = await dirHandle.getDirectoryHandle(directoryStack.shift());
    }
    return dirHandle;
  };
  const printTree = async (directoryHandle_ = rootHandlePromise, depth = Number.POSITIVE_INFINITY, prefix = "") => {
    if (depth < 0)
      return;
    const directoryHandle = await directoryHandle_;
    const entries = directoryHandle.values();
    for await (const entry of entries) {
      const isDirectory = entry.kind === "directory";
      const size2 = entry.kind === "file" ? await entry.getFile().then((file) => prettyBytes(file.size)) : void 0;
      console.log(`${prefix}${isDirectory ? "📁" : "📄"} ${entry.name} ${size2 ? `(${size2})` : ""}`);
      if (isDirectory) {
        const nestedDirectoryHandle = await directoryHandle.getDirectoryHandle(entry.name);
        await printTree(nestedDirectoryHandle, depth - 1, `${prefix}  `);
      }
    }
  };
  const deleteAll = async (directoryHandle) => {
    if (directoryHandle.kind !== "directory")
      return;
    for await (const entryName of directoryHandle.keys()) {
      await directoryHandle.removeEntry(entryName, { recursive: true });
    }
  };
  var OpfsUtils = /* @__PURE__ */ Object.freeze({
    __proto__: null,
    deleteAll,
    getDirHandle,
    printTree,
    rootHandlePromise
  });
  class PersistedSqliteError extends TaggedError()("PersistedSqliteError", {
    cause: Defect
  }) {
  }
  const sanitizeOpfsDir = (directory, storeId) => {
    if (directory === void 0 || directory === "" || directory === "/")
      return `livestore-${storeId}@${liveStoreStorageFormatVersion}`;
    if (directory.includes("/")) {
      throw new Error(`@livestore/adapter-web:worker:sanitizeOpfsDir: Nested directories are not yet supported ('${directory}')`);
    }
    return `${directory}@${liveStoreStorageFormatVersion}`;
  };
  const getStateDbFileName = (schema2) => {
    const schemaHashSuffix = schema2.state.sqlite.migrations.strategy === "manual" ? "fixed" : schema2.state.sqlite.hash.toString();
    return `state${schemaHashSuffix}.db`;
  };
  const makeShutdownChannel = (storeId) => broadcastChannel({
    channelName: `livestore.shutdown.${storeId}`,
    schema: All
  });
  const StorageTypeOpfs = Struct({
    type: Literal("opfs"),
    /**
     * Default is `livestore-${storeId}`
     *
     * When providing this option, make sure to include the `storeId` in the path to avoid
     * conflicts with other LiveStore apps.
     */
    directory: optional(String$)
  });
  const StorageType = Union(StorageTypeOpfs);
  Record({ key: String$, value: JsonValue });
  var LeaderWorkerOuter;
  (function(LeaderWorkerOuter2) {
    class InitialMessage extends TaggedRequest()("InitialMessage", {
      payload: { port: MessagePort, storeId: String$, clientId: String$ },
      success: Void,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerOuter2.InitialMessage = InitialMessage;
    class Request2 extends Union(InitialMessage) {
    }
    LeaderWorkerOuter2.Request = Request2;
  })(LeaderWorkerOuter || (LeaderWorkerOuter = {}));
  var LeaderWorkerInner;
  (function(LeaderWorkerInner2) {
    class InitialMessage extends TaggedRequest()("InitialMessage", {
      payload: {
        storageOptions: StorageType,
        devtoolsEnabled: Boolean$,
        storeId: String$,
        clientId: String$,
        debugInstanceId: String$,
        syncPayload: UndefinedOr(JsonValue)
      },
      success: Void,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.InitialMessage = InitialMessage;
    class BootStatusStream extends TaggedRequest()("BootStatusStream", {
      payload: {},
      success: BootStatus,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.BootStatusStream = BootStatusStream;
    class PushToLeader extends TaggedRequest()("PushToLeader", {
      payload: {
        batch: Array$(AnyEncoded)
      },
      success: Void,
      failure: Union(UnexpectedError, LeaderAheadError)
    }) {
    }
    LeaderWorkerInner2.PushToLeader = PushToLeader;
    class PullStream extends TaggedRequest()("PullStream", {
      payload: {
        cursor: LeaderPullCursor
      },
      success: Struct({
        payload: PayloadUpstream,
        mergeCounter: Number$
      }),
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.PullStream = PullStream;
    class Export extends TaggedRequest()("Export", {
      payload: {},
      success: Uint8Array$1,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.Export = Export;
    class ExportEventlog extends TaggedRequest()("ExportEventlog", {
      payload: {},
      success: Uint8Array$1,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.ExportEventlog = ExportEventlog;
    class GetRecreateSnapshot extends TaggedRequest()("GetRecreateSnapshot", {
      payload: {},
      success: Struct({
        snapshot: Uint8Array$1,
        migrationsReport: MigrationsReport
      }),
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.GetRecreateSnapshot = GetRecreateSnapshot;
    class GetLeaderHead extends TaggedRequest()("GetLeaderHead", {
      payload: {},
      success: EventSequenceNumber,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.GetLeaderHead = GetLeaderHead;
    class GetLeaderSyncState extends TaggedRequest()("GetLeaderSyncState", {
      payload: {},
      success: SyncState,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.GetLeaderSyncState = GetLeaderSyncState;
    class Shutdown extends TaggedRequest()("Shutdown", {
      payload: {},
      success: Void,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.Shutdown = Shutdown;
    class ExtraDevtoolsMessage extends TaggedRequest()("ExtraDevtoolsMessage", {
      payload: {
        message: MessageToApp
      },
      success: Void,
      failure: UnexpectedError
    }) {
    }
    LeaderWorkerInner2.ExtraDevtoolsMessage = ExtraDevtoolsMessage;
    LeaderWorkerInner2.Request = Union(InitialMessage, BootStatusStream, PushToLeader, PullStream, Export, ExportEventlog, GetRecreateSnapshot, GetLeaderHead, GetLeaderSyncState, Shutdown, ExtraDevtoolsMessage, CreateConnection$1);
  })(LeaderWorkerInner || (LeaderWorkerInner = {}));
  var SharedWorker;
  (function(SharedWorker2) {
    class InitialMessagePayloadFromClientSession extends TaggedStruct("FromClientSession", {
      initialMessage: LeaderWorkerInner.InitialMessage
    }) {
    }
    SharedWorker2.InitialMessagePayloadFromClientSession = InitialMessagePayloadFromClientSession;
    class InitialMessage extends TaggedRequest()("InitialMessage", {
      payload: {
        payload: Union(InitialMessagePayloadFromClientSession, TaggedStruct("FromWebBridge", {})),
        // To guard against scenarios where a client session is already running a newer version of LiveStore
        // We should probably find a better way to handle those cases once they become more common.
        liveStoreVersion: Literal(liveStoreVersion$1)
      },
      success: Void,
      failure: UnexpectedError
    }) {
    }
    SharedWorker2.InitialMessage = InitialMessage;
    class UpdateMessagePort extends TaggedRequest()("UpdateMessagePort", {
      payload: {
        port: MessagePort
      },
      success: Void,
      failure: UnexpectedError
    }) {
    }
    SharedWorker2.UpdateMessagePort = UpdateMessagePort;
    class Request2 extends Union(
      InitialMessage,
      UpdateMessagePort,
      // Proxied requests
      LeaderWorkerInner.BootStatusStream,
      LeaderWorkerInner.PushToLeader,
      LeaderWorkerInner.PullStream,
      LeaderWorkerInner.Export,
      LeaderWorkerInner.GetRecreateSnapshot,
      LeaderWorkerInner.ExportEventlog,
      LeaderWorkerInner.GetLeaderHead,
      LeaderWorkerInner.GetLeaderSyncState,
      LeaderWorkerInner.Shutdown,
      LeaderWorkerInner.ExtraDevtoolsMessage,
      CreateConnection$1
    ) {
    }
    SharedWorker2.Request = Request2;
  })(SharedWorker || (SharedWorker = {}));
  if (isDevEnv()) {
    globalThis.__debugLiveStoreUtils = {
      opfs: OpfsUtils,
      blobUrl: (buffer) => URL.createObjectURL(new Blob([buffer], { type: "application/octet-stream" })),
      runSync: (effect2) => runSync(effect2),
      runFork: (effect2) => runFork$1(effect2)
    };
  }
  const makeWorker = (options2) => {
    makeWorkerEffect(options2).pipe(runFork$1);
  };
  const makeWorkerEffect = (options2) => {
    var _a2;
    const TracingLive = ((_a2 = options2.otelOptions) == null ? void 0 : _a2.tracer) ? unwrapEffect(map$5(make$5, setTracer)).pipe(provideMerge(succeed$4(OtelTracer, options2.otelOptions.tracer))) : void 0;
    return makeWorkerRunnerOuter(options2).pipe(
      provide(layer),
      launch,
      scoped$3,
      tapCauseLogPretty,
      annotateLogs({ thread: self.name }),
      provide$1(prettyWithThread(self.name)),
      provide$1(layer$2),
      LS_DEV ? withAsyncTaggingTracing((name) => console.createTask(name)) : identity,
      TracingLive ? provide$1(TracingLive) : identity,
      // We're using this custom scheduler to improve op batching behaviour and reduce the overhead
      // of the Effect fiber runtime given we have different tradeoffs on a worker thread.
      // Despite the "message channel" name, is has nothing to do with the `incomingRequestsPort` above.
      withScheduler(messageChannel()),
      // We're increasing the Effect ops limit here to allow for larger chunks of operations at a time
      withMaxOpsBeforeYield(4096),
      withMinimumLogLevel(Debug)
    );
  };
  const makeWorkerRunnerOuter = (workerOptions) => layerSerialized(LeaderWorkerOuter.InitialMessage, {
    // Port coming from client session and forwarded via the shared worker
    InitialMessage: ({ port: incomingRequestsPort, storeId, clientId: clientId2 }) => gen$2(function* () {
      yield* makeWorkerRunnerInner(workerOptions).pipe(provide(layerMessagePort(incomingRequestsPort)), launch, scoped$3, withSpan$3("@livestore/adapter-web:worker:wrapper:InitialMessage:innerFiber"), tapCauseLogPretty, provide$1(CacheService.layer({ nodeName: makeNodeName.client.leader({ storeId, clientId: clientId2 }) })), forkScoped);
      return empty$5;
    }).pipe(withSpan$3("@livestore/adapter-web:worker:wrapper:InitialMessage"), unwrapScoped$3)
  });
  const makeWorkerRunnerInner = ({ schema: schema2, sync: syncOptions }) => layerSerialized(LeaderWorkerInner.Request, {
    InitialMessage: ({ storageOptions, storeId, clientId: clientId2, devtoolsEnabled, debugInstanceId, syncPayload }) => gen$2(function* () {
      const sqlite3 = yield* promise(() => loadSqlite3Wasm());
      const makeSqliteDb2 = sqliteDbFactory({ sqlite3 });
      const runtime$12 = yield* runtime();
      const makeDb = (kind) => makeSqliteDb2({
        _tag: "opfs",
        opfsDirectory: sanitizeOpfsDir(storageOptions.directory, storeId),
        fileName: kind === "state" ? getStateDbFileName(schema2) : "eventlog.db",
        configureDb: (db) => configureConnection(db, {
          //  The persisted databases use the AccessHandlePoolVFS which always uses a single database connection.
          //  Multiple connections are not supported. This means that we can use the exclusive locking mode to
          //  avoid unnecessary system calls and enable the use of the WAL journal mode without the use of shared memory.
          // TODO bring back exclusive locking mode when `WAL` is working properly
          // lockingMode: 'EXCLUSIVE',
          foreignKeys: true
        }).pipe(provide$1(runtime$12), runSync)
      }).pipe(acquireRelease((db) => try_(() => db.close()).pipe(ignoreLogged)));
      const [dbState, dbEventlog] = yield* all([makeDb("state"), makeDb("eventlog")], {
        concurrency: 2
      });
      const devtoolsOptions = yield* makeDevtoolsOptions({ devtoolsEnabled, dbState, dbEventlog });
      const shutdownChannel = yield* makeShutdownChannel(storeId);
      return makeLeaderThreadLayer({
        schema: schema2,
        storeId,
        clientId: clientId2,
        makeSqliteDb: makeSqliteDb2,
        syncOptions,
        dbState,
        dbEventlog,
        devtoolsOptions,
        shutdownChannel,
        syncPayload
      });
    }).pipe(tapCauseLogPretty, UnexpectedError.mapToUnexpectedError, withPerformanceMeasure("@livestore/adapter-web:worker:InitialMessage"), withSpan$3("@livestore/adapter-web:worker:InitialMessage"), annotateSpans({ debugInstanceId }), unwrapScoped$3),
    GetRecreateSnapshot: () => gen$2(function* () {
      const workerCtx = yield* LeaderThreadCtx;
      const snapshot = workerCtx.dbState.export();
      return { snapshot, migrationsReport: workerCtx.initialState.migrationsReport };
    }).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:GetRecreateSnapshot")),
    PullStream: ({ cursor }) => gen$2(function* () {
      const { syncProcessor } = yield* LeaderThreadCtx;
      return syncProcessor.pull({ cursor });
    }).pipe(unwrapScoped),
    PushToLeader: ({ batch }) => andThen(LeaderThreadCtx, ({ syncProcessor }) => syncProcessor.push(
      batch.map((event) => new EncodedWithMeta(event)),
      // We'll wait in order to keep back pressure on the client session
      { waitForProcessing: true }
    )).pipe(uninterruptible, withSpan$3("@livestore/adapter-web:worker:PushToLeader")),
    Export: () => andThen(LeaderThreadCtx, (_) => _.dbState.export()).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:Export")),
    ExportEventlog: () => andThen(LeaderThreadCtx, (_) => _.dbEventlog.export()).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:ExportEventlog")),
    BootStatusStream: () => andThen(LeaderThreadCtx, (_) => fromQueue(_.bootStatusQueue)).pipe(unwrap),
    GetLeaderHead: () => gen$2(function* () {
      const workerCtx = yield* LeaderThreadCtx;
      return getClientHeadFromDb(workerCtx.dbEventlog);
    }).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:GetLeaderHead")),
    GetLeaderSyncState: () => gen$2(function* () {
      const workerCtx = yield* LeaderThreadCtx;
      return yield* workerCtx.syncProcessor.syncState;
    }).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:GetLeaderSyncState")),
    Shutdown: () => gen$2(function* () {
      yield* logDebug("[@livestore/adapter-web:worker] Shutdown");
      yield* sleep(300);
    }).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:Shutdown")),
    ExtraDevtoolsMessage: ({ message }) => andThen(LeaderThreadCtx, (_) => _.extraIncomingMessagesQueue.offer(message)).pipe(UnexpectedError.mapToUnexpectedError, withSpan$3("@livestore/adapter-web:worker:ExtraDevtoolsMessage")),
    "DevtoolsWebCommon.CreateConnection": CreateConnection
  });
  const makeDevtoolsOptions = ({ devtoolsEnabled, dbState, dbEventlog }) => gen$2(function* () {
    if (devtoolsEnabled === false) {
      return { enabled: false };
    }
    const { node } = yield* CacheService;
    return {
      enabled: true,
      boot: gen$2(function* () {
        const persistenceInfo = {
          state: dbState.metadata.persistenceInfo,
          eventlog: dbEventlog.metadata.persistenceInfo
        };
        return { node, persistenceInfo, mode: "direct" };
      })
    };
  });
  const tables = {
    todos: table({
      name: "todos",
      columns: {
        id: text({ primaryKey: true }),
        text: text({ default: "" }),
        completed: boolean({ default: false }),
        deletedAt: integer({ nullable: true, schema: DateFromNumber })
      }
    }),
    // Client documents can be used for local-only state (e.g. form inputs)
    uiState: clientDocument({
      name: "uiState",
      schema: Struct({ newTodoText: String$, filter: Literal("all", "active", "completed") }),
      default: { id: SessionIdSymbol, value: { newTodoText: "", filter: "all" } }
    })
  };
  const events = {
    todoCreated: synced({
      name: "v1.TodoCreated",
      schema: Struct({ id: String$, text: String$ })
    }),
    todoCompleted: synced({
      name: "v1.TodoCompleted",
      schema: Struct({ id: String$ })
    }),
    todoUncompleted: synced({
      name: "v1.TodoUncompleted",
      schema: Struct({ id: String$ })
    }),
    todoDeleted: synced({
      name: "v1.TodoDeleted",
      schema: Struct({ id: String$, deletedAt: Date$ })
    }),
    todoClearedCompleted: synced({
      name: "v1.TodoClearedCompleted",
      schema: Struct({ deletedAt: Date$ })
    }),
    uiStateSet: tables.uiState.set
  };
  const materializers = materializers$1(events, {
    "v1.TodoCreated": ({ id: id2, text: text2 }) => tables.todos.insert({ id: id2, text: text2, completed: false }),
    "v1.TodoCompleted": ({ id: id2 }) => tables.todos.update({ completed: true }).where({ id: id2 }),
    "v1.TodoUncompleted": ({ id: id2 }) => tables.todos.update({ completed: false }).where({ id: id2 }),
    "v1.TodoDeleted": ({ id: id2, deletedAt }) => tables.todos.update({ deletedAt }).where({ id: id2 }),
    "v1.TodoClearedCompleted": ({ deletedAt }) => tables.todos.update({ deletedAt }).where({ completed: true })
  });
  const state = makeState({ tables, materializers });
  const schema = makeSchema({ events, state });
  makeWorker({
    schema
  });
})();
